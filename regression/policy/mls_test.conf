#line 1 "flask/security_classes"
# FLASK

#
# Define the security object classes 
#

class security
class process
class system
class capability

# file-related classes
class filesystem
class file
class dir
class fd
class lnk_file
class chr_file
class blk_file
class sock_file
class fifo_file

# network-related classes
class socket
class tcp_socket
class udp_socket
class rawip_socket
class node
class netif
class netlink_socket
class packet_socket
class key_socket
class unix_stream_socket
class unix_dgram_socket

# sysv-ipc-related classes
class sem
class msg
class msgq
class shm
class ipc

#
# userspace object manager classes
#

# passwd/chfn/chsh
class passwd

# SE-X Windows stuff
class drawable
class window
class gc
class font
class colormap
class property
class cursor
class xclient
class xinput
class xserver
class xextension

# pax flags
class pax

# extended netlink sockets
class netlink_route_socket
class netlink_firewall_socket
class netlink_tcpdiag_socket
class netlink_nflog_socket
class netlink_xfrm_socket
class netlink_selinux_socket
class netlink_audit_socket
class netlink_ip6fw_socket
class netlink_dnrt_socket

class dbus
class nscd

# IPSec association
class association

# Updated Netlink class for KOBJECT_UEVENT family.
class netlink_kobject_uevent_socket

# FLASK
#line 1 "flask/initial_sids"
# FLASK

#
# Define initial security identifiers 
#

sid kernel
sid security
sid unlabeled
sid fs
sid file
sid file_labels
sid init
sid any_socket
sid port
sid netif
sid netmsg
sid node
sid igmp_packet
sid icmp_socket
sid tcp_socket
sid sysctl_modprobe
sid sysctl
sid sysctl_fs
sid sysctl_kernel
sid sysctl_net
sid sysctl_net_unix
sid sysctl_vm
sid sysctl_dev
sid kmod
sid policy
sid scmp_packet
sid devnull

# FLASK
#line 1 "flask/access_vectors"
#
# Define common prefixes for access vectors
#
# common common_name { permission_name ... }


#
# Define a common prefix for file access vectors.
#

common file
{
	ioctl
	read
	write
	create
	getattr
	setattr
	lock
	relabelfrom
	relabelto
	append
	unlink
	link
	rename
	execute
	swapon
	quotaon
	mounton
}


#
# Define a common prefix for socket access vectors.
#

common socket
{
# inherited from file
	ioctl
	read
	write
	create
	getattr
	setattr
	lock
	relabelfrom
	relabelto
	append
# socket-specific
	bind
	connect
	listen
	accept
	getopt
	setopt
	shutdown
	recvfrom
	sendto
	recv_msg
	send_msg
	name_bind
}	

#
# Define a common prefix for ipc access vectors.
#

common ipc
{
	create
	destroy
	getattr
	setattr
	read
	write
	associate
	unix_read
	unix_write
}

#
# Define the access vectors.
#
# class class_name [ inherits common_name ] { permission_name ... }


#
# Define the access vector interpretation for file-related objects.
#

class filesystem
{
	mount
	remount
	unmount
	getattr
	relabelfrom
	relabelto
	transition
	associate
	quotamod
	quotaget
}

class dir
inherits file
{
	add_name
	remove_name
	reparent
	search
	rmdir
}

class file
inherits file
{
	execute_no_trans
	entrypoint
	execmod
}

class lnk_file
inherits file

class chr_file
inherits file
{
	execute_no_trans
	entrypoint
	execmod
}

class blk_file
inherits file

class sock_file
inherits file

class fifo_file
inherits file

class fd
{
	use
}


#
# Define the access vector interpretation for network-related objects.
#

class socket
inherits socket

class tcp_socket
inherits socket
{
	connectto
	newconn
	acceptfrom
	node_bind
	name_connect
}

class udp_socket
inherits socket
{
	node_bind
}

class rawip_socket
inherits socket
{
	node_bind
}

class node 
{
	tcp_recv
	tcp_send
	udp_recv
	udp_send
	rawip_recv
	rawip_send
	enforce_dest
}

class netif
{
	tcp_recv
	tcp_send
	udp_recv
	udp_send
	rawip_recv
	rawip_send
}

class netlink_socket
inherits socket

class packet_socket
inherits socket

class key_socket
inherits socket

class unix_stream_socket
inherits socket
{
	connectto
	newconn
	acceptfrom
}

class unix_dgram_socket
inherits socket


#
# Define the access vector interpretation for process-related objects
#

class process
{
	fork
	transition
	sigchld # commonly granted from child to parent
	sigkill # cannot be caught or ignored
	sigstop # cannot be caught or ignored
	signull # for kill(pid, 0)
	signal  # all other signals
	ptrace
	getsched
	setsched
	getsession
	getpgid
	setpgid
	getcap
	setcap
	share
	getattr
	setexec
	setfscreate
	noatsecure
	siginh
	setrlimit
	rlimitinh
	dyntransition
	setcurrent
	execmem
	execstack
	execheap
}


#
# Define the access vector interpretation for ipc-related objects
#

class ipc
inherits ipc

class sem
inherits ipc

class msgq
inherits ipc
{
	enqueue
}

class msg
{
	send
	receive
}

class shm
inherits ipc
{
	lock
}


#
# Define the access vector interpretation for the security server. 
#

class security
{
	compute_av
	compute_create
	compute_member
	check_context
	load_policy
	compute_relabel
	compute_user
	setenforce     # was avc_toggle in system class
	setbool
	setsecparam
	setcheckreqprot
}


#
# Define the access vector interpretation for system operations.
#

class system
{
	ipc_info
	syslog_read  
	syslog_mod
	syslog_console
}

#
# Define the access vector interpretation for controling capabilies
#

class capability
{
	# The capabilities are defined in include/linux/capability.h
	# Care should be taken to ensure that these are consistent with
	# those definitions. (Order matters)

	chown           
	dac_override    
	dac_read_search 
	fowner          
	fsetid          
	kill            
	setgid           
	setuid           
	setpcap          
	linux_immutable  
	net_bind_service 
	net_broadcast    
	net_admin        
	net_raw          
	ipc_lock         
	ipc_owner        
	sys_module       
	sys_rawio        
	sys_chroot       
	sys_ptrace       
	sys_pacct        
	sys_admin        
	sys_boot         
	sys_nice         
	sys_resource     
	sys_time         
	sys_tty_config  
	mknod
	lease
	audit_write
	audit_control
}


#
# Define the access vector interpretation for controlling
# changes to passwd information.
#
class passwd
{
	passwd	# change another user passwd
	chfn	# change another user finger info
	chsh	# change another user shell
	rootok  # pam_rootok check (skip auth)
	crontab # crontab on another user
}

#
# SE-X Windows stuff
#
class drawable
{
	create
	destroy
	draw
	copy
	getattr
}

class gc
{
	create
	free
	getattr
	setattr
}

class window 
{
	addchild
	create
	destroy
	map
	unmap
	chstack
	chproplist
	chprop	
	listprop
	getattr
	setattr
	setfocus
	move
	chselection
	chparent
	ctrllife
	enumerate
	transparent
	mousemotion
	clientcomevent
	inputevent
	drawevent
	windowchangeevent
	windowchangerequest
	serverchangeevent
	extensionevent
}

class font
{
	load
	free
	getattr
	use
}

class colormap
{
	create
	free
	install
	uninstall
	list
	read
	store
	getattr
	setattr
}

class property
{
	create
	free
	read
	write
}

class cursor
{
	create
	createglyph
	free
	assign
	setattr
}

class xclient
{
	kill
}

class xinput
{
	lookup
	getattr
	setattr
	setfocus
	warppointer
	activegrab
	passivegrab
	ungrab
	bell
	mousemotion
	relabelinput
}

class xserver
{
	screensaver
	gethostlist
	sethostlist
	getfontpath
	setfontpath
	getattr
	grab
	ungrab
}

class xextension
{
	query
	use
}

#
# Define the access vector interpretation for controlling
# PaX flags
#
class pax
{
        pageexec        # Paging based non-executable pages
        emutramp        # Emulate trampolines
        mprotect        # Restrict mprotect()
        randmmap        # Randomize mmap() base
        randexec        # Randomize ET_EXEC base
        segmexec        # Segmentation based non-executable pages
}

#
# Extended Netlink classes
#
class netlink_route_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_firewall_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_tcpdiag_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_nflog_socket
inherits socket

class netlink_xfrm_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_selinux_socket
inherits socket

class netlink_audit_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
	nlmsg_relay
	nlmsg_readpriv
}

class netlink_ip6fw_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_dnrt_socket
inherits socket

# Define the access vector interpretation for controlling
# access and communication through the D-BUS messaging
# system.
#
class dbus
{
	acquire_svc
	send_msg
}

# Define the access vector interpretation for controlling
# access through the name service cache daemon (nscd).
#
class nscd
{
	getpwd
	getgrp
	gethost
	getstat
	admin
       shmempwd
       shmemgrp
       shmemhost
}

# Define the access vector interpretation for controlling
# access to IPSec network data by association
#
class association
{
       sendto
       recvfrom
}

# Updated Netlink class for KOBJECT_UEVENT family.
class netlink_kobject_uevent_socket
inherits socket
#line 1 "mls"
#
# Define sensitivities 
#
# Each sensitivity has a name and zero or more aliases.
#
sensitivity s0 alias lowestS;
sensitivity s1 alias lowestS_one;
sensitivity s2 alias lowestS_two;
sensitivity s3 alias {lowestS_three s_and_3 fourth_up};
sensitivity s4 alias lowestS_four;
sensitivity s5 alias lowestS_five;
sensitivity s6 alias lowestS_six;
sensitivity s7 alias lowestS_seven;
sensitivity s8 alias lowestS_eight;
sensitivity s9 alias lowestS_nine;
sensitivity s10 alias lowestS_ten;
sensitivity s11 alias lowestS_eleven;
sensitivity s12 alias lowestS_twelve;
sensitivity s13 alias lowestS_thirteen;
sensitivity s14 alias lowestS_fourteen;
sensitivity s15 alias lowestS_fifteen;

sensitivity public;
sensitivity super_secret;
sensitivity national_secret;
sensitivity middle_secret;

sensitivity force_public;
sensitivity exec_sens;
sensitivity boot_sens;
#
# Define the ordering of the sensitivity levels (least to greatest)
#
dominance { force_public public s0 boot_sens s1 s2 s3 s4 exec_sens s5 s6 s7 s8 s9 super_secret s10 s11 s12 middle_secret s13 s14 s15 national_secret }


#
# Define the categories
#
# Each category has a name and zero or more aliases.
#
category employee_memo;
category rand_cat0; category rand_cat1; category rand_cat2;
category alessandro_file0 alias {my_name intern_name name_start_with_a only_aliased_cat}; 
category alessandro_file1; category alessandro_file2;
category intern_file0; category intern_file1; category intern_file2;
category c0; category c1; category c2; category c3;
category c4; category c5; category c6; category c7;
category c8; category c9; category c10; category c11;
category c12; category c13; category c14; category c15;
category c16; category c17; category c18; category c19;
category c20; category c21; category c22; category c23;
category c24; category c25; category c26; category c27;
category c28; category c29; category c30; category c31;
category c32; category c33; category c34; category c35;
category c36; category c37; category c38; category c39;
category c40; category c41; category c42; category c43;
category c44; category c45; category c46; category c47;
category c48; category c49; category c50; category c51;
category c52; category c53; category c54; category c55;
category c56; category c57; category c58; category c59;
category c60; category c61; category c62; category c63;
category c64; category c65; category c66; category c67;
category c68; category c69; category c70; category c71;
category c72; category c73; category c74; category c75;
category c76; category c77; category c78; category c79;
category c80; category c81; category c82; category c83;
category c84; category c85; category c86; category c87;
category c88; category c89; category c90; category c91;
category c92; category c93; category c94; category c95;
category c96; category c97; category c98; category c99;

category project_report_low; category project_report_mid;
category project_report_high;

category c100; category c101; category c102; category c103;
category c104; category c105; category c106; category c107;
category c108; category c109; category c110; category c111;
category c112; category c113; category c114; category c115;
category c116; category c117; category c118; category c119;
category ls_bin_cat;
category c120; category c121; category c122; category c123;
category c124; category c125; category c126; category c127;
category c128; category c129; category c130; category c131;
category c132; category c133; category c134; category c135;
category c136; category c137; category c138; category c139;
category c140; category c141; category c142; category c143;
category c144; category c145; category c146; category c147;
category c148; category c149; category c150; category c151;
category c152; category c153; category c154; category c155;
category c156; category c157; category c158; category c159;
category c160; category c161; category c162; category c163;
category c164; category c165; category c166; category c167;
category c168; category c169; category c170; category c171;
category misc_bin; category low_secure_bin;  category mid_secure_bin; category high_secure_bin;
category shell_bin0; category shell_bin1; category shell_bin2;
category zshell_bin;
category browsers_cat; category browsers_java_cat; category browsers_java_cookies_cat;
category c172; category c173; category c174; category c175;
category c176; category c177; category c178; category c179;
category c180; category c181; category c182; category c183;
category c184; category c185; category c186; category c187;
category c188; category c189; category c190; category c191;
category c192; category c193; category c194; category c195;
category c196; category c197; category c198; category c199;
category c200; category c201; category c202; category c203;
category c204; category c205; category c206; category c207;
category c208; category c209; category c210; category c211;
category c212; category c213; category c214; category c215;
category c216; category c217; category c218; category c219;
category c220; category c221; category c222; category c223;
category c224; category c225; category c226; category c227;
category c228; category c229; category c230; category c231;
category c232; category c233; category c234; category c235;
category c236; category c237; category c238; category c239;
category c240; category c241; category c242; category c243;
category c244; category c245; category c246; category c247;
category c248; category c249; category c250; category c251;
category c252; category c253; category c254; category c255;
category absolute_cat0; category absolute_cat1; category absolute_cat2;
category absolute_cat3; category absolute_cat4;
category c_console_exec_low; category c_console_exec_mid; category c_console_exec_high;
#
# Each MLS level specifies a sensitivity and zero or more categories which may
# be associated with that sensitivity.
#
level s0:c0.c255;
level s1:c0.c255;
level s2:c0.c255;
level s3:c0.c255;
level s4:c0.c255;
level s5:c0.c255;
level s6:c0.c255;
level s7:c0.c255;
level s8:c0.c255;
level s9:c0.c255;
level s10:c0.c255;
level s11:c0.c255;
level s12:c0.c255;
level s13:c0.c255;
level s14:c0.c255;
level s15:c0.c255;
level national_secret:rand_cat1,rand_cat2,c15.c20;
level public:alessandro_file0.alessandro_file2,c25.c234;
level super_secret:intern_file0.intern_file2,c28.c47;
level middle_secret:c213.c240,absolute_cat0.absolute_cat4,project_report_low.project_report_high;
level force_public:employee_memo.rand_cat2;
level exec_sens:ls_bin_cat,misc_bin.browsers_java_cookies_cat, c_console_exec_low.c_console_exec_high, c100.c200;
level boot_sens:c0.c6;
#
# Define the MLS policy
#
# mlsconstrain class_set perm_set expression ;
#
# mlsvalidatetrans class_set expression ;
#
# expression : ( expression )
#	     | not expression
#	     | expression and expression
#	     | expression or expression
#	     | u1 op u2
#	     | r1 role_mls_op r2
#	     | t1 op t2
#	     | l1 role_mls_op l2
#	     | l1 role_mls_op h2
#	     | h1 role_mls_op l2
#	     | h1 role_mls_op h2
#	     | l1 role_mls_op h1
#	     | l2 role_mls_op h2
#	     | u1 op names
#	     | u2 op names
#	     | r1 op names
#	     | r2 op names
#	     | t1 op names
#	     | t2 op names
#	     | u3 op names (NOTE: this is only available for mlsvalidatetrans)
#	     | r3 op names (NOTE: this is only available for mlsvalidatetrans)
#	     | t3 op names (NOTE: this is only available for mlsvalidatetrans)
#
# op : == | !=
# role_mls_op : == | != | eq | dom | domby | incomp
#
# names : name | { name_list }
# name_list : name | name_list name
#

#
# MLS policy for the file classes
#

# make sure these file classes are "single level"
mlsconstrain { file lnk_file fifo_file } { create relabelto }
	( l2 eq h2 );

# new file labels must be dominated by the relabeling subject's clearance
mlsconstrain { dir file lnk_file chr_file blk_file sock_file fifo_file } relabelto
	( h1 dom h2 );

# the file "read" ops (note the check is dominance of the low level)
mlsconstrain { dir file lnk_file chr_file blk_file sock_file fifo_file } { read getattr execute }
	(( l1 dom l2 ) or
	 (( t1 == mlsfilereadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsfileread ) or
	 ( t2 == mlstrustedobject ));

mlsconstrain dir search
	(( l1 dom l2 ) or
	 (( t1 == mlsfilereadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsfileread ) or
	 ( t2 == mlstrustedobject ));

# the "single level" file "write" ops
mlsconstrain { file lnk_file fifo_file } { write create setattr relabelfrom append unlink link rename mounton }
	(( l1 eq l2 ) or
	 (( t1 == mlsfilewritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsfilewrite ) or
	 ( t2 == mlstrustedobject ));

# the "ranged" file "write" ops
mlsconstrain { dir chr_file blk_file sock_file } { write create setattr relabelfrom append unlink link rename mounton }
	((( l1 dom l2 ) and ( l1 domby h2 )) or
	 (( t1 == mlsfilewritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsfilewrite ) or
	 ( t2 == mlstrustedobject ));

mlsconstrain dir { add_name remove_name reparent rmdir }
	((( l1 dom l2 ) and ( l1 domby h2 )) or
	 (( t1 == mlsfilewritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsfilewrite ) or
	 ( t2 == mlstrustedobject ));

# these access vectors have no MLS restrictions
# { dir file lnk_file chr_file blk_file sock_file fifo_file } { ioctl lock swapon quotaon }
#
# { file chr_file } { execute_no_trans entrypoint execmod }

# the file upgrade/downgrade rule
mlsvalidatetrans { dir file lnk_file chr_file blk_file sock_file fifo_file }
	((( l1 eq l2 ) or
	  (( t3 == mlsfileupgrade ) and ( l1 domby l2 )) or
	  (( t3 == mlsfiledowngrade ) and ( l1 dom l2 )) or
	  (( t3 == mlsfiledowngrade ) and ( l1 incomp l2 ))) and
	 (( h1 eq h2 ) or
	  (( t3 == mlsfileupgrade ) and ( h1 domby h2 )) or
	  (( t3 == mlsfiledowngrade ) and ( h1 dom h2 )) or
	  (( t3 == mlsfiledowngrade ) and ( h1 incomp h2 ))));

# create can also require the upgrade/downgrade checks if the creating process
# has used setfscreate (note that both the high and low level of the object
# default to the process' sensitivity level)
mlsconstrain { dir file lnk_file chr_file blk_file sock_file fifo_file } create
	((( l1 eq l2 ) or
	  (( t1 == mlsfileupgrade ) and ( l1 domby l2 )) or
	  (( t1 == mlsfiledowngrade ) and ( l1 dom l2 )) or
	  (( t1 == mlsfiledowngrade ) and ( l1 incomp l2 ))) and
	 (( l1 eq h2 ) or
	  (( t1 == mlsfileupgrade ) and ( l1 domby h2 )) or
	  (( t1 == mlsfiledowngrade ) and ( l1 dom h2 )) or
	  (( t1 == mlsfiledowngrade ) and ( l1 incomp h2 ))));




#
# MLS policy for the filesystem class
#

# new filesystem labels must be dominated by the relabeling subject's clearance
mlsconstrain filesystem relabelto
	( h1 dom h2 );

# the filesystem "read" ops (implicit single level)
mlsconstrain filesystem { getattr quotaget }
	(( l1 dom l2 ) or
	 (( t1 == mlsfilereadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsfileread ));

# all the filesystem "write" ops (implicit single level)
mlsconstrain filesystem { mount remount unmount relabelfrom quotamod }
	(( l1 eq l2 ) or
	 (( t1 == mlsfilewritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsfilewrite ));

# these access vectors have no MLS restrictions
# filesystem { transition associate }




#
# MLS policy for the socket classes
#

# new socket labels must be dominated by the relabeling subject's clearance
mlsconstrain { socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket } relabelto
	( h1 dom h2 );

# the socket "read" ops (note the check is dominance of the low level)
mlsconstrain { socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket } { read getattr listen accept getopt recvfrom recv_msg }
	(( l1 dom l2 ) or
	 (( t1 == mlsnetreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsnetread ));

mlsconstrain { netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_xfrm_socket netlink_audit_socket netlink_ip6fw_socket } nlmsg_read
	(( l1 dom l2 ) or
	 (( t1 == mlsnetreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsnetread ));

# the socket "write" ops
mlsconstrain { socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket } { write setattr relabelfrom connect setopt shutdown }
	((( l1 dom l2 ) and ( l1 domby h2 )) or
	 (( t1 == mlsnetwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsnetwrite ));

# these access vectors have no MLS restrictions
# { socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket } { ioctl create lock append bind sendto send_msg name_bind }
#
# { tcp_socket udp_socket rawip_socket } node_bind
#
# { tcp_socket unix_stream_socket } { connectto newconn acceptfrom }
#
# { netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_xfrm_socket netlink_audit_socket netlink_ip6fw_socket } nlmsg_write
#




#
# MLS policy for the ipc classes
#

# the ipc "read" ops (implicit single level)
mlsconstrain { ipc sem msgq shm } { getattr read unix_read }
	(( l1 dom l2 ) or
	 (( t1 == mlsipcreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsipcread ));

mlsconstrain msg receive
	(( l1 dom l2 ) or
	 (( t1 == mlsipcreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsipcread ));

# the ipc "write" ops (implicit single level)
mlsconstrain { ipc sem msgq shm } { create destroy setattr write unix_write }
	(( l1 eq l2 ) or
	 (( t1 == mlsipcwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsipcwrite ));

mlsconstrain msgq enqueue
	(( l1 eq l2 ) or
	 (( t1 == mlsipcwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsipcwrite ));

mlsconstrain shm lock
	(( l1 eq l2 ) or
	 (( t1 == mlsipcwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsipcwrite ));

mlsconstrain msg send
	(( l1 eq l2 ) or
	 (( t1 == mlsipcwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsipcwrite ));

# these access vectors have no MLS restrictions
# { ipc sem msgq shm } associate




#
# MLS policy for the fd class
#

# these access vectors have no MLS restrictions
# fd use




#
# MLS policy for the network object classes
#

# the netif/node "read" ops (implicit single level socket doing the read)
#                           (note the check is dominance of the low level)
mlsconstrain { node netif } { tcp_recv udp_recv rawip_recv }
	(( l1 dom l2 ) or ( t1 == mlsnetrecvall ));

# the netif/node "write" ops (implicit single level socket doing the write)
mlsconstrain { netif node } { tcp_send udp_send rawip_send }
	(( l1 dom l2 ) and ( l1 domby h2 ));

# these access vectors have no MLS restrictions
# { netif node } { enforce_dest }




#
# MLS policy for the process class
#

# new process labels must be dominated by the relabeling subject's clearance
# and sensitivity level changes require privilege
mlsconstrain process transition
	(( h1 dom h2 ) and
	 (( l1 eq l2 ) or ( t1 == mlsprocsetsl ) or
	  (( t1 == privrangetrans ) and ( t2 == mlsrangetrans ))));
mlsconstrain process dyntransition
	(( h1 dom h2 ) and
	 (( l1 eq l2 ) or ( t1 == mlsprocsetsl )));

# all the process "read" ops
mlsconstrain process { getsched getsession getpgid getcap getattr ptrace share }
	(( l1 dom l2 ) or
	 (( t1 == mlsprocreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsprocread ));

# all the process "write" ops (note the check is equality on the low level)
mlsconstrain process { sigkill sigstop signal setsched setpgid setcap setexec setfscreate setcurrent ptrace share }
	(( l1 eq l2 ) or
	 (( t1 == mlsprocwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsprocwrite ));

# these access vectors have no MLS restrictions
# process { fork sigchld signull noatsecure siginh setrlimit rlimitinh execmem }




#
# MLS policy for the security class
#

# these access vectors have no MLS restrictions
# security *




#
# MLS policy for the system class
#

# these access vectors have no MLS restrictions
# system *




#
# MLS policy for the capability class
#

# these access vectors have no MLS restrictions
# capability *




#
# MLS policy for the passwd class
#

# these access vectors have no MLS restrictions
# passwd *




#
# MLS policy for the drawable class
#

# the drawable "read" ops (implicit single level)
mlsconstrain drawable { getattr copy }
	(( l1 dom l2 ) or
	 (( t1 == mlsxwinreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsxwinread ));

# the drawable "write" ops (implicit single level)
mlsconstrain drawable { create destroy draw copy }
	(( l1 eq l2 ) or
	 (( t1 == mlsxwinwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsxwinwrite ));




#
# MLS policy for the gc class
#

# the gc "read" ops (implicit single level)
mlsconstrain gc getattr
	(( l1 dom l2 ) or
	 (( t1 == mlsxwinreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsxwinread ));

# the gc "write" ops (implicit single level)
mlsconstrain gc { create free setattr }
	(( l1 eq l2 ) or
	 (( t1 == mlsxwinwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsxwinwrite ));




#
# MLS policy for the window class
#

# the window "read" ops (implicit single level)
mlsconstrain window { listprop getattr enumerate mousemotion inputevent drawevent windowchangeevent windowchangerequest serverchangeevent extensionevent }
	(( l1 dom l2 ) or
	 (( t1 == mlsxwinreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsxwinread ));

# the window "write" ops (implicit single level)
mlsconstrain window { addchild create destroy chstack chproplist chprop setattr setfocus move chselection chparent ctrllife transparent clientcomevent }
	(( l1 eq l2 ) or
	 (( t1 == mlsxwinwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsxwinwrite ) or
	 ( t2 == mlstrustedobject ));

# these access vectors have no MLS restrictions
# window { map unmap }




#
# MLS policy for the font class
#

# the font "read" ops (implicit single level)
mlsconstrain font { load getattr }
	(( l1 dom l2 ) or
	 (( t1 == mlsxwinreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsxwinread ));

# the font "write" ops (implicit single level)
mlsconstrain font free
	(( l1 eq l2 ) or
	 (( t1 == mlsxwinwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsxwinwrite ));

# these access vectors have no MLS restrictions
# font use




#
# MLS policy for the colormap class
#

# the colormap "read" ops (implicit single level)
mlsconstrain colormap { list read getattr }
	(( l1 dom l2 ) or
	 (( t1 == mlsxwinreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsxwinreadcolormap ) or
	 ( t1 == mlsxwinread ));

# the colormap "write" ops (implicit single level)
mlsconstrain colormap { create free install uninstall store setattr }
	(( l1 eq l2 ) or
	 (( t1 == mlsxwinwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsxwinwritecolormap ) or
	 ( t1 == mlsxwinwrite ));




#
# MLS policy for the property class
#

# the property "read" ops (implicit single level)
mlsconstrain property { read }
	(( l1 dom l2 ) or
	 (( t1 == mlsxwinreadtoclr ) and ( h1 dom l2 )) or
	 ( t1 == mlsxwinreadproperty ) or
	 ( t1 == mlsxwinread ));

# the property "write" ops (implicit single level)
mlsconstrain property { create free write }
	(( l1 eq l2 ) or
	 (( t1 == mlsxwinwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsxwinwriteproperty ) or
	 ( t1 == mlsxwinwrite ));




#
# MLS policy for the cursor class
#

# the cursor "write" ops (implicit single level)
mlsconstrain cursor { create createglyph free assign setattr }
	(( l1 eq l2 ) or
	 (( t1 == mlsxwinwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsxwinwrite ));




#
# MLS policy for the xclient class
#

# the xclient "write" ops (implicit single level)
mlsconstrain xclient kill
	(( l1 eq l2 ) or
	 (( t1 == mlsxwinwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsxwinwrite ));




#
# MLS policy for the xinput class
#

# these access vectors have no MLS restrictions
# xinput ~{ relabelinput setattr }

# the xinput "write" ops (implicit single level)
mlsconstrain xinput { setattr relabelinput }
	(( l1 eq l2 ) or
	 (( t1 == mlsxwinwritetoclr ) and ( h1 dom l2 ) and ( l1 domby l2 )) or
	 ( t1 == mlsxwinwritexinput ) or
	 ( t1 == mlsxwinwrite ));




#
# MLS policy for the xserver class
#

# these access vectors have no MLS restrictions
# xserver *




#
# MLS policy for the xextension class
#

# these access vectors have no MLS restrictions
# xextension { query use }


#
# MLS policy for the pax class
#

# these access vectors have no MLS restrictions
# pax { pageexec emutramp mprotect randmmap randexec segmexec }




#
# MLS policy for the dbus class
#

# these access vectors have no MLS restrictions
# dbus { acquire_svc send_msg }




#
# MLS policy for the nscd class
#

# these access vectors have no MLS restrictions
# nscd { getpwd getgrp gethost getstat admin shmempwd shmemgrp shmemhost }




#
# MLS policy for the association class
#

# these access vectors have no MLS restrictions
# association { sendto recvfrom }

#line 1 "tunables/distro.tun"
# Distro-specific customizations.

# Comment out all but the one that matches your distro.
# The policy .te files can then wrap distro-specific customizations with
# appropriate ifdefs.




#line 11

#line 13

#line 1 "tunables/tunable.tun"






#line 1 "attrib.te"
#
# Declarations for type attributes.
# 

# A type attribute can be used to identify a set of types with a similar
# property.  Each type can have any number of attributes, and each
# attribute can be associated with any number of types.  Attributes are
# explicitly declared here, and can then be associated with particular
# types in type declarations.  Attribute names can then be used throughout 
# the configuration to express the set of types that are associated with 
# the attribute.  Attributes have no implicit meaning to SELinux.  The
# meaning of all attributes are completely defined through their
# usage within the configuration, but should be documented here as
# comments preceding the attribute declaration.  

#####################
# Attributes for MLS:
#

# Common Terminology
# 	MLS Range: low-high
#		low referred to as "Effective Sensitivity Label (SL)"
#		high referred to as "Clearance SL"


#
# File System MLS attributes/privileges
#
# Grant MLS read access to files not dominated by the process Effective SL
attribute mlsfileread;
# Grant MLS read access to files which dominate the process Effective SL
# and are dominated by the process Clearance SL
attribute mlsfilereadtoclr;
# Grant MLS write access to files not equal to the Effective SL
attribute mlsfilewrite;
# Grant MLS write access to files which dominate the process Effective SL
# and are dominated by the process Clearance SL
attribute mlsfilewritetoclr;
# Grant MLS ability to change file label to a new label which dominates
# the old label  
attribute mlsfileupgrade;
# Grant MLS ability to change file label to a new label which is
# dominated by or incomparable to the old label
attribute mlsfiledowngrade;
attribute device_a;
#
# Network MLS attributes/privileges
#
# Grant MLS read access to packets not dominated by the process Effective SL
attribute mlsnetread;
# Grant MLS read access to packets which dominate the process Effective SL
# and are dominated by the process Clearance SL
attribute mlsnetreadtoclr;
# Grant MLS write access to packets not equal to the Effective SL
attribute mlsnetwrite;
# Grant MLS write access to packets which dominate the Effective SL
# and are dominated by the process Clearance SL
attribute mlsnetwritetoclr;
# Grant MLS read access to packets from hosts or interfaces which dominate
# or incomparable to the process Effective SL
attribute mlsnetrecvall;
# Grant MLS ability to change socket label to a new label which dominates
# the old label  
attribute mlsnetupgrade;
# Grant MLS ability to change socket label to a new label which is
# dominated by or incomparable to the old label
attribute mlsnetdowngrade;

#
# IPC MLS attributes/privileges
#
# Grant MLS read access to IPC objects not dominated by the process Effective SL
attribute mlsipcread;
# Grant MLS read access to IPC objects which dominate the process Effective SL
# and are dominated by the process Clearance SL
attribute mlsipcreadtoclr;
# Grant MLS write access to IPC objects not equal to the process Effective SL
attribute mlsipcwrite;
# Grant MLS write access to IPC objects which dominate the process Effective SL
# and are dominated by the process Clearance SL
attribute mlsipcwritetoclr;

#
# Process MLS attributes/privileges
#
# Grant MLS read access to processes not dominated by the process Effective SL
attribute mlsprocread;
# Grant MLS read access to processes which dominate the process Effective SL
# and are dominated by the process Clearance SL
attribute mlsprocreadtoclr;
# Grant MLS write access to processes not equal to the Effective SL
attribute mlsprocwrite;
# Grant MLS write access to processes which dominate the process Effective SL
# and are dominated by the process Clearance SL
attribute mlsprocwritetoclr;
# Grant MLS ability to change Effective SL or Clearance SL of process to a
# label dominated by the Clearance SL
attribute mlsprocsetsl;

#
# X Window MLS attributes/privileges
#
# Grant MLS read access to X objects not dominated by the process Effective SL
attribute mlsxwinread;
# Grant MLS read access to X objects which dominate the process Effective SL
# and are dominated by the process Clearance SL
attribute mlsxwinreadtoclr;
# Grant MLS write access to X objects not equal to the process Effective SL
attribute mlsxwinwrite;
# Grant MLS write access to X objects which dominate the process Effective SL
# and are dominated by the process Clearance SL
attribute mlsxwinwritetoclr;
# Grant MLS read access to X properties not dominated by
# the process Effective SL
attribute mlsxwinreadproperty;
# Grant MLS write access to X properties not equal to the process Effective SL
attribute mlsxwinwriteproperty;
# Grant MLS read access to X colormaps not dominated by
# the process Effective SL
attribute mlsxwinreadcolormap;
# Grant MLS write access to X colormaps not equal to the process Effective SL
attribute mlsxwinwritecolormap;
# Grant MLS write access to X xinputs not equal to the process Effective SL
attribute mlsxwinwritexinput;

# Grant MLS read/write access to objects which internally arbitrate MLS
attribute mlstrustedobject;

#
# Both of the following attributes are needed for a range transition to succeed
#
# Grant ability for the current domain to change SL upon process transition
attribute privrangetrans;
# Grant ability for the new process domain to change SL upon process transition
attribute mlsrangetrans;

#########################
# Attributes for domains:
#

# The domain attribute identifies every type that can be 
# assigned to a process.  This attribute is used in TE rules 
# that should be applied to all domains, e.g. permitting 
# init to kill all processes.
attribute domain;

# The daemon attribute identifies domains for system processes created via
# the daemon_domain, daemon_base_domain, and init_service_domain macros.
attribute daemon;

# The privuser attribute identifies every domain that can 
# change its SELinux user identity.  This attribute is used 
# in the constraints configuration.  NOTE:  This attribute
# is not required for domains that merely change the Linux
# uid attributes, only for domains that must change the
# SELinux user identity.  Also note that this attribute makes
# no sense without the privrole attribute.
attribute privuser;

# The privrole attribute identifies every domain that can 
# change its SELinux role.  This attribute is used in the 
# constraints configuration.
attribute privrole;

# The userspace_objmgr attribute identifies every domain
# which enforces its own policy.
attribute userspace_objmgr;

# The priv_system_role attribute identifies every domain that can
# change role from a user role to system_r role, and identity from a user
# identity to system_u.  It is used in the constraints configuration.
attribute priv_system_role;

# The privowner attribute identifies every domain that can 
# assign a different SELinux user identity to a file, or that
# can create a file with an identity that is not the same as the
# process identity.  This attribute is used in the constraints
# configuration.
attribute privowner;

# The privlog attribute identifies every domain that can 
# communicate with syslogd through its Unix domain socket.
# There is an assertion that other domains can not do it,
# and an allow rule to permit it
attribute privlog;

# The privmodule attribute identifies every domain that can run
# modprobe, there is an assertion that other domains can not do it,
# and an allow rule to permit it
attribute privmodule;

# The privsysmod attribute identifies every domain that can have the
# sys_module capability
attribute privsysmod;

# The privmem attribute identifies every domain that can 
# access kernel memory devices.
# This attribute is used in the TE assertions to verify
# that such access is limited to domains that are explicitly
# tagged with this attribute.
attribute privmem;

# The privkmsg attribute identifies every domain that can 
# read kernel messages (/proc/kmsg)
# This attribute is used in the TE assertions to verify
# that such access is limited to domains that are explicitly
# tagged with this attribute.
attribute privkmsg;

# The privfd attribute identifies every domain that should have
# file handles inherited widely (IE sshd_t and getty_t).
attribute privfd;

# The privhome attribute identifies every domain that can create files under
# regular user home directories in the regular context (IE act on behalf of
# a user in writing regular files)
attribute privhome;

# The auth attribute identifies every domain that needs
# to read /etc/shadow, and grants the permission.
attribute auth;

# The auth_bool attribute identifies every domain that can 
# read /etc/shadow if its boolean is set;
attribute auth_bool;

# The auth_write attribute identifies every domain that can have write or
# relabel access to /etc/shadow, but does not grant it.
attribute auth_write;

# The auth_chkpwd attribute identifies every system domain that can
# authenticate users by running unix_chkpwd
attribute auth_chkpwd;

# The change_context attribute identifies setfiles_t, restorecon_t, and other
# system domains that change the context of most/all files on the system
attribute change_context;

# The etc_writer attribute identifies every domain that can write to etc_t
attribute etc_writer;

# The sysctl_kernel_writer attribute identifies domains that can write to
# sysctl_kernel_t, in addition the admin attribute is permitted write access
attribute sysctl_kernel_writer;

# the sysctl_net_writer attribute identifies domains that can write to
# sysctl_net_t files.
attribute sysctl_net_writer;

# The sysctl_type attribute identifies every type that is assigned
# to a sysctl entry.  This can be used in allow rules to grant
# permissions to all sysctl entries without enumerating each individual
# type, but should be used with care.
attribute sysctl_type;

# The admin attribute identifies every administrator domain.
# It is used in TE assertions when verifying that only administrator 
# domains have certain permissions.  
# This attribute is presently associated with sysadm_t and 
# certain administrator utility domains.  
# XXX The use of this attribute should be reviewed for consistency.
# XXX Might want to partition into several finer-grained attributes 
# XXX used in different assertions within assert.te.
attribute admin;

# The secadmin attribute identifies every security administrator domain.
# It is used in TE assertions when verifying that only administrator 
# domains have certain permissions.  
# This attribute is presently associated with sysadm_t and secadm_t
attribute secadmin;

# The userdomain attribute identifies every user domain, presently
# user_t and sysadm_t.  It is used in TE rules that should be applied
# to all user domains.
attribute userdomain;

# for a small domain that can only be used for newrole
attribute user_mini_domain;

# pty for the mini domain
attribute mini_pty_type;

# pty created by a server such as sshd
attribute server_pty;

# attribute for all non-administrative devpts types
attribute userpty_type;

# The user_tty_type identifies every type for a tty or pty owned by an
# unpriviledged user
attribute user_tty_type;

# The admin_tty_type identifies every type for a tty or pty owned by a
# priviledged user
attribute admin_tty_type;

# The user_crond_domain attribute identifies every user_crond domain, presently
# user_crond_t and sysadm_crond_t.  It is used in TE rules that should be
# applied to all user domains.
attribute user_crond_domain;

# The unpriv_userdomain identifies non-administrative users (default user_t)
attribute unpriv_userdomain;

# This attribute is for the main user home directory for unpriv users
attribute user_home_dir_type;

# The gphdomain attribute identifies every gnome-pty-helper derived
# domain.  It is used in TE rules to permit inheritance and use of
# descriptors created by these domains.
attribute gphdomain;

# The fs_domain identifies every domain that may directly access a fixed disk
attribute fs_domain;

# This attribute is for all domains for the userhelper program.
attribute userhelperdomain;

############################
# Attributes for file types:
#

# The file_type attribute identifies all types assigned to files 
# in persistent filesystems.  It is used in TE rules to permit
# the association of all such file types with persistent filesystem
# types, and to permit certain domains to access all such types as 
# appropriate.
attribute file_type;

# The secure_file_type attribute identifies files 
# which will be treated with a higer level of security.
# Most domains will be prevented from manipulating files in this domain
attribute secure_file_type;

# The device_type attribute identifies all types assigned to device nodes
attribute device_type;

# The proc_fs attribute identifies all types that may be assigned to
# files under /proc.
attribute proc_fs;

# The dev_fs attribute identifies all types that may be assigned to
# files, sockets, or pipes under /dev.
attribute dev_fs;

# The sysadmfile attribute identifies all types assigned to files 
# that should be completely accessible to administrators.  It is used
# in TE rules to grant such access for administrator domains.
attribute sysadmfile;

# The secadmfile attribute identifies all types assigned to files 
# that should be only accessible to security administrators.  It is used
# in TE rules to grant such access for security administrator domains.
attribute secadmfile;

# The fs_type attribute identifies all types assigned to filesystems
# (not limited to persistent filesystems).
# It is used in TE rules to permit certain domains to mount
# any filesystem and to permit most domains to obtain the
# overall filesystem statistics.
attribute fs_type;

# The mount_point attribute identifies all types that can serve
# as a mount point (for the mount binary). It is used in the mount 
# policy to grant mounton permission, and in other domains to grant 
# getattr permission over all the mount points.
attribute mount_point;

# The exec_type attribute identifies all types assigned
# to entrypoint executables for domains.  This attribute is 
# used in TE rules and assertions that should be applied to all 
# such executables.
attribute exec_type;

# The tmpfile attribute identifies all types assigned to temporary 
# files.  This attribute is used in TE rules to grant certain 
# domains the ability to remove all such files (e.g. init, crond).
attribute tmpfile;

# The user_tmpfile attribute identifies all types associated with temporary
# files for unpriv_userdomain domains.
attribute user_tmpfile;

# for the user_xserver_tmp_t etc
attribute xserver_tmpfile;

# The tmpfsfile attribute identifies all types defined for tmpfs 
# type transitions. 
# It is used in TE rules to grant certain domains the ability to
# access all such files.
attribute tmpfsfile;

# The home_type attribute identifies all types assigned to home
# directories.  This attribute is used in TE rules to grant certain
# domains the ability to access all home directory types.
attribute home_type;

# This attribute is for the main user home directory /home/user, to
# distinguish it from sub-dirs.  Often you want a process to be able to
# read the user home directory but not read the regular directories under it.
attribute home_dir_type;

# The ttyfile attribute identifies all types assigned to ttys.
# It is used in TE rules to grant certain domains the ability to
# access all ttys.
attribute ttyfile;

# The ptyfile attribute identifies all types assigned to ptys.
# It is used in TE rules to grant certain domains the ability to
# access all ptys.
attribute ptyfile;

# The pidfile attribute identifies all types assigned to pid files.
# It is used in TE rules to grant certain domains the ability to
# access all such files.
attribute pidfile;


############################
# Attributes for network types:
#

# The socket_type attribute identifies all types assigned to 
# kernel-created sockets.  Ordinary sockets are assigned the 
# domain of the creating process.
# XXX This attribute is unused.  Remove?
attribute socket_type;

# Identifies all types assigned to port numbers to control binding.
attribute port_type;

# Identifies all types assigned to reserved port (<1024) numbers to control binding.
attribute reserved_port_type;

# Identifies all types assigned to network interfaces to control
# operations on the interface (XXX obsolete, not supported via LSM) 
# and to control traffic sent or received on the interface.
attribute netif_type;

# Identifies all default types assigned to packets received 
# on network interfaces.  
attribute netmsg_type;

# Identifies all types assigned to network nodes/hosts to control
# traffic sent to or received from the node.
attribute node_type;

# Identifier for log files or directories that only exist for log files.
attribute logfile;

# Identifier for lock files (/var/lock/*) or directories that only exist for
# lock files.
attribute lockfile;



##############################
# Attributes for security policy types:
#

# The login_contexts attribute idenitifies the files used
# to define default contexts for login types (e.g., login, cron).
attribute login_contexts;

# Identifier for a domain used by "sendmail -t" (IE user_mail_t,
# sysadm_mail_t, etc)
attribute user_mail_domain;

# Identifies domains that can transition to system_mail_t
attribute privmail;

# Type for non-sysadm home directory
attribute user_home_type;

# For domains that are part of a mail server and need to read user files and
# fifos, and inherit file handles to enable user email to get to the mail
# spool
attribute mta_user_agent;

# For domains that are part of a mail server for delivering messages to the
# user
attribute mta_delivery_agent;

# For domains that make outbound TCP port 25 connections to send mail from the
# mail server.
attribute mail_server_sender;

# For a mail server process that takes TCP connections on port 25
attribute mail_server_domain;

# For web clients such as netscape and squid
attribute web_client_domain;

# For X Window System server domains
attribute xserver;

# For X Window System client domains
attribute xclient;

# For X Window System protocol extensions
attribute xextension;

# For X Window System property types
attribute xproperty;

#
# For file systems that do not have extended attributes but need to be
# r/w by users
#
attribute noexattrfile;

#
# For filetypes that the usercan read
#
attribute usercanread;

#
# For serial devices
#
attribute serial_device;

# Attribute to designate unrestricted access
attribute unrestricted;

# Attribute to designate can transition to unconfined_t
attribute unconfinedtrans;

# For clients of nscd.
attribute nscd_client_domain;

# For clients of nscd that can use shmem interface.
attribute nscd_shmem_domain;

# For labeling of content for httpd.  This attribute is only used by
# the httpd_unified domain, which says treat all httpdcontent the
# same.  If you want content to be served in a "non-unified" system
# you must specifically add "r_dir_file(httpd_t, your_content_t)" to
# your policy.
attribute httpdcontent;

# For labeling of domains whos transition can be disabled
attribute transitionbool;

# For labelling daemons that should not have a range transition to "s0"
# included in the daemon_base_domain macro
attribute no_daemon_range_trans;

# For labeling of file_context domains which users can change files to rather
# then the default file context.  These file_context can survive a relabeling
# of the file system.
attribute customizable;

##############################
# Attributes for polyinstatiation support:
#

# For labeling types that are to be polyinstantiated
attribute polydir;

# And for labeling the parent directories of those polyinstantiated directories
# This is necessary for remounting the original in the parent to give
# security aware apps access
attribute polyparent;

# And labeling for the member directories
attribute polymember;

#line 1 "tmp/program_used_flags.te"




































































































#line 1 "macros/program/apache_macros.te"

#line 149

#line 205

#line 1 "macros/program/bonobo_macros.te"
#
# Bonobo
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#
# bonobo_domain(role_prefix) - invoke per role
# bonobo_client(app_prefix, role_prefix) - invoke per client app
# bonobo_connect(type1_prefix, type2_prefix) - 
# 	connect two bonobo clients, the channel is bidirectional

######################

#line 78
 
#line 80
#####################

#line 106
 
#line 108
#####################

#line 117
 # macros for the cdrecord domain
#line 2 "macros/program/cdrecord_macros.te"
# Author: Thomas Bleher <ThomasBleher@gmx.de>

#line 52


#line 1 "macros/program/chkpwd_macros.te"
#
# Macros for chkpwd domains.
#

#
# chkpwd_domain(domain_prefix)
#
# Define a derived domain for the *_chkpwd program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/su.te. 
#

#line 72

#line 72

#line 72

#line 72

#line 1 "macros/program/chroot_macros.te"

# macro for chroot environments
# Author Russell Coker

# chroot(initial_domain, basename, role, tty_device_type)
#line 131

#line 1 "macros/program/clamav_macros.te"
#
# Macros for clamscan
#
# Author:  Brian May <bam@snoopy.apana.org.au>
#

#
# can_clamd_connect(domain_prefix)
#
# Define a domain that can access clamd
#
#line 17


# clamscan_domain(domain_prefix)
#
# Define a derived domain for the clamscan program when executed
#
#line 45


#line 57


#line 1 "macros/program/crond_macros.te"
#
# Macros for crond domains.
#

#
# Authors:  Jonathan Crowley (MITRE) <jonathan@mitre.org>,
#	    Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser
#           Russell Coker <rcoker@redhat.com>
#

#
# crond_domain(domain_prefix)
#
# Define a derived domain for cron jobs executed by crond on behalf 
# of a user domain.  These domains are separate from the top-level domain
# defined for the crond daemon and the domain defined for system cron jobs,
# which are specified in domains/program/crond.te.
#

#line 114


# When system_crond_t domain executes a type $1 executable then transition to
# domain $2, allow $2 to interact with crond_t as well.
#line 1 "macros/program/crontab_macros.te"
#
# Macros for crontab domains.
#

#
# Authors:  Jonathan Crowley (MITRE) <jonathan@mitre.org>
# Revised by Stephen Smalley <sds@epoch.ncsc.mil>
#

#
# crontab_domain(domain_prefix)
#
# Define a derived domain for the crontab program when executed by
# a user domain.  
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/crontab.te. 
#

#line 102

#line 10 "macros/program/daemontools_macros.te"
 
#line 1 "macros/program/dbusd_macros.te"
#
# Macros for Dbus
#
# Author: Colin Walters <walters@redhat.com>

# dbusd_domain(domain_prefix)
#
# Define a derived domain for the DBus daemon.

#line 53

# dbusd_client(dbus_type, domain_prefix)
# Example: dbusd_client_domain(system, user)
#
# Define a new derived domain for connecting to dbus_type
# from domain_prefix_t. 

#line 78


# can_dbusd_converse(dbus_type, domain_prefix_a, domain_prefix_b)
# Example: can_dbusd_converse(system, hald, updfstab)
# Example: can_dbusd_converse(session, user, user)

#line 90

#line 90

#line 90
 
#line 1 "macros/program/ethereal_macros.te"
# DESC - Ethereal  
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#

#############################################################
# ethereal_networking(app_prefix) - 
#	restricted ethereal rules (sysadm only)
#                               

#line 25
 
#line 27
########################################################
# Ethereal (GNOME) 
#

#line 82
 #
#line 2 "macros/program/evolution_macros.te"
# Evolution   
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#

################################################
# evolution_common(app_prefix,role_prefix)
# 
#line 28
 
#line 30
#######################################
# evolution_data_server(role_prefix) 
#

#line 69
 
#line 71
#######################################
# evolution_webcal(role_prefix)
#

#line 97
 
#line 99
#######################################
# evolution_alarm(role_prefix)
#
#line 122
 
#line 124
########################################
# evolution_exchange(role_prefix)
#
#line 158
 
#line 160
#######################################
# evolution_domain(role_prefix)
#

#line 223
 
#line 225
#################################
#  evolution_domains(role_prefix) 

#line 234
 #
#line 2 "macros/program/fingerd_macros.te"
# Macro for fingerd
#
# Author:  Russell Coker <russell@coker.com.au>
#

#
# fingerd_macro(domain_prefix)
#
# allow fingerd to create a fingerlog file in the user home dir
#
#line 15

#line 1 "macros/program/fontconfig_macros.te"
#
# Fontconfig related types 
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#
# fontconfig_domain(role_prefix) - create fontconfig domain
#
# read_fonts(domain, role_prefix) - 
#         allow domain to read fonts, optionally per/user
#  

#line 27
 
#line 29
####################

#line 52
 #DESC games
#line 2 "macros/program/games_domain.te"
#
# Macros for games
#
#
# Authors:  Dan Walsh <dwalsh@redhat.com> 
#
#
# games_domain(domain_prefix)
#
#
#line 89

#line 1 "macros/program/gconf_macros.te"
#
# GConfd daemon  
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#

#######################################
# gconfd_domain(role_prefix)
#

#line 39
 
#line 41
#####################################
# gconf_client(prefix, role_prefix)
#

#line 57
 #
#line 2 "macros/program/gift_macros.te"
# Macros for giFT
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#
# gift_domains(domain_prefix)
# declares a domain for giftui and giftd

#########################
#  gift_domain(user)    #
#########################

#line 46
 
#line 48
##########################
#  giftd_domain(user)    #
##########################

#line 95
 
#line 97
##########################
#  gift_domains(user)    #
##########################

#line 104
 #
#line 2 "macros/program/gnome_macros.te"
# GNOME related types 
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#
# gnome_domain(role_prefix) - create GNOME domain (run for each role)
# gnome_application(app_prefix, role_prefix) - common stuff for gnome apps
# gnome_file_dialog(role_prefix) - gnome file dialog rules
# gnome_private_store(app_prefix, role_prefix) - store private files in .gnome2_private

#line 42


#################################

#line 88
 
#line 90
################################

#line 101
 
#line 103
################################

#line 115
 #
#line 2 "macros/program/gnome_vfs_macros.te"
# GNOME VFS daemon  
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#

#######################################
# gnome_vfs_domain(role_prefix)
#

#line 44
 
#line 46
#####################################
# gnome_vfs_client(prefix, role_prefix)
#

#line 55
 #
#line 2 "macros/program/gpg_agent_macros.te"
# Macros for gpg agent
#
# Author: Thomas Bleher <ThomasBleher@gmx.de>
#
# 
# gpg_agent_domain(domain_prefix)
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/gpg-agent.te. 
#
#line 1 "macros/program/gpg_macros.te"
#
# Macros for gpg and pgp
#
# Author:  Russell Coker <russell@coker.com.au>
#
# based on the work of:
# Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser
#

#
# gpg_domain(domain_prefix)
#
# Define a derived domain for the gpg/pgp program when executed by
# a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/gpg.te.
#
#line 1 "macros/program/gph_macros.te"
#
# Macros for gnome-pty-helper domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser 
#

#
# gph_domain(domain_prefix, role_prefix)
#
# Define a derived domain for the gnome-pty-helper program when
# executed by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/gnome-pty-helper.te. 
#
# The *_gph_t domains are for the gnome_pty_helper program.
# This program is executed by gnome-terminal to handle
# updates to utmp and wtmp.  In this regard, it is similar
# to utempter.  However, unlike utempter, gnome-pty-helper
# also creates the pty file for the terminal program.
# There is one *_gph_t domain for each user domain.  
#

#line 1 "macros/program/i18n_input_macros.te"
#
# Macros for i18n_input
#

#
# Authors:  Dan Walsh <dwalsh@redhat.com> 
#

#
# i18n_input_domain(domain)
#
#line 19



#line 1 "macros/program/iceauth_macros.te"
#
# Macros for iceauth domains.
#
# Author:  Ivan Gyurdiev <gyurdiev@redhat.com>
#
# iceauth_domain(domain_prefix)

#line 1 "macros/program/ice_macros.te"
#
# ICE related types 
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#
# ice_domain(prefix, role) - create ICE sockets
# ice_connect(type1_prefix, type2_prefix) - allow communication through ICE sockets 

#line 24


# FIXME: Should this be bidirectional?
# Adding only unidirectional for now.

#line 38

#line 1 "macros/program/inetd_macros.te"
#################################
#
# Rules for the $1_t domain.
#
# $1_t is a general domain for daemons started
# by inetd that do not have their own individual domains yet.
# $1_exec_t is the type of the corresponding
# programs.
#
#line 75

#line 97

#line 1 "macros/program/irc_macros.te"
#
# Macros for irc domains.
#

#
# Author:  Russell Coker <russell@coker.com.au>
#

#
# irc_domain(domain_prefix)
#
# Define a derived domain for the irc program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/irc.te. 
#

#line 85

#line 85

#line 85

#line 85

#line 1 "macros/program/java_macros.te"
#
# Authors:  Dan Walsh <dwalsh@redhat.com> 
#
# Macros for javaplugin (java plugin) domains.
#
#
# javaplugin_domain(domain_prefix, role)
#
# Define a derived domain for the javaplugin program when executed by
# a web browser.  
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/java.te. 
#
#line 93

#line 11 "macros/program/kerberos_macros.te"

#line 1 "macros/program/lockdev_macros.te"
#
# Macros for lockdev domains.
#

#
# Authors:  Daniel Walsh <dwalsh@redhat.com> 
#

#
# lockdev_domain(domain_prefix)
#
# Define a derived domain for the lockdev programs when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/lockdev.te. 
#

#line 46

#line 1 "macros/program/login_macros.te"
# Macros for login type programs (/bin/login, sshd, etc).
#
#  Author: Russell Coker <russell@coker.com.au>
#

#line 11

#line 1 "macros/program/lpr_macros.te"
#
# Macros for lpr domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser 
#

#
# lpr_domain(domain_prefix)
#
# Define a derived domain for the lpr/lpq/lprm programs when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/lpr.te. 
#

#line 117

#line 1 "macros/program/mail_client_macros.te"
#
# Shared macro for mail clients
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#

########################################
# mail_client_domain(client, role_prefix)
#

#line 68

#line 1 "macros/program/mount_macros.te"
#
# Macros for mount
#
# Author:  Brian May <bam@snoopy.apana.org.au>
# Extended by Russell Coker <russell@coker.com.au>
#

#
# mount_domain(domain_prefix,dst_domain_prefix)
#
# Define a derived domain for the mount program for anyone.
#
#line 77
 
#line 79
# mount_loopback_privs(domain_prefix,dst_domain_prefix)
#
# Add loopback mounting privileges to a particular derived
# mount domain. 
#
#line 89


#line 1 "macros/program/mozilla_macros.te"
#
# Macros for mozilla/mozilla (or other browser) domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser 
#

#
# mozilla_domain(domain_prefix)
#
# Define a derived domain for the mozilla/mozilla program when executed by
# a user domain.  
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/mozilla.te. 
#

# FIXME: Rules were removed to centralize policy in a gnome_app macro
# A similar thing might be necessary for mozilla compiled without GNOME
# support (is this possible?). 

#line 157

#line 1 "macros/program/mplayer_macros.te"
#
# Macros for mplayer
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#
# mplayer_domains(user) declares domains for mplayer, gmplayer,
# and mencoder

#####################################################
#    mplayer_common(role_prefix, mplayer_domain)    #
#####################################################

#line 63


###################################
#  mplayer_domain(role_prefix)    #
###################################

#line 123
 
#line 125
###################################
#  mencoder_domain(role_prefix)   #
###################################

#line 149
 
#line 151
#############################
#  mplayer_domains(role)    #
#############################

#line 158
 
#line 1 "macros/program/mta_macros.te"
# Macros for MTA domains.
#

#
# Author:   Russell Coker <russell@coker.com.au>
# Based on the work of: Stephen Smalley <sds@epoch.ncsc.mil>
#                       Timothy Fraser 
#

#
# mail_domain(domain_prefix)
#
# Define a derived domain for the sendmail program when executed by
# a user domain to send outgoing mail.  These domains are separate and
# independent of the domain used for the sendmail daemon process.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/mta.te. 
#

#line 121

#line 1 "macros/program/newrole_macros.te"
# Authors:  Anthony Colatrella (NSA)    Stephen Smalley <sds@epoch.ncsc.mil>
#           Russell Coker <russell@coker.com.au>

# This macro defines the rules for a newrole like program, it is used by
# newrole.te and sudo.te, but may be used by other policy at some later time.

#line 97

#line 1 "macros/program/orbit_macros.te"
#
# ORBit related types 
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#
# orbit_domain(prefix, role_prefix) - create ORBit sockets
# orbit_connect(type1_prefix, type2_prefix) 
#	- allow communication through ORBit sockets from type1 to type2 

#line 35
 
#line 37
##########################

#line 44
 #
#line 2 "macros/program/pyzor_macros.te"
# Pyzor - Pyzor is a collaborative, networked system to detect and
#         block spam using identifying digests of messages.
#
# Author:  David Hampton <hampton@employees.org>
#

##########
# common definitions for pyzord and all flavors of pyzor
##########
#line 38



#
# Define a user domain for a pyzor
#
# Note: expects to be called with an argument of user, sysadm

#line 69

#line 1 "macros/program/razor_macros.te"
#
# Razor - Razor is a collaborative, networked system to detect and
#         block spam using identifying digests of messages.
#
# Author:  David Hampton <hampton@employees.org>
#

##########
# common definitions for razord and all flavors of razor
##########
#line 48



#
# Define a user domain for a razor
#
# Note: expects to be called with an argument of user, sysadm

#line 75

#line 1 "macros/program/resmgrd_macros.te"
# Macro for resmgrd

#line 10


#line 1 "macros/program/rhgb_macros.te"

#line 8

#line 1 "macros/program/rssh_macros.te"
#
# Macros for Rssh domains
#
# Author: Colin Walters <walters@verbum.org>
#

#
# rssh_domain(domain_prefix)
#
# Define a specific rssh domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/rssh.te. 
#

#line 58

#line 58

#line 58

#line 58

#line 58

#line 1 "macros/program/run_program_macros.te"

# $1 is the source domain (or domains), $2 is the source role (or roles) and $3
# is the base name for the domain to run.  $1 is normally sysadm_t, and $2 is
# normally sysadm_r.  $4 is the type of program to run and $5 is the domain to
# transition to.
# sample usage:
# run_program(sysadm_t, sysadm_r, init, etc_t, initrc_t)
#
# if you have several users who run the same run_init type program for
# different purposes (think of a run_db program used by several database
# administrators to start several databases) then you can list all the source
# domains in $1, all the source roles in $2, but you may not want to list all
# types of programs to run in $4 and target domains in $5 (as that may permit
# entering a domain from the wrong type).  In such a situation just specify
# one value for each of $4 and $5 and have some rules such as the following:
# domain_trans(run_whatever_t, whatever_exec_t, whatever_t)

#line 73

#line 1 "macros/program/samba_macros.te"
#
# Macros for samba domains.
#

#
# Authors:  Dan Walsh <dwalsh@redhat.com>
#

# 
# samba_domain(domain_prefix)
#
# Define a derived domain for the samba program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/samba.te. 
#

#line 30

#line 30

#line 1 "macros/program/screen_macros.te"
#
# Macros for screen domains.
#

#
# Author: Russell Coker <russell@coker.com.au>
# Based on the work of Stephen Smalley <sds@epoch.ncsc.mil>
# and Timothy Fraser
#

#
# screen_domain(domain_prefix)
#
# Define a derived domain for the screen program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/screen.te. 
#

#line 113

#line 113

#line 113

#line 113

#line 113

#line 1 "macros/program/sendmail_macros.te"
#
# Macros for sendmail domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser 
#           Russell Coker <russell@coker.com.au>
#

#
# sendmail_user_domain(domain_prefix)
#
# Define a derived domain for the sendmail program when executed by
# a user domain to send outgoing mail.  These domains are separate and
# independent of the domain used for the sendmail daemon process.
#

#line 55


#line 1 "macros/program/slocate_macros.te"
#
# Macros for locate domains.
#

#
# Author:  Russell Coker <russell@coker.com.au>
#

#
# locate_domain(domain_prefix)
#
# Define a derived domain for the locate program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/locate.te. 
#

#line 64

#line 64

#line 64

#line 64

#line 64

#line 1 "macros/program/spamassassin_macros.te"
#
# Macros for spamassassin domains.
#
# Author: Colin Walters <walters@verbum.org>

# spamassassin_domain(domain_prefix)
#
# Define derived domains for various spamassassin tools when executed
# by a user domain.
#
# The type declarations for the executable types of these programs are
# provided separately in domains/program/spamassassin.te and
# domains/program/spamc.te.
#





#line 128

#line 128

#line 128
#######
#line 128
# Macros used internally in these spamassassin macros.
#line 128
#
#line 128

#line 128
###
#line 128
# Define a domain for a spamassassin-like program (spamc/spamassassin).
#line 128
#
#line 128
# Note: most of this should really be in a generic macro like
#line 128
# base_user_program($1, foo)
#line 128
 
#line 128
###
#line 128
# Give privileges to a domain for accessing ~/.spamassassin
#line 128
# and a few other misc things like /dev/random.
#line 128
# This is granted to /usr/bin/spamassassin and
#line 128
# /usr/sbin/spamd, but NOT spamc (because it does not need it).
#line 128
#
#line 128

#line 128

#line 128
#######
#line 128
# Define the main spamassassin macro.  This itself creates a
#line 128
# domain for /usr/bin/spamassassin, and also spamc/spamd if
#line 128
# applicable.
#line 128
#
#line 128
 
#line 128

#line 1 "macros/program/ssh_agent_macros.te"
#
# Macros for ssh agent
#

#
# Author:  Thomas Bleher <ThomasBleher@gmx.de>
#

# 
# ssh_agent_domain(domain_prefix)
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/ssh-agent.te. 
#
#line 117

#line 1 "macros/program/ssh_macros.te"
#
# Macros for ssh domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil>
#           Russell Coker <russell@coker.com.au>
#           Thomas Bleher <ThomasBleher@gmx.de>
#

# 
# ssh_domain(domain_prefix)
#
# Define a derived domain for the ssh program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/ssh.te. 
#

#line 168

#line 1 "macros/program/sudo_macros.te"
# Authors:  Dan Walsh,  Russell Coker
# Maintained by Dan Walsh <dwalsh@redhat.com>
#line 34

#line 1 "macros/program/su_macros.te"
#
# Macros for su domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser
#

#
# su_domain(domain_prefix)
#
# Define a derived domain for the su program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/su.te. 
#




#line 187

#line 187

#line 187

#line 187

#line 187


#line 1 "macros/program/thunderbird_macros.te"
#
# Thunderbird
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#

#######################################
# thunderbird_domain(role_prefix)
#

# FIXME: Rules were removed to centralize policy in a gnome_app macro
# A similar thing might be necessary for mozilla compiled without GNOME
# support (is this possible?).

#line 60

#line 1 "macros/program/tvtime_macros.te"
#
# Macros for tvtime domains.
#

#
# Author: Dan Walsh <dwalsh@redhat.com>
#

#
# tvtime_domain(domain_prefix)
#
# Define a derived domain for the tvtime program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/tvtime.te. 
#

#line 63

#line 63

#line 63

#line 63

#line 63


#line 1 "macros/program/uml_macros.te"
#
# Macros for uml domains.
#

#
# Author:  Russell Coker <russell@coker.com.au>
#

#
# uml_domain(domain_prefix)
#
# Define a derived domain for the uml program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/uml.te. 
#

#line 137

#line 137

#line 137

#line 137

#line 137

#line 1 "macros/program/userhelper_macros.te"
#DESC Userhelper - SELinux utility to run a shell with a new role
#
# Authors:  Dan Walsh (Red Hat)
# Maintained by Dan Walsh <dwalsh@redhat.com>
#

#
# userhelper_domain(domain_prefix)
#
# Define a derived domain for the userhelper/userhelper program when executed by
# a user domain.  
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/userhelper.te. 
#
#line 1 "macros/program/vmware_macros.te"
# Macro for vmware
#
# Based on work contributed by Mark Westerman (mark.westerman@westcam.com), 
# modifications by NAI Labs.
#
# Turned into a macro by Thomas Bleher <ThomasBleher@gmx.de>
#
# vmware_domain(domain_prefix)
#
# Define a derived domain for the vmware program when executed by
# a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/vmware.te. This file also
# implements a separate domain vmware_t.
#
 
#line 127


#line 1 "macros/program/xauth_macros.te"
#
# Macros for xauth domains.
#

#
# Author:  Russell Coker <russell@coker.com.au>
#

#
# xauth_domain(domain_prefix)
#
# Define a derived domain for the xauth program when executed
# by a user domain.
#
# The type declaration for the executable type for this program is
# provided separately in domains/program/xauth.te. 
#

#line 83

#line 83

#line 83

#line 83

#line 1 "macros/program/x_client_macros.te"
#
# Macros for X client programs 
#

#
# Author: Russell Coker <russell@coker.com.au>
# Based on the work of Stephen Smalley <sds@epoch.ncsc.mil>
# and Timothy Fraser 
#

# Allows clients to write to the X server's shm 
bool allow_write_xshm false;

#line 41


#
# x_client_domain(client, role)
#
# Defines common X access rules for the client domain
#
#line 1 "macros/program/xdm_macros.te"
########################################
#
# can_pipe_xdm(domain)
#
# Allow communication to xdm over a pipe
#

#line 13
 #
#line 2 "macros/program/xserver_macros.te"
# Macros for X server domains.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser
#

#################################
#
# xserver_domain(domain_prefix)
#
# Define a derived domain for the X server when executed
# by a user domain (e.g. via startx).  See the xdm_t domain
# in domains/program/xdm.te if using an X Display Manager.
#
# The type declarations for the executable type for this program 
# and the log type are provided separately in domains/program/xserver.te. 
#
# FIXME!  The X server requires far too many privileges.
#

#line 273

#line 273

#line 273

#line 273

#line 273


#line 9 "macros/program/ypbind_macros.te"


#line 19
 #
#line 2 "macros/admin_macros.te"
# Macros for all admin domains.
#

#
# admin_domain(domain_prefix)
#
# Define derived types and rules for an administrator domain.
#
# The type declaration and role authorization for the domain must be
# provided separately.  Likewise, domain transitions into this domain
# must be specified separately.  If the every_domain() rules are desired,
# then these rules must also be specified separately.
#

#line 188


#line 225



#line 1 "macros/base_user_macros.te"
#
# Macros for all user login domains.
#

#
# base_user_domain(domain_prefix)
#
# Define derived types and rules for an ordinary user domain.
#
# The type declaration and role authorization for the domain must be
# provided separately.  Likewise, domain transitions into this domain
# must be specified separately.  
#

# base_user_domain() is also called by the admin_domain() macro

#line 397

#line 1 "macros/content_macros.te"
# Content access macros

# FIXME: After nested booleans are supported, replace NFS/CIFS
# w/ read_network_home, and write_network_home macros from global

# FIXME: If true/false constant booleans are supported, replace
# ugly $3 ifdefs with if(true), if(false)...

# FIXME: Do we want write to imply read?

############################################################
# read_content(domain, role_prefix, bool_prefix)
#
# Allow the given domain to read content.
# Content may be trusted or untrusted,
# Reading anything is subject to a controlling boolean based on bool_prefix.
# Reading untrusted content is additionally subject to read_untrusted_content
# Reading default_t is additionally subject to read_default_t

#line 91
 
#line 93
#################################################
# write_trusted(domain, role_prefix, bool_prefix)
#
# Allow the given domain to write trusted content.
# This is subject to a controlling boolean based
# on bool_prefix.

#line 147
 
#line 149
#########################################
# write_untrusted(domain, role_prefix)
#
# Allow the given domain to write untrusted content. 
# This is subject to the global boolean write_untrusted.

#line 188
 
#line 2 "macros/core_macros.te"
##############################
#
# core macros for the type enforcement (TE) configuration.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil>, Timothy Fraser  
#           Howard Holm (NSA) <hdholm@epoch.ncsc.mil>
#           Russell Coker <russell@coker.com.au>
#

#################################
# 
# Macros for groups of classes and 
# groups of permissions.
#

#
# All directory and file classes
#


#
# All non-directory file classes.
#


#
# Non-device file classes.
#


#
# Device file classes.
#


#
# All socket classes.
#



#
# Datagram socket classes.
# 


#
# Stream socket classes.
#


#
# Unprivileged socket classes (exclude rawip, netlink, packet).
#



# 
# Permissions for getting file attributes.
#


# 
# Permissions for executing files.
#


# 
# Permissions for reading files and their attributes.
#


# 
# Permissions for reading and executing files.
#


# 
# Permissions for reading and writing files and their attributes.
#


# 
# Permissions for reading and appending to files.
#


#
# Permissions for linking, unlinking and renaming files.
# 


#
# Permissions for creating lnk_files.
#


#
# Permissions for creating and using files.
# 


# 
# Permissions for reading directories and their attributes.
#


# 
# Permissions for reading and writing directories and their attributes.
#


# 
# Permissions for reading and adding names to directories.
#



#
# Permissions for creating and using directories.
# 


#
# Permissions to mount and unmount file systems.
#


#
# Permissions for using sockets.
# 


#
# Permissions for creating and using sockets.
# 


#
# Permissions for using stream sockets.
# 


#
# Permissions for creating and using stream sockets.
# 


#
# Permissions for creating and using sockets.
# 


#
# Permissions for creating and using sockets.
# 



#
# Permissions for creating and using netlink sockets.
# 


#
# Permissions for using netlink sockets for operations that modify state.
# 


#
# Permissions for using netlink sockets for operations that observe state.
# 


#
# Permissions for sending all signals.
#


#
# Permissions for sending and receiving network packets.
#


#
# Permissions for using System V IPC
#










#################################
# 
# Macros for type transition rules and
# access vector rules.
#

#
# Simple combinations for reading and writing both
# directories and files.
# 
#line 215


#line 221


#line 227


#line 233


#line 239


#line 245


#line 251


#line 256


##################################
#
# can_ps(domain1, domain2)
#
# Authorize domain1 to see /proc entries for domain2 (see it in ps output)
#
#line 273


##################################
#
# can_getsecurity(domain)
#
# Authorize a domain to get security policy decisions.
#
#line 291


##################################
#
# can_setenforce(domain)
#
# Authorize a domain to set the enforcing flag.
# Due to its sensitivity, always audit this permission.
#
#line 313


##################################
#
# can_setbool(domain)
#
# Authorize a domain to set a policy boolean.
# Due to its sensitivity, always audit this permission.
#
#line 335


##################################
#
# can_setsecparam(domain)
#
# Authorize a domain to set security parameters.
# Due to its sensitivity, always audit this permission.
#
#line 355


##################################
#
# can_loadpol(domain)
#
# Authorize a domain to load a policy configuration.
# Due to its sensitivity, always audit this permission.
#
#line 378


#################################
#
# domain_trans(parent_domain, program_type, child_domain)
#
# Permissions for transitioning to a new domain.
#

#line 440


#################################
#
# domain_auto_trans(parent_domain, program_type, child_domain)
#
# Define a default domain transition and allow it.
#
#line 451


#################################
#
# can_ptrace(domain, domain)
#
# Permissions for running ptrace (strace or gdb) on another domain
#
#line 462


#################################
#
# can_exec(domain, type)
#
# Permissions for executing programs with
# a specified type without changing domains.
#
#line 473


# this is an internal macro used by can_create
#line 485


#################################
#
# can_create(domain, file_type, object_class)
#
# Permissions for creating files of the specified type and class
#
#line 499

#################################
#
# file_type_trans(domain, dir_type, file_type)
#
# Permissions for transitioning to a new file type.
#

#line 523


#################################
#
# file_type_auto_trans(creator_domain, parent_directory_type, file_type, object_class)
#
# the object class will default to notdevfile_class_set if not specified as
# the fourth parameter
#
# Define a default file type transition and allow it.
#
#line 544



#################################
#
# can_unix_connect(client, server)
#
# Permissions for establishing a Unix stream connection.
#
#line 555


#################################
#
# can_unix_send(sender, receiver)
#
# Permissions for sending Unix datagrams.
#
#line 565


#################################
#
# can_tcp_connect(client, server)
#
# Permissions for establishing a TCP connection.
# Irrelevant until we have labeled networking.
#
#line 579


#################################
#
# can_udp_send(sender, receiver)
#
# Permissions for sending/receiving UDP datagrams.
# Irrelevant until we have labeled networking.
#
#line 591



##################################
#
# base_pty_perms(domain_prefix)
#
# Base permissions used for can_create_pty() and can_create_other_pty()
#
#line 611



##################################
#
# pty_slave_label(domain_prefix, attributes)
#
# give access to a slave pty but do not allow creating new ptys
#
#line 634



##################################
#
# can_create_pty(domain_prefix, attributes)
#
# Permissions for creating ptys.
#
#line 646



##################################
#
# can_create_other_pty(domain_prefix,other_domain)
#
# Permissions for creating ptys for another domain.
#
#line 662



#
# general_domain_access(domain)
#
# Grant permissions within the domain.
# This includes permissions to processes, /proc/PID files,
# file descriptors, pipes, Unix sockets, and System V IPC objects
# labeled with the domain.
#
#line 1 "macros/global_macros.te"
##############################
#
# Global macros for the type enforcement (TE) configuration.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#           Howard Holm (NSA) <hdholm@epoch.ncsc.mil>
#           Russell Coker <russell@coker.com.au>
#
#
#

##################################
#
# can_setexec(domain)
#
# Authorize a domain to set its exec context
# (via /proc/pid/attr/exec).
#
#line 27


##################################
#
# can_getcon(domain)
#
# Authorize a domain to get its context
# (via /proc/pid/attr/current).
#
#line 42


##################################
#
# can_setcon(domain)
#
# Authorize a domain to set its current context
# (via /proc/pid/attr/current).
#
#line 57


##################################
# read_sysctl(domain)
#
# Permissions for reading sysctl variables.
# If the second parameter is full, allow
# reading of any sysctl variables, else only
# sysctl_kernel_t.
#
#line 79

##################################
#
# can_setfscreate(domain)
#
# Authorize a domain to set its fscreate context
# (via /proc/pid/attr/fscreate).
#
#line 93


#################################
#
# uses_shlib(domain)
#
# Permissions for using shared libraries.
#
#line 113


#################################
#
# can_exec_any(domain)
#
# Permissions for executing a variety
# of executable types.
#
#line 132



#################################
#
# can_sysctl(domain)
#
# Permissions for modifying sysctl parameters.
#
#line 144



##################################
#
# read_locale(domain)
#
# Permissions for reading the locale data,
# /etc/localtime and the files that it links to
#
#line 158


#line 163


###################################
#
# access_terminal(domain, typeprefix)
#
# Permissions for accessing the terminal
#
#line 175
 

#
# general_proc_read_access(domain)
#
# Grant read/search permissions to most of /proc, excluding
# the /proc/PID directories and the /proc/kmsg and /proc/kcore files.
# The general_domain_access macro grants access to the domain /proc/PID
# directories, but not to other domains.  Only permissions to stat
# are granted for /proc/kmsg and /proc/kcore, since these files are more
# sensitive.
# 
#line 198


#
# base_file_read_access(domain)
#
# Grant read/search permissions to a few system file types.
#
#line 234


#######################
# daemon_core_rules(domain_prefix, attribs)
#
# Define the core rules for a daemon, used by both daemon_base_domain() and
# init_service_domain().
# Attribs is the list of attributes which must start with "," if it is not empty
#
# Author:  Russell Coker <russell@coker.com.au>
#
#line 279

#######################
# init_service_domain(domain_prefix, attribs)
#
# Define a domain for a program that is run from init
# Attribs is the list of attributes which must start with "," if it is not empty
#
# Author:  Russell Coker <russell@coker.com.au>
#
#line 297

#######################
# daemon_base_domain(domain_prefix, attribs)
#
# Define a daemon domain with a base set of type declarations
# and permissions that are common to most daemons.
# attribs is the list of attributes which must start with "," if it is not empty
# nosysadm may be given as an optional third parameter, to specify that the
# sysadmin should not transition to the domain when directly calling the executable
#
# Author:  Russell Coker <russell@coker.com.au>
#
#line 352

# allow a domain to create its own files under /var/run and to create files
# in directories that are created for it.  $2 is an optional list of
# classes to use; default is file.
#line 366


#######################
# daemon_domain(domain_prefix, attribs)
#
# see daemon_base_domain for calling details
# daemon_domain defines some additional privileges needed by many domains,
# like pid files and locale support

#line 399

#line 405


# define a sub-domain, $1_t is the parent domain, $2 is the name
# of the sub-domain.
#
#line 443


# grant access to /tmp
# by default, only plain files and dirs may be stored there.
# This can be overridden with a third parameter
#line 453


# grant access to /tmp. Do not perform an automatic transition.
#line 458


#line 468


#line 474


#line 479


#line 484


#line 489


#line 495


#line 502


#line 507


#line 512


#######################
# application_domain(domain_prefix)
#
# Define a domain with a base set of type declarations
# and permissions that are common to simple applications.
#
# Author:  Russell Coker <russell@coker.com.au>
#
#line 531


#line 539


# Dontaudit macros to prevent flooding the log

#line 548

#line 554

#line 560

# Define legacy_domain  for legacy binaries (java)
# "legacy" binary == lacks PT_GNU_STACK header, i.e. built with an old
# toolchain.  They cause the kernel to automatically start translating all
# read protection requests to read|execute for backward compatibility on
# x86.  They will all need execmem and execmod, including execmod to
# shlib_t and ld_so_t unlike non-legacy binaries.

#line 573



# Allow domain to perform polyinstantiation functions
# polyinstantiater(domain)

#line 608

# 
# Domain that is allow to read anonymous data off the network
# without providing authentication.
# Also define boolean to allow anonymous writing
#
#line 620

# 
# Define a domain that can do anything, so that it is
# effectively unconfined by the SELinux policy.  This
# means that it is only restricted by the normal Linux 
# protections.  Note that you may need to add further rules
# to allow other domains to interact with this domain as expected,
# since this macro only allows the specified domain to act upon
# all other domains and types, not vice versa.
#
#line 740


#line 758


#line 774

#line 1 "macros/home_macros.te"
# Home macros

################################################
# network_home(source)
#
# Allows source domain to use a network home
# This includes privileges of create and execute
# as well as the ability to create sockets and fifo

#line 24
 
#line 26
################################################
# write_network_home(source)
#
# Allows source domain to create directories and
# files on network file system

#line 42
 
#line 44
################################################
# read_network_home(source)
#
# Allows source domain to read directories and
# files on network file system

#line 60
 
#line 62
##################################################
# home_domain_ro_access(source, user, app)
#
# Gives source access to the read-only home
# domain of app for the given user type

#line 76
 
#line 78
#################################################
# home_domain_access(source, user, app)
#
# Gives source full access to the home
# domain of app for the given user type
#
# Requires transition in caller

#line 95
 
#line 97
####################################################################
# home_domain (prefix, app)
#
# Creates a domain in the prefix home where an application can
# store its settings. It is accessible by the prefix domain.
#
# Requires transition in caller

#line 117


####################################################################
# home_domain_ro (user, app)
#
# Creates a read-only domain in the user home where an application can
# store its settings. It is fully accessible by the user, but
# it is read-only for the application.
#

#line 139

#line 1 "macros/mini_user_macros.te"
#
# Macros for all user login domains.
#

#
# mini_user_domain(domain_prefix)
#
# Define derived types and rules for a minimal privs user domain named
# $1_mini_t which is permitted to be in $1_r role and transition to $1_t.
#

#line 57

#line 1 "macros/network_macros.te"
#################################
#
# can_network(domain)
#
# Permissions for accessing the network.
# See types/network.te for the network types.
# See net_contexts for security contexts for network entities.
#
#line 48

#################################
#
# can_network_server_tcp(domain)
#
# Permissions for accessing a tcp network.
# See types/network.te for the network types.
# See net_contexts for security contexts for network entities.
#
#line 60


#################################
#
# can_network_client_tcp(domain)
#
# Permissions for accessing a tcp network.
# See types/network.te for the network types.
# See net_contexts for security contexts for network entities.
#
#line 73


#################################
#
# can_network_tcp(domain)
#
# Permissions for accessing the network.
# See types/network.te for the network types.
# See net_contexts for security contexts for network entities.
#
#line 88


#################################
#
# can_network_udp(domain)
#
# Permissions for accessing the network.
# See types/network.te for the network types.
# See net_contexts for security contexts for network entities.
#
#line 101


#################################
#
# can_network_server(domain)
#
# Permissions for accessing the network.
# See types/network.te for the network types.
# See net_contexts for security contexts for network entities.
#
#line 117


#################################
#
# can_network_client(domain)
#
# Permissions for accessing the network.
# See types/network.te for the network types.
# See net_contexts for security contexts for network entities.
#
#line 133

#################################
#
# can_network(domain)
#
# Permissions for accessing the network.
# See types/network.te for the network types.
# See net_contexts for security contexts for network entities.
#
#line 156

#line 160


#line 165


#line 170


#line 178



#################################
#
# nsswitch_domain(domain)
#
# Permissions for looking up uid/username mapping via nsswitch
#
#line 192

#line 1 "macros/user_macros.te"
#
# Macros for all user login domains.
#

# role_tty_type_change(starting_role, ending_role)
#
# change from role $1_r to $2_r and relabel tty appropriately
#


#line 17


#
# reach_sysadm(user)
#
# Reach sysadm_t via programs like userhelper/sudo/su
#


#line 45
 
#line 47
#
# priv_user(user)
#
# Privileged user domain
#


#line 73
 
#line 75
#
# user_domain(domain_prefix)
#
# Define derived types and rules for an ordinary user domain.
#
# The type declaration and role authorization for the domain must be
# provided separately.  Likewise, domain transitions into this domain
# must be specified separately.  
#

# user_domain() is also called by the admin_domain() macro

#line 186


###########################################################################
#
# Domains for ordinary users.
#

#line 243



#line 319



#line 325


#line 1 "types/device.te"
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

############################################
#
# Device types
#

#
# device_t is the type of /dev.
#
type device_t, file_type, mount_point, dev_fs;

#
# null_device_t is the type of /dev/null.
#
type null_device_t, device_type, dev_fs, mlstrustedobject;

#
# zero_device_t is the type of /dev/zero.
#
type zero_device_t, device_type, dev_fs, mlstrustedobject;

#
# console_device_t is the type of /dev/console.
#
type console_device_t, device_type, dev_fs;

#
# xconsole_device_t is the type of /dev/xconsole
type xconsole_device_t, file_type, dev_fs;

#
# memory_device_t is the type of /dev/kmem,
# /dev/mem, and /dev/port.
#
type memory_device_t, device_type, dev_fs;

#
# random_device_t is the type of /dev/random
# urandom_device_t is the type of /dev/urandom
#
type random_device_t, device_type, dev_fs, user_mini_domain;
type urandom_device_t, device_type, dev_fs;

#
# devtty_t is the type of /dev/tty.
#
type devtty_t, device_type, dev_fs, mlstrustedobject;

#
# tty_device_t is the type of /dev/*tty*
#
type tty_device_t, serial_device, device_type, dev_fs;

#
# bsdpty_device_t is the type of /dev/[tp]ty[abcdepqrstuvwxyz][0-9a-f]
type bsdpty_device_t, device_type, dev_fs;

#
# usbtty_device_t is the type of /dev/usr/tty*
#
type usbtty_device_t, serial_device, device_type, dev_fs;

#
# printer_device_t is the type for printer devices
#
type printer_device_t, device_type, dev_fs;

#
# fixed_disk_device_t is the type of 
# /dev/hd* and /dev/sd*.
#
type fixed_disk_device_t, device_type, dev_fs;

#
# scsi_generic_device_t is the type of /dev/sg*
# it gives access to ALL SCSI devices (both fixed and removable)
#
type scsi_generic_device_t, device_type, dev_fs;

#
# removable_device_t is the type of
# /dev/scd* and /dev/fd*.
#
type removable_device_t, device_type, dev_fs;

#
# clock_device_t is the type of
# /dev/rtc.
#
type clock_device_t, device_type, dev_fs;

#
# tun_tap_device_t is the type of /dev/net/tun/* and /dev/net/tap/*
#
type tun_tap_device_t, device_type, dev_fs;

#
# misc_device_t is the type of miscellaneous devices.
# XXX:  FIXME!  Appropriate access to these devices need to be identified.
#
type misc_device_t, device_type, dev_fs;

#
# A more general type for mouse devices.
#
type mouse_device_t, device_type, dev_fs;

#
# For generic /dev/input/event* event devices
#
type event_device_t, device_type, dev_fs;

#
# Not sure what these devices are for, but X wants access to them.
#
type agp_device_t, device_type, dev_fs;
type dri_device_t, device_type, dev_fs;

# Type for sound devices.
type sound_device_t, device_type, dev_fs;

# Type for /dev/ppp.
type ppp_device_t, device_type, dev_fs;

# Type for frame buffer /dev/fb/*
type framebuf_device_t, device_type, dev_fs;

# Type for /dev/.devfsd
type devfs_control_t, device_type, dev_fs;

# Type for /dev/cpu/mtrr and /proc/mtrr
type mtrr_device_t, device_type, dev_fs, proc_fs;

# Type for /dev/pmu 
type power_device_t, device_type, dev_fs;

# Type for /dev/apm_bios
type apm_bios_t, device_type, dev_fs;

# Type for v4l
type v4l_device_t, device_type, dev_fs;

# tape drives
type tape_device_t, device_type, dev_fs;

# scanners
type scanner_device_t, device_type, dev_fs;

# cpu control devices /dev/cpu/0/*
type cpu_device_t, device_type, dev_fs;

# for other device nodes such as the NVidia binary-only driver
type xserver_misc_device_t, device_type, dev_fs;

# for the IBM zSeries z90crypt hardware ssl accelorator
type crypt_device_t, device_type, dev_fs;




#line 1 "types/devpts.te"
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

############################################
#
# Devpts types
#

#
# ptmx_t is the type for /dev/ptmx.
#
type ptmx_t, sysadmfile, device_type, dev_fs, mlstrustedobject;

#
# devpts_t is the type of the devpts file system and 
# the type of the root directory of the file system.
#
type devpts_t, mount_point, fs_type;

#line 23

#line 23
typeattribute devpts_t ttyfile;
#line 23

#line 1 "types/file.te"
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#######################################
#
# General file-related types
#

#
# unlabeled_t is the type of unlabeled objects.
# Objects that have no known labeling information or that
# have labels that are no longer valid are treated as having this type.
#
type unlabeled_t, sysadmfile;

#
# fs_t is the default type for conventional filesystems.
#
type fs_t, fs_type;

# needs more work
type eventpollfs_t, fs_type;
type futexfs_t, fs_type;
type bdev_t, fs_type;
type usbfs_t, mount_point, fs_type;
type nfsd_fs_t, fs_type;
type rpc_pipefs_t, fs_type;
type binfmt_misc_fs_t, mount_point, fs_type;

#
# file_t is the default type of a file that has not yet been
# assigned an extended attribute (EA) value (when using a filesystem
# that supports EAs).
#
type file_t, file_type, mount_point, sysadmfile;

# default_t is the default type for files that do not
# match any specification in the file_contexts configuration
# other than the generic /.* specification.
type default_t, file_type, mount_point, sysadmfile;

#
# root_t is the type for the root directory.
#
type root_t, file_type, mount_point, polyparent, sysadmfile;

#
# mnt_t is the type for mount points such as /mnt/cdrom
type mnt_t, file_type, mount_point, sysadmfile;

#
# home_root_t is the type for the directory where user home directories
# are created
#
type home_root_t, file_type, mount_point, polyparent, sysadmfile;

#
# lost_found_t is the type for the lost+found directories.
#
type lost_found_t, file_type, sysadmfile;

#
# boot_t is the type for files in /boot,
# including the kernel.
#
type boot_t, file_type, mount_point, sysadmfile;
# system_map_t is for the system.map files in /boot
type system_map_t, file_type, sysadmfile;

#
# boot_runtime_t is the type for /boot/kernel.h,
# which is automatically generated at boot time.
# only for red hat
type boot_runtime_t, file_type, sysadmfile;

#
# tmp_t is the type of /tmp and /var/tmp.
#
type tmp_t, file_type, mount_point, sysadmfile, polydir, tmpfile;

#
# etc_t is the type of the system etc directories.
#
type etc_t, file_type, sysadmfile;

# etc_mail_t is the type of /etc/mail.
type etc_mail_t, file_type, sysadmfile, usercanread;

#
# shadow_t is the type of the /etc/shadow file
#
type shadow_t, file_type, secure_file_type;
allow auth shadow_t:file { getattr read };

#
# ld_so_cache_t is the type of /etc/ld.so.cache.
#
type ld_so_cache_t, file_type, sysadmfile;

#
# etc_runtime_t is the type of various
# files in /etc that are automatically
# generated during initialization.
#
type etc_runtime_t, file_type, sysadmfile;

#
# fonts_runtime_t is the type of various
# fonts files in /usr that are automatically
# generated during initialization.
#
type fonts_t, file_type, sysadmfile, usercanread;

#
# etc_aliases_t is the type of the aliases database.
#
type etc_aliases_t, file_type, sysadmfile;

# net_conf_t is the type of the /etc/resolv.conf file.
# all DHCP clients and PPP need write access to this file.
type net_conf_t, file_type, sysadmfile;

#
# lib_t is the type of files in the system lib directories.
#
type lib_t, file_type, sysadmfile;

#
# shlib_t is the type of shared objects in the system lib
# directories.
#
#line 137

#line 137
typealias lib_t alias shlib_t;
#line 137


#
# texrel_shlib_t is the type of shared objects in the system lib
# directories, which require text relocation.
#
#line 147

#line 147
typealias lib_t alias texrel_shlib_t;
#line 147


# ld_so_t is the type of the system dynamic loaders.
#
type ld_so_t, file_type, sysadmfile;

#
# bin_t is the type of files in the system bin directories.
#
type bin_t, file_type, sysadmfile;

#
# cert_t is the type of files in the system certs directories.
#
type cert_t, file_type, sysadmfile, secure_file_type;

#
# ls_exec_t is the type of the ls program.
#
type ls_exec_t, file_type, exec_type, sysadmfile;

#
# shell_exec_t is the type of user shells such as /bin/bash.
#
type shell_exec_t, file_type, exec_type, sysadmfile;

#
# sbin_t is the type of files in the system sbin directories.
#
type sbin_t, file_type, sysadmfile;

#
# usr_t is the type for /usr.
#
type usr_t, file_type, mount_point, sysadmfile;

#
# src_t is the type of files in the system src directories.
#
type src_t, file_type, mount_point, sysadmfile;

#
# var_t is the type for /var.
#
type var_t, file_type, mount_point, sysadmfile;

#
# Types for subdirectories of /var.
#
type var_run_t, file_type, sysadmfile;
type var_log_t, file_type, sysadmfile, logfile;
typealias var_log_t alias crond_log_t;
type faillog_t, file_type, sysadmfile, logfile;
type var_lock_t, file_type, sysadmfile, lockfile;
type var_lib_t, mount_point, file_type, sysadmfile;
type var_auth_t, file_type, sysadmfile;
# for /var/{spool,lib}/texmf index files
type tetex_data_t, file_type, sysadmfile, tmpfile;
type var_spool_t, file_type, sysadmfile, tmpfile;
type var_yp_t, file_type, sysadmfile;
type netif_lo_t, device_a;
type netif_eth0_t, device_a;
type netif_eth1_t, device_a;
type netif_eth2_t, device_a;
type netif_ippp0_t, device_a;
type netif_ipsec0_t, device_a;
type netif_ipsec1_t, device_a;
type netif_ipsec2_t, device_a;

# Type for /var/log/ksyms.
type var_log_ksyms_t, file_type, sysadmfile, logfile;

# Type for /var/log/lastlog.
type lastlog_t, file_type, sysadmfile, logfile;

# Type for /var/lib/nfs.
type var_lib_nfs_t, file_type, mount_point, sysadmfile, usercanread;

#
# wtmp_t is the type of /var/log/wtmp.
#
type wtmp_t, file_type, sysadmfile, logfile;

#
# cron_spool_t is the type for /var/spool/cron.
#
type cron_spool_t, file_type, sysadmfile;

#
# print_spool_t is the type for /var/spool/lpd and /var/spool/cups.
#
type print_spool_t, file_type, sysadmfile, tmpfile;

#
# mail_spool_t is the type for /var/spool/mail.
#
type mail_spool_t, file_type, sysadmfile;

#
# mqueue_spool_t is the type for /var/spool/mqueue.
#
type mqueue_spool_t, file_type, sysadmfile;

#
# man_t is the type for the man directories.
#
type man_t, file_type, sysadmfile;
typealias man_t alias catman_t;

#
# readable_t is a general type for
# files that are readable by all domains.
#
type readable_t, file_type, sysadmfile;

# 
# Base type for the tests directory.
# 
type test_file_t, file_type, sysadmfile;

#
# poly_t is the type for the polyinstantiated directories.
#
type poly_t, file_type, sysadmfile;

#
# swapfile_t is for swap files
#
type swapfile_t, file_type, sysadmfile;

#
# locale_t is the type for system localization
# 
type locale_t, file_type, sysadmfile;

#
# Allow each file type to be associated with 
# the default file system type.
#
allow { file_type device_type ttyfile fs_type } fs_t:filesystem associate;

type tmpfs_t, file_type, mount_point, sysadmfile, fs_type;
allow { logfile tmpfs_t tmpfile home_type } tmpfs_t:filesystem associate;
allow { logfile tmpfile home_type } tmp_t:filesystem associate;
#line 285

#line 285
allow { dev_fs ttyfile } { tmpfs_t tmp_t }:filesystem associate;
#line 285


type autofs_t, fs_type, noexattrfile, sysadmfile;
type usbdevfs_t, fs_type, mount_point, noexattrfile, sysadmfile;
type sysfs_t, mount_point, fs_type,  sysadmfile;
type iso9660_t, fs_type, noexattrfile, sysadmfile;
type romfs_t, fs_type, sysadmfile;
type ramfs_t, fs_type, sysadmfile;
type dosfs_t, fs_type, noexattrfile, sysadmfile;
type hugetlbfs_t, mount_point, fs_type,  sysadmfile;
typealias file_t alias  mqueue_t;

# udev_runtime_t is the type of the udev table file
type udev_runtime_t, file_type, sysadmfile;

# krb5_conf_t is the type of the /etc/krb5.conf file
type krb5_conf_t, file_type, sysadmfile;

type cifs_t, fs_type, noexattrfile, sysadmfile;
type debugfs_t, fs_type, sysadmfile;
type configfs_t, fs_type, sysadmfile;
type inotifyfs_t, fs_type, sysadmfile;
type capifs_t, fs_type, sysadmfile;

# removable_t is the default type of all removable media
type removable_t, file_type, sysadmfile, usercanread;
allow file_type removable_t:filesystem associate;
allow file_type noexattrfile:filesystem associate;

# Type for anonymous FTP data, used by ftp and rsync
type public_content_t, file_type, sysadmfile, customizable;
type public_content_rw_t, file_type, sysadmfile, customizable;
typealias public_content_t alias ftpd_anon_t;
typealias public_content_rw_t alias ftpd_anon_rw_t;

# type for /tmp/.ICE-unix
type ice_tmp_t, file_type, sysadmfile, tmpfile;

# type for /usr/share/hwdata
type hwdata_t, file_type, sysadmfile;
allow { fs_type file_type } self:filesystem associate;

#line 1 "types/network.te"
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

# Modified by Reino Wallin <reino@oribium.com>
# Multi NIC, and IPSEC features

# Modified by Russell Coker
# Move port types to their respective domains, add ifdefs, other cleanups.

type xserver_port_t, port_type;
#
# Defines used by the te files need to be defined outside of net_constraints
#
type rsh_port_t, port_type, reserved_port_type;
type dns_port_t, port_type, reserved_port_type;
type smtp_port_t, port_type, reserved_port_type;
type dhcpd_port_t, port_type, reserved_port_type;
type smbd_port_t, port_type, reserved_port_type;
type nmbd_port_t, port_type, reserved_port_type;
type http_cache_port_t, port_type;
type http_port_t, port_type, reserved_port_type;
type ipp_port_t, port_type, reserved_port_type;
type gopher_port_t, port_type, reserved_port_type;
type isakmp_port_t, port_type, reserved_port_type;

allow web_client_domain { http_cache_port_t http_port_t }:tcp_socket name_connect;
type pop_port_t, port_type, reserved_port_type;

type ftp_port_t, port_type, reserved_port_type;
type ftp_data_port_t, port_type, reserved_port_type;

############################################
#
# Network types
#

#
# mail_port_t is for generic mail ports shared by different mail servers
#
type mail_port_t, port_type;

#
# Ports used to communicate with kerberos server
#
type kerberos_port_t, port_type, reserved_port_type;
type kerberos_admin_port_t, port_type, reserved_port_type;

#
# Ports used to communicate with portmap server
#
type portmap_port_t, port_type, reserved_port_type;

#
# Ports used to communicate with ldap server
#
type ldap_port_t, port_type, reserved_port_type;

#
# port_t is the default type of INET port numbers.
# The *_port_t types are used for specific port
# numbers in net_contexts or net_contexts.mls.
#
type port_t, port_type;

# reserved_port_t is the default type for INET reserved ports
# that are not otherwise mapped to a specific port type.
type reserved_port_t, port_type;

#
# netif_t is the default type of network interfaces.
# The netif_*_t types are used for specific network
# interfaces in net_contexts or net_contexts.mls.
#
type netif_t, netif_type;

#
# node_t is the default type of network nodes.
# The node_*_t types are used for specific network
# nodes in net_contexts or net_contexts.mls.
#
type node_t, node_type;
type node_lo_t, node_type;
type node_internal_t, node_type;
type node_inaddr_any_t, node_type;
type node_unspec_t, node_type;
type node_link_local_t, node_type;
type node_site_local_t, node_type;
type node_multicast_t, node_type;
type node_mapped_ipv4_t, node_type;
type node_compat_ipv4_t, node_type;

# Kernel-generated traffic, e.g. ICMP replies.
allow kernel_t netif_type:netif { rawip_send rawip_recv };
allow kernel_t node_type:node { rawip_send rawip_recv };

# Kernel-generated traffic, e.g. TCP resets.
allow kernel_t netif_type:netif { tcp_send tcp_recv };
allow kernel_t node_type:node { tcp_send tcp_recv };
type radius_port_t, port_type;
type radacct_port_t, port_type;
type rndc_port_t, port_type, reserved_port_type;
type tftp_port_t, port_type, reserved_port_type;
type printer_port_t, port_type, reserved_port_type;
type mysqld_port_t, port_type;
type postgresql_port_t, port_type;
type ptal_port_t, port_type;
type howl_port_t, port_type;
type dict_port_t, port_type;
type syslogd_port_t, port_type, reserved_port_type;
type spamd_port_t, port_type, reserved_port_type;
type ssh_port_t, port_type, reserved_port_type;
type pxe_port_t, port_type;
type amanda_port_t, port_type;
type fingerd_port_t, port_type, reserved_port_type;
type dhcpc_port_t, port_type, reserved_port_type;
type ntp_port_t, port_type, reserved_port_type;
type stunnel_port_t, port_type;
type bgp_port_t, port_type, reserved_port_type;
type zebra_port_t, port_type;
type i18n_input_port_t, port_type;
type vnc_port_t, port_type;
type pegasus_http_port_t, port_type;
type pegasus_https_port_t, port_type;
type openvpn_port_t, port_type;
type clamd_port_t, port_type;
type transproxy_port_t, port_type;
type clockspeed_port_t, port_type;
type pyzor_port_t, port_type;
type postgrey_port_t, port_type;
type asterisk_port_t, port_type;
type utcpserver_port_t, port_type;
type nessus_port_t, port_type;
type razor_port_t, port_type;
type distccd_port_t, port_type;
type socks_port_t, port_type;
type gatekeeper_port_t, port_type;
type dcc_port_t, port_type;
type lrrd_port_t, port_type;
type jabber_client_port_t, port_type;
type jabber_interserver_port_t, port_type;
type ircd_port_t, port_type;
type giftd_port_t, port_type;
type soundd_port_t, port_type;
type imaze_port_t, port_type;
type monopd_port_t, port_type;
# Differentiate between the port where amavisd receives mail, and the
# port where it returns cleaned mail back to the MTA.
type amavisd_recv_port_t, port_type;
type amavisd_send_port_t, port_type;
type innd_port_t, port_type, reserved_port_type;
type snmp_port_t, port_type, reserved_port_type;
type biff_port_t, port_type, reserved_port_type;
type hplip_port_t, port_type;

#inetd_child_ports

type rlogind_port_t, port_type, reserved_port_type;
type telnetd_port_t, port_type, reserved_port_type;
type comsat_port_t, port_type, reserved_port_type;
type cvs_port_t, port_type;
type dbskkd_port_t, port_type;
type inetd_child_port_t, port_type, reserved_port_type;
type ktalkd_port_t, port_type, reserved_port_type;
type rsync_port_t, port_type, reserved_port_type;
type uucpd_port_t, port_type, reserved_port_type;
type swat_port_t, port_type, reserved_port_type;
type zope_port_t, port_type;
type auth_port_t, port_type, reserved_port_type;

# afs ports

type afs_fs_port_t, port_type;
type afs_pt_port_t, port_type;
type afs_vl_port_t, port_type;
type afs_ka_port_t, port_type;
type afs_bos_port_t, port_type;

#line 1 "types/nfs.te"
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#############################################
#
# NFS types
#

#
# nfs_t is the default type for NFS file systems 
# and their files.  
# The nfs_*_t types are used for specific NFS
# servers in net_contexts or net_contexts.mls.
#
type nfs_t, mount_point, fs_type;

#
# Allow NFS files to be associated with an NFS file system.
#
allow file_type nfs_t:filesystem associate;
#line 1 "types/procfs.te"
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

############################################
#
# Procfs types
#

#
# proc_t is the type of /proc.
# proc_kmsg_t is the type of /proc/kmsg.
# proc_kcore_t is the type of /proc/kcore.
# proc_mdstat_t is the type of /proc/mdstat.
# proc_net_t is the type of /proc/net.
#
type proc_t, fs_type, mount_point, proc_fs;
type proc_kmsg_t, proc_fs;
type proc_kcore_t, proc_fs;
type proc_mdstat_t, proc_fs;
type proc_net_t, proc_fs;

#
# sysctl_t is the type of /proc/sys.
# sysctl_fs_t is the type of /proc/sys/fs.
# sysctl_kernel_t is the type of /proc/sys/kernel.
# sysctl_modprobe_t is the type of /proc/sys/kernel/modprobe.
# sysctl_hotplug_t is the type of /proc/sys/kernel/hotplug.
# sysctl_net_t is the type of /proc/sys/net.
# sysctl_net_unix_t is the type of /proc/sys/net/unix.
# sysctl_vm_t is the type of /proc/sys/vm.
# sysctl_dev_t is the type of /proc/sys/dev.
# sysctl_rpc_t is the type of /proc/net/rpc.
#
# These types are applied to both the entries in
# /proc/sys and the corresponding sysctl parameters.
#
type sysctl_t, mount_point, sysctl_type;
type sysctl_fs_t, sysctl_type;
type sysctl_kernel_t, sysctl_type;
type sysctl_modprobe_t, sysctl_type;
type sysctl_hotplug_t, sysctl_type;
type sysctl_net_t, sysctl_type;
type sysctl_net_unix_t, sysctl_type;
type sysctl_vm_t, sysctl_type;
type sysctl_dev_t, sysctl_type;
type sysctl_rpc_t, sysctl_type;
type sysctl_irq_t, sysctl_type;


#line 1 "types/security.te"
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

############################################
#
# Security types
#

# 
# security_t is the target type when checking
# the permissions in the security class.  It is also
# applied to selinuxfs inodes.
#
type security_t, mount_point, fs_type, mlstrustedobject;
dontaudit domain security_t:dir search;
dontaudit domain security_t:file { getattr read };

#
# policy_config_t is the type of /etc/security/selinux/*
# the security server policy configuration.
#
type policy_config_t, file_type, secadmfile;
# Since libselinux attempts to read these by default, most domains 
# do not need it.
dontaudit domain selinux_config_t:dir search;
dontaudit domain selinux_config_t:file { getattr read };

#
# policy_src_t is the type of the policy source
# files.
#
type policy_src_t, file_type, secadmfile;


#
# default_context_t is the type applied to 
# /etc/selinux/*/contexts/*
#
type default_context_t, file_type, login_contexts, secadmfile;

#
# file_context_t is the type applied to 
# /etc/selinux/*/contexts/files
#
type file_context_t, file_type, secadmfile;

#
# no_access_t is the type for objects that should
# only be accessed administratively. 
#
type no_access_t, file_type, sysadmfile;

#
# selinux_config_t is the type applied to 
# /etc/selinux/config
#
type selinux_config_t, file_type, secadmfile;


#line 1 "types/x.te"
#
# Authors:  Eamon Walsh <ewalsh@epoch.ncsc.mil>
#

#######################################
#
# Types for the SELinux-enabled X Window System
#

#
# X protocol extension types.  The SELinux extension in the X server
# has a hardcoded table that maps actual extension names to these types.
#
type accelgraphics_ext_t, xextension;
type debug_ext_t, xextension;
type font_ext_t, xextension;
type input_ext_t, xextension;
type screensaver_ext_t, xextension;
type security_ext_t, xextension;
type shmem_ext_t, xextension;
type std_ext_t, xextension;
type sync_ext_t, xextension;
type unknown_ext_t, xextension;
type video_ext_t, xextension;
type windowmgr_ext_t, xextension;

#
# X property types.  The SELinux extension in the X server has a 
# hardcoded table that maps actual extension names to these types.
#
type wm_property_t, xproperty;
type unknown_property_t, xproperty;
#line 1 "domains/unconfined.te"
#DESC Unconfined - The unconfined domain

# This is the initial domain, and is used for everything that
# is not explicitly confined.  It has no restrictions.
# It needs to be carefully protected from the confined domains.

type unconfined_t, domain, privuser, privhome, privrole, privowner, admin, auth_write, fs_domain, privmem;
role system_r types unconfined_t;
role user_r types unconfined_t;
role sysadm_r types unconfined_t;

#line 11

#line 11
typeattribute unconfined_t unrestricted;
#line 11
typeattribute unconfined_t privuser;
#line 11

#line 11
# Mount/unmount any filesystem. 
#line 11
allow unconfined_t fs_type:filesystem *;
#line 11

#line 11
# Mount/unmount any filesystem with the context= option. 
#line 11
allow unconfined_t file_type:filesystem *;
#line 11
allow unconfined_t unconfined_t:file read;
#line 11
# Create/access any file in a labeled filesystem;
#line 11
allow unconfined_t file_type:{ file chr_file } ~execmod;
#line 11
allow unconfined_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 11
allow unconfined_t sysctl_t:{ dir file } *;
#line 11
allow unconfined_t device_type:{ chr_file blk_file } *;
#line 11
allow unconfined_t mtrr_device_t:file *;
#line 11

#line 11
# Create/access other files.  fs_type is to pick up various
#line 11
# pseudo filesystem types that are applied to both the filesystem
#line 11
# and its files.
#line 11
allow unconfined_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 11
allow unconfined_t unlabeled_t:association { sendto recvfrom };
#line 11

#line 11
allow unconfined_t proc_fs:{ dir file } *;
#line 11

#line 11
# For /proc/pid
#line 11

#line 11
allow unconfined_t domain:dir { read getattr lock search ioctl };
#line 11
allow unconfined_t domain:file { read getattr lock ioctl };
#line 11
allow unconfined_t domain:lnk_file { getattr read };
#line 11

#line 11
# Write access is for setting attributes under /proc/self/attr.
#line 11
allow unconfined_t self:file { ioctl read getattr lock write append };
#line 11

#line 11
# Read and write sysctls.
#line 11

#line 11
allow unconfined_t sysctl_type:dir { read getattr lock search ioctl };
#line 11
allow unconfined_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 11

#line 11

#line 11
# Access the network.
#line 11
allow unconfined_t node_type:node *;
#line 11
allow unconfined_t netif_type:netif *;
#line 11
allow unconfined_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 11
allow unconfined_t port_type:tcp_socket name_connect;
#line 11

#line 11
# Bind to any network address.
#line 11
allow unconfined_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 11
allow unconfined_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 11
allow unconfined_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 11

#line 11
# Use/sendto/connectto sockets created by any domain.
#line 11
allow unconfined_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 11

#line 11
# Use descriptors and pipes created by any domain.
#line 11
allow unconfined_t domain:fd use;
#line 11
allow unconfined_t domain:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
# Act upon any other process.
#line 11
allow unconfined_t domain:process ~{ transition dyntransition execmem };
#line 11
# Transition to myself, to make get_ordered_context_list happy.
#line 11
allow unconfined_t self:process transition;
#line 11

#line 11
if (allow_execmem) {
#line 11
# Allow making anonymous memory executable, e.g. 
#line 11
# for runtime-code generation or executable stack.
#line 11
allow unconfined_t self:process execmem;
#line 11
}
#line 11

#line 11
if (allow_execmem && allow_execstack) {
#line 11
# Allow making the stack executable via mprotect.
#line 11
allow unconfined_t self:process execstack;
#line 11
}
#line 11

#line 11
if (allow_execmod) {
#line 11
# Allow text relocations on system shared libraries, e.g. libGL.
#line 11

#line 11
allow unconfined_t file_type:file execmod;
#line 11

#line 11
}
#line 11

#line 11
# Create/access any System V IPC objects.
#line 11
allow unconfined_t domain:{ sem msgq shm } *;
#line 11
allow unconfined_t domain:msg  { send receive };
#line 11

#line 11
# Access the security API.
#line 11
if (!secure_mode_policyload) {
#line 11
allow unconfined_t security_t:security *;
#line 11
auditallow unconfined_t security_t:security { load_policy setenforce setbool };
#line 11
}
#line 11
# Perform certain system operations that lacked individual capabilities.
#line 11
allow unconfined_t kernel_t:system *;
#line 11

#line 11
# Use any Linux capability.
#line 11
allow unconfined_t self:capability *;
#line 11

#line 11
# Set user information and skip authentication.
#line 11
allow unconfined_t self:passwd *;
#line 11

#line 11
# Communicate via dbusd.
#line 11
allow unconfined_t self:dbus *;
#line 11

#line 11
allow unconfined_t system_dbusd_t:dbus *;
#line 11

#line 11

#line 11
# Get info via nscd.
#line 11
allow unconfined_t self:nscd *;
#line 11

#line 11
allow unconfined_t nscd_t:nscd *;
#line 11

#line 11

#line 11

allow domain unconfined_t:fd use;
allow domain unconfined_t:process sigchld;

# Define some type aliases to help with compatibility with
# macros and domains from the "strict" policy.
typealias bin_t alias su_exec_t;
typealias unconfined_t alias { logrotate_t sendmail_t sshd_t secadm_t sysadm_t rpm_t rpm_script_t xdm_t };
typeattribute tty_device_t admin_tty_type;
typeattribute devpts_t admin_tty_type;

# User home directory type.
type user_home_t, file_type, sysadmfile, home_type;
type user_home_dir_t, file_type, sysadmfile, home_dir_type;

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the process to modify the directory.
#line 25
#
#line 25
allow unconfined_t home_root_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 25

#line 25
#
#line 25
# Allow the process to create the file.
#line 25
#
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow unconfined_t user_home_dir_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
type_transition unconfined_t home_root_t:dir user_home_dir_t;
#line 25

#line 25

allow privhome home_root_t:dir { getattr search };

#line 27

#line 27

#line 27

#line 27
#
#line 27
# Allow the process to modify the directory.
#line 27
#
#line 27
allow privhome user_home_dir_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 27

#line 27
#
#line 27
# Allow the process to create the file.
#line 27
#
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
allow privhome user_home_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
allow privhome user_home_t:lnk_file { create read getattr setattr link unlink rename };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
allow privhome user_home_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
allow privhome user_home_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
allow privhome user_home_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
type_transition privhome user_home_dir_t:dir user_home_t;
#line 27
type_transition privhome user_home_dir_t:{ file lnk_file sock_file fifo_file } user_home_t;
#line 27

#line 27


#line 36


#line 37

#line 37
typealias user_home_t alias sysadm_home_t;
#line 37
typealias user_home_dir_t alias sysadm_home_dir_t;
#line 37

#line 37
typealias tty_device_t alias sysadm_tty_device_t;
#line 37
typealias devpts_t alias sysadm_devpts_t;
#line 37


#line 38

#line 38
typealias user_home_t alias staff_home_t;
#line 38
typealias user_home_dir_t alias staff_home_dir_t;
#line 38

#line 38
typealias tty_device_t alias staff_tty_device_t;
#line 38
typealias devpts_t alias staff_devpts_t;
#line 38


#line 39

#line 39
typealias tty_device_t alias user_tty_device_t;
#line 39
typealias devpts_t alias user_devpts_t;
#line 39

attribute user_file_type;
attribute staff_file_type;
attribute sysadm_file_type;

allow unconfined_t unlabeled_t:filesystem *;
allow unconfined_t self:system syslog_read;
allow unlabeled_t self:filesystem associate;

# Support NFS home directories
bool use_nfs_home_dirs false;

# Allow making anonymous memory executable, e.g. 
# for runtime-code generation or executable stack.
bool allow_execmem true;

# Allow making the stack executable via mprotect.
# Also requires allow_execmem.
bool allow_execstack true;

# Allow making a modified private file mapping executable (text relocation).
bool allow_execmod true;

# Support SAMBA home directories
bool use_samba_home_dirs false;


#line 65
if ( samba_enable_home_dirs ) {
#line 65
allow smbd_t home_root_t:dir { read getattr lock search ioctl };
#line 65

#line 65

#line 65

#line 65

#line 65
#
#line 65
# Allow the process to modify the directory.
#line 65
#
#line 65
allow smbd_t user_home_dir_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 65

#line 65
#
#line 65
# Allow the process to create the file.
#line 65
#
#line 65

#line 65

#line 65

#line 65

#line 65

#line 65
allow smbd_t user_home_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65
allow smbd_t user_home_t:lnk_file { create read getattr setattr link unlink rename };
#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65
allow smbd_t user_home_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65
allow smbd_t user_home_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65
allow smbd_t user_home_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65
type_transition smbd_t user_home_dir_t:dir user_home_t;
#line 65
type_transition smbd_t user_home_dir_t:{ file lnk_file sock_file fifo_file } user_home_t;
#line 65

#line 65

#line 65
dontaudit smbd_t user_file_type:{ dir file lnk_file sock_file fifo_file chr_file blk_file } getattr;
#line 65
}
#line 65



# Allow system to run with NIS
bool allow_ypbind false;

# Allow system to run with Kerberos
bool allow_kerberos false;

# allow reading of default file context
bool read_default_t true;

if (allow_execmem) {
allow domain self:process execmem;
}

#Removing i18n_input from targeted for now, since wants to read users homedirs
typealias bin_t alias i18n_input_exec_t;
typealias unconfined_t alias i18n_input_t;
typealias var_run_t alias i18n_input_var_run_t;
#line 93


#line 1 "domains/misc/kernel.te"
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

#################################
#
# Rules for the kernel_t domain.
#

#
# kernel_t is the domain of kernel threads.
# It is also the target type when checking permissions in the system class.
# 
type kernel_t, domain, privmodule, privlog, sysctl_kernel_writer, mlsprocread, mlsprocwrite, privsysmod, etc_writer, privrangetrans ;
role system_r types kernel_t;

#line 16
# Access other processes in the same domain.
#line 16
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 16
# These must be granted separately if desired.
#line 16
allow kernel_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 16

#line 16
# Access /proc/PID files for processes in the same domain.
#line 16
allow kernel_t self:dir { read getattr lock search ioctl };
#line 16
allow kernel_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 16

#line 16
# Access file descriptions, pipes, and sockets
#line 16
# created by processes in the same domain.
#line 16
allow kernel_t self:fd *;
#line 16
allow kernel_t self:fifo_file { ioctl read getattr lock write append };
#line 16
allow kernel_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 16
allow kernel_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 16

#line 16
# Allow the domain to communicate with other processes in the same domain.
#line 16
allow kernel_t self:unix_dgram_socket sendto;
#line 16
allow kernel_t self:unix_stream_socket connectto;
#line 16

#line 16
# Access System V IPC objects created by processes in the same domain.
#line 16
allow kernel_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 16
allow kernel_t self:msg  { send receive };
#line 16
allow kernel_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 16
allow kernel_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 16
allow kernel_t unpriv_userdomain:fd use;
#line 16
#
#line 16
# Every app is asking for ypbind so I am adding this here, 
#line 16
# eventually this should become can_nsswitch
#line 16
#
#line 16

#line 16

#line 16
if (allow_ypbind) {
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow kernel_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow kernel_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow kernel_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow kernel_t node_type:node { tcp_send rawip_send };
#line 16
allow kernel_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow kernel_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow kernel_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow kernel_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow kernel_t self:tcp_socket { listen accept };
#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow kernel_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow kernel_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow kernel_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow kernel_t node_type:node { tcp_send rawip_send };
#line 16
allow kernel_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow kernel_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow kernel_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow kernel_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow kernel_t self:tcp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use udp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow kernel_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow kernel_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow kernel_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow kernel_t node_type:node { udp_send rawip_send };
#line 16
allow kernel_t node_type:node { udp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow kernel_t port_type:udp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow kernel_t node_type:udp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow kernel_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow kernel_t self:udp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
allow kernel_t var_yp_t:dir { read getattr lock search ioctl };
#line 16
allow kernel_t var_yp_t:file { read getattr lock ioctl };
#line 16
allow kernel_t var_yp_t:lnk_file { getattr read };
#line 16

#line 16
allow kernel_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 16
allow kernel_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 16
dontaudit kernel_t self:capability net_bind_service;
#line 16
dontaudit kernel_t reserved_port_type:tcp_socket name_connect;
#line 16
dontaudit kernel_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 16

#line 16
} else {
#line 16
dontaudit kernel_t var_yp_t:dir search;
#line 16
}
#line 16
 
#line 16
allow kernel_t autofs_t:dir { search getattr };
#line 16


#line 17
# Read system information files in /proc.
#line 17

#line 17
allow kernel_t proc_t:dir { read getattr lock search ioctl };
#line 17
allow kernel_t proc_t:file { read getattr lock ioctl };
#line 17
allow kernel_t proc_t:lnk_file { getattr read };
#line 17

#line 17

#line 17
allow kernel_t proc_net_t:dir { read getattr lock search ioctl };
#line 17
allow kernel_t proc_net_t:file { read getattr lock ioctl };
#line 17
allow kernel_t proc_net_t:lnk_file { getattr read };
#line 17

#line 17
allow kernel_t proc_mdstat_t:file { read getattr lock ioctl };
#line 17

#line 17
# Stat /proc/kmsg and /proc/kcore.
#line 17
allow kernel_t proc_fs:file { getattr };
#line 17

#line 17
# Read system variables in /proc/sys.
#line 17

#line 17
# Read system variables in /sys.
#line 17

#line 17
allow kernel_t sysctl_t:dir search;
#line 17
allow kernel_t sysctl_kernel_t:dir search;
#line 17
allow kernel_t sysctl_kernel_t:file { getattr read };
#line 17

#line 17

#line 17

#line 17


#line 18
# Read /.
#line 18
allow kernel_t root_t:dir { read getattr lock search ioctl };
#line 18
allow kernel_t root_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 18

#line 18
# Read /home.
#line 18
allow kernel_t home_root_t:dir { read getattr lock search ioctl };
#line 18

#line 18
# Read /usr.
#line 18
allow kernel_t usr_t:dir { read getattr lock search ioctl };
#line 18
allow kernel_t usr_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 18

#line 18
# Read bin and sbin directories.
#line 18
allow kernel_t bin_t:dir { read getattr lock search ioctl };
#line 18
allow kernel_t bin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 18
allow kernel_t sbin_t:dir { read getattr lock search ioctl };
#line 18
allow kernel_t sbin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 18

#line 18
# Read system variables in /sys.
#line 18

#line 18
allow kernel_t sysctl_t:dir search;
#line 18
allow kernel_t sysctl_kernel_t:dir search;
#line 18
allow kernel_t sysctl_kernel_t:file { getattr read };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
allow kernel_t selinux_config_t:dir { read getattr lock search ioctl };
#line 18
allow kernel_t selinux_config_t:file { read getattr lock ioctl };
#line 18
allow kernel_t selinux_config_t:lnk_file { getattr read };
#line 18

#line 18

#line 18
if (read_default_t) {
#line 18
#
#line 18
# Read default_t
#line 18
#.
#line 18
allow kernel_t default_t:dir { read getattr lock search ioctl };
#line 18
allow kernel_t default_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 18
}
#line 18

#line 18


#line 19
allow kernel_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 19
allow kernel_t lib_t:lnk_file { read getattr lock ioctl };
#line 19
allow kernel_t ld_so_t:file { read getattr lock execute ioctl };
#line 19
#allow kernel_t ld_so_t:file execute_no_trans;
#line 19
allow kernel_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 19
allow kernel_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 19
allow kernel_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 19
allow kernel_t texrel_shlib_t:file execmod;
#line 19
allow kernel_t ld_so_cache_t:file { read getattr lock ioctl };
#line 19
allow kernel_t device_t:dir search;
#line 19
allow kernel_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 19


#line 20
allow kernel_t shell_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 20


# Use capabilities.
allow kernel_t self:capability *;


#line 25
allow kernel_t sysfs_t:dir { read getattr lock search ioctl };
#line 25
allow kernel_t sysfs_t:file { read getattr lock ioctl };
#line 25
allow kernel_t sysfs_t:lnk_file { getattr read };
#line 25

allow kernel_t { usbfs_t usbdevfs_t }:dir search;

# Run init in the init_t domain.

#line 29

#line 29

#line 29
#
#line 29
# Allow the process to transition to the new domain.
#line 29
#
#line 29
allow kernel_t init_t:process transition;
#line 29

#line 29
#
#line 29
# Do not audit when glibc secure mode is enabled upon the transition.
#line 29
#
#line 29
dontaudit kernel_t init_t:process noatsecure;
#line 29

#line 29
#
#line 29
# Do not audit when signal-related state is cleared upon the transition.
#line 29
#
#line 29
dontaudit kernel_t init_t:process siginh;
#line 29

#line 29
#
#line 29
# Do not audit when resource limits are reset upon the transition.
#line 29
#
#line 29
dontaudit kernel_t init_t:process rlimitinh;
#line 29

#line 29
#
#line 29
# Allow the process to execute the program.
#line 29
# 
#line 29
allow kernel_t init_exec_t:file { read { getattr execute } };
#line 29

#line 29
#
#line 29
# Allow the process to reap the new domain.
#line 29
#
#line 29
allow init_t kernel_t:process sigchld;
#line 29

#line 29
#
#line 29
# Allow the new domain to inherit and use file 
#line 29
# descriptions from the creating process and vice versa.
#line 29
#
#line 29
allow init_t kernel_t:fd use;
#line 29
allow kernel_t init_t:fd use;
#line 29

#line 29
#
#line 29
# Allow the new domain to write back to the old domain via a pipe.
#line 29
#
#line 29
allow init_t kernel_t:fifo_file { ioctl read getattr lock write append };
#line 29

#line 29
#
#line 29
# Allow the new domain to read and execute the program.
#line 29
#
#line 29
allow init_t init_exec_t:file { read getattr lock execute ioctl };
#line 29

#line 29
#
#line 29
# Allow the new domain to be entered via the program.
#line 29
#
#line 29
allow init_t init_exec_t:file entrypoint;
#line 29

#line 29
type_transition kernel_t init_exec_t:process init_t;
#line 29


#line 34


# Share state with the init process.
allow kernel_t init_t:process share;

# Mount and unmount file systems.
allow kernel_t fs_type:filesystem { mount remount unmount getattr };

# Send signal to any process.
allow kernel_t domain:process signal;
allow kernel_t domain:dir search;

# Access the console.
allow kernel_t device_t:dir search;
allow kernel_t console_device_t:chr_file { ioctl read getattr lock write append };

# Access the initrd filesystem.
allow kernel_t file_t:chr_file { ioctl read getattr lock write append };

#line 52
allow kernel_t file_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 52

#line 55

allow kernel_t self:capability sys_chroot;

allow kernel_t { unlabeled_t root_t file_t }:dir mounton;
allow kernel_t unlabeled_t:fifo_file { ioctl read getattr lock write append };
allow kernel_t file_t:dir { read getattr lock search ioctl add_name remove_name write };
allow kernel_t file_t:blk_file { create ioctl read getattr lock write setattr append link unlink rename };
allow kernel_t { sysctl_t sysctl_kernel_t }:file { setattr { ioctl read getattr lock write append } };

# Lookup the policy.
allow kernel_t policy_config_t:dir { read getattr lock search ioctl };

# Load the policy configuration.

#line 68
# Get the selinuxfs mount point via /proc/self/mounts.
#line 68
allow kernel_t proc_t:dir search;
#line 68
allow kernel_t proc_t:lnk_file read;
#line 68
allow kernel_t proc_t:file { getattr read };
#line 68
allow kernel_t self:dir search;
#line 68
allow kernel_t self:file { getattr read };
#line 68
# Access selinuxfs.
#line 68
allow kernel_t security_t:dir { read search getattr };
#line 68
allow kernel_t security_t:file { getattr read write };
#line 68
if (!secure_mode_policyload) {
#line 68
allow kernel_t security_t:security load_policy;
#line 68
auditallow kernel_t security_t:security load_policy;
#line 68
}

# /proc/sys/kernel/modprobe is set to /bin/true if not using modules.

#line 71
allow kernel_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 71


#line 75

#line 75

#line 75

#line 75
typeattribute kernel_t unrestricted;
#line 75
typeattribute kernel_t privuser;
#line 75

#line 75
# Mount/unmount any filesystem. 
#line 75
allow kernel_t fs_type:filesystem *;
#line 75

#line 75
# Mount/unmount any filesystem with the context= option. 
#line 75
allow kernel_t file_type:filesystem *;
#line 75

#line 75
# Create/access any file in a labeled filesystem;
#line 75
allow kernel_t file_type:{ file chr_file } ~execmod;
#line 75
allow kernel_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 75
allow kernel_t sysctl_t:{ dir file } *;
#line 75
allow kernel_t device_type:{ chr_file blk_file } *;
#line 75
allow kernel_t mtrr_device_t:file *;
#line 75

#line 75
# Create/access other files.  fs_type is to pick up various
#line 75
# pseudo filesystem types that are applied to both the filesystem
#line 75
# and its files.
#line 75
allow kernel_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 75
allow kernel_t unlabeled_t:association { sendto recvfrom };
#line 75

#line 75
allow kernel_t proc_fs:{ dir file } *;
#line 75

#line 75
# For /proc/pid
#line 75

#line 75
allow kernel_t domain:dir { read getattr lock search ioctl };
#line 75
allow kernel_t domain:file { read getattr lock ioctl };
#line 75
allow kernel_t domain:lnk_file { getattr read };
#line 75

#line 75
# Write access is for setting attributes under /proc/self/attr.
#line 75
allow kernel_t self:file { ioctl read getattr lock write append };
#line 75

#line 75
# Read and write sysctls.
#line 75

#line 75
allow kernel_t sysctl_type:dir { read getattr lock search ioctl };
#line 75
allow kernel_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 75

#line 75

#line 75
# Access the network.
#line 75
allow kernel_t node_type:node *;
#line 75
allow kernel_t netif_type:netif *;
#line 75
allow kernel_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 75
allow kernel_t port_type:tcp_socket name_connect;
#line 75

#line 75
# Bind to any network address.
#line 75
allow kernel_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 75
allow kernel_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 75
allow kernel_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 75

#line 75
# Use/sendto/connectto sockets created by any domain.
#line 75
allow kernel_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 75

#line 75
# Use descriptors and pipes created by any domain.
#line 75
allow kernel_t domain:fd use;
#line 75
allow kernel_t domain:fifo_file { ioctl read getattr lock write append };
#line 75

#line 75
# Act upon any other process.
#line 75
allow kernel_t domain:process ~{ transition dyntransition execmem };
#line 75
# Transition to myself, to make get_ordered_context_list happy.
#line 75
allow kernel_t self:process transition;
#line 75

#line 75
if (allow_execmem) {
#line 75
# Allow making anonymous memory executable, e.g. 
#line 75
# for runtime-code generation or executable stack.
#line 75
allow kernel_t self:process execmem;
#line 75
}
#line 75

#line 75
if (allow_execmem && allow_execstack) {
#line 75
# Allow making the stack executable via mprotect.
#line 75
allow kernel_t self:process execstack;
#line 75
}
#line 75

#line 75
if (allow_execmod) {
#line 75
# Allow text relocations on system shared libraries, e.g. libGL.
#line 75

#line 75
allow kernel_t file_type:file execmod;
#line 75

#line 75
}
#line 75

#line 75
# Create/access any System V IPC objects.
#line 75
allow kernel_t domain:{ sem msgq shm } *;
#line 75
allow kernel_t domain:msg  { send receive };
#line 75

#line 75
# Access the security API.
#line 75
if (!secure_mode_policyload) {
#line 75
allow kernel_t security_t:security *;
#line 75
auditallow kernel_t security_t:security { load_policy setenforce setbool };
#line 75
}
#line 75
# Perform certain system operations that lacked individual capabilities.
#line 75
allow kernel_t kernel_t:system *;
#line 75

#line 75
# Use any Linux capability.
#line 75
allow kernel_t self:capability *;
#line 75

#line 75
# Set user information and skip authentication.
#line 75
allow kernel_t self:passwd *;
#line 75

#line 75
# Communicate via dbusd.
#line 75
allow kernel_t self:dbus *;
#line 75

#line 75
allow kernel_t system_dbusd_t:dbus *;
#line 75

#line 75

#line 75
# Get info via nscd.
#line 75
allow kernel_t self:nscd *;
#line 75

#line 75
allow kernel_t nscd_t:nscd *;
#line 75

#line 75

#line 75

#line 75

#line 1 "domains/misc/local.te"
# Local customization of existing policy should be done in this file.  
# If you are creating brand new policy for a new "target" domain, you
# need to create a type enforcement (.te) file in domains/program
# and a file context (.fc) file in file_context/program.

#line 1 "domains/program/acct.te"
#DESC Acct - BSD process accounting
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: acct
#

#################################
#
# Rules for the acct_t domain.
#
# acct_exec_t is the type of the acct executable.
#

#line 13

#line 13
type acct_t, domain, privlog, daemon ;
#line 13
type acct_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit acct_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types acct_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow acct_t init_t:fd use;
#line 13
allow acct_t init_t:process sigchld;
#line 13
allow acct_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow acct_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow acct_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow acct_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow acct_t ld_so_t:file execute_no_trans;
#line 13
allow acct_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow acct_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow acct_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow acct_t texrel_shlib_t:file execmod;
#line 13
allow acct_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow acct_t device_t:dir search;
#line 13
allow acct_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow acct_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow acct_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow acct_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow acct_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow acct_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit acct_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit acct_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow acct_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow acct_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow acct_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow acct_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit acct_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit acct_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow acct_t sysctl_t:dir search;
#line 13
allow acct_t sysctl_kernel_t:dir search;
#line 13
allow acct_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t acct_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t acct_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t acct_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t acct_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t acct_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow acct_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow acct_t initrc_t:fd use;
#line 13
allow initrc_t acct_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow acct_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow acct_t acct_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow acct_t acct_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t acct_exec_t:process acct_t;
#line 13

#line 13

#line 13
allow initrc_t acct_t:process { noatsecure siginh rlimitinh };
#line 13
 
#line 13
allow acct_t privfd:fd use;
#line 13

#line 13
allow acct_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the process to transition to the new domain.
#line 19
#
#line 19
allow system_crond_t acct_t:process transition;
#line 19

#line 19
#
#line 19
# Do not audit when glibc secure mode is enabled upon the transition.
#line 19
#
#line 19
dontaudit system_crond_t acct_t:process noatsecure;
#line 19

#line 19
#
#line 19
# Do not audit when signal-related state is cleared upon the transition.
#line 19
#
#line 19
dontaudit system_crond_t acct_t:process siginh;
#line 19

#line 19
#
#line 19
# Do not audit when resource limits are reset upon the transition.
#line 19
#
#line 19
dontaudit system_crond_t acct_t:process rlimitinh;
#line 19

#line 19
#
#line 19
# Allow the process to execute the program.
#line 19
# 
#line 19
allow system_crond_t acct_exec_t:file { read { getattr execute } };
#line 19

#line 19
#
#line 19
# Allow the process to reap the new domain.
#line 19
#
#line 19
allow acct_t system_crond_t:process sigchld;
#line 19

#line 19
#
#line 19
# Allow the new domain to inherit and use file 
#line 19
# descriptions from the creating process and vice versa.
#line 19
#
#line 19
allow acct_t system_crond_t:fd use;
#line 19
allow system_crond_t acct_t:fd use;
#line 19

#line 19
#
#line 19
# Allow the new domain to write back to the old domain via a pipe.
#line 19
#
#line 19
allow acct_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 19

#line 19
#
#line 19
# Allow the new domain to read and execute the program.
#line 19
#
#line 19
allow acct_t acct_exec_t:file { read getattr lock execute ioctl };
#line 19

#line 19
#
#line 19
# Allow the new domain to be entered via the program.
#line 19
#
#line 19
allow acct_t acct_exec_t:file entrypoint;
#line 19

#line 19
type_transition system_crond_t acct_exec_t:process acct_t;
#line 19

#line 19
allow acct_t crond_t:fifo_file { getattr read write ioctl };
#line 19
# a rule for privfd may make this obsolete
#line 19
allow acct_t crond_t:fd use;
#line 19
allow acct_t crond_t:process sigchld;
#line 19

#line 19

#line 19
# for monthly cron job
#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the process to modify the directory.
#line 19
#
#line 19
allow acct_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 19

#line 19
#
#line 19
# Allow the process to create the file.
#line 19
#
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow acct_t wtmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
type_transition acct_t var_log_t:file wtmp_t;
#line 19

#line 19

#line 19


# for SSP
allow acct_t urandom_device_t:chr_file read;

type acct_data_t, file_type, logfile, sysadmfile;

# not sure why we need this, the command "last" is reported as using it
dontaudit acct_t self:capability kill;

# gzip needs chown capability for some reason
allow acct_t self:capability { chown fsetid sys_pacct };

allow acct_t var_t:dir { getattr search };

#line 33
allow acct_t acct_data_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 33
allow acct_t acct_data_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 33
allow acct_t acct_data_t:lnk_file { create read getattr setattr link unlink rename };
#line 33



#line 35
allow acct_t { shell_exec_t bin_t initrc_exec_t acct_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 35

allow acct_t { bin_t sbin_t }:dir search;
allow acct_t bin_t:lnk_file read;


#line 39
allow acct_t etc_t:lnk_file read;
#line 39
allow acct_t lib_t:file { read getattr lock ioctl };
#line 39

#line 39
allow acct_t locale_t:dir { read getattr lock search ioctl };
#line 39
allow acct_t locale_t:file { read getattr lock ioctl };
#line 39
allow acct_t locale_t:lnk_file { getattr read };
#line 39

#line 39


allow acct_t fs_t:filesystem getattr;

allow acct_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

allow acct_t self:fifo_file { read write getattr };

allow acct_t { self proc_t }:file { read getattr };


#line 49
# Read system variables in /sys.
#line 49

#line 49
allow acct_t sysctl_t:dir search;
#line 49
allow acct_t sysctl_kernel_t:dir search;
#line 49
allow acct_t sysctl_kernel_t:file { getattr read };
#line 49

#line 49

#line 49


dontaudit acct_t sysadm_home_dir_t:dir { getattr search };

# for nscd
dontaudit acct_t var_run_t:dir search;


allow acct_t devtty_t:chr_file { read write };

allow acct_t { etc_t etc_runtime_t }:file { read getattr };

#line 65


#line 1 "domains/program/amanda.te"
#DESC Amanda - Automated backup program
#
# This policy file sets the rigths for amanda client started by inetd_t
# and amrecover 
#
# X-Debian-Packages: amanda-common amanda-server
# Depends: inetd.te
# Author     :  Carsten Grohmann <carstengrohmann@gmx.de>
#
# License    :  GPL
#
# last change:  27. August 2002
#
# state      :  complete and tested
#
# Hints      :
#  - amanda.fc is the appendant file context file
#  - If you use amrecover please extract the files and directories to the
#    directory speficified in amanda.fc as type amanda_recover_dir_t.
#  - The type amanda_user_exec_t is defined to label the files but not used.
#    This configuration works only as an client and a amanda client does not need
#    this programs.
#
# Enhancements/Corrections:
#  - set tighter permissions to /bin/tar instead bin_t 

##############################################################################
# AMANDA CLIENT DECLARATIONS
##############################################################################

# General declarations
######################

type amanda_t, domain, privlog, auth, fs_domain, nscd_client_domain;
role system_r types amanda_t;

# type for the amanda executables
type amanda_exec_t, file_type, sysadmfile, exec_type;

# type for the amanda executables started by inetd
type amanda_inetd_exec_t, file_type, sysadmfile, exec_type;

# type for amanda configurations files
type amanda_config_t, file_type, sysadmfile;

# type for files in /usr/lib/amanda
type amanda_usr_lib_t, file_type, sysadmfile;

# type for all files in /var/lib/amanda
type amanda_var_lib_t, file_type, sysadmfile;

# type for all files in /var/lib/amanda/gnutar-lists/
type amanda_gnutarlists_t, file_type, sysadmfile;

# type for user startable files
type amanda_user_exec_t, file_type, sysadmfile, exec_type;

# type for same awk and other scripts
type amanda_script_exec_t, file_type, sysadmfile, exec_type;

# type for the shell configuration files 
type amanda_shellconfig_t, file_type, sysadmfile;


#line 64
type amanda_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 64

#line 64

#line 64

#line 64

#line 64
#
#line 64
# Allow the process to modify the directory.
#line 64
#
#line 64
allow amanda_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 64

#line 64
#
#line 64
# Allow the process to create the file.
#line 64
#
#line 64

#line 64

#line 64

#line 64

#line 64

#line 64
allow amanda_t amanda_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64
allow amanda_t amanda_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64
type_transition amanda_t tmp_t:{ file dir } amanda_tmp_t;
#line 64

#line 64

#line 64

 
# type for /etc/amandates
type amanda_amandates_t, file_type, sysadmfile;

# type for /etc/dumpdates
type amanda_dumpdates_t, file_type, sysadmfile;

# type for amanda data
type amanda_data_t, file_type, sysadmfile;

# Domain transitions
####################


#line 78

#line 78

#line 78
#
#line 78
# Allow the process to transition to the new domain.
#line 78
#
#line 78
allow inetd_t amanda_t:process transition;
#line 78

#line 78
#
#line 78
# Do not audit when glibc secure mode is enabled upon the transition.
#line 78
#
#line 78
dontaudit inetd_t amanda_t:process noatsecure;
#line 78

#line 78
#
#line 78
# Do not audit when signal-related state is cleared upon the transition.
#line 78
#
#line 78
dontaudit inetd_t amanda_t:process siginh;
#line 78

#line 78
#
#line 78
# Do not audit when resource limits are reset upon the transition.
#line 78
#
#line 78
dontaudit inetd_t amanda_t:process rlimitinh;
#line 78

#line 78
#
#line 78
# Allow the process to execute the program.
#line 78
# 
#line 78
allow inetd_t amanda_inetd_exec_t:file { read { getattr execute } };
#line 78

#line 78
#
#line 78
# Allow the process to reap the new domain.
#line 78
#
#line 78
allow amanda_t inetd_t:process sigchld;
#line 78

#line 78
#
#line 78
# Allow the new domain to inherit and use file 
#line 78
# descriptions from the creating process and vice versa.
#line 78
#
#line 78
allow amanda_t inetd_t:fd use;
#line 78
allow inetd_t amanda_t:fd use;
#line 78

#line 78
#
#line 78
# Allow the new domain to write back to the old domain via a pipe.
#line 78
#
#line 78
allow amanda_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 78

#line 78
#
#line 78
# Allow the new domain to read and execute the program.
#line 78
#
#line 78
allow amanda_t amanda_inetd_exec_t:file { read getattr lock execute ioctl };
#line 78

#line 78
#
#line 78
# Allow the new domain to be entered via the program.
#line 78
#
#line 78
allow amanda_t amanda_inetd_exec_t:file entrypoint;
#line 78

#line 78
type_transition inetd_t amanda_inetd_exec_t:process amanda_t;
#line 78



##################
# File permissions
##################

# configuration files -> read only
allow amanda_t amanda_config_t:file { getattr read };

# access to amanda_amandates_t
allow amanda_t amanda_amandates_t:file { getattr lock read write };

# access to amanda_dumpdates_t
allow amanda_t amanda_dumpdates_t:file { getattr lock read write };

# access to amandas data structure
allow amanda_t amanda_data_t:dir { read search write };
allow amanda_t amanda_data_t:file { read write };

# access to proc_t
allow amanda_t proc_t:file { getattr read };

# access to etc_t and similar
allow amanda_t etc_t:file { getattr read };
allow amanda_t etc_runtime_t:file { getattr read };

# access to amanda_gnutarlists_t (/var/lib/amanda/gnutar-lists)

#line 106
allow amanda_t amanda_gnutarlists_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 106
allow amanda_t amanda_gnutarlists_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 106
allow amanda_t amanda_gnutarlists_t:lnk_file { create read getattr setattr link unlink rename };
#line 106


# access to device_t and similar
allow amanda_t devtty_t:chr_file { read write };

# access to fs_t
allow amanda_t fs_t:filesystem getattr;

# access to sysctl_kernel_t ( proc/sys/kernel/* )

#line 115
# Read system variables in /sys.
#line 115

#line 115
allow amanda_t sysctl_t:dir search;
#line 115
allow amanda_t sysctl_kernel_t:dir search;
#line 115
allow amanda_t sysctl_kernel_t:file { getattr read };
#line 115

#line 115

#line 115


#####################
# process permissions
#####################

# Allow to use shared libs

#line 122
allow amanda_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 122
allow amanda_t lib_t:lnk_file { read getattr lock ioctl };
#line 122
allow amanda_t ld_so_t:file { read getattr lock execute ioctl };
#line 122
#allow amanda_t ld_so_t:file execute_no_trans;
#line 122
allow amanda_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 122
allow amanda_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 122
allow amanda_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 122
allow amanda_t texrel_shlib_t:file execmod;
#line 122
allow amanda_t ld_so_cache_t:file { read getattr lock ioctl };
#line 122
allow amanda_t device_t:dir search;
#line 122
allow amanda_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 122


# Allow to execute a amanda executable file
allow amanda_t amanda_exec_t:file { execute execute_no_trans getattr read };	

# Allow to run a shell
allow amanda_t shell_exec_t:file { execute execute_no_trans getattr read };

# access to bin_t (tar)
allow amanda_t bin_t:file { execute execute_no_trans };

allow amanda_t self:capability { chown dac_override setuid };
allow amanda_t self:process { fork sigchld setpgid signal };
allow amanda_t self:dir search;
allow amanda_t self:file { getattr read };


###################################
# Network and process communication
###################################


#line 143

#line 143

#line 143

#line 143
#
#line 143
# Allow the domain to create and use tcp sockets.
#line 143
# Other kinds of sockets must be separately authorized for use.
#line 143
allow amanda_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 143

#line 143
allow amanda_t unlabeled_t:association { sendto recvfrom };
#line 143

#line 143
#
#line 143
# Allow the domain to send or receive using any network interface.
#line 143
# netif_type is a type attribute for all network interface types.
#line 143
#
#line 143
allow amanda_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 143
#
#line 143
# Allow the domain to send to or receive from any node.
#line 143
# node_type is a type attribute for all node types.
#line 143
#
#line 143
allow amanda_t node_type:node { tcp_send rawip_send };
#line 143
allow amanda_t node_type:node { tcp_recv rawip_recv };
#line 143

#line 143
#
#line 143
# Allow the domain to send to or receive from any port.
#line 143
# port_type is a type attribute for all port types.
#line 143
#
#line 143

#line 143
allow amanda_t port_type:tcp_socket { send_msg recv_msg };
#line 143

#line 143

#line 143
# XXX Allow binding to any node type.  Remove once
#line 143
# individual rules have been added to all domains that 
#line 143
# bind sockets. 
#line 143
allow amanda_t node_type:tcp_socket node_bind;
#line 143
#
#line 143
# Allow access to network files including /etc/resolv.conf
#line 143
#
#line 143
allow amanda_t net_conf_t:file { read getattr lock ioctl };
#line 143

#line 143
allow amanda_t self:tcp_socket { listen accept };
#line 143

#line 143

#line 143

#line 143
#
#line 143
# Allow the domain to create and use udp sockets.
#line 143
# Other kinds of sockets must be separately authorized for use.
#line 143
allow amanda_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 143

#line 143
allow amanda_t unlabeled_t:association { sendto recvfrom };
#line 143

#line 143
#
#line 143
# Allow the domain to send or receive using any network interface.
#line 143
# netif_type is a type attribute for all network interface types.
#line 143
#
#line 143
allow amanda_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 143
#
#line 143
# Allow the domain to send to or receive from any node.
#line 143
# node_type is a type attribute for all node types.
#line 143
#
#line 143
allow amanda_t node_type:node { udp_send rawip_send };
#line 143
allow amanda_t node_type:node { udp_recv rawip_recv };
#line 143

#line 143
#
#line 143
# Allow the domain to send to or receive from any port.
#line 143
# port_type is a type attribute for all port types.
#line 143
#
#line 143

#line 143
allow amanda_t port_type:udp_socket { send_msg recv_msg };
#line 143

#line 143

#line 143
# XXX Allow binding to any node type.  Remove once
#line 143
# individual rules have been added to all domains that 
#line 143
# bind sockets. 
#line 143
allow amanda_t node_type:udp_socket node_bind;
#line 143
#
#line 143
# Allow access to network files including /etc/resolv.conf
#line 143
#
#line 143
allow amanda_t net_conf_t:file { read getattr lock ioctl };
#line 143

#line 143
allow amanda_t self:udp_socket { connect };
#line 143

#line 143

#line 143
;

#line 144

#line 144
if (allow_ypbind) {
#line 144

#line 144

#line 144

#line 144

#line 144

#line 144

#line 144

#line 144
#
#line 144
# Allow the domain to create and use tcp sockets.
#line 144
# Other kinds of sockets must be separately authorized for use.
#line 144
allow amanda_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 144

#line 144
allow amanda_t unlabeled_t:association { sendto recvfrom };
#line 144

#line 144
#
#line 144
# Allow the domain to send or receive using any network interface.
#line 144
# netif_type is a type attribute for all network interface types.
#line 144
#
#line 144
allow amanda_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 144
#
#line 144
# Allow the domain to send to or receive from any node.
#line 144
# node_type is a type attribute for all node types.
#line 144
#
#line 144
allow amanda_t node_type:node { tcp_send rawip_send };
#line 144
allow amanda_t node_type:node { tcp_recv rawip_recv };
#line 144

#line 144
#
#line 144
# Allow the domain to send to or receive from any port.
#line 144
# port_type is a type attribute for all port types.
#line 144
#
#line 144

#line 144
allow amanda_t port_type:tcp_socket { send_msg recv_msg };
#line 144

#line 144

#line 144
# XXX Allow binding to any node type.  Remove once
#line 144
# individual rules have been added to all domains that 
#line 144
# bind sockets. 
#line 144
allow amanda_t node_type:tcp_socket node_bind;
#line 144
#
#line 144
# Allow access to network files including /etc/resolv.conf
#line 144
#
#line 144
allow amanda_t net_conf_t:file { read getattr lock ioctl };
#line 144

#line 144
allow amanda_t self:tcp_socket { listen accept };
#line 144

#line 144

#line 144

#line 144
#
#line 144
# Allow the domain to create and use tcp sockets.
#line 144
# Other kinds of sockets must be separately authorized for use.
#line 144
allow amanda_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 144

#line 144
allow amanda_t unlabeled_t:association { sendto recvfrom };
#line 144

#line 144
#
#line 144
# Allow the domain to send or receive using any network interface.
#line 144
# netif_type is a type attribute for all network interface types.
#line 144
#
#line 144
allow amanda_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 144
#
#line 144
# Allow the domain to send to or receive from any node.
#line 144
# node_type is a type attribute for all node types.
#line 144
#
#line 144
allow amanda_t node_type:node { tcp_send rawip_send };
#line 144
allow amanda_t node_type:node { tcp_recv rawip_recv };
#line 144

#line 144
#
#line 144
# Allow the domain to send to or receive from any port.
#line 144
# port_type is a type attribute for all port types.
#line 144
#
#line 144

#line 144
allow amanda_t port_type:tcp_socket { send_msg recv_msg };
#line 144

#line 144

#line 144
# XXX Allow binding to any node type.  Remove once
#line 144
# individual rules have been added to all domains that 
#line 144
# bind sockets. 
#line 144
allow amanda_t node_type:tcp_socket node_bind;
#line 144
#
#line 144
# Allow access to network files including /etc/resolv.conf
#line 144
#
#line 144
allow amanda_t net_conf_t:file { read getattr lock ioctl };
#line 144

#line 144
allow amanda_t self:tcp_socket { connect };
#line 144

#line 144

#line 144

#line 144

#line 144

#line 144
#
#line 144
# Allow the domain to create and use udp sockets.
#line 144
# Other kinds of sockets must be separately authorized for use.
#line 144
allow amanda_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 144

#line 144
allow amanda_t unlabeled_t:association { sendto recvfrom };
#line 144

#line 144
#
#line 144
# Allow the domain to send or receive using any network interface.
#line 144
# netif_type is a type attribute for all network interface types.
#line 144
#
#line 144
allow amanda_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 144
#
#line 144
# Allow the domain to send to or receive from any node.
#line 144
# node_type is a type attribute for all node types.
#line 144
#
#line 144
allow amanda_t node_type:node { udp_send rawip_send };
#line 144
allow amanda_t node_type:node { udp_recv rawip_recv };
#line 144

#line 144
#
#line 144
# Allow the domain to send to or receive from any port.
#line 144
# port_type is a type attribute for all port types.
#line 144
#
#line 144

#line 144
allow amanda_t port_type:udp_socket { send_msg recv_msg };
#line 144

#line 144

#line 144
# XXX Allow binding to any node type.  Remove once
#line 144
# individual rules have been added to all domains that 
#line 144
# bind sockets. 
#line 144
allow amanda_t node_type:udp_socket node_bind;
#line 144
#
#line 144
# Allow access to network files including /etc/resolv.conf
#line 144
#
#line 144
allow amanda_t net_conf_t:file { read getattr lock ioctl };
#line 144

#line 144
allow amanda_t self:udp_socket { connect };
#line 144

#line 144

#line 144

#line 144

#line 144

#line 144

#line 144
allow amanda_t var_yp_t:dir { read getattr lock search ioctl };
#line 144
allow amanda_t var_yp_t:file { read getattr lock ioctl };
#line 144
allow amanda_t var_yp_t:lnk_file { getattr read };
#line 144

#line 144
allow amanda_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 144
allow amanda_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 144
dontaudit amanda_t self:capability net_bind_service;
#line 144
dontaudit amanda_t reserved_port_type:tcp_socket name_connect;
#line 144
dontaudit amanda_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 144

#line 144
} else {
#line 144
dontaudit amanda_t var_yp_t:dir search;
#line 144
}
#line 144
 ;

#line 145
allow amanda_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 145
;
	
allow amanda_t self:fifo_file { getattr read write ioctl lock };
allow amanda_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow amanda_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };


##########################
# Communication with inetd
##########################

allow amanda_t inetd_t:udp_socket { read write };


###################
# inetd permissions
###################

allow inetd_t amanda_usr_lib_t:dir search;


########################
# Access to to save data
########################

# access to user_home_t
allow amanda_t user_home_type:file { getattr read };

##############################################################################
# AMANDA RECOVER DECLARATIONS
##############################################################################


# General declarations
######################

# type for amrecover
type amanda_recover_t, domain;
role sysadm_r types amanda_recover_t;
role system_r types amanda_recover_t;

# exec types for amrecover 
type amanda_recover_exec_t, file_type, sysadmfile, exec_type;

# type for recover files ( restored data )
type amanda_recover_dir_t, file_type, sysadmfile;

#line 191

#line 191

#line 191

#line 191
#
#line 191
# Allow the process to modify the directory.
#line 191
#
#line 191
allow amanda_recover_t sysadm_home_dir_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 191

#line 191
#
#line 191
# Allow the process to create the file.
#line 191
#
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow amanda_recover_t amanda_recover_dir_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow amanda_recover_t amanda_recover_dir_t:lnk_file { create read getattr setattr link unlink rename };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow amanda_recover_t amanda_recover_dir_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow amanda_recover_t amanda_recover_dir_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow amanda_recover_t amanda_recover_dir_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
type_transition amanda_recover_t sysadm_home_dir_t:dir amanda_recover_dir_t;
#line 191
type_transition amanda_recover_t sysadm_home_dir_t:{ file lnk_file sock_file fifo_file } amanda_recover_dir_t;
#line 191

#line 191


# domain transsition

#line 194

#line 194

#line 194
#
#line 194
# Allow the process to transition to the new domain.
#line 194
#
#line 194
allow sysadm_t amanda_recover_t:process transition;
#line 194

#line 194
#
#line 194
# Do not audit when glibc secure mode is enabled upon the transition.
#line 194
#
#line 194
dontaudit sysadm_t amanda_recover_t:process noatsecure;
#line 194

#line 194
#
#line 194
# Do not audit when signal-related state is cleared upon the transition.
#line 194
#
#line 194
dontaudit sysadm_t amanda_recover_t:process siginh;
#line 194

#line 194
#
#line 194
# Do not audit when resource limits are reset upon the transition.
#line 194
#
#line 194
dontaudit sysadm_t amanda_recover_t:process rlimitinh;
#line 194

#line 194
#
#line 194
# Allow the process to execute the program.
#line 194
# 
#line 194
allow sysadm_t amanda_recover_exec_t:file { read { getattr execute } };
#line 194

#line 194
#
#line 194
# Allow the process to reap the new domain.
#line 194
#
#line 194
allow amanda_recover_t sysadm_t:process sigchld;
#line 194

#line 194
#
#line 194
# Allow the new domain to inherit and use file 
#line 194
# descriptions from the creating process and vice versa.
#line 194
#
#line 194
allow amanda_recover_t sysadm_t:fd use;
#line 194
allow sysadm_t amanda_recover_t:fd use;
#line 194

#line 194
#
#line 194
# Allow the new domain to write back to the old domain via a pipe.
#line 194
#
#line 194
allow amanda_recover_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 194

#line 194
#
#line 194
# Allow the new domain to read and execute the program.
#line 194
#
#line 194
allow amanda_recover_t amanda_recover_exec_t:file { read getattr lock execute ioctl };
#line 194

#line 194
#
#line 194
# Allow the new domain to be entered via the program.
#line 194
#
#line 194
allow amanda_recover_t amanda_recover_exec_t:file entrypoint;
#line 194

#line 194
type_transition sysadm_t amanda_recover_exec_t:process amanda_recover_t;
#line 194


# file type auto trans to write debug messages

#line 197

#line 197

#line 197

#line 197
#
#line 197
# Allow the process to modify the directory.
#line 197
#
#line 197
allow amanda_recover_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 197

#line 197
#
#line 197
# Allow the process to create the file.
#line 197
#
#line 197

#line 197

#line 197

#line 197

#line 197

#line 197
allow amanda_recover_t amanda_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197
allow amanda_recover_t amanda_tmp_t:lnk_file { create read getattr setattr link unlink rename };
#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197
allow amanda_recover_t amanda_tmp_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197
allow amanda_recover_t amanda_tmp_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197
allow amanda_recover_t amanda_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197

#line 197
type_transition amanda_recover_t tmp_t:dir amanda_tmp_t;
#line 197
type_transition amanda_recover_t tmp_t:{ file lnk_file sock_file fifo_file } amanda_tmp_t;
#line 197

#line 197



# amanda recover process permissions
####################################


#line 203
allow amanda_recover_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 203
allow amanda_recover_t lib_t:lnk_file { read getattr lock ioctl };
#line 203
allow amanda_recover_t ld_so_t:file { read getattr lock execute ioctl };
#line 203
#allow amanda_recover_t ld_so_t:file execute_no_trans;
#line 203
allow amanda_recover_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 203
allow amanda_recover_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 203
allow amanda_recover_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 203
allow amanda_recover_t texrel_shlib_t:file execmod;
#line 203
allow amanda_recover_t ld_so_cache_t:file { read getattr lock ioctl };
#line 203
allow amanda_recover_t device_t:dir search;
#line 203
allow amanda_recover_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 203

allow amanda_recover_t self:process { fork sigkill sigstop sigchld signal };
allow amanda_recover_t self:capability { fowner fsetid kill setgid setuid chown dac_override net_bind_service };

#line 206
allow amanda_recover_t shell_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 206

allow amanda_recover_t privfd:fd use;


# amrecover network and process communication
#############################################


#line 213

#line 213

#line 213

#line 213

#line 213

#line 213
#
#line 213
# Allow the domain to create and use tcp sockets.
#line 213
# Other kinds of sockets must be separately authorized for use.
#line 213
allow amanda_recover_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 213

#line 213
allow amanda_recover_t unlabeled_t:association { sendto recvfrom };
#line 213

#line 213
#
#line 213
# Allow the domain to send or receive using any network interface.
#line 213
# netif_type is a type attribute for all network interface types.
#line 213
#
#line 213
allow amanda_recover_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 213
#
#line 213
# Allow the domain to send to or receive from any node.
#line 213
# node_type is a type attribute for all node types.
#line 213
#
#line 213
allow amanda_recover_t node_type:node { tcp_send rawip_send };
#line 213
allow amanda_recover_t node_type:node { tcp_recv rawip_recv };
#line 213

#line 213
#
#line 213
# Allow the domain to send to or receive from any port.
#line 213
# port_type is a type attribute for all port types.
#line 213
#
#line 213

#line 213
allow amanda_recover_t port_type:tcp_socket { send_msg recv_msg };
#line 213

#line 213

#line 213
# XXX Allow binding to any node type.  Remove once
#line 213
# individual rules have been added to all domains that 
#line 213
# bind sockets. 
#line 213
allow amanda_recover_t node_type:tcp_socket node_bind;
#line 213
#
#line 213
# Allow access to network files including /etc/resolv.conf
#line 213
#
#line 213
allow amanda_recover_t net_conf_t:file { read getattr lock ioctl };
#line 213

#line 213
allow amanda_recover_t self:tcp_socket { listen accept };
#line 213

#line 213

#line 213

#line 213
#
#line 213
# Allow the domain to create and use tcp sockets.
#line 213
# Other kinds of sockets must be separately authorized for use.
#line 213
allow amanda_recover_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 213

#line 213
allow amanda_recover_t unlabeled_t:association { sendto recvfrom };
#line 213

#line 213
#
#line 213
# Allow the domain to send or receive using any network interface.
#line 213
# netif_type is a type attribute for all network interface types.
#line 213
#
#line 213
allow amanda_recover_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 213
#
#line 213
# Allow the domain to send to or receive from any node.
#line 213
# node_type is a type attribute for all node types.
#line 213
#
#line 213
allow amanda_recover_t node_type:node { tcp_send rawip_send };
#line 213
allow amanda_recover_t node_type:node { tcp_recv rawip_recv };
#line 213

#line 213
#
#line 213
# Allow the domain to send to or receive from any port.
#line 213
# port_type is a type attribute for all port types.
#line 213
#
#line 213

#line 213
allow amanda_recover_t port_type:tcp_socket { send_msg recv_msg };
#line 213

#line 213

#line 213
# XXX Allow binding to any node type.  Remove once
#line 213
# individual rules have been added to all domains that 
#line 213
# bind sockets. 
#line 213
allow amanda_recover_t node_type:tcp_socket node_bind;
#line 213
#
#line 213
# Allow access to network files including /etc/resolv.conf
#line 213
#
#line 213
allow amanda_recover_t net_conf_t:file { read getattr lock ioctl };
#line 213

#line 213
allow amanda_recover_t self:tcp_socket { connect };
#line 213

#line 213

#line 213

#line 213

#line 213

#line 213
#
#line 213
# Allow the domain to create and use udp sockets.
#line 213
# Other kinds of sockets must be separately authorized for use.
#line 213
allow amanda_recover_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 213

#line 213
allow amanda_recover_t unlabeled_t:association { sendto recvfrom };
#line 213

#line 213
#
#line 213
# Allow the domain to send or receive using any network interface.
#line 213
# netif_type is a type attribute for all network interface types.
#line 213
#
#line 213
allow amanda_recover_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 213
#
#line 213
# Allow the domain to send to or receive from any node.
#line 213
# node_type is a type attribute for all node types.
#line 213
#
#line 213
allow amanda_recover_t node_type:node { udp_send rawip_send };
#line 213
allow amanda_recover_t node_type:node { udp_recv rawip_recv };
#line 213

#line 213
#
#line 213
# Allow the domain to send to or receive from any port.
#line 213
# port_type is a type attribute for all port types.
#line 213
#
#line 213

#line 213
allow amanda_recover_t port_type:udp_socket { send_msg recv_msg };
#line 213

#line 213

#line 213
# XXX Allow binding to any node type.  Remove once
#line 213
# individual rules have been added to all domains that 
#line 213
# bind sockets. 
#line 213
allow amanda_recover_t node_type:udp_socket node_bind;
#line 213
#
#line 213
# Allow access to network files including /etc/resolv.conf
#line 213
#
#line 213
allow amanda_recover_t net_conf_t:file { read getattr lock ioctl };
#line 213

#line 213
allow amanda_recover_t self:udp_socket { connect };
#line 213

#line 213

#line 213

#line 213

#line 213
;
allow amanda_recover_t amanda_port_t:tcp_socket name_connect;

#line 215

#line 215
if (allow_ypbind) {
#line 215

#line 215

#line 215

#line 215

#line 215

#line 215

#line 215

#line 215
#
#line 215
# Allow the domain to create and use tcp sockets.
#line 215
# Other kinds of sockets must be separately authorized for use.
#line 215
allow amanda_recover_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 215

#line 215
allow amanda_recover_t unlabeled_t:association { sendto recvfrom };
#line 215

#line 215
#
#line 215
# Allow the domain to send or receive using any network interface.
#line 215
# netif_type is a type attribute for all network interface types.
#line 215
#
#line 215
allow amanda_recover_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 215
#
#line 215
# Allow the domain to send to or receive from any node.
#line 215
# node_type is a type attribute for all node types.
#line 215
#
#line 215
allow amanda_recover_t node_type:node { tcp_send rawip_send };
#line 215
allow amanda_recover_t node_type:node { tcp_recv rawip_recv };
#line 215

#line 215
#
#line 215
# Allow the domain to send to or receive from any port.
#line 215
# port_type is a type attribute for all port types.
#line 215
#
#line 215

#line 215
allow amanda_recover_t port_type:tcp_socket { send_msg recv_msg };
#line 215

#line 215

#line 215
# XXX Allow binding to any node type.  Remove once
#line 215
# individual rules have been added to all domains that 
#line 215
# bind sockets. 
#line 215
allow amanda_recover_t node_type:tcp_socket node_bind;
#line 215
#
#line 215
# Allow access to network files including /etc/resolv.conf
#line 215
#
#line 215
allow amanda_recover_t net_conf_t:file { read getattr lock ioctl };
#line 215

#line 215
allow amanda_recover_t self:tcp_socket { listen accept };
#line 215

#line 215

#line 215

#line 215
#
#line 215
# Allow the domain to create and use tcp sockets.
#line 215
# Other kinds of sockets must be separately authorized for use.
#line 215
allow amanda_recover_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 215

#line 215
allow amanda_recover_t unlabeled_t:association { sendto recvfrom };
#line 215

#line 215
#
#line 215
# Allow the domain to send or receive using any network interface.
#line 215
# netif_type is a type attribute for all network interface types.
#line 215
#
#line 215
allow amanda_recover_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 215
#
#line 215
# Allow the domain to send to or receive from any node.
#line 215
# node_type is a type attribute for all node types.
#line 215
#
#line 215
allow amanda_recover_t node_type:node { tcp_send rawip_send };
#line 215
allow amanda_recover_t node_type:node { tcp_recv rawip_recv };
#line 215

#line 215
#
#line 215
# Allow the domain to send to or receive from any port.
#line 215
# port_type is a type attribute for all port types.
#line 215
#
#line 215

#line 215
allow amanda_recover_t port_type:tcp_socket { send_msg recv_msg };
#line 215

#line 215

#line 215
# XXX Allow binding to any node type.  Remove once
#line 215
# individual rules have been added to all domains that 
#line 215
# bind sockets. 
#line 215
allow amanda_recover_t node_type:tcp_socket node_bind;
#line 215
#
#line 215
# Allow access to network files including /etc/resolv.conf
#line 215
#
#line 215
allow amanda_recover_t net_conf_t:file { read getattr lock ioctl };
#line 215

#line 215
allow amanda_recover_t self:tcp_socket { connect };
#line 215

#line 215

#line 215

#line 215

#line 215

#line 215
#
#line 215
# Allow the domain to create and use udp sockets.
#line 215
# Other kinds of sockets must be separately authorized for use.
#line 215
allow amanda_recover_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 215

#line 215
allow amanda_recover_t unlabeled_t:association { sendto recvfrom };
#line 215

#line 215
#
#line 215
# Allow the domain to send or receive using any network interface.
#line 215
# netif_type is a type attribute for all network interface types.
#line 215
#
#line 215
allow amanda_recover_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 215
#
#line 215
# Allow the domain to send to or receive from any node.
#line 215
# node_type is a type attribute for all node types.
#line 215
#
#line 215
allow amanda_recover_t node_type:node { udp_send rawip_send };
#line 215
allow amanda_recover_t node_type:node { udp_recv rawip_recv };
#line 215

#line 215
#
#line 215
# Allow the domain to send to or receive from any port.
#line 215
# port_type is a type attribute for all port types.
#line 215
#
#line 215

#line 215
allow amanda_recover_t port_type:udp_socket { send_msg recv_msg };
#line 215

#line 215

#line 215
# XXX Allow binding to any node type.  Remove once
#line 215
# individual rules have been added to all domains that 
#line 215
# bind sockets. 
#line 215
allow amanda_recover_t node_type:udp_socket node_bind;
#line 215
#
#line 215
# Allow access to network files including /etc/resolv.conf
#line 215
#
#line 215
allow amanda_recover_t net_conf_t:file { read getattr lock ioctl };
#line 215

#line 215
allow amanda_recover_t self:udp_socket { connect };
#line 215

#line 215

#line 215

#line 215

#line 215

#line 215

#line 215
allow amanda_recover_t var_yp_t:dir { read getattr lock search ioctl };
#line 215
allow amanda_recover_t var_yp_t:file { read getattr lock ioctl };
#line 215
allow amanda_recover_t var_yp_t:lnk_file { getattr read };
#line 215

#line 215
allow amanda_recover_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 215
allow amanda_recover_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 215
dontaudit amanda_recover_t self:capability net_bind_service;
#line 215
dontaudit amanda_recover_t reserved_port_type:tcp_socket name_connect;
#line 215
dontaudit amanda_recover_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 215

#line 215
} else {
#line 215
dontaudit amanda_recover_t var_yp_t:dir search;
#line 215
}
#line 215
 ;

#line 216
allow amanda_recover_t etc_t:lnk_file read;
#line 216
allow amanda_recover_t lib_t:file { read getattr lock ioctl };
#line 216

#line 216
allow amanda_recover_t locale_t:dir { read getattr lock search ioctl };
#line 216
allow amanda_recover_t locale_t:file { read getattr lock ioctl };
#line 216
allow amanda_recover_t locale_t:lnk_file { getattr read };
#line 216

#line 216
;

allow amanda_recover_t self:fifo_file { getattr ioctl read write };
allow amanda_recover_t self:unix_stream_socket { connect create read write };
allow amanda_recover_t var_log_t:dir search;

#line 221
allow amanda_recover_t amanda_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 221
allow amanda_recover_t amanda_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 221
allow amanda_recover_t amanda_log_t:lnk_file { create read getattr setattr link unlink rename };
#line 221


# amrecover file permissions
############################

# access to etc_t and similar
allow amanda_recover_t etc_t:dir search;
allow amanda_recover_t etc_t:file { getattr read };
allow amanda_recover_t etc_runtime_t:file { getattr read };

# access to amanda_recover_dir_t
allow amanda_recover_t amanda_recover_dir_t:dir { add_name remove_name search write };
allow amanda_recover_t amanda_recover_dir_t:file { append create getattr setattr unlink };

# access to var_t and var_run_t
allow amanda_recover_t var_t:dir search;
allow amanda_recover_t var_run_t:dir search;

# access to proc_t
allow amanda_recover_t proc_t:dir search;
allow amanda_recover_t proc_t:file { getattr read };

# access to sysctl_kernel_t

#line 244
# Read system variables in /sys.
#line 244

#line 244
allow amanda_recover_t sysctl_t:dir search;
#line 244
allow amanda_recover_t sysctl_kernel_t:dir search;
#line 244
allow amanda_recover_t sysctl_kernel_t:file { getattr read };
#line 244

#line 244

#line 244


# access to dev_t and similar
allow amanda_recover_t device_t:dir search;
allow amanda_recover_t devtty_t:chr_file { read write };
allow amanda_recover_t null_device_t:chr_file { getattr write };

# access to bin_t
allow amanda_recover_t bin_t:file { execute execute_no_trans };

# access to sysadm_home_t and sysadm_home_dir_t to start amrecover 
# in the sysadm home directory
allow amanda_recover_t { sysadm_home_dir_t sysadm_home_t }:dir { search getattr };

# access to use sysadm_tty_device_t (/dev/tty?)
allow amanda_recover_t sysadm_tty_device_t:chr_file { getattr ioctl read write };

# access to amanda_tmp_t and tmp_t
allow amanda_recover_t amanda_tmp_t:dir { add_name remove_name search write };
allow amanda_recover_t amanda_tmp_t:file { append create getattr setattr unlink };
allow amanda_recover_t tmp_t:dir search;

#
#  Rules to allow amanda to be run as a service in xinetd
#
allow inetd_t amanda_port_t:{ tcp_socket udp_socket } name_bind;

#amanda needs to look at fs_type directories to decide whether it should backup
allow amanda_t { fs_type file_type }:dir {getattr read search };
allow amanda_t file_type:{ lnk_file file chr_file blk_file } {getattr read };
allow amanda_t device_type:{ blk_file chr_file } getattr;
allow amanda_t fixed_disk_device_t:blk_file read;

#line 276

#line 276

#line 276
#
#line 276
# Allow the process to transition to the new domain.
#line 276
#
#line 276
allow amanda_t fsadm_t:process transition;
#line 276

#line 276
#
#line 276
# Do not audit when glibc secure mode is enabled upon the transition.
#line 276
#
#line 276
dontaudit amanda_t fsadm_t:process noatsecure;
#line 276

#line 276
#
#line 276
# Do not audit when signal-related state is cleared upon the transition.
#line 276
#
#line 276
dontaudit amanda_t fsadm_t:process siginh;
#line 276

#line 276
#
#line 276
# Do not audit when resource limits are reset upon the transition.
#line 276
#
#line 276
dontaudit amanda_t fsadm_t:process rlimitinh;
#line 276

#line 276
#
#line 276
# Allow the process to execute the program.
#line 276
# 
#line 276
allow amanda_t fsadm_exec_t:file { read { getattr execute } };
#line 276

#line 276
#
#line 276
# Allow the process to reap the new domain.
#line 276
#
#line 276
allow fsadm_t amanda_t:process sigchld;
#line 276

#line 276
#
#line 276
# Allow the new domain to inherit and use file 
#line 276
# descriptions from the creating process and vice versa.
#line 276
#
#line 276
allow fsadm_t amanda_t:fd use;
#line 276
allow amanda_t fsadm_t:fd use;
#line 276

#line 276
#
#line 276
# Allow the new domain to write back to the old domain via a pipe.
#line 276
#
#line 276
allow fsadm_t amanda_t:fifo_file { ioctl read getattr lock write append };
#line 276

#line 276
#
#line 276
# Allow the new domain to read and execute the program.
#line 276
#
#line 276
allow fsadm_t fsadm_exec_t:file { read getattr lock execute ioctl };
#line 276

#line 276
#
#line 276
# Allow the new domain to be entered via the program.
#line 276
#
#line 276
allow fsadm_t fsadm_exec_t:file entrypoint;
#line 276

#line 276
type_transition amanda_t fsadm_exec_t:process fsadm_t;
#line 276


allow amanda_t file_type:sock_file getattr;

#line 279

#line 279
type amanda_log_t, file_type, sysadmfile, logfile;
#line 279

#line 279

#line 279

#line 279

#line 279
#
#line 279
# Allow the process to modify the directory.
#line 279
#
#line 279
allow amanda_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 279

#line 279
#
#line 279
# Allow the process to create the file.
#line 279
#
#line 279

#line 279

#line 279

#line 279

#line 279

#line 279
allow amanda_t amanda_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279
type_transition amanda_t var_log_t:file amanda_log_t;
#line 279

#line 279

#line 279

#line 279
allow amanda_t amanda_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 279


dontaudit amanda_t proc_t:lnk_file read;
dontaudit amanda_t unlabeled_t:file getattr;
#amanda wants to check attributes on fifo_files
allow amanda_t file_type:fifo_file getattr;
#line 1 "domains/program/anaconda.te"
#DESC Anaconda - Red Hat Installation program
#
# Authors:  Dan Walsh <dwalsh@redhat.com>
#
#

#################################
#
# Rules for the anaconda_t domain.
#
# anaconda_t is the domain of the installation program
#
type anaconda_t, admin, etc_writer, fs_domain, privmem, auth_write, domain, privlog, privowner, privmodule, sysctl_kernel_writer;
role system_r types anaconda_t;

#line 15

#line 15
typeattribute anaconda_t unrestricted;
#line 15
typeattribute anaconda_t privuser;
#line 15

#line 15
# Mount/unmount any filesystem. 
#line 15
allow anaconda_t fs_type:filesystem *;
#line 15

#line 15
# Mount/unmount any filesystem with the context= option. 
#line 15
allow anaconda_t file_type:filesystem *;
#line 15

#line 15
# Create/access any file in a labeled filesystem;
#line 15
allow anaconda_t file_type:{ file chr_file } ~execmod;
#line 15
allow anaconda_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 15
allow anaconda_t sysctl_t:{ dir file } *;
#line 15
allow anaconda_t device_type:{ chr_file blk_file } *;
#line 15
allow anaconda_t mtrr_device_t:file *;
#line 15

#line 15
# Create/access other files.  fs_type is to pick up various
#line 15
# pseudo filesystem types that are applied to both the filesystem
#line 15
# and its files.
#line 15
allow anaconda_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 15
allow anaconda_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
allow anaconda_t proc_fs:{ dir file } *;
#line 15

#line 15
# For /proc/pid
#line 15

#line 15
allow anaconda_t domain:dir { read getattr lock search ioctl };
#line 15
allow anaconda_t domain:file { read getattr lock ioctl };
#line 15
allow anaconda_t domain:lnk_file { getattr read };
#line 15

#line 15
# Write access is for setting attributes under /proc/self/attr.
#line 15
allow anaconda_t self:file { ioctl read getattr lock write append };
#line 15

#line 15
# Read and write sysctls.
#line 15

#line 15
allow anaconda_t sysctl_type:dir { read getattr lock search ioctl };
#line 15
allow anaconda_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 15

#line 15

#line 15
# Access the network.
#line 15
allow anaconda_t node_type:node *;
#line 15
allow anaconda_t netif_type:netif *;
#line 15
allow anaconda_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 15
allow anaconda_t port_type:tcp_socket name_connect;
#line 15

#line 15
# Bind to any network address.
#line 15
allow anaconda_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 15
allow anaconda_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 15
allow anaconda_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 15

#line 15
# Use/sendto/connectto sockets created by any domain.
#line 15
allow anaconda_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 15

#line 15
# Use descriptors and pipes created by any domain.
#line 15
allow anaconda_t domain:fd use;
#line 15
allow anaconda_t domain:fifo_file { ioctl read getattr lock write append };
#line 15

#line 15
# Act upon any other process.
#line 15
allow anaconda_t domain:process ~{ transition dyntransition execmem };
#line 15
# Transition to myself, to make get_ordered_context_list happy.
#line 15
allow anaconda_t self:process transition;
#line 15

#line 15
if (allow_execmem) {
#line 15
# Allow making anonymous memory executable, e.g. 
#line 15
# for runtime-code generation or executable stack.
#line 15
allow anaconda_t self:process execmem;
#line 15
}
#line 15

#line 15
if (allow_execmem && allow_execstack) {
#line 15
# Allow making the stack executable via mprotect.
#line 15
allow anaconda_t self:process execstack;
#line 15
}
#line 15

#line 15
if (allow_execmod) {
#line 15
# Allow text relocations on system shared libraries, e.g. libGL.
#line 15

#line 15
allow anaconda_t file_type:file execmod;
#line 15

#line 15
}
#line 15

#line 15
# Create/access any System V IPC objects.
#line 15
allow anaconda_t domain:{ sem msgq shm } *;
#line 15
allow anaconda_t domain:msg  { send receive };
#line 15

#line 15
# Access the security API.
#line 15
if (!secure_mode_policyload) {
#line 15
allow anaconda_t security_t:security *;
#line 15
auditallow anaconda_t security_t:security { load_policy setenforce setbool };
#line 15
}
#line 15
# Perform certain system operations that lacked individual capabilities.
#line 15
allow anaconda_t kernel_t:system *;
#line 15

#line 15
# Use any Linux capability.
#line 15
allow anaconda_t self:capability *;
#line 15

#line 15
# Set user information and skip authentication.
#line 15
allow anaconda_t self:passwd *;
#line 15

#line 15
# Communicate via dbusd.
#line 15
allow anaconda_t self:dbus *;
#line 15

#line 15
allow anaconda_t system_dbusd_t:dbus *;
#line 15

#line 15

#line 15
# Get info via nscd.
#line 15
allow anaconda_t self:nscd *;
#line 15

#line 15
allow anaconda_t nscd_t:nscd *;
#line 15

#line 15

#line 15


role system_r types ldconfig_t;

#line 18

#line 18

#line 18
#
#line 18
# Allow the process to transition to the new domain.
#line 18
#
#line 18
allow anaconda_t ldconfig_t:process transition;
#line 18

#line 18
#
#line 18
# Do not audit when glibc secure mode is enabled upon the transition.
#line 18
#
#line 18
dontaudit anaconda_t ldconfig_t:process noatsecure;
#line 18

#line 18
#
#line 18
# Do not audit when signal-related state is cleared upon the transition.
#line 18
#
#line 18
dontaudit anaconda_t ldconfig_t:process siginh;
#line 18

#line 18
#
#line 18
# Do not audit when resource limits are reset upon the transition.
#line 18
#
#line 18
dontaudit anaconda_t ldconfig_t:process rlimitinh;
#line 18

#line 18
#
#line 18
# Allow the process to execute the program.
#line 18
# 
#line 18
allow anaconda_t ldconfig_exec_t:file { read { getattr execute } };
#line 18

#line 18
#
#line 18
# Allow the process to reap the new domain.
#line 18
#
#line 18
allow ldconfig_t anaconda_t:process sigchld;
#line 18

#line 18
#
#line 18
# Allow the new domain to inherit and use file 
#line 18
# descriptions from the creating process and vice versa.
#line 18
#
#line 18
allow ldconfig_t anaconda_t:fd use;
#line 18
allow anaconda_t ldconfig_t:fd use;
#line 18

#line 18
#
#line 18
# Allow the new domain to write back to the old domain via a pipe.
#line 18
#
#line 18
allow ldconfig_t anaconda_t:fifo_file { ioctl read getattr lock write append };
#line 18

#line 18
#
#line 18
# Allow the new domain to read and execute the program.
#line 18
#
#line 18
allow ldconfig_t ldconfig_exec_t:file { read getattr lock execute ioctl };
#line 18

#line 18
#
#line 18
# Allow the new domain to be entered via the program.
#line 18
#
#line 18
allow ldconfig_t ldconfig_exec_t:file entrypoint;
#line 18

#line 18
type_transition anaconda_t ldconfig_exec_t:process ldconfig_t;
#line 18


# Run other rc scripts in the anaconda_t domain.

#line 21

#line 21

#line 21
#
#line 21
# Allow the process to transition to the new domain.
#line 21
#
#line 21
allow anaconda_t initrc_t:process transition;
#line 21

#line 21
#
#line 21
# Do not audit when glibc secure mode is enabled upon the transition.
#line 21
#
#line 21
dontaudit anaconda_t initrc_t:process noatsecure;
#line 21

#line 21
#
#line 21
# Do not audit when signal-related state is cleared upon the transition.
#line 21
#
#line 21
dontaudit anaconda_t initrc_t:process siginh;
#line 21

#line 21
#
#line 21
# Do not audit when resource limits are reset upon the transition.
#line 21
#
#line 21
dontaudit anaconda_t initrc_t:process rlimitinh;
#line 21

#line 21
#
#line 21
# Allow the process to execute the program.
#line 21
# 
#line 21
allow anaconda_t initrc_exec_t:file { read { getattr execute } };
#line 21

#line 21
#
#line 21
# Allow the process to reap the new domain.
#line 21
#
#line 21
allow initrc_t anaconda_t:process sigchld;
#line 21

#line 21
#
#line 21
# Allow the new domain to inherit and use file 
#line 21
# descriptions from the creating process and vice versa.
#line 21
#
#line 21
allow initrc_t anaconda_t:fd use;
#line 21
allow anaconda_t initrc_t:fd use;
#line 21

#line 21
#
#line 21
# Allow the new domain to write back to the old domain via a pipe.
#line 21
#
#line 21
allow initrc_t anaconda_t:fifo_file { ioctl read getattr lock write append };
#line 21

#line 21
#
#line 21
# Allow the new domain to read and execute the program.
#line 21
#
#line 21
allow initrc_t initrc_exec_t:file { read getattr lock execute ioctl };
#line 21

#line 21
#
#line 21
# Allow the new domain to be entered via the program.
#line 21
#
#line 21
allow initrc_t initrc_exec_t:file entrypoint;
#line 21

#line 21
type_transition anaconda_t initrc_exec_t:process initrc_t;
#line 21


#line 25


#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
#
#line 29
# Allow the process to modify the directory.
#line 29
#
#line 29
allow anaconda_t boot_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 29

#line 29
#
#line 29
# Allow the process to create the file.
#line 29
#
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
allow anaconda_t boot_runtime_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
type_transition anaconda_t boot_t:file boot_runtime_t;
#line 29

#line 29

#line 29


#line 34

#line 34
# Access /var/lib/rpm.
#line 34

#line 34

#line 34

#line 34
#
#line 34
# Allow the process to transition to the new domain.
#line 34
#
#line 34
allow anaconda_t rpm_t:process transition;
#line 34

#line 34
#
#line 34
# Do not audit when glibc secure mode is enabled upon the transition.
#line 34
#
#line 34
dontaudit anaconda_t rpm_t:process noatsecure;
#line 34

#line 34
#
#line 34
# Do not audit when signal-related state is cleared upon the transition.
#line 34
#
#line 34
dontaudit anaconda_t rpm_t:process siginh;
#line 34

#line 34
#
#line 34
# Do not audit when resource limits are reset upon the transition.
#line 34
#
#line 34
dontaudit anaconda_t rpm_t:process rlimitinh;
#line 34

#line 34
#
#line 34
# Allow the process to execute the program.
#line 34
# 
#line 34
allow anaconda_t rpm_exec_t:file { read { getattr execute } };
#line 34

#line 34
#
#line 34
# Allow the process to reap the new domain.
#line 34
#
#line 34
allow rpm_t anaconda_t:process sigchld;
#line 34

#line 34
#
#line 34
# Allow the new domain to inherit and use file 
#line 34
# descriptions from the creating process and vice versa.
#line 34
#
#line 34
allow rpm_t anaconda_t:fd use;
#line 34
allow anaconda_t rpm_t:fd use;
#line 34

#line 34
#
#line 34
# Allow the new domain to write back to the old domain via a pipe.
#line 34
#
#line 34
allow rpm_t anaconda_t:fifo_file { ioctl read getattr lock write append };
#line 34

#line 34
#
#line 34
# Allow the new domain to read and execute the program.
#line 34
#
#line 34
allow rpm_t rpm_exec_t:file { read getattr lock execute ioctl };
#line 34

#line 34
#
#line 34
# Allow the new domain to be entered via the program.
#line 34
#
#line 34
allow rpm_t rpm_exec_t:file entrypoint;
#line 34

#line 34
type_transition anaconda_t rpm_exec_t:process rpm_t;
#line 34

#line 34



#line 36

#line 36

#line 36

#line 36
#
#line 36
# Allow the process to modify the directory.
#line 36
#
#line 36
allow anaconda_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 36

#line 36
#
#line 36
# Allow the process to create the file.
#line 36
#
#line 36

#line 36

#line 36

#line 36

#line 36

#line 36
allow anaconda_t var_log_ksyms_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36
type_transition anaconda_t var_log_t:file var_log_ksyms_t;
#line 36

#line 36


#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the process to transition to the new domain.
#line 40
#
#line 40
allow anaconda_t udev_t:process transition;
#line 40

#line 40
#
#line 40
# Do not audit when glibc secure mode is enabled upon the transition.
#line 40
#
#line 40
dontaudit anaconda_t udev_t:process noatsecure;
#line 40

#line 40
#
#line 40
# Do not audit when signal-related state is cleared upon the transition.
#line 40
#
#line 40
dontaudit anaconda_t udev_t:process siginh;
#line 40

#line 40
#
#line 40
# Do not audit when resource limits are reset upon the transition.
#line 40
#
#line 40
dontaudit anaconda_t udev_t:process rlimitinh;
#line 40

#line 40
#
#line 40
# Allow the process to execute the program.
#line 40
# 
#line 40
allow anaconda_t udev_exec_t:file { read { getattr execute } };
#line 40

#line 40
#
#line 40
# Allow the process to reap the new domain.
#line 40
#
#line 40
allow udev_t anaconda_t:process sigchld;
#line 40

#line 40
#
#line 40
# Allow the new domain to inherit and use file 
#line 40
# descriptions from the creating process and vice versa.
#line 40
#
#line 40
allow udev_t anaconda_t:fd use;
#line 40
allow anaconda_t udev_t:fd use;
#line 40

#line 40
#
#line 40
# Allow the new domain to write back to the old domain via a pipe.
#line 40
#
#line 40
allow udev_t anaconda_t:fifo_file { ioctl read getattr lock write append };
#line 40

#line 40
#
#line 40
# Allow the new domain to read and execute the program.
#line 40
#
#line 40
allow udev_t udev_exec_t:file { read getattr lock execute ioctl };
#line 40

#line 40
#
#line 40
# Allow the new domain to be entered via the program.
#line 40
#
#line 40
allow udev_t udev_exec_t:file entrypoint;
#line 40

#line 40
type_transition anaconda_t udev_exec_t:process udev_t;
#line 40

#line 40


#line 45

#line 48

#line 48

#line 48

#line 48

#line 48
#
#line 48
# Allow the process to transition to the new domain.
#line 48
#
#line 48
allow anaconda_t  sysadm_passwd_t:process transition;
#line 48

#line 48
#
#line 48
# Do not audit when glibc secure mode is enabled upon the transition.
#line 48
#
#line 48
dontaudit anaconda_t  sysadm_passwd_t:process noatsecure;
#line 48

#line 48
#
#line 48
# Do not audit when signal-related state is cleared upon the transition.
#line 48
#
#line 48
dontaudit anaconda_t  sysadm_passwd_t:process siginh;
#line 48

#line 48
#
#line 48
# Do not audit when resource limits are reset upon the transition.
#line 48
#
#line 48
dontaudit anaconda_t  sysadm_passwd_t:process rlimitinh;
#line 48

#line 48
#
#line 48
# Allow the process to execute the program.
#line 48
# 
#line 48
allow anaconda_t  admin_passwd_exec_t:file { read { getattr execute } };
#line 48

#line 48
#
#line 48
# Allow the process to reap the new domain.
#line 48
#
#line 48
allow sysadm_passwd_t anaconda_t :process sigchld;
#line 48

#line 48
#
#line 48
# Allow the new domain to inherit and use file 
#line 48
# descriptions from the creating process and vice versa.
#line 48
#
#line 48
allow sysadm_passwd_t anaconda_t :fd use;
#line 48
allow anaconda_t  sysadm_passwd_t:fd use;
#line 48

#line 48
#
#line 48
# Allow the new domain to write back to the old domain via a pipe.
#line 48
#
#line 48
allow sysadm_passwd_t anaconda_t :fifo_file { ioctl read getattr lock write append };
#line 48

#line 48
#
#line 48
# Allow the new domain to read and execute the program.
#line 48
#
#line 48
allow sysadm_passwd_t admin_passwd_exec_t:file { read getattr lock execute ioctl };
#line 48

#line 48
#
#line 48
# Allow the new domain to be entered via the program.
#line 48
#
#line 48
allow sysadm_passwd_t admin_passwd_exec_t:file entrypoint;
#line 48

#line 48
type_transition anaconda_t  admin_passwd_exec_t:process sysadm_passwd_t;
#line 48

#line 48

#line 1 "domains/program/apache.te"
#DESC Apache - Web server
#
# X-Debian-Packages: apache2-common apache
#
###############################################################################
#
# Policy file for running the Apache web server
#
# NOTES: 
#  This policy will work with SUEXEC enabled as part of the Apache
#  configuration. However, the user CGI scripts will run under the
#  system_u:system_r:httpd_$1_script_t domain where $1 is the domain of the
#  of the creating user.
#
#  The user CGI scripts must be labeled with the httpd_$1_script_exec_t
#  type, and the directory containing the scripts should also be labeled
#  with these types. This policy allows user_r role to perform that 
#  relabeling. If it is desired that only sysadm_r should be able to relabel
#  the user CGI scripts, then relabel rule for user_r should be removed.
#
###############################################################################

#line 27


bool httpd_unified false;

# Allow httpd to use built in scripting (usually php)
bool httpd_builtin_scripting false;

# Allow httpd cgi support
bool httpd_enable_cgi false;

# Allow httpd to read home directories
bool httpd_enable_homedirs false;

# Run SSI execs in system CGI script domain.
bool httpd_ssi_exec false;

# Allow http daemon to communicate with the TTY
bool httpd_tty_comm false;

# Allow http daemon to tcp connect 
bool httpd_can_network_connect false;

#########################################################
# Apache types
#########################################################
# httpd_config_t is the type given to the configuration
# files for apache /etc/httpd/conf
#
type httpd_config_t, file_type, sysadmfile;

# httpd_modules_t is the type given to module files (libraries) 
# that come with Apache /etc/httpd/modules and /usr/lib/apache
#
type httpd_modules_t, file_type, sysadmfile;

# httpd_cache_t is the type given to the /var/cache/httpd
# directory and the files under that directory
#
type httpd_cache_t, file_type, sysadmfile;

# httpd_exec_t is the type give to the httpd executable.
#

#line 69

#line 69

#line 69

#line 69
type httpd_t, domain, privlog, daemon , privmail, auth_chkpwd, nscd_client_domain, transitionbool;
#line 69
type httpd_exec_t, file_type, sysadmfile, exec_type;
#line 69
dontaudit httpd_t self:capability sys_tty_config;
#line 69

#line 69
role system_r types httpd_t;
#line 69

#line 69
# Inherit and use descriptors from init.
#line 69
allow httpd_t init_t:fd use;
#line 69
allow httpd_t init_t:process sigchld;
#line 69
allow httpd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 69

#line 69

#line 69
allow httpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 69
allow httpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 69
allow httpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 69
#allow httpd_t ld_so_t:file execute_no_trans;
#line 69
allow httpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 69
allow httpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 69
allow httpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 69
allow httpd_t texrel_shlib_t:file execmod;
#line 69
allow httpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 69
allow httpd_t device_t:dir search;
#line 69
allow httpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 69

#line 69

#line 69
allow httpd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 69
allow httpd_t { self proc_t }:lnk_file { getattr read };
#line 69

#line 69
allow httpd_t device_t:dir { read getattr lock search ioctl };
#line 69

#line 69
allow httpd_t udev_tdb_t:file { read getattr lock ioctl };
#line 69
allow httpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 69
dontaudit httpd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 69
dontaudit httpd_t unpriv_userdomain:fd use;
#line 69

#line 69

#line 69
allow httpd_t sysfs_t:dir { read getattr lock search ioctl };
#line 69
allow httpd_t sysfs_t:file { read getattr lock ioctl };
#line 69
allow httpd_t sysfs_t:lnk_file { getattr read };
#line 69
 
#line 69

#line 69
allow httpd_t autofs_t:dir { search getattr };
#line 69

#line 69
dontaudit httpd_t { tty_device_t devpts_t }:chr_file { read write };
#line 69
dontaudit httpd_t root_t:file { getattr read };
#line 69
 
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
# Read system variables in /sys.
#line 69

#line 69
allow httpd_t sysctl_t:dir search;
#line 69
allow httpd_t sysctl_kernel_t:dir search;
#line 69
allow httpd_t sysctl_kernel_t:file { getattr read };
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
#
#line 69
# Allows user to define a tunable to disable domain transition
#line 69
#
#line 69

#line 69
bool httpd_disable_trans false;
#line 69
if (httpd_disable_trans) {
#line 69

#line 69
allow initrc_t httpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 69

#line 69

#line 69
allow sysadm_t httpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 69

#line 69
} else {
#line 69
 
#line 69

#line 69

#line 69
#
#line 69
# Allow the process to transition to the new domain.
#line 69
#
#line 69
allow initrc_t httpd_t:process transition;
#line 69

#line 69
#
#line 69
# Do not audit when glibc secure mode is enabled upon the transition.
#line 69
#
#line 69
dontaudit initrc_t httpd_t:process noatsecure;
#line 69

#line 69
#
#line 69
# Do not audit when signal-related state is cleared upon the transition.
#line 69
#
#line 69
dontaudit initrc_t httpd_t:process siginh;
#line 69

#line 69
#
#line 69
# Do not audit when resource limits are reset upon the transition.
#line 69
#
#line 69
dontaudit initrc_t httpd_t:process rlimitinh;
#line 69

#line 69
#
#line 69
# Allow the process to execute the program.
#line 69
# 
#line 69
allow initrc_t httpd_exec_t:file { read { getattr execute } };
#line 69

#line 69
#
#line 69
# Allow the process to reap the new domain.
#line 69
#
#line 69
allow httpd_t initrc_t:process sigchld;
#line 69

#line 69
#
#line 69
# Allow the new domain to inherit and use file 
#line 69
# descriptions from the creating process and vice versa.
#line 69
#
#line 69
allow httpd_t initrc_t:fd use;
#line 69
allow initrc_t httpd_t:fd use;
#line 69

#line 69
#
#line 69
# Allow the new domain to write back to the old domain via a pipe.
#line 69
#
#line 69
allow httpd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 69

#line 69
#
#line 69
# Allow the new domain to read and execute the program.
#line 69
#
#line 69
allow httpd_t httpd_exec_t:file { read getattr lock execute ioctl };
#line 69

#line 69
#
#line 69
# Allow the new domain to be entered via the program.
#line 69
#
#line 69
allow httpd_t httpd_exec_t:file entrypoint;
#line 69

#line 69
type_transition initrc_t httpd_exec_t:process httpd_t;
#line 69

#line 69

#line 69
allow initrc_t httpd_t:process { noatsecure siginh rlimitinh };
#line 69

#line 69
}
#line 69
 
#line 69
allow httpd_t privfd:fd use;
#line 69

#line 69
allow httpd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 69

#line 69

#line 69
# Create pid file.
#line 69
allow httpd_t var_t:dir { getattr search };
#line 69

#line 69
type httpd_var_run_t, file_type, sysadmfile, pidfile;
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
#
#line 69
# Allow the process to modify the directory.
#line 69
#
#line 69
allow httpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 69

#line 69
#
#line 69
# Allow the process to create the file.
#line 69
#
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
allow httpd_t httpd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
type_transition httpd_t var_run_t:file httpd_var_run_t;
#line 69

#line 69

#line 69

#line 69
allow httpd_t var_t:dir search;
#line 69
allow httpd_t httpd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 69

#line 69

#line 69
allow httpd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 69

#line 69
# for daemons that look at /root on startup
#line 69
dontaudit httpd_t sysadm_home_dir_t:dir search;
#line 69

#line 69
# for df
#line 69
allow httpd_t fs_type:filesystem getattr;
#line 69
allow httpd_t removable_t:filesystem getattr;
#line 69

#line 69

#line 69
allow httpd_t etc_t:lnk_file read;
#line 69
allow httpd_t lib_t:file { read getattr lock ioctl };
#line 69

#line 69
allow httpd_t locale_t:dir { read getattr lock search ioctl };
#line 69
allow httpd_t locale_t:file { read getattr lock ioctl };
#line 69
allow httpd_t locale_t:lnk_file { getattr read };
#line 69

#line 69

#line 69

#line 69
# for localization
#line 69
allow httpd_t lib_t:file { getattr read };
#line 69



#line 71

#line 71
type httpd_log_t, file_type, sysadmfile, logfile;
#line 71
allow httpd_t var_log_t:dir { read getattr lock search ioctl add_name write };
#line 71
allow httpd_t httpd_log_t:file  { create { ioctl read getattr lock append } };
#line 71
type_transition httpd_t var_log_t:file httpd_log_t;
#line 71

#line 71
allow httpd_t httpd_log_t:dir { setattr { read getattr lock search ioctl add_name write } };
#line 71

#can read /etc/httpd/logs
allow httpd_t httpd_log_t:lnk_file read;

# For /etc/init.d/apache2 reload

#line 76
#allow httpd_t httpd_t:tcp_socket { connectto recvfrom };
#line 76
#allow httpd_t httpd_t:tcp_socket { acceptfrom recvfrom };
#line 76
#allow httpd_t kernel_t:tcp_socket recvfrom;
#line 76
#allow httpd_t kernel_t:tcp_socket recvfrom;
#line 76



#line 78
#allow web_client_domain httpd_t:tcp_socket { connectto recvfrom };
#line 78
#allow httpd_t web_client_domain:tcp_socket { acceptfrom recvfrom };
#line 78
#allow httpd_t kernel_t:tcp_socket recvfrom;
#line 78
#allow web_client_domain kernel_t:tcp_socket recvfrom;
#line 78



#line 80
allow httpd_t httpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 80


#line 81

#line 81

#line 81

#line 81
#
#line 81
# Allow the process to modify the directory.
#line 81
#
#line 81
allow httpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 81

#line 81
#
#line 81
# Allow the process to create the file.
#line 81
#
#line 81

#line 81

#line 81

#line 81

#line 81

#line 81
allow httpd_t httpd_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81
type_transition httpd_t var_run_t:sock_file httpd_var_run_t;
#line 81

#line 81



#line 83
# Access other processes in the same domain.
#line 83
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 83
# These must be granted separately if desired.
#line 83
allow httpd_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 83

#line 83
# Access /proc/PID files for processes in the same domain.
#line 83
allow httpd_t self:dir { read getattr lock search ioctl };
#line 83
allow httpd_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 83

#line 83
# Access file descriptions, pipes, and sockets
#line 83
# created by processes in the same domain.
#line 83
allow httpd_t self:fd *;
#line 83
allow httpd_t self:fifo_file { ioctl read getattr lock write append };
#line 83
allow httpd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 83
allow httpd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 83

#line 83
# Allow the domain to communicate with other processes in the same domain.
#line 83
allow httpd_t self:unix_dgram_socket sendto;
#line 83
allow httpd_t self:unix_stream_socket connectto;
#line 83

#line 83
# Access System V IPC objects created by processes in the same domain.
#line 83
allow httpd_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 83
allow httpd_t self:msg  { send receive };
#line 83
allow httpd_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 83
allow httpd_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 83
allow httpd_t unpriv_userdomain:fd use;
#line 83
#
#line 83
# Every app is asking for ypbind so I am adding this here, 
#line 83
# eventually this should become can_nsswitch
#line 83
#
#line 83

#line 83

#line 83
if (allow_ypbind) {
#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83
#
#line 83
# Allow the domain to create and use tcp sockets.
#line 83
# Other kinds of sockets must be separately authorized for use.
#line 83
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 83

#line 83
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 83

#line 83
#
#line 83
# Allow the domain to send or receive using any network interface.
#line 83
# netif_type is a type attribute for all network interface types.
#line 83
#
#line 83
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 83
#
#line 83
# Allow the domain to send to or receive from any node.
#line 83
# node_type is a type attribute for all node types.
#line 83
#
#line 83
allow httpd_t node_type:node { tcp_send rawip_send };
#line 83
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 83

#line 83
#
#line 83
# Allow the domain to send to or receive from any port.
#line 83
# port_type is a type attribute for all port types.
#line 83
#
#line 83

#line 83
allow httpd_t port_type:tcp_socket { send_msg recv_msg };
#line 83

#line 83

#line 83
# XXX Allow binding to any node type.  Remove once
#line 83
# individual rules have been added to all domains that 
#line 83
# bind sockets. 
#line 83
allow httpd_t node_type:tcp_socket node_bind;
#line 83
#
#line 83
# Allow access to network files including /etc/resolv.conf
#line 83
#
#line 83
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 83

#line 83
allow httpd_t self:tcp_socket { listen accept };
#line 83

#line 83

#line 83

#line 83
#
#line 83
# Allow the domain to create and use tcp sockets.
#line 83
# Other kinds of sockets must be separately authorized for use.
#line 83
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 83

#line 83
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 83

#line 83
#
#line 83
# Allow the domain to send or receive using any network interface.
#line 83
# netif_type is a type attribute for all network interface types.
#line 83
#
#line 83
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 83
#
#line 83
# Allow the domain to send to or receive from any node.
#line 83
# node_type is a type attribute for all node types.
#line 83
#
#line 83
allow httpd_t node_type:node { tcp_send rawip_send };
#line 83
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 83

#line 83
#
#line 83
# Allow the domain to send to or receive from any port.
#line 83
# port_type is a type attribute for all port types.
#line 83
#
#line 83

#line 83
allow httpd_t port_type:tcp_socket { send_msg recv_msg };
#line 83

#line 83

#line 83
# XXX Allow binding to any node type.  Remove once
#line 83
# individual rules have been added to all domains that 
#line 83
# bind sockets. 
#line 83
allow httpd_t node_type:tcp_socket node_bind;
#line 83
#
#line 83
# Allow access to network files including /etc/resolv.conf
#line 83
#
#line 83
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 83

#line 83
allow httpd_t self:tcp_socket { connect };
#line 83

#line 83

#line 83

#line 83

#line 83

#line 83
#
#line 83
# Allow the domain to create and use udp sockets.
#line 83
# Other kinds of sockets must be separately authorized for use.
#line 83
allow httpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 83

#line 83
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 83

#line 83
#
#line 83
# Allow the domain to send or receive using any network interface.
#line 83
# netif_type is a type attribute for all network interface types.
#line 83
#
#line 83
allow httpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 83
#
#line 83
# Allow the domain to send to or receive from any node.
#line 83
# node_type is a type attribute for all node types.
#line 83
#
#line 83
allow httpd_t node_type:node { udp_send rawip_send };
#line 83
allow httpd_t node_type:node { udp_recv rawip_recv };
#line 83

#line 83
#
#line 83
# Allow the domain to send to or receive from any port.
#line 83
# port_type is a type attribute for all port types.
#line 83
#
#line 83

#line 83
allow httpd_t port_type:udp_socket { send_msg recv_msg };
#line 83

#line 83

#line 83
# XXX Allow binding to any node type.  Remove once
#line 83
# individual rules have been added to all domains that 
#line 83
# bind sockets. 
#line 83
allow httpd_t node_type:udp_socket node_bind;
#line 83
#
#line 83
# Allow access to network files including /etc/resolv.conf
#line 83
#
#line 83
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 83

#line 83
allow httpd_t self:udp_socket { connect };
#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83
allow httpd_t var_yp_t:dir { read getattr lock search ioctl };
#line 83
allow httpd_t var_yp_t:file { read getattr lock ioctl };
#line 83
allow httpd_t var_yp_t:lnk_file { getattr read };
#line 83

#line 83
allow httpd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 83
allow httpd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 83
dontaudit httpd_t self:capability net_bind_service;
#line 83
dontaudit httpd_t reserved_port_type:tcp_socket name_connect;
#line 83
dontaudit httpd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 83

#line 83
} else {
#line 83
dontaudit httpd_t var_yp_t:dir search;
#line 83
}
#line 83
 
#line 83
allow httpd_t autofs_t:dir { search getattr };
#line 83


allow httpd_t { random_device_t urandom_device_t }:chr_file { getattr ioctl read };


#line 87
# Read system variables in /sys.
#line 87

#line 87
allow httpd_t sysctl_t:dir search;
#line 87
allow httpd_t sysctl_kernel_t:dir search;
#line 87
allow httpd_t sysctl_kernel_t:file { getattr read };
#line 87

#line 87

#line 87


allow httpd_t crypt_device_t:chr_file { ioctl read getattr lock write append };

# for modules that want to access /etc/mtab and /proc/meminfo
allow httpd_t { proc_t etc_runtime_t }:file { getattr read };


#line 94
allow httpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 94
allow httpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 94
allow httpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 94
#allow httpd_t ld_so_t:file execute_no_trans;
#line 94
allow httpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 94
allow httpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 94
allow httpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 94
allow httpd_t texrel_shlib_t:file execmod;
#line 94
allow httpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 94
allow httpd_t device_t:dir search;
#line 94
allow httpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 94

allow httpd_t { usr_t lib_t }:file { getattr read ioctl };
allow httpd_t usr_t:lnk_file { getattr read };

# for apache2 memory mapped files

#line 99
type httpd_var_lib_t, file_type, sysadmfile;
#line 99

#line 99

#line 99

#line 99

#line 99
#
#line 99
# Allow the process to modify the directory.
#line 99
#
#line 99
allow httpd_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 99

#line 99
#
#line 99
# Allow the process to create the file.
#line 99
#
#line 99

#line 99

#line 99

#line 99

#line 99

#line 99
allow httpd_t httpd_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 99

#line 99

#line 99

#line 99

#line 99

#line 99

#line 99

#line 99

#line 99

#line 99
type_transition httpd_t var_lib_t:file httpd_var_lib_t;
#line 99

#line 99

#line 99
allow httpd_t httpd_var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 99


# for tomcat

#line 102
allow httpd_t var_lib_t:dir { read getattr lock search ioctl };
#line 102
allow httpd_t var_lib_t:file { read getattr lock ioctl };
#line 102
allow httpd_t var_lib_t:lnk_file { getattr read };
#line 102


# execute perl
allow httpd_t { bin_t sbin_t }:dir { read getattr lock search ioctl };

#line 106
allow httpd_t { bin_t sbin_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 106

allow httpd_t bin_t:lnk_file read;

########################################
# Set up networking
########################################


#line 113

#line 113

#line 113

#line 113
#
#line 113
# Allow the domain to create and use tcp sockets.
#line 113
# Other kinds of sockets must be separately authorized for use.
#line 113
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 113

#line 113
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 113

#line 113
#
#line 113
# Allow the domain to send or receive using any network interface.
#line 113
# netif_type is a type attribute for all network interface types.
#line 113
#
#line 113
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 113
#
#line 113
# Allow the domain to send to or receive from any node.
#line 113
# node_type is a type attribute for all node types.
#line 113
#
#line 113
allow httpd_t node_type:node { tcp_send rawip_send };
#line 113
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 113

#line 113
#
#line 113
# Allow the domain to send to or receive from any port.
#line 113
# port_type is a type attribute for all port types.
#line 113
#
#line 113

#line 113
allow httpd_t port_type:tcp_socket { send_msg recv_msg };
#line 113

#line 113

#line 113
# XXX Allow binding to any node type.  Remove once
#line 113
# individual rules have been added to all domains that 
#line 113
# bind sockets. 
#line 113
allow httpd_t node_type:tcp_socket node_bind;
#line 113
#
#line 113
# Allow access to network files including /etc/resolv.conf
#line 113
#
#line 113
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 113

#line 113
allow httpd_t self:tcp_socket { listen accept };
#line 113

#line 113

#line 113

#line 113
#
#line 113
# Allow the domain to create and use udp sockets.
#line 113
# Other kinds of sockets must be separately authorized for use.
#line 113
allow httpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 113

#line 113
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 113

#line 113
#
#line 113
# Allow the domain to send or receive using any network interface.
#line 113
# netif_type is a type attribute for all network interface types.
#line 113
#
#line 113
allow httpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 113
#
#line 113
# Allow the domain to send to or receive from any node.
#line 113
# node_type is a type attribute for all node types.
#line 113
#
#line 113
allow httpd_t node_type:node { udp_send rawip_send };
#line 113
allow httpd_t node_type:node { udp_recv rawip_recv };
#line 113

#line 113
#
#line 113
# Allow the domain to send to or receive from any port.
#line 113
# port_type is a type attribute for all port types.
#line 113
#
#line 113

#line 113
allow httpd_t port_type:udp_socket { send_msg recv_msg };
#line 113

#line 113

#line 113
# XXX Allow binding to any node type.  Remove once
#line 113
# individual rules have been added to all domains that 
#line 113
# bind sockets. 
#line 113
allow httpd_t node_type:udp_socket node_bind;
#line 113
#
#line 113
# Allow access to network files including /etc/resolv.conf
#line 113
#
#line 113
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 113

#line 113
allow httpd_t self:udp_socket { connect };
#line 113

#line 113

#line 113


#line 114

#line 114
if (allow_kerberos) {
#line 114

#line 114

#line 114

#line 114

#line 114
#
#line 114
# Allow the domain to create and use tcp sockets.
#line 114
# Other kinds of sockets must be separately authorized for use.
#line 114
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 114

#line 114
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 114

#line 114
#
#line 114
# Allow the domain to send or receive using any network interface.
#line 114
# netif_type is a type attribute for all network interface types.
#line 114
#
#line 114
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 114
#
#line 114
# Allow the domain to send to or receive from any node.
#line 114
# node_type is a type attribute for all node types.
#line 114
#
#line 114
allow httpd_t node_type:node { tcp_send rawip_send };
#line 114
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 114

#line 114
#
#line 114
# Allow the domain to send to or receive from any port.
#line 114
# port_type is a type attribute for all port types.
#line 114
#
#line 114

#line 114
allow httpd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 114

#line 114

#line 114
# XXX Allow binding to any node type.  Remove once
#line 114
# individual rules have been added to all domains that 
#line 114
# bind sockets. 
#line 114
allow httpd_t node_type:tcp_socket node_bind;
#line 114
#
#line 114
# Allow access to network files including /etc/resolv.conf
#line 114
#
#line 114
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 114

#line 114
allow httpd_t self:tcp_socket { connect };
#line 114

#line 114

#line 114

#line 114
#
#line 114
# Allow the domain to create and use udp sockets.
#line 114
# Other kinds of sockets must be separately authorized for use.
#line 114
allow httpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 114

#line 114
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 114

#line 114
#
#line 114
# Allow the domain to send or receive using any network interface.
#line 114
# netif_type is a type attribute for all network interface types.
#line 114
#
#line 114
allow httpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 114
#
#line 114
# Allow the domain to send to or receive from any node.
#line 114
# node_type is a type attribute for all node types.
#line 114
#
#line 114
allow httpd_t node_type:node { udp_send rawip_send };
#line 114
allow httpd_t node_type:node { udp_recv rawip_recv };
#line 114

#line 114
#
#line 114
# Allow the domain to send to or receive from any port.
#line 114
# port_type is a type attribute for all port types.
#line 114
#
#line 114

#line 114
allow httpd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 114

#line 114

#line 114
# XXX Allow binding to any node type.  Remove once
#line 114
# individual rules have been added to all domains that 
#line 114
# bind sockets. 
#line 114
allow httpd_t node_type:udp_socket node_bind;
#line 114
#
#line 114
# Allow access to network files including /etc/resolv.conf
#line 114
#
#line 114
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 114

#line 114
allow httpd_t self:udp_socket { connect };
#line 114

#line 114

#line 114

#line 114
allow httpd_t kerberos_port_t:tcp_socket name_connect;
#line 114

#line 114

#line 114

#line 114

#line 114

#line 114
#
#line 114
# Allow the domain to create and use tcp sockets.
#line 114
# Other kinds of sockets must be separately authorized for use.
#line 114
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 114

#line 114
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 114

#line 114
#
#line 114
# Allow the domain to send or receive using any network interface.
#line 114
# netif_type is a type attribute for all network interface types.
#line 114
#
#line 114
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 114
#
#line 114
# Allow the domain to send to or receive from any node.
#line 114
# node_type is a type attribute for all node types.
#line 114
#
#line 114
allow httpd_t node_type:node { tcp_send rawip_send };
#line 114
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 114

#line 114
#
#line 114
# Allow the domain to send to or receive from any port.
#line 114
# port_type is a type attribute for all port types.
#line 114
#
#line 114

#line 114
allow httpd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 114

#line 114

#line 114
# XXX Allow binding to any node type.  Remove once
#line 114
# individual rules have been added to all domains that 
#line 114
# bind sockets. 
#line 114
allow httpd_t node_type:tcp_socket node_bind;
#line 114
#
#line 114
# Allow access to network files including /etc/resolv.conf
#line 114
#
#line 114
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 114

#line 114
allow httpd_t self:tcp_socket { connect };
#line 114

#line 114

#line 114

#line 114
#
#line 114
# Allow the domain to create and use udp sockets.
#line 114
# Other kinds of sockets must be separately authorized for use.
#line 114
allow httpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 114

#line 114
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 114

#line 114
#
#line 114
# Allow the domain to send or receive using any network interface.
#line 114
# netif_type is a type attribute for all network interface types.
#line 114
#
#line 114
allow httpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 114
#
#line 114
# Allow the domain to send to or receive from any node.
#line 114
# node_type is a type attribute for all node types.
#line 114
#
#line 114
allow httpd_t node_type:node { udp_send rawip_send };
#line 114
allow httpd_t node_type:node { udp_recv rawip_recv };
#line 114

#line 114
#
#line 114
# Allow the domain to send to or receive from any port.
#line 114
# port_type is a type attribute for all port types.
#line 114
#
#line 114

#line 114
allow httpd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 114

#line 114

#line 114
# XXX Allow binding to any node type.  Remove once
#line 114
# individual rules have been added to all domains that 
#line 114
# bind sockets. 
#line 114
allow httpd_t node_type:udp_socket node_bind;
#line 114
#
#line 114
# Allow access to network files including /etc/resolv.conf
#line 114
#
#line 114
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 114

#line 114
allow httpd_t self:udp_socket { connect };
#line 114

#line 114

#line 114

#line 114
allow httpd_t dns_port_t:tcp_socket name_connect;
#line 114

#line 114
}
#line 114
 dontaudit httpd_t krb5_conf_t:file write;
#line 114
allow httpd_t krb5_conf_t:file { getattr read };
#line 114


#line 115

#line 115

#line 115

#line 115

#line 115
#
#line 115
# Allow the domain to create and use tcp sockets.
#line 115
# Other kinds of sockets must be separately authorized for use.
#line 115
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 115

#line 115
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 115

#line 115
#
#line 115
# Allow the domain to send or receive using any network interface.
#line 115
# netif_type is a type attribute for all network interface types.
#line 115
#
#line 115
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 115
#
#line 115
# Allow the domain to send to or receive from any node.
#line 115
# node_type is a type attribute for all node types.
#line 115
#
#line 115
allow httpd_t node_type:node { tcp_send rawip_send };
#line 115
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 115

#line 115
#
#line 115
# Allow the domain to send to or receive from any port.
#line 115
# port_type is a type attribute for all port types.
#line 115
#
#line 115

#line 115
allow httpd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 115

#line 115

#line 115
# XXX Allow binding to any node type.  Remove once
#line 115
# individual rules have been added to all domains that 
#line 115
# bind sockets. 
#line 115
allow httpd_t node_type:tcp_socket node_bind;
#line 115
#
#line 115
# Allow access to network files including /etc/resolv.conf
#line 115
#
#line 115
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 115

#line 115
allow httpd_t self:tcp_socket { connect };
#line 115

#line 115

#line 115

#line 115
#
#line 115
# Allow the domain to create and use udp sockets.
#line 115
# Other kinds of sockets must be separately authorized for use.
#line 115
allow httpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 115

#line 115
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 115

#line 115
#
#line 115
# Allow the domain to send or receive using any network interface.
#line 115
# netif_type is a type attribute for all network interface types.
#line 115
#
#line 115
allow httpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 115
#
#line 115
# Allow the domain to send to or receive from any node.
#line 115
# node_type is a type attribute for all node types.
#line 115
#
#line 115
allow httpd_t node_type:node { udp_send rawip_send };
#line 115
allow httpd_t node_type:node { udp_recv rawip_recv };
#line 115

#line 115
#
#line 115
# Allow the domain to send to or receive from any port.
#line 115
# port_type is a type attribute for all port types.
#line 115
#
#line 115

#line 115
allow httpd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 115

#line 115

#line 115
# XXX Allow binding to any node type.  Remove once
#line 115
# individual rules have been added to all domains that 
#line 115
# bind sockets. 
#line 115
allow httpd_t node_type:udp_socket node_bind;
#line 115
#
#line 115
# Allow access to network files including /etc/resolv.conf
#line 115
#
#line 115
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 115

#line 115
allow httpd_t self:udp_socket { connect };
#line 115

#line 115

#line 115

#line 115
allow httpd_t dns_port_t:tcp_socket name_connect;
#line 115


#line 116

#line 116

#line 116

#line 116

#line 116

#line 116
#
#line 116
# Allow the domain to create and use tcp sockets.
#line 116
# Other kinds of sockets must be separately authorized for use.
#line 116
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 116

#line 116
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 116

#line 116
#
#line 116
# Allow the domain to send or receive using any network interface.
#line 116
# netif_type is a type attribute for all network interface types.
#line 116
#
#line 116
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 116
#
#line 116
# Allow the domain to send to or receive from any node.
#line 116
# node_type is a type attribute for all node types.
#line 116
#
#line 116
allow httpd_t node_type:node { tcp_send rawip_send };
#line 116
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 116

#line 116
#
#line 116
# Allow the domain to send to or receive from any port.
#line 116
# port_type is a type attribute for all port types.
#line 116
#
#line 116

#line 116
allow httpd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 116

#line 116

#line 116
# XXX Allow binding to any node type.  Remove once
#line 116
# individual rules have been added to all domains that 
#line 116
# bind sockets. 
#line 116
allow httpd_t node_type:tcp_socket node_bind;
#line 116
#
#line 116
# Allow access to network files including /etc/resolv.conf
#line 116
#
#line 116
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 116

#line 116
allow httpd_t self:tcp_socket { connect };
#line 116

#line 116

#line 116

#line 116
#
#line 116
# Allow the domain to create and use udp sockets.
#line 116
# Other kinds of sockets must be separately authorized for use.
#line 116
allow httpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 116

#line 116
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 116

#line 116
#
#line 116
# Allow the domain to send or receive using any network interface.
#line 116
# netif_type is a type attribute for all network interface types.
#line 116
#
#line 116
allow httpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 116
#
#line 116
# Allow the domain to send to or receive from any node.
#line 116
# node_type is a type attribute for all node types.
#line 116
#
#line 116
allow httpd_t node_type:node { udp_send rawip_send };
#line 116
allow httpd_t node_type:node { udp_recv rawip_recv };
#line 116

#line 116
#
#line 116
# Allow the domain to send to or receive from any port.
#line 116
# port_type is a type attribute for all port types.
#line 116
#
#line 116

#line 116
allow httpd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 116

#line 116

#line 116
# XXX Allow binding to any node type.  Remove once
#line 116
# individual rules have been added to all domains that 
#line 116
# bind sockets. 
#line 116
allow httpd_t node_type:udp_socket node_bind;
#line 116
#
#line 116
# Allow access to network files including /etc/resolv.conf
#line 116
#
#line 116
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 116

#line 116
allow httpd_t self:udp_socket { connect };
#line 116

#line 116

#line 116

#line 116
allow httpd_t dns_port_t:tcp_socket name_connect;
#line 116

#line 116

#line 116

#line 116
if (allow_ypbind) {
#line 116

#line 116

#line 116

#line 116

#line 116

#line 116

#line 116

#line 116
#
#line 116
# Allow the domain to create and use tcp sockets.
#line 116
# Other kinds of sockets must be separately authorized for use.
#line 116
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 116

#line 116
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 116

#line 116
#
#line 116
# Allow the domain to send or receive using any network interface.
#line 116
# netif_type is a type attribute for all network interface types.
#line 116
#
#line 116
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 116
#
#line 116
# Allow the domain to send to or receive from any node.
#line 116
# node_type is a type attribute for all node types.
#line 116
#
#line 116
allow httpd_t node_type:node { tcp_send rawip_send };
#line 116
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 116

#line 116
#
#line 116
# Allow the domain to send to or receive from any port.
#line 116
# port_type is a type attribute for all port types.
#line 116
#
#line 116

#line 116
allow httpd_t port_type:tcp_socket { send_msg recv_msg };
#line 116

#line 116

#line 116
# XXX Allow binding to any node type.  Remove once
#line 116
# individual rules have been added to all domains that 
#line 116
# bind sockets. 
#line 116
allow httpd_t node_type:tcp_socket node_bind;
#line 116
#
#line 116
# Allow access to network files including /etc/resolv.conf
#line 116
#
#line 116
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 116

#line 116
allow httpd_t self:tcp_socket { listen accept };
#line 116

#line 116

#line 116

#line 116
#
#line 116
# Allow the domain to create and use tcp sockets.
#line 116
# Other kinds of sockets must be separately authorized for use.
#line 116
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 116

#line 116
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 116

#line 116
#
#line 116
# Allow the domain to send or receive using any network interface.
#line 116
# netif_type is a type attribute for all network interface types.
#line 116
#
#line 116
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 116
#
#line 116
# Allow the domain to send to or receive from any node.
#line 116
# node_type is a type attribute for all node types.
#line 116
#
#line 116
allow httpd_t node_type:node { tcp_send rawip_send };
#line 116
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 116

#line 116
#
#line 116
# Allow the domain to send to or receive from any port.
#line 116
# port_type is a type attribute for all port types.
#line 116
#
#line 116

#line 116
allow httpd_t port_type:tcp_socket { send_msg recv_msg };
#line 116

#line 116

#line 116
# XXX Allow binding to any node type.  Remove once
#line 116
# individual rules have been added to all domains that 
#line 116
# bind sockets. 
#line 116
allow httpd_t node_type:tcp_socket node_bind;
#line 116
#
#line 116
# Allow access to network files including /etc/resolv.conf
#line 116
#
#line 116
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 116

#line 116
allow httpd_t self:tcp_socket { connect };
#line 116

#line 116

#line 116

#line 116

#line 116

#line 116
#
#line 116
# Allow the domain to create and use udp sockets.
#line 116
# Other kinds of sockets must be separately authorized for use.
#line 116
allow httpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 116

#line 116
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 116

#line 116
#
#line 116
# Allow the domain to send or receive using any network interface.
#line 116
# netif_type is a type attribute for all network interface types.
#line 116
#
#line 116
allow httpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 116
#
#line 116
# Allow the domain to send to or receive from any node.
#line 116
# node_type is a type attribute for all node types.
#line 116
#
#line 116
allow httpd_t node_type:node { udp_send rawip_send };
#line 116
allow httpd_t node_type:node { udp_recv rawip_recv };
#line 116

#line 116
#
#line 116
# Allow the domain to send to or receive from any port.
#line 116
# port_type is a type attribute for all port types.
#line 116
#
#line 116

#line 116
allow httpd_t port_type:udp_socket { send_msg recv_msg };
#line 116

#line 116

#line 116
# XXX Allow binding to any node type.  Remove once
#line 116
# individual rules have been added to all domains that 
#line 116
# bind sockets. 
#line 116
allow httpd_t node_type:udp_socket node_bind;
#line 116
#
#line 116
# Allow access to network files including /etc/resolv.conf
#line 116
#
#line 116
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 116

#line 116
allow httpd_t self:udp_socket { connect };
#line 116

#line 116

#line 116

#line 116

#line 116

#line 116

#line 116
allow httpd_t var_yp_t:dir { read getattr lock search ioctl };
#line 116
allow httpd_t var_yp_t:file { read getattr lock ioctl };
#line 116
allow httpd_t var_yp_t:lnk_file { getattr read };
#line 116

#line 116
allow httpd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 116
allow httpd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 116
dontaudit httpd_t self:capability net_bind_service;
#line 116
dontaudit httpd_t reserved_port_type:tcp_socket name_connect;
#line 116
dontaudit httpd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 116

#line 116
} else {
#line 116
dontaudit httpd_t var_yp_t:dir search;
#line 116
}
#line 116
 
#line 116

#line 116

#line 116

#line 116
#
#line 116
# Allow the domain to create and use tcp sockets.
#line 116
# Other kinds of sockets must be separately authorized for use.
#line 116
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 116

#line 116
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 116

#line 116
#
#line 116
# Allow the domain to send or receive using any network interface.
#line 116
# netif_type is a type attribute for all network interface types.
#line 116
#
#line 116
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 116
#
#line 116
# Allow the domain to send to or receive from any node.
#line 116
# node_type is a type attribute for all node types.
#line 116
#
#line 116
allow httpd_t node_type:node { tcp_send rawip_send };
#line 116
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 116

#line 116
#
#line 116
# Allow the domain to send to or receive from any port.
#line 116
# port_type is a type attribute for all port types.
#line 116
#
#line 116

#line 116
allow httpd_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 116

#line 116

#line 116
# XXX Allow binding to any node type.  Remove once
#line 116
# individual rules have been added to all domains that 
#line 116
# bind sockets. 
#line 116
allow httpd_t node_type:tcp_socket node_bind;
#line 116
#
#line 116
# Allow access to network files including /etc/resolv.conf
#line 116
#
#line 116
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 116

#line 116
allow httpd_t self:tcp_socket { connect };
#line 116

#line 116
allow httpd_t ldap_port_t:tcp_socket name_connect;
#line 116

#line 116

#line 116

#line 116
allow httpd_t winbind_var_run_t:dir { getattr search };
#line 116
allow httpd_t winbind_t:unix_stream_socket connectto;
#line 116
allow httpd_t winbind_var_run_t:sock_file { getattr read write };
#line 116

#line 116

#line 116

allow httpd_t { http_port_t http_cache_port_t }:tcp_socket name_bind;
# allow httpd to connect to mysql/posgresql 
allow httpd_t { postgresql_port_t mysqld_port_t }:tcp_socket name_connect;
# allow httpd to work as a relay
allow httpd_t { gopher_port_t ftp_port_t http_port_t http_cache_port_t }:tcp_socket name_connect;

if (httpd_can_network_connect) {

#line 124

#line 124

#line 124

#line 124
#
#line 124
# Allow the domain to create and use tcp sockets.
#line 124
# Other kinds of sockets must be separately authorized for use.
#line 124
allow httpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 124

#line 124
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 124

#line 124
#
#line 124
# Allow the domain to send or receive using any network interface.
#line 124
# netif_type is a type attribute for all network interface types.
#line 124
#
#line 124
allow httpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 124
#
#line 124
# Allow the domain to send to or receive from any node.
#line 124
# node_type is a type attribute for all node types.
#line 124
#
#line 124
allow httpd_t node_type:node { tcp_send rawip_send };
#line 124
allow httpd_t node_type:node { tcp_recv rawip_recv };
#line 124

#line 124
#
#line 124
# Allow the domain to send to or receive from any port.
#line 124
# port_type is a type attribute for all port types.
#line 124
#
#line 124

#line 124
allow httpd_t port_type:tcp_socket { send_msg recv_msg };
#line 124

#line 124

#line 124
# XXX Allow binding to any node type.  Remove once
#line 124
# individual rules have been added to all domains that 
#line 124
# bind sockets. 
#line 124
allow httpd_t node_type:tcp_socket node_bind;
#line 124
#
#line 124
# Allow access to network files including /etc/resolv.conf
#line 124
#
#line 124
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 124

#line 124
allow httpd_t self:tcp_socket { connect };
#line 124

#line 124

#line 124

#line 124
#
#line 124
# Allow the domain to create and use udp sockets.
#line 124
# Other kinds of sockets must be separately authorized for use.
#line 124
allow httpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 124

#line 124
allow httpd_t unlabeled_t:association { sendto recvfrom };
#line 124

#line 124
#
#line 124
# Allow the domain to send or receive using any network interface.
#line 124
# netif_type is a type attribute for all network interface types.
#line 124
#
#line 124
allow httpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 124
#
#line 124
# Allow the domain to send to or receive from any node.
#line 124
# node_type is a type attribute for all node types.
#line 124
#
#line 124
allow httpd_t node_type:node { udp_send rawip_send };
#line 124
allow httpd_t node_type:node { udp_recv rawip_recv };
#line 124

#line 124
#
#line 124
# Allow the domain to send to or receive from any port.
#line 124
# port_type is a type attribute for all port types.
#line 124
#
#line 124

#line 124
allow httpd_t port_type:udp_socket { send_msg recv_msg };
#line 124

#line 124

#line 124
# XXX Allow binding to any node type.  Remove once
#line 124
# individual rules have been added to all domains that 
#line 124
# bind sockets. 
#line 124
allow httpd_t node_type:udp_socket node_bind;
#line 124
#
#line 124
# Allow access to network files including /etc/resolv.conf
#line 124
#
#line 124
allow httpd_t net_conf_t:file { read getattr lock ioctl };
#line 124

#line 124
allow httpd_t self:udp_socket { connect };
#line 124

#line 124

#line 124

allow httpd_t port_type:tcp_socket name_connect;
}

##########################################
# Legacy: remove when it's fixed         #
# Allow libphp5.so with text relocations #
##########################################
allow httpd_t texrel_shlib_t:file execmod;

#########################################
# Allow httpd to search users directories
#########################################
allow httpd_t home_root_t:dir { getattr search };
dontaudit httpd_t sysadm_home_dir_t:dir getattr;

############################################################################
# Allow the httpd_t the capability to bind to a port and various other stuff
############################################################################
allow httpd_t self:capability { chown dac_override kill setgid setuid net_bind_service sys_tty_config };
dontaudit httpd_t self:capability net_admin;

#################################################
# Allow the httpd_t to read the web servers config files
###################################################

#line 149
allow httpd_t httpd_config_t:dir { read getattr lock search ioctl };
#line 149
allow httpd_t httpd_config_t:file { read getattr lock ioctl };
#line 149
allow httpd_t httpd_config_t:lnk_file { getattr read };
#line 149

# allow logrotate to read the config files for restart
#line 155


#line 156
allow initrc_t httpd_config_t:dir { read getattr lock search ioctl };
#line 156
allow initrc_t httpd_config_t:file { read getattr lock ioctl };
#line 156
allow initrc_t httpd_config_t:lnk_file { getattr read };
#line 156

##################################################

###############################
# Allow httpd_t to put files in /var/cache/httpd etc
##############################

#line 162
allow httpd_t httpd_cache_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 162
allow httpd_t httpd_cache_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 162
allow httpd_t httpd_cache_t:lnk_file { create read getattr setattr link unlink rename };
#line 162


###############################
# Allow httpd_t to access the tmpfs file system
##############################

#line 167

#line 167

#line 167
type httpd_tmpfs_t, file_type, sysadmfile, tmpfsfile;
#line 167
# Use this type when creating tmpfs/shm objects.
#line 167

#line 167

#line 167

#line 167

#line 167
#
#line 167
# Allow the process to modify the directory.
#line 167
#
#line 167
allow httpd_t tmpfs_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 167

#line 167
#
#line 167
# Allow the process to create the file.
#line 167
#
#line 167

#line 167

#line 167

#line 167

#line 167

#line 167
allow httpd_t httpd_tmpfs_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167
allow httpd_t httpd_tmpfs_t:lnk_file { create read getattr setattr link unlink rename };
#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167
allow httpd_t httpd_tmpfs_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167
allow httpd_t httpd_tmpfs_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167
allow httpd_t httpd_tmpfs_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167

#line 167
type_transition httpd_t tmpfs_t:dir httpd_tmpfs_t;
#line 167
type_transition httpd_t tmpfs_t:{ file lnk_file sock_file fifo_file } httpd_tmpfs_t;
#line 167

#line 167

#line 167
allow httpd_tmpfs_t tmpfs_t:filesystem associate;
#line 167

#line 167


#####################
# Allow httpd_t to access
# libraries for its modules
###############################
allow httpd_t httpd_modules_t:file { read getattr lock execute ioctl };
allow httpd_t httpd_modules_t:dir { read getattr lock search ioctl };
allow httpd_t httpd_modules_t:lnk_file { read getattr lock ioctl };

######################################################################
# Allow initrc_t to access the Apache modules directory.
######################################################################
allow initrc_t httpd_modules_t:dir { read getattr lock search ioctl };

##############################################
# Allow httpd_t to have access to files
# such as nisswitch.conf
# need ioctl for php
###############################################
allow httpd_t etc_t:file { read getattr ioctl };
allow httpd_t etc_t:lnk_file { getattr read };

# setup the system domain for system CGI scripts

#line 191

#line 191
#This type is for webpages
#line 191
#
#line 191
type httpd_sys_content_t, file_type, httpdcontent, sysadmfile, customizable;
#line 191

#line 191
# This type is used for .htaccess files
#line 191
#
#line 191
type httpd_sys_htaccess_t, file_type, sysadmfile, customizable;
#line 191
allow httpd_t httpd_sys_htaccess_t: file { read getattr lock ioctl };
#line 191

#line 191
# This type is used for executable scripts files
#line 191
#
#line 191
type httpd_sys_script_exec_t, file_type, sysadmfile, customizable;
#line 191

#line 191
# Type that CGI scripts run as
#line 191
type httpd_sys_script_t, domain, privmail, nscd_client_domain;
#line 191
role system_r types httpd_sys_script_t;
#line 191

#line 191
allow httpd_sys_script_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t lib_t:lnk_file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t ld_so_t:file { read getattr lock execute ioctl };
#line 191
#allow httpd_sys_script_t ld_so_t:file execute_no_trans;
#line 191
allow httpd_sys_script_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 191
allow httpd_sys_script_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t texrel_shlib_t:file execmod;
#line 191
allow httpd_sys_script_t ld_so_cache_t:file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t device_t:dir search;
#line 191
allow httpd_sys_script_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 191

#line 191

#line 191
if (httpd_enable_cgi) {
#line 191

#line 191

#line 191

#line 191
#
#line 191
# Allow the process to transition to the new domain.
#line 191
#
#line 191
allow httpd_t httpd_sys_script_t:process transition;
#line 191

#line 191
#
#line 191
# Do not audit when glibc secure mode is enabled upon the transition.
#line 191
#
#line 191
dontaudit httpd_t httpd_sys_script_t:process noatsecure;
#line 191

#line 191
#
#line 191
# Do not audit when signal-related state is cleared upon the transition.
#line 191
#
#line 191
dontaudit httpd_t httpd_sys_script_t:process siginh;
#line 191

#line 191
#
#line 191
# Do not audit when resource limits are reset upon the transition.
#line 191
#
#line 191
dontaudit httpd_t httpd_sys_script_t:process rlimitinh;
#line 191

#line 191
#
#line 191
# Allow the process to execute the program.
#line 191
# 
#line 191
allow httpd_t httpd_sys_script_exec_t:file { read { getattr execute } };
#line 191

#line 191
#
#line 191
# Allow the process to reap the new domain.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_t:process sigchld;
#line 191

#line 191
#
#line 191
# Allow the new domain to inherit and use file 
#line 191
# descriptions from the creating process and vice versa.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_t:fd use;
#line 191
allow httpd_t httpd_sys_script_t:fd use;
#line 191

#line 191
#
#line 191
# Allow the new domain to write back to the old domain via a pipe.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_t:fifo_file { ioctl read getattr lock write append };
#line 191

#line 191
#
#line 191
# Allow the new domain to read and execute the program.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_sys_script_exec_t:file { read getattr lock execute ioctl };
#line 191

#line 191
#
#line 191
# Allow the new domain to be entered via the program.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_sys_script_exec_t:file entrypoint;
#line 191

#line 191
type_transition httpd_t httpd_sys_script_exec_t:process httpd_sys_script_t;
#line 191

#line 191
allow httpd_t httpd_sys_script_t:process { signal sigkill sigstop };
#line 191
allow httpd_t httpd_sys_script_exec_t:dir { read getattr lock search ioctl };
#line 191
allow httpd_t httpd_sys_script_exec_t:file { read getattr lock ioctl };
#line 191

#line 191
allow httpd_sys_script_t httpd_t:fd use;
#line 191
allow httpd_sys_script_t httpd_t:process sigchld;
#line 191

#line 191
allow httpd_sys_script_t { usr_t lib_t }:file { getattr read ioctl };
#line 191
allow httpd_sys_script_t usr_t:lnk_file { getattr read };
#line 191

#line 191
allow httpd_sys_script_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 191

#line 191
allow httpd_sys_script_t devtty_t:chr_file { getattr read write };
#line 191
allow httpd_sys_script_t urandom_device_t:chr_file { getattr read };
#line 191
allow httpd_sys_script_t etc_runtime_t:file { getattr read };
#line 191

#line 191
allow httpd_sys_script_t etc_t:lnk_file read;
#line 191
allow httpd_sys_script_t lib_t:file { read getattr lock ioctl };
#line 191

#line 191
allow httpd_sys_script_t locale_t:dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t locale_t:file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t locale_t:lnk_file { getattr read };
#line 191

#line 191

#line 191
allow httpd_sys_script_t fs_t:filesystem getattr;
#line 191
allow httpd_sys_script_t self:unix_stream_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept } connectto };
#line 191

#line 191
allow httpd_sys_script_t { self proc_t }:file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t { self proc_t }:dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t { self proc_t }:lnk_file read;
#line 191

#line 191
allow httpd_sys_script_t device_t:dir { getattr search };
#line 191
allow httpd_sys_script_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 191
}
#line 191

#line 191
if (httpd_enable_cgi && httpd_can_network_connect) {
#line 191

#line 191

#line 191

#line 191

#line 191
#
#line 191
# Allow the domain to create and use tcp sockets.
#line 191
# Other kinds of sockets must be separately authorized for use.
#line 191
allow httpd_sys_script_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 191

#line 191
allow httpd_sys_script_t unlabeled_t:association { sendto recvfrom };
#line 191

#line 191
#
#line 191
# Allow the domain to send or receive using any network interface.
#line 191
# netif_type is a type attribute for all network interface types.
#line 191
#
#line 191
allow httpd_sys_script_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 191
#
#line 191
# Allow the domain to send to or receive from any node.
#line 191
# node_type is a type attribute for all node types.
#line 191
#
#line 191
allow httpd_sys_script_t node_type:node { tcp_send rawip_send };
#line 191
allow httpd_sys_script_t node_type:node { tcp_recv rawip_recv };
#line 191

#line 191
#
#line 191
# Allow the domain to send to or receive from any port.
#line 191
# port_type is a type attribute for all port types.
#line 191
#
#line 191

#line 191
allow httpd_sys_script_t port_type:tcp_socket { send_msg recv_msg };
#line 191

#line 191

#line 191
# XXX Allow binding to any node type.  Remove once
#line 191
# individual rules have been added to all domains that 
#line 191
# bind sockets. 
#line 191
allow httpd_sys_script_t node_type:tcp_socket node_bind;
#line 191
#
#line 191
# Allow access to network files including /etc/resolv.conf
#line 191
#
#line 191
allow httpd_sys_script_t net_conf_t:file { read getattr lock ioctl };
#line 191

#line 191
allow httpd_sys_script_t self:tcp_socket { connect };
#line 191

#line 191

#line 191

#line 191
#
#line 191
# Allow the domain to create and use udp sockets.
#line 191
# Other kinds of sockets must be separately authorized for use.
#line 191
allow httpd_sys_script_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 191

#line 191
allow httpd_sys_script_t unlabeled_t:association { sendto recvfrom };
#line 191

#line 191
#
#line 191
# Allow the domain to send or receive using any network interface.
#line 191
# netif_type is a type attribute for all network interface types.
#line 191
#
#line 191
allow httpd_sys_script_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 191
#
#line 191
# Allow the domain to send to or receive from any node.
#line 191
# node_type is a type attribute for all node types.
#line 191
#
#line 191
allow httpd_sys_script_t node_type:node { udp_send rawip_send };
#line 191
allow httpd_sys_script_t node_type:node { udp_recv rawip_recv };
#line 191

#line 191
#
#line 191
# Allow the domain to send to or receive from any port.
#line 191
# port_type is a type attribute for all port types.
#line 191
#
#line 191

#line 191
allow httpd_sys_script_t port_type:udp_socket { send_msg recv_msg };
#line 191

#line 191

#line 191
# XXX Allow binding to any node type.  Remove once
#line 191
# individual rules have been added to all domains that 
#line 191
# bind sockets. 
#line 191
allow httpd_sys_script_t node_type:udp_socket node_bind;
#line 191
#
#line 191
# Allow access to network files including /etc/resolv.conf
#line 191
#
#line 191
allow httpd_sys_script_t net_conf_t:file { read getattr lock ioctl };
#line 191

#line 191
allow httpd_sys_script_t self:udp_socket { connect };
#line 191

#line 191

#line 191

#line 191
allow httpd_sys_script_t port_type:tcp_socket name_connect;
#line 191
}
#line 191

#line 191

#line 191
if (httpd_enable_cgi && allow_ypbind) {
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
#
#line 191
# Allow the domain to create and use tcp sockets.
#line 191
# Other kinds of sockets must be separately authorized for use.
#line 191
allow httpd_sys_script_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 191

#line 191
allow httpd_sys_script_t unlabeled_t:association { sendto recvfrom };
#line 191

#line 191
#
#line 191
# Allow the domain to send or receive using any network interface.
#line 191
# netif_type is a type attribute for all network interface types.
#line 191
#
#line 191
allow httpd_sys_script_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 191
#
#line 191
# Allow the domain to send to or receive from any node.
#line 191
# node_type is a type attribute for all node types.
#line 191
#
#line 191
allow httpd_sys_script_t node_type:node { tcp_send rawip_send };
#line 191
allow httpd_sys_script_t node_type:node { tcp_recv rawip_recv };
#line 191

#line 191
#
#line 191
# Allow the domain to send to or receive from any port.
#line 191
# port_type is a type attribute for all port types.
#line 191
#
#line 191

#line 191
allow httpd_sys_script_t port_type:tcp_socket { send_msg recv_msg };
#line 191

#line 191

#line 191
# XXX Allow binding to any node type.  Remove once
#line 191
# individual rules have been added to all domains that 
#line 191
# bind sockets. 
#line 191
allow httpd_sys_script_t node_type:tcp_socket node_bind;
#line 191
#
#line 191
# Allow access to network files including /etc/resolv.conf
#line 191
#
#line 191
allow httpd_sys_script_t net_conf_t:file { read getattr lock ioctl };
#line 191

#line 191
allow httpd_sys_script_t self:tcp_socket { listen accept };
#line 191

#line 191

#line 191

#line 191
#
#line 191
# Allow the domain to create and use tcp sockets.
#line 191
# Other kinds of sockets must be separately authorized for use.
#line 191
allow httpd_sys_script_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 191

#line 191
allow httpd_sys_script_t unlabeled_t:association { sendto recvfrom };
#line 191

#line 191
#
#line 191
# Allow the domain to send or receive using any network interface.
#line 191
# netif_type is a type attribute for all network interface types.
#line 191
#
#line 191
allow httpd_sys_script_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 191
#
#line 191
# Allow the domain to send to or receive from any node.
#line 191
# node_type is a type attribute for all node types.
#line 191
#
#line 191
allow httpd_sys_script_t node_type:node { tcp_send rawip_send };
#line 191
allow httpd_sys_script_t node_type:node { tcp_recv rawip_recv };
#line 191

#line 191
#
#line 191
# Allow the domain to send to or receive from any port.
#line 191
# port_type is a type attribute for all port types.
#line 191
#
#line 191

#line 191
allow httpd_sys_script_t port_type:tcp_socket { send_msg recv_msg };
#line 191

#line 191

#line 191
# XXX Allow binding to any node type.  Remove once
#line 191
# individual rules have been added to all domains that 
#line 191
# bind sockets. 
#line 191
allow httpd_sys_script_t node_type:tcp_socket node_bind;
#line 191
#
#line 191
# Allow access to network files including /etc/resolv.conf
#line 191
#
#line 191
allow httpd_sys_script_t net_conf_t:file { read getattr lock ioctl };
#line 191

#line 191
allow httpd_sys_script_t self:tcp_socket { connect };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
#
#line 191
# Allow the domain to create and use udp sockets.
#line 191
# Other kinds of sockets must be separately authorized for use.
#line 191
allow httpd_sys_script_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 191

#line 191
allow httpd_sys_script_t unlabeled_t:association { sendto recvfrom };
#line 191

#line 191
#
#line 191
# Allow the domain to send or receive using any network interface.
#line 191
# netif_type is a type attribute for all network interface types.
#line 191
#
#line 191
allow httpd_sys_script_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 191
#
#line 191
# Allow the domain to send to or receive from any node.
#line 191
# node_type is a type attribute for all node types.
#line 191
#
#line 191
allow httpd_sys_script_t node_type:node { udp_send rawip_send };
#line 191
allow httpd_sys_script_t node_type:node { udp_recv rawip_recv };
#line 191

#line 191
#
#line 191
# Allow the domain to send to or receive from any port.
#line 191
# port_type is a type attribute for all port types.
#line 191
#
#line 191

#line 191
allow httpd_sys_script_t port_type:udp_socket { send_msg recv_msg };
#line 191

#line 191

#line 191
# XXX Allow binding to any node type.  Remove once
#line 191
# individual rules have been added to all domains that 
#line 191
# bind sockets. 
#line 191
allow httpd_sys_script_t node_type:udp_socket node_bind;
#line 191
#
#line 191
# Allow access to network files including /etc/resolv.conf
#line 191
#
#line 191
allow httpd_sys_script_t net_conf_t:file { read getattr lock ioctl };
#line 191

#line 191
allow httpd_sys_script_t self:udp_socket { connect };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow httpd_sys_script_t var_yp_t:dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t var_yp_t:file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t var_yp_t:lnk_file { getattr read };
#line 191

#line 191
allow httpd_sys_script_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 191
allow httpd_sys_script_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 191
dontaudit httpd_sys_script_t self:capability net_bind_service;
#line 191
dontaudit httpd_sys_script_t reserved_port_type:tcp_socket name_connect;
#line 191
dontaudit httpd_sys_script_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 191

#line 191
}
#line 191

#line 191
# The following are the only areas that 
#line 191
# scripts can read, read/write, or append to
#line 191
#
#line 191
type httpd_sys_script_ro_t, file_type, httpdcontent, sysadmfile, customizable;
#line 191
type httpd_sys_script_rw_t, file_type, httpdcontent, sysadmfile, customizable;
#line 191
type httpd_sys_script_ra_t, file_type, httpdcontent, sysadmfile, customizable;
#line 191

#line 191

#line 191

#line 191

#line 191
#
#line 191
# Allow the process to modify the directory.
#line 191
#
#line 191
allow httpd_sys_script_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 191

#line 191
#
#line 191
# Allow the process to create the file.
#line 191
#
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_rw_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_rw_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191

#line 191
type_transition httpd_sys_script_t tmp_t:dir httpd_sys_script_rw_t;
#line 191
type_transition httpd_sys_script_t tmp_t:{ file lnk_file sock_file fifo_file } httpd_sys_script_rw_t;
#line 191

#line 191

#line 191

#line 191
#########################################################
#line 191
# Permissions for running child processes and scripts
#line 191
##########################################################
#line 191
allow httpd_suexec_t { httpd_sys_content_t httpd_sys_script_ro_t httpd_sys_script_rw_t httpd_sys_script_exec_t }:dir { getattr search };
#line 191

#line 191

#line 191

#line 191

#line 191
#
#line 191
# Allow the process to transition to the new domain.
#line 191
#
#line 191
allow httpd_suexec_t httpd_sys_script_t:process transition;
#line 191

#line 191
#
#line 191
# Do not audit when glibc secure mode is enabled upon the transition.
#line 191
#
#line 191
dontaudit httpd_suexec_t httpd_sys_script_t:process noatsecure;
#line 191

#line 191
#
#line 191
# Do not audit when signal-related state is cleared upon the transition.
#line 191
#
#line 191
dontaudit httpd_suexec_t httpd_sys_script_t:process siginh;
#line 191

#line 191
#
#line 191
# Do not audit when resource limits are reset upon the transition.
#line 191
#
#line 191
dontaudit httpd_suexec_t httpd_sys_script_t:process rlimitinh;
#line 191

#line 191
#
#line 191
# Allow the process to execute the program.
#line 191
# 
#line 191
allow httpd_suexec_t httpd_sys_script_exec_t:file { read { getattr execute } };
#line 191

#line 191
#
#line 191
# Allow the process to reap the new domain.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_suexec_t:process sigchld;
#line 191

#line 191
#
#line 191
# Allow the new domain to inherit and use file 
#line 191
# descriptions from the creating process and vice versa.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_suexec_t:fd use;
#line 191
allow httpd_suexec_t httpd_sys_script_t:fd use;
#line 191

#line 191
#
#line 191
# Allow the new domain to write back to the old domain via a pipe.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_suexec_t:fifo_file { ioctl read getattr lock write append };
#line 191

#line 191
#
#line 191
# Allow the new domain to read and execute the program.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_sys_script_exec_t:file { read getattr lock execute ioctl };
#line 191

#line 191
#
#line 191
# Allow the new domain to be entered via the program.
#line 191
#
#line 191
allow httpd_sys_script_t httpd_sys_script_exec_t:file entrypoint;
#line 191

#line 191
type_transition httpd_suexec_t httpd_sys_script_exec_t:process httpd_sys_script_t;
#line 191

#line 191

#line 191
allow httpd_sys_script_t httpd_t:fifo_file write;
#line 191

#line 191
allow httpd_sys_script_t self:fifo_file { ioctl read getattr lock write append };
#line 191

#line 191
allow httpd_sys_script_t { urandom_device_t random_device_t }:chr_file { read getattr lock ioctl };
#line 191

#line 191
###########################################################################
#line 191
# Allow the script interpreters to run the scripts.  So
#line 191
# the perl executable will be able to run a perl script
#line 191
#########################################################################
#line 191
allow httpd_sys_script_t httpd_sys_script_exec_t:dir { read getattr lock search ioctl };
#line 191

#line 191
allow httpd_sys_script_t { bin_t sbin_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t { bin_t sbin_t etc_t }:lnk_file { getattr read };
#line 191

#line 191
allow httpd_sys_script_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t lib_t:lnk_file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t ld_so_t:file { read getattr lock execute ioctl };
#line 191
#allow httpd_sys_script_t ld_so_t:file execute_no_trans;
#line 191
allow httpd_sys_script_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 191
allow httpd_sys_script_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t texrel_shlib_t:file execmod;
#line 191
allow httpd_sys_script_t ld_so_cache_t:file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t device_t:dir search;
#line 191
allow httpd_sys_script_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 191

#line 191

#line 191
allow httpd_sys_script_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 191

#line 191

#line 191
allow httpd_sys_script_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 191

#line 191

#line 191
allow httpd_sys_script_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 191

#line 191

#line 191
allow httpd_sys_script_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 191

#line 191

#line 191
allow httpd_sys_script_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 191

#line 191

#line 191
allow httpd_sys_script_t ld_so_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 191

#line 191

#line 191

#line 191
allow httpd_sys_script_t etc_t:file { getattr read };
#line 191
dontaudit httpd_sys_script_t selinux_config_t:dir search;
#line 191

#line 191
############################################################################
#line 191
# Allow the script process to search the cgi directory, and users directory
#line 191
##############################################################################
#line 191
allow httpd_sys_script_t httpd_sys_script_exec_t:dir { search getattr };
#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 191

#line 191
allow httpd_sys_script_t home_root_t:dir { getattr search };
#line 191
allow httpd_sys_script_t httpd_sys_content_t:dir { getattr search };
#line 191

#line 191
#############################################################################
#line 191
# Allow the scripts to read, read/write, append to the specified directories
#line 191
# or files
#line 191
############################################################################
#line 191

#line 191

#line 191
# Read global fonts and font config
#line 191

#line 191
allow httpd_sys_script_t fonts_t:dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t fonts_t:file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t fonts_t:lnk_file { getattr read };
#line 191

#line 191

#line 191
allow httpd_sys_script_t etc_t:dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t etc_t:file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t etc_t:lnk_file { getattr read };
#line 191

#line 191

#line 191
 
#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_ro_t:dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t httpd_sys_script_ro_t:file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t httpd_sys_script_ro_t:lnk_file { getattr read };
#line 191

#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 191
allow httpd_sys_script_t httpd_sys_script_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191
allow httpd_sys_script_t httpd_sys_script_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_rw_t:sock_file { ioctl read getattr lock write append };
#line 191

#line 191
allow httpd_sys_script_t httpd_sys_script_ra_t:dir { read getattr lock search ioctl add_name write };
#line 191
allow httpd_sys_script_t httpd_sys_script_ra_t:file { ioctl read getattr lock append };
#line 191
allow httpd_sys_script_t httpd_sys_script_ra_t:lnk_file { getattr read };
#line 191

#line 191

#line 191

#line 191
allow httpd_sys_script_t { public_content_t public_content_rw_t } :dir { read getattr lock search ioctl };
#line 191
allow httpd_sys_script_t { public_content_t public_content_rw_t } :file { read getattr lock ioctl };
#line 191
allow httpd_sys_script_t { public_content_t public_content_rw_t } :lnk_file { getattr read };
#line 191

#line 191
bool allow_httpd_sys_script_anon_write false;
#line 191
if (allow_httpd_sys_script_anon_write) {
#line 191

#line 191
allow httpd_sys_script_t public_content_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 191
allow httpd_sys_script_t public_content_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191
allow httpd_sys_script_t public_content_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 191

#line 191
}
#line 191

#line 191

#line 191
if (httpd_enable_cgi && httpd_unified  && ! httpd_disable_trans) {
#line 191

#line 191
allow httpd_sys_script_t httpdcontent:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 191
allow httpd_sys_script_t httpdcontent:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191
allow httpd_sys_script_t httpdcontent:lnk_file { create read getattr setattr link unlink rename };
#line 191

#line 191

#line 191
allow httpd_sys_script_t httpdcontent:file { { read getattr lock execute ioctl } execute_no_trans };
#line 191

#line 191
}
#line 191

#line 191
#
#line 191
# If a user starts a script by hand it gets the proper context
#line 191
#
#line 191

#line 191
role sysadm_r types httpd_sys_script_t;
#line 191

#line 191
dontaudit httpd_sys_script_t sysctl_kernel_t:dir search;
#line 191
dontaudit httpd_sys_script_t sysctl_t:dir search;
#line 191

#line 191
############################################
#line 191
# Allow scripts to append to http logs
#line 191
#########################################
#line 191
allow httpd_sys_script_t { var_t var_log_t httpd_log_t }:dir  search;
#line 191
allow httpd_sys_script_t httpd_log_t:file { getattr append };
#line 191

#line 191
# apache should set close-on-exec
#line 191
dontaudit  httpd_sys_script_t httpd_t:unix_stream_socket { read write };
#line 191

#line 191
################################################################
#line 191
# Allow the web server to run scripts and serve pages
#line 191
##############################################################
#line 191
if (httpd_builtin_scripting) {
#line 191

#line 191
allow httpd_t httpd_sys_script_ro_t:dir { read getattr lock search ioctl };
#line 191
allow httpd_t httpd_sys_script_ro_t:file { read getattr lock ioctl };
#line 191
allow httpd_t httpd_sys_script_ro_t:lnk_file { getattr read };
#line 191

#line 191

#line 191
allow httpd_t httpd_sys_script_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 191
allow httpd_t httpd_sys_script_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 191
allow httpd_t httpd_sys_script_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 191

#line 191
allow httpd_t httpd_sys_script_rw_t:sock_file { ioctl read getattr lock write append };
#line 191

#line 191
allow httpd_t httpd_sys_script_ra_t:dir { read getattr lock search ioctl add_name write };
#line 191
allow httpd_t httpd_sys_script_ra_t:file { ioctl read getattr lock append };
#line 191
allow httpd_t httpd_sys_script_ra_t:lnk_file { getattr read };
#line 191

#line 191

#line 191
allow httpd_t httpd_sys_content_t:dir { read getattr lock search ioctl };
#line 191
allow httpd_t httpd_sys_content_t:file { read getattr lock ioctl };
#line 191
allow httpd_t httpd_sys_content_t:lnk_file { getattr read };
#line 191

#line 191
}
#line 191

#line 191

dontaudit httpd_sys_script_t httpd_config_t:dir search;

# Run SSI execs in system CGI script domain.
if (httpd_ssi_exec) {

#line 196

#line 196

#line 196
#
#line 196
# Allow the process to transition to the new domain.
#line 196
#
#line 196
allow httpd_t httpd_sys_script_t:process transition;
#line 196

#line 196
#
#line 196
# Do not audit when glibc secure mode is enabled upon the transition.
#line 196
#
#line 196
dontaudit httpd_t httpd_sys_script_t:process noatsecure;
#line 196

#line 196
#
#line 196
# Do not audit when signal-related state is cleared upon the transition.
#line 196
#
#line 196
dontaudit httpd_t httpd_sys_script_t:process siginh;
#line 196

#line 196
#
#line 196
# Do not audit when resource limits are reset upon the transition.
#line 196
#
#line 196
dontaudit httpd_t httpd_sys_script_t:process rlimitinh;
#line 196

#line 196
#
#line 196
# Allow the process to execute the program.
#line 196
# 
#line 196
allow httpd_t shell_exec_t:file { read { getattr execute } };
#line 196

#line 196
#
#line 196
# Allow the process to reap the new domain.
#line 196
#
#line 196
allow httpd_sys_script_t httpd_t:process sigchld;
#line 196

#line 196
#
#line 196
# Allow the new domain to inherit and use file 
#line 196
# descriptions from the creating process and vice versa.
#line 196
#
#line 196
allow httpd_sys_script_t httpd_t:fd use;
#line 196
allow httpd_t httpd_sys_script_t:fd use;
#line 196

#line 196
#
#line 196
# Allow the new domain to write back to the old domain via a pipe.
#line 196
#
#line 196
allow httpd_sys_script_t httpd_t:fifo_file { ioctl read getattr lock write append };
#line 196

#line 196
#
#line 196
# Allow the new domain to read and execute the program.
#line 196
#
#line 196
allow httpd_sys_script_t shell_exec_t:file { read getattr lock execute ioctl };
#line 196

#line 196
#
#line 196
# Allow the new domain to be entered via the program.
#line 196
#
#line 196
allow httpd_sys_script_t shell_exec_t:file entrypoint;
#line 196

#line 196
type_transition httpd_t shell_exec_t:process httpd_sys_script_t;
#line 196

}
allow httpd_sys_script_t httpd_t:tcp_socket { read write };

##################################################
#
# PHP Directives
##################################################

type httpd_php_exec_t, file_type, sysadmfile, exec_type;
type httpd_php_t, domain;

# Transition from the user domain to this domain.

#line 209

#line 209

#line 209
#
#line 209
# Allow the process to transition to the new domain.
#line 209
#
#line 209
allow httpd_t httpd_php_t:process transition;
#line 209

#line 209
#
#line 209
# Do not audit when glibc secure mode is enabled upon the transition.
#line 209
#
#line 209
dontaudit httpd_t httpd_php_t:process noatsecure;
#line 209

#line 209
#
#line 209
# Do not audit when signal-related state is cleared upon the transition.
#line 209
#
#line 209
dontaudit httpd_t httpd_php_t:process siginh;
#line 209

#line 209
#
#line 209
# Do not audit when resource limits are reset upon the transition.
#line 209
#
#line 209
dontaudit httpd_t httpd_php_t:process rlimitinh;
#line 209

#line 209
#
#line 209
# Allow the process to execute the program.
#line 209
# 
#line 209
allow httpd_t httpd_php_exec_t:file { read { getattr execute } };
#line 209

#line 209
#
#line 209
# Allow the process to reap the new domain.
#line 209
#
#line 209
allow httpd_php_t httpd_t:process sigchld;
#line 209

#line 209
#
#line 209
# Allow the new domain to inherit and use file 
#line 209
# descriptions from the creating process and vice versa.
#line 209
#
#line 209
allow httpd_php_t httpd_t:fd use;
#line 209
allow httpd_t httpd_php_t:fd use;
#line 209

#line 209
#
#line 209
# Allow the new domain to write back to the old domain via a pipe.
#line 209
#
#line 209
allow httpd_php_t httpd_t:fifo_file { ioctl read getattr lock write append };
#line 209

#line 209
#
#line 209
# Allow the new domain to read and execute the program.
#line 209
#
#line 209
allow httpd_php_t httpd_php_exec_t:file { read getattr lock execute ioctl };
#line 209

#line 209
#
#line 209
# Allow the new domain to be entered via the program.
#line 209
#
#line 209
allow httpd_php_t httpd_php_exec_t:file entrypoint;
#line 209

#line 209
type_transition httpd_t httpd_php_exec_t:process httpd_php_t;
#line 209


# The system role is authorized for this domain.
role system_r types httpd_php_t;


#line 214
# Access other processes in the same domain.
#line 214
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 214
# These must be granted separately if desired.
#line 214
allow httpd_php_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 214

#line 214
# Access /proc/PID files for processes in the same domain.
#line 214
allow httpd_php_t self:dir { read getattr lock search ioctl };
#line 214
allow httpd_php_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 214

#line 214
# Access file descriptions, pipes, and sockets
#line 214
# created by processes in the same domain.
#line 214
allow httpd_php_t self:fd *;
#line 214
allow httpd_php_t self:fifo_file { ioctl read getattr lock write append };
#line 214
allow httpd_php_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 214
allow httpd_php_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 214

#line 214
# Allow the domain to communicate with other processes in the same domain.
#line 214
allow httpd_php_t self:unix_dgram_socket sendto;
#line 214
allow httpd_php_t self:unix_stream_socket connectto;
#line 214

#line 214
# Access System V IPC objects created by processes in the same domain.
#line 214
allow httpd_php_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 214
allow httpd_php_t self:msg  { send receive };
#line 214
allow httpd_php_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 214
allow httpd_php_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 214
allow httpd_php_t unpriv_userdomain:fd use;
#line 214
#
#line 214
# Every app is asking for ypbind so I am adding this here, 
#line 214
# eventually this should become can_nsswitch
#line 214
#
#line 214

#line 214

#line 214
if (allow_ypbind) {
#line 214

#line 214

#line 214

#line 214

#line 214

#line 214

#line 214

#line 214
#
#line 214
# Allow the domain to create and use tcp sockets.
#line 214
# Other kinds of sockets must be separately authorized for use.
#line 214
allow httpd_php_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 214

#line 214
allow httpd_php_t unlabeled_t:association { sendto recvfrom };
#line 214

#line 214
#
#line 214
# Allow the domain to send or receive using any network interface.
#line 214
# netif_type is a type attribute for all network interface types.
#line 214
#
#line 214
allow httpd_php_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 214
#
#line 214
# Allow the domain to send to or receive from any node.
#line 214
# node_type is a type attribute for all node types.
#line 214
#
#line 214
allow httpd_php_t node_type:node { tcp_send rawip_send };
#line 214
allow httpd_php_t node_type:node { tcp_recv rawip_recv };
#line 214

#line 214
#
#line 214
# Allow the domain to send to or receive from any port.
#line 214
# port_type is a type attribute for all port types.
#line 214
#
#line 214

#line 214
allow httpd_php_t port_type:tcp_socket { send_msg recv_msg };
#line 214

#line 214

#line 214
# XXX Allow binding to any node type.  Remove once
#line 214
# individual rules have been added to all domains that 
#line 214
# bind sockets. 
#line 214
allow httpd_php_t node_type:tcp_socket node_bind;
#line 214
#
#line 214
# Allow access to network files including /etc/resolv.conf
#line 214
#
#line 214
allow httpd_php_t net_conf_t:file { read getattr lock ioctl };
#line 214

#line 214
allow httpd_php_t self:tcp_socket { listen accept };
#line 214

#line 214

#line 214

#line 214
#
#line 214
# Allow the domain to create and use tcp sockets.
#line 214
# Other kinds of sockets must be separately authorized for use.
#line 214
allow httpd_php_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 214

#line 214
allow httpd_php_t unlabeled_t:association { sendto recvfrom };
#line 214

#line 214
#
#line 214
# Allow the domain to send or receive using any network interface.
#line 214
# netif_type is a type attribute for all network interface types.
#line 214
#
#line 214
allow httpd_php_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 214
#
#line 214
# Allow the domain to send to or receive from any node.
#line 214
# node_type is a type attribute for all node types.
#line 214
#
#line 214
allow httpd_php_t node_type:node { tcp_send rawip_send };
#line 214
allow httpd_php_t node_type:node { tcp_recv rawip_recv };
#line 214

#line 214
#
#line 214
# Allow the domain to send to or receive from any port.
#line 214
# port_type is a type attribute for all port types.
#line 214
#
#line 214

#line 214
allow httpd_php_t port_type:tcp_socket { send_msg recv_msg };
#line 214

#line 214

#line 214
# XXX Allow binding to any node type.  Remove once
#line 214
# individual rules have been added to all domains that 
#line 214
# bind sockets. 
#line 214
allow httpd_php_t node_type:tcp_socket node_bind;
#line 214
#
#line 214
# Allow access to network files including /etc/resolv.conf
#line 214
#
#line 214
allow httpd_php_t net_conf_t:file { read getattr lock ioctl };
#line 214

#line 214
allow httpd_php_t self:tcp_socket { connect };
#line 214

#line 214

#line 214

#line 214

#line 214

#line 214
#
#line 214
# Allow the domain to create and use udp sockets.
#line 214
# Other kinds of sockets must be separately authorized for use.
#line 214
allow httpd_php_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 214

#line 214
allow httpd_php_t unlabeled_t:association { sendto recvfrom };
#line 214

#line 214
#
#line 214
# Allow the domain to send or receive using any network interface.
#line 214
# netif_type is a type attribute for all network interface types.
#line 214
#
#line 214
allow httpd_php_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 214
#
#line 214
# Allow the domain to send to or receive from any node.
#line 214
# node_type is a type attribute for all node types.
#line 214
#
#line 214
allow httpd_php_t node_type:node { udp_send rawip_send };
#line 214
allow httpd_php_t node_type:node { udp_recv rawip_recv };
#line 214

#line 214
#
#line 214
# Allow the domain to send to or receive from any port.
#line 214
# port_type is a type attribute for all port types.
#line 214
#
#line 214

#line 214
allow httpd_php_t port_type:udp_socket { send_msg recv_msg };
#line 214

#line 214

#line 214
# XXX Allow binding to any node type.  Remove once
#line 214
# individual rules have been added to all domains that 
#line 214
# bind sockets. 
#line 214
allow httpd_php_t node_type:udp_socket node_bind;
#line 214
#
#line 214
# Allow access to network files including /etc/resolv.conf
#line 214
#
#line 214
allow httpd_php_t net_conf_t:file { read getattr lock ioctl };
#line 214

#line 214
allow httpd_php_t self:udp_socket { connect };
#line 214

#line 214

#line 214

#line 214

#line 214

#line 214

#line 214
allow httpd_php_t var_yp_t:dir { read getattr lock search ioctl };
#line 214
allow httpd_php_t var_yp_t:file { read getattr lock ioctl };
#line 214
allow httpd_php_t var_yp_t:lnk_file { getattr read };
#line 214

#line 214
allow httpd_php_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 214
allow httpd_php_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 214
dontaudit httpd_php_t self:capability net_bind_service;
#line 214
dontaudit httpd_php_t reserved_port_type:tcp_socket name_connect;
#line 214
dontaudit httpd_php_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 214

#line 214
} else {
#line 214
dontaudit httpd_php_t var_yp_t:dir search;
#line 214
}
#line 214
 
#line 214
allow httpd_php_t autofs_t:dir { search getattr };
#line 214


#line 215
allow httpd_php_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 215
allow httpd_php_t lib_t:lnk_file { read getattr lock ioctl };
#line 215
allow httpd_php_t ld_so_t:file { read getattr lock execute ioctl };
#line 215
#allow httpd_php_t ld_so_t:file execute_no_trans;
#line 215
allow httpd_php_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 215
allow httpd_php_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 215
allow httpd_php_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 215
allow httpd_php_t texrel_shlib_t:file execmod;
#line 215
allow httpd_php_t ld_so_cache_t:file { read getattr lock ioctl };
#line 215
allow httpd_php_t device_t:dir search;
#line 215
allow httpd_php_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 215


#line 216
allow httpd_php_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 216


# allow php to read and append to apache logfiles
allow httpd_php_t httpd_log_t:file { ioctl read getattr lock append };

# access to /tmp

#line 222
type httpd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 222

#line 222

#line 222

#line 222

#line 222
#
#line 222
# Allow the process to modify the directory.
#line 222
#
#line 222
allow httpd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 222

#line 222
#
#line 222
# Allow the process to create the file.
#line 222
#
#line 222

#line 222

#line 222

#line 222

#line 222

#line 222
allow httpd_t httpd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 222

#line 222

#line 222

#line 222

#line 222

#line 222

#line 222
allow httpd_t httpd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 222

#line 222

#line 222

#line 222

#line 222

#line 222

#line 222

#line 222

#line 222

#line 222

#line 222

#line 222
type_transition httpd_t tmp_t:{ file dir } httpd_tmp_t;
#line 222

#line 222

#line 222


#line 223
type httpd_php_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 223

#line 223

#line 223

#line 223

#line 223
#
#line 223
# Allow the process to modify the directory.
#line 223
#
#line 223
allow httpd_php_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 223

#line 223
#
#line 223
# Allow the process to create the file.
#line 223
#
#line 223

#line 223

#line 223

#line 223

#line 223

#line 223
allow httpd_php_t httpd_php_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 223

#line 223

#line 223

#line 223

#line 223

#line 223

#line 223
allow httpd_php_t httpd_php_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 223

#line 223

#line 223

#line 223

#line 223

#line 223

#line 223

#line 223

#line 223

#line 223

#line 223

#line 223
type_transition httpd_php_t tmp_t:{ file dir } httpd_php_tmp_t;
#line 223

#line 223

#line 223


# Creation of lock files for apache2

#line 226
type httpd_lock_t, file_type, sysadmfile, lockfile;
#line 226

#line 226

#line 226

#line 226

#line 226
#
#line 226
# Allow the process to modify the directory.
#line 226
#
#line 226
allow httpd_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 226

#line 226
#
#line 226
# Allow the process to create the file.
#line 226
#
#line 226

#line 226

#line 226

#line 226

#line 226

#line 226
allow httpd_t httpd_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 226

#line 226

#line 226

#line 226

#line 226

#line 226

#line 226

#line 226

#line 226

#line 226
type_transition httpd_t var_lock_t:file httpd_lock_t;
#line 226

#line 226

#line 226


# Allow apache to used public_content_t

#line 229

#line 229
allow httpd_t { public_content_t public_content_rw_t } :dir { read getattr lock search ioctl };
#line 229
allow httpd_t { public_content_t public_content_rw_t } :file { read getattr lock ioctl };
#line 229
allow httpd_t { public_content_t public_content_rw_t } :lnk_file { getattr read };
#line 229

#line 229
bool allow_httpd_anon_write false;
#line 229
if (allow_httpd_anon_write) {
#line 229

#line 229
allow httpd_t public_content_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 229
allow httpd_t public_content_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 229
allow httpd_t public_content_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 229

#line 229
}
#line 229


# connect to mysql
#line 241

#line 241

#line 241
allow httpd_php_t mysqld_t:unix_stream_socket connectto;
#line 241

#line 241

#line 241
allow httpd_t mysqld_t:unix_stream_socket connectto;
#line 241

#line 241

#line 241
allow httpd_sys_script_t mysqld_t:unix_stream_socket connectto;
#line 241

#line 241
allow httpd_php_t mysqld_var_run_t:dir search;
#line 241
allow httpd_php_t mysqld_var_run_t:sock_file write;
#line 241
allow { httpd_t httpd_sys_script_t } mysqld_db_t:dir search;
#line 241
allow { httpd_t httpd_sys_script_t } mysqld_db_t:sock_file { ioctl read getattr lock write append };
#line 241
allow { httpd_t httpd_sys_script_t } mysqld_var_run_t:sock_file { ioctl read getattr lock write append };
#line 241

allow httpd_t bin_t:dir search;
allow httpd_t sbin_t:dir search;
allow httpd_t httpd_log_t:dir remove_name;


#line 246

#line 246
# Read global fonts and font config
#line 246

#line 246
allow httpd_t fonts_t:dir { read getattr lock search ioctl };
#line 246
allow httpd_t fonts_t:file { read getattr lock ioctl };
#line 246
allow httpd_t fonts_t:lnk_file { getattr read };
#line 246

#line 246

#line 246
allow httpd_t etc_t:dir { read getattr lock search ioctl };
#line 246
allow httpd_t etc_t:file { read getattr lock ioctl };
#line 246
allow httpd_t etc_t:lnk_file { getattr read };
#line 246

#line 246

#line 246
 

allow httpd_t self:netlink_route_socket { bind create getattr nlmsg_read read write };

allow httpd_t autofs_t:dir { search getattr };

if (use_nfs_home_dirs && httpd_enable_homedirs) {

#line 253

#line 253
allow httpd_t nfs_t:dir { read getattr lock search ioctl };
#line 253
allow httpd_t nfs_t:file { read getattr lock ioctl };
#line 253
allow httpd_t nfs_t:lnk_file { getattr read };
#line 253

#line 253

#line 253
allow httpd_suexec_t nfs_t:dir { read getattr lock search ioctl };
#line 253
allow httpd_suexec_t nfs_t:file { read getattr lock ioctl };
#line 253
allow httpd_suexec_t nfs_t:lnk_file { getattr read };
#line 253

#line 253

#line 253
allow httpd_suexec_t nfs_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 253

#line 253

}
if (use_samba_home_dirs && httpd_enable_homedirs) {

#line 256

#line 256
allow httpd_t cifs_t:dir { read getattr lock search ioctl };
#line 256
allow httpd_t cifs_t:file { read getattr lock ioctl };
#line 256
allow httpd_t cifs_t:lnk_file { getattr read };
#line 256

#line 256

#line 256
allow httpd_suexec_t cifs_t:dir { read getattr lock search ioctl };
#line 256
allow httpd_suexec_t cifs_t:file { read getattr lock ioctl };
#line 256
allow httpd_suexec_t cifs_t:lnk_file { getattr read };
#line 256

#line 256

#line 256
allow httpd_suexec_t cifs_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 256

#line 256

}

#
# Allow users to mount additional directories as http_source
#
allow httpd_t mnt_t:dir { read getattr lock search ioctl };

#line 272

#line 272

#line 272

#line 272

#line 272
#
#line 272
# Allow the process to transition to the new domain.
#line 272
#
#line 272
allow unconfined_t httpd_t:process transition;
#line 272

#line 272
#
#line 272
# Do not audit when glibc secure mode is enabled upon the transition.
#line 272
#
#line 272
dontaudit unconfined_t httpd_t:process noatsecure;
#line 272

#line 272
#
#line 272
# Do not audit when signal-related state is cleared upon the transition.
#line 272
#
#line 272
dontaudit unconfined_t httpd_t:process siginh;
#line 272

#line 272
#
#line 272
# Do not audit when resource limits are reset upon the transition.
#line 272
#
#line 272
dontaudit unconfined_t httpd_t:process rlimitinh;
#line 272

#line 272
#
#line 272
# Allow the process to execute the program.
#line 272
# 
#line 272
allow unconfined_t httpd_exec_t:file { read { getattr execute } };
#line 272

#line 272
#
#line 272
# Allow the process to reap the new domain.
#line 272
#
#line 272
allow httpd_t unconfined_t:process sigchld;
#line 272

#line 272
#
#line 272
# Allow the new domain to inherit and use file 
#line 272
# descriptions from the creating process and vice versa.
#line 272
#
#line 272
allow httpd_t unconfined_t:fd use;
#line 272
allow unconfined_t httpd_t:fd use;
#line 272

#line 272
#
#line 272
# Allow the new domain to write back to the old domain via a pipe.
#line 272
#
#line 272
allow httpd_t unconfined_t:fifo_file { ioctl read getattr lock write append };
#line 272

#line 272
#
#line 272
# Allow the new domain to read and execute the program.
#line 272
#
#line 272
allow httpd_t httpd_exec_t:file { read getattr lock execute ioctl };
#line 272

#line 272
#
#line 272
# Allow the new domain to be entered via the program.
#line 272
#
#line 272
allow httpd_t httpd_exec_t:file entrypoint;
#line 272

#line 272
type_transition unconfined_t httpd_exec_t:process httpd_t;
#line 272

#line 272
typealias httpd_sys_content_t alias httpd_user_content_t;
#line 272
typealias httpd_sys_script_exec_t alias httpd_user_script_exec_t;
#line 272

#line 272
if (httpd_enable_homedirs) {
#line 272
allow { httpd_t httpd_sys_script_t httpd_suexec_t } user_home_dir_t:dir { getattr search };
#line 272
}
#line 272
 
#line 274
# We no longer call httpd_domain(sysadm), but need httpd_sysadm_content_t for file context
typealias httpd_sys_content_t alias httpd_sysadm_content_t;

#line 285

#line 285
#
#line 285
# mod_jk2 creates /var/log/httpd/jk2.shm to communicate with tomcat
#line 285
# This is a bug but it still exists in FC2
#line 285
#
#line 285
typealias httpd_log_t  alias httpd_runtime_t;
#line 285
allow { httpd_t httpd_sys_script_t } httpd_runtime_t:file { getattr append };
#line 285
dontaudit httpd_t httpd_runtime_t:file ioctl;
#line 285
 #
#line 287
# Customer reported the following
#
#line 294

#line 294
dontaudit httpd_t snmpd_var_lib_t:dir search;
#line 294
dontaudit httpd_t snmpd_var_lib_t:file { getattr write read };
#line 294



#line 296
type httpd_helper_t, domain, privlog ;
#line 296
type httpd_helper_exec_t, file_type, sysadmfile, exec_type;
#line 296
role sysadm_r types httpd_helper_t;
#line 296

#line 296
role system_r types httpd_helper_t;
#line 296

#line 296

#line 296

#line 296

#line 296
#
#line 296
# Allow the process to transition to the new domain.
#line 296
#
#line 296
allow sysadm_t httpd_helper_t:process transition;
#line 296

#line 296
#
#line 296
# Do not audit when glibc secure mode is enabled upon the transition.
#line 296
#
#line 296
dontaudit sysadm_t httpd_helper_t:process noatsecure;
#line 296

#line 296
#
#line 296
# Do not audit when signal-related state is cleared upon the transition.
#line 296
#
#line 296
dontaudit sysadm_t httpd_helper_t:process siginh;
#line 296

#line 296
#
#line 296
# Do not audit when resource limits are reset upon the transition.
#line 296
#
#line 296
dontaudit sysadm_t httpd_helper_t:process rlimitinh;
#line 296

#line 296
#
#line 296
# Allow the process to execute the program.
#line 296
# 
#line 296
allow sysadm_t httpd_helper_exec_t:file { read { getattr execute } };
#line 296

#line 296
#
#line 296
# Allow the process to reap the new domain.
#line 296
#
#line 296
allow httpd_helper_t sysadm_t:process sigchld;
#line 296

#line 296
#
#line 296
# Allow the new domain to inherit and use file 
#line 296
# descriptions from the creating process and vice versa.
#line 296
#
#line 296
allow httpd_helper_t sysadm_t:fd use;
#line 296
allow sysadm_t httpd_helper_t:fd use;
#line 296

#line 296
#
#line 296
# Allow the new domain to write back to the old domain via a pipe.
#line 296
#
#line 296
allow httpd_helper_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 296

#line 296
#
#line 296
# Allow the new domain to read and execute the program.
#line 296
#
#line 296
allow httpd_helper_t httpd_helper_exec_t:file { read getattr lock execute ioctl };
#line 296

#line 296
#
#line 296
# Allow the new domain to be entered via the program.
#line 296
#
#line 296
allow httpd_helper_t httpd_helper_exec_t:file entrypoint;
#line 296

#line 296
type_transition sysadm_t httpd_helper_exec_t:process httpd_helper_t;
#line 296

#line 296

#line 296
allow httpd_helper_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 296
allow httpd_helper_t lib_t:lnk_file { read getattr lock ioctl };
#line 296
allow httpd_helper_t ld_so_t:file { read getattr lock execute ioctl };
#line 296
#allow httpd_helper_t ld_so_t:file execute_no_trans;
#line 296
allow httpd_helper_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 296
allow httpd_helper_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 296
allow httpd_helper_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 296
allow httpd_helper_t texrel_shlib_t:file execmod;
#line 296
allow httpd_helper_t ld_so_cache_t:file { read getattr lock ioctl };
#line 296
allow httpd_helper_t device_t:dir search;
#line 296
allow httpd_helper_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 296

#line 296

role system_r types httpd_helper_t;

#line 298

#line 298

#line 298
#
#line 298
# Allow the process to transition to the new domain.
#line 298
#
#line 298
allow httpd_t httpd_helper_t:process transition;
#line 298

#line 298
#
#line 298
# Do not audit when glibc secure mode is enabled upon the transition.
#line 298
#
#line 298
dontaudit httpd_t httpd_helper_t:process noatsecure;
#line 298

#line 298
#
#line 298
# Do not audit when signal-related state is cleared upon the transition.
#line 298
#
#line 298
dontaudit httpd_t httpd_helper_t:process siginh;
#line 298

#line 298
#
#line 298
# Do not audit when resource limits are reset upon the transition.
#line 298
#
#line 298
dontaudit httpd_t httpd_helper_t:process rlimitinh;
#line 298

#line 298
#
#line 298
# Allow the process to execute the program.
#line 298
# 
#line 298
allow httpd_t httpd_helper_exec_t:file { read { getattr execute } };
#line 298

#line 298
#
#line 298
# Allow the process to reap the new domain.
#line 298
#
#line 298
allow httpd_helper_t httpd_t:process sigchld;
#line 298

#line 298
#
#line 298
# Allow the new domain to inherit and use file 
#line 298
# descriptions from the creating process and vice versa.
#line 298
#
#line 298
allow httpd_helper_t httpd_t:fd use;
#line 298
allow httpd_t httpd_helper_t:fd use;
#line 298

#line 298
#
#line 298
# Allow the new domain to write back to the old domain via a pipe.
#line 298
#
#line 298
allow httpd_helper_t httpd_t:fifo_file { ioctl read getattr lock write append };
#line 298

#line 298
#
#line 298
# Allow the new domain to read and execute the program.
#line 298
#
#line 298
allow httpd_helper_t httpd_helper_exec_t:file { read getattr lock execute ioctl };
#line 298

#line 298
#
#line 298
# Allow the new domain to be entered via the program.
#line 298
#
#line 298
allow httpd_helper_t httpd_helper_exec_t:file entrypoint;
#line 298

#line 298
type_transition httpd_t httpd_helper_exec_t:process httpd_helper_t;
#line 298

allow httpd_helper_t httpd_config_t:file { getattr read };
allow httpd_helper_t httpd_log_t:file { append };

########################################
# When the admin starts the server, the server wants to access
# the TTY or PTY associated with the session. The httpd appears
# to run correctly without this permission, so the permission
# are dontaudited here. 
##################################################

if (httpd_tty_comm) {
allow { httpd_t httpd_helper_t } devpts_t:dir search;
#line 313

#line 313
allow { httpd_helper_t httpd_t } { devtty_t devpts_t }:chr_file { ioctl read getattr lock write append };
#line 313

allow { httpd_t httpd_helper_t } admin_tty_type:chr_file { ioctl read getattr lock write append };
} else {
dontaudit httpd_t admin_tty_type:chr_file { ioctl read getattr lock write append };
}


#line 319
# Read system variables in /sys.
#line 319

#line 319
allow httpd_sys_script_t sysctl_t:dir search;
#line 319
allow httpd_sys_script_t sysctl_kernel_t:dir search;
#line 319
allow httpd_sys_script_t sysctl_kernel_t:file { getattr read };
#line 319

#line 319

#line 319

allow httpd_sys_script_t var_lib_t:dir search;
dontaudit httpd_t selinux_config_t:dir search;

#line 322
allow httpd_t cert_t:dir { read getattr lock search ioctl };
#line 322
allow httpd_t cert_t:file { read getattr lock ioctl };
#line 322
allow httpd_t cert_t:lnk_file { getattr read };
#line 322


#
# unconfined domain for apache scripts.  Only to be used as a last resort
#
type httpd_unconfined_script_exec_t, file_type, sysadmfile, customizable;
type httpd_unconfined_script_t, domain, nscd_client_domain;
role system_r types httpd_unconfined_script_t;

#line 330

#line 330
typeattribute httpd_unconfined_script_t unrestricted;
#line 330
typeattribute httpd_unconfined_script_t privuser;
#line 330

#line 330
# Mount/unmount any filesystem. 
#line 330
allow httpd_unconfined_script_t fs_type:filesystem *;
#line 330

#line 330
# Mount/unmount any filesystem with the context= option. 
#line 330
allow httpd_unconfined_script_t file_type:filesystem *;
#line 330

#line 330
# Create/access any file in a labeled filesystem;
#line 330
allow httpd_unconfined_script_t file_type:{ file chr_file } ~execmod;
#line 330
allow httpd_unconfined_script_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 330
allow httpd_unconfined_script_t sysctl_t:{ dir file } *;
#line 330
allow httpd_unconfined_script_t device_type:{ chr_file blk_file } *;
#line 330
allow httpd_unconfined_script_t mtrr_device_t:file *;
#line 330

#line 330
# Create/access other files.  fs_type is to pick up various
#line 330
# pseudo filesystem types that are applied to both the filesystem
#line 330
# and its files.
#line 330
allow httpd_unconfined_script_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 330
allow httpd_unconfined_script_t unlabeled_t:association { sendto recvfrom };
#line 330

#line 330
allow httpd_unconfined_script_t proc_fs:{ dir file } *;
#line 330

#line 330
# For /proc/pid
#line 330

#line 330
allow httpd_unconfined_script_t domain:dir { read getattr lock search ioctl };
#line 330
allow httpd_unconfined_script_t domain:file { read getattr lock ioctl };
#line 330
allow httpd_unconfined_script_t domain:lnk_file { getattr read };
#line 330

#line 330
# Write access is for setting attributes under /proc/self/attr.
#line 330
allow httpd_unconfined_script_t self:file { ioctl read getattr lock write append };
#line 330

#line 330
# Read and write sysctls.
#line 330

#line 330
allow httpd_unconfined_script_t sysctl_type:dir { read getattr lock search ioctl };
#line 330
allow httpd_unconfined_script_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 330

#line 330

#line 330
# Access the network.
#line 330
allow httpd_unconfined_script_t node_type:node *;
#line 330
allow httpd_unconfined_script_t netif_type:netif *;
#line 330
allow httpd_unconfined_script_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 330
allow httpd_unconfined_script_t port_type:tcp_socket name_connect;
#line 330

#line 330
# Bind to any network address.
#line 330
allow httpd_unconfined_script_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 330
allow httpd_unconfined_script_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 330
allow httpd_unconfined_script_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 330

#line 330
# Use/sendto/connectto sockets created by any domain.
#line 330
allow httpd_unconfined_script_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 330

#line 330
# Use descriptors and pipes created by any domain.
#line 330
allow httpd_unconfined_script_t domain:fd use;
#line 330
allow httpd_unconfined_script_t domain:fifo_file { ioctl read getattr lock write append };
#line 330

#line 330
# Act upon any other process.
#line 330
allow httpd_unconfined_script_t domain:process ~{ transition dyntransition execmem };
#line 330
# Transition to myself, to make get_ordered_context_list happy.
#line 330
allow httpd_unconfined_script_t self:process transition;
#line 330

#line 330
if (allow_execmem) {
#line 330
# Allow making anonymous memory executable, e.g. 
#line 330
# for runtime-code generation or executable stack.
#line 330
allow httpd_unconfined_script_t self:process execmem;
#line 330
}
#line 330

#line 330
if (allow_execmem && allow_execstack) {
#line 330
# Allow making the stack executable via mprotect.
#line 330
allow httpd_unconfined_script_t self:process execstack;
#line 330
}
#line 330

#line 330
if (allow_execmod) {
#line 330
# Allow text relocations on system shared libraries, e.g. libGL.
#line 330

#line 330
allow httpd_unconfined_script_t file_type:file execmod;
#line 330

#line 330
}
#line 330

#line 330
# Create/access any System V IPC objects.
#line 330
allow httpd_unconfined_script_t domain:{ sem msgq shm } *;
#line 330
allow httpd_unconfined_script_t domain:msg  { send receive };
#line 330

#line 330
# Access the security API.
#line 330
if (!secure_mode_policyload) {
#line 330
allow httpd_unconfined_script_t security_t:security *;
#line 330
auditallow httpd_unconfined_script_t security_t:security { load_policy setenforce setbool };
#line 330
}
#line 330
# Perform certain system operations that lacked individual capabilities.
#line 330
allow httpd_unconfined_script_t kernel_t:system *;
#line 330

#line 330
# Use any Linux capability.
#line 330
allow httpd_unconfined_script_t self:capability *;
#line 330

#line 330
# Set user information and skip authentication.
#line 330
allow httpd_unconfined_script_t self:passwd *;
#line 330

#line 330
# Communicate via dbusd.
#line 330
allow httpd_unconfined_script_t self:dbus *;
#line 330

#line 330
allow httpd_unconfined_script_t system_dbusd_t:dbus *;
#line 330

#line 330

#line 330
# Get info via nscd.
#line 330
allow httpd_unconfined_script_t self:nscd *;
#line 330

#line 330
allow httpd_unconfined_script_t nscd_t:nscd *;
#line 330

#line 330

#line 330


# The following are types for SUEXEC,which runs user scripts as their
# own user ID
#

#line 335
# httpd_t is the parent domain (or domains), httpd_suexec_t is the child domain,
#line 335
# and , transitionbool is any attributes to apply to the child
#line 335
type httpd_suexec_t, domain, privlog, daemon , transitionbool;
#line 335
type httpd_suexec_exec_t, file_type, sysadmfile, exec_type;
#line 335

#line 335
role system_r types httpd_suexec_t;
#line 335

#line 335

#line 335

#line 335
bool httpd_suexec_disable_trans false;
#line 335

#line 335
if (! httpd_suexec_disable_trans) {
#line 335

#line 335

#line 335

#line 335
#
#line 335
# Allow the process to transition to the new domain.
#line 335
#
#line 335
allow httpd_t httpd_suexec_t:process transition;
#line 335

#line 335
#
#line 335
# Do not audit when glibc secure mode is enabled upon the transition.
#line 335
#
#line 335
dontaudit httpd_t httpd_suexec_t:process noatsecure;
#line 335

#line 335
#
#line 335
# Do not audit when signal-related state is cleared upon the transition.
#line 335
#
#line 335
dontaudit httpd_t httpd_suexec_t:process siginh;
#line 335

#line 335
#
#line 335
# Do not audit when resource limits are reset upon the transition.
#line 335
#
#line 335
dontaudit httpd_t httpd_suexec_t:process rlimitinh;
#line 335

#line 335
#
#line 335
# Allow the process to execute the program.
#line 335
# 
#line 335
allow httpd_t httpd_suexec_exec_t:file { read { getattr execute } };
#line 335

#line 335
#
#line 335
# Allow the process to reap the new domain.
#line 335
#
#line 335
allow httpd_suexec_t httpd_t:process sigchld;
#line 335

#line 335
#
#line 335
# Allow the new domain to inherit and use file 
#line 335
# descriptions from the creating process and vice versa.
#line 335
#
#line 335
allow httpd_suexec_t httpd_t:fd use;
#line 335
allow httpd_t httpd_suexec_t:fd use;
#line 335

#line 335
#
#line 335
# Allow the new domain to write back to the old domain via a pipe.
#line 335
#
#line 335
allow httpd_suexec_t httpd_t:fifo_file { ioctl read getattr lock write append };
#line 335

#line 335
#
#line 335
# Allow the new domain to read and execute the program.
#line 335
#
#line 335
allow httpd_suexec_t httpd_suexec_exec_t:file { read getattr lock execute ioctl };
#line 335

#line 335
#
#line 335
# Allow the new domain to be entered via the program.
#line 335
#
#line 335
allow httpd_suexec_t httpd_suexec_exec_t:file entrypoint;
#line 335

#line 335
type_transition httpd_t httpd_suexec_exec_t:process httpd_suexec_t;
#line 335

#line 335
}
#line 335

#line 335
;
#line 335
# Inherit and use descriptors from parent.
#line 335
allow httpd_suexec_t httpd_t:fd use;
#line 335
allow httpd_suexec_t httpd_t:process sigchld;
#line 335

#line 335
allow httpd_suexec_t self:process { sigchld sigkill sigstop signull signal };
#line 335

#line 335

#line 335
allow httpd_suexec_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 335
allow httpd_suexec_t lib_t:lnk_file { read getattr lock ioctl };
#line 335
allow httpd_suexec_t ld_so_t:file { read getattr lock execute ioctl };
#line 335
#allow httpd_suexec_t ld_so_t:file execute_no_trans;
#line 335
allow httpd_suexec_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 335
allow httpd_suexec_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 335
allow httpd_suexec_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 335
allow httpd_suexec_t texrel_shlib_t:file execmod;
#line 335
allow httpd_suexec_t ld_so_cache_t:file { read getattr lock ioctl };
#line 335
allow httpd_suexec_t device_t:dir search;
#line 335
allow httpd_suexec_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 335

#line 335

#line 335
allow httpd_suexec_t { self proc_t }:dir { read getattr lock search ioctl };
#line 335
allow httpd_suexec_t { self proc_t }:lnk_file read;
#line 335

#line 335
allow httpd_suexec_t device_t:dir getattr;
#line 335

allow httpd_t httpd_suexec_exec_t:file { getattr read };

#########################################################
# Permissions for running child processes and scripts
##########################################################

allow httpd_suexec_t self:capability { setuid setgid };

dontaudit httpd_suexec_t var_run_t:dir search;
allow httpd_suexec_t { var_t var_log_t }:dir search;
allow httpd_suexec_t home_root_t:dir search;

allow httpd_suexec_t httpd_log_t:dir { read getattr lock search ioctl add_name write };
allow httpd_suexec_t httpd_log_t:file { create { ioctl read getattr lock append } };
allow httpd_suexec_t httpd_t:fifo_file getattr;
allow httpd_suexec_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

allow httpd_suexec_t etc_t:file { getattr read };

#line 354
allow httpd_suexec_t etc_t:lnk_file read;
#line 354
allow httpd_suexec_t lib_t:file { read getattr lock ioctl };
#line 354

#line 354
allow httpd_suexec_t locale_t:dir { read getattr lock search ioctl };
#line 354
allow httpd_suexec_t locale_t:file { read getattr lock ioctl };
#line 354
allow httpd_suexec_t locale_t:lnk_file { getattr read };
#line 354

#line 354


#line 355
# Read system variables in /sys.
#line 355

#line 355
allow httpd_suexec_t sysctl_t:dir search;
#line 355
allow httpd_suexec_t sysctl_kernel_t:dir search;
#line 355
allow httpd_suexec_t sysctl_kernel_t:file { getattr read };
#line 355

#line 355

#line 355

allow httpd_suexec_t urandom_device_t:chr_file { getattr read };

# for shell scripts
allow httpd_suexec_t bin_t:dir { read getattr lock search ioctl };
allow httpd_suexec_t bin_t:lnk_file read;

#line 361
allow httpd_suexec_t { bin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 361


if (httpd_can_network_connect) {

#line 364

#line 364

#line 364

#line 364

#line 364

#line 364
#
#line 364
# Allow the domain to create and use tcp sockets.
#line 364
# Other kinds of sockets must be separately authorized for use.
#line 364
allow httpd_suexec_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 364

#line 364
allow httpd_suexec_t unlabeled_t:association { sendto recvfrom };
#line 364

#line 364
#
#line 364
# Allow the domain to send or receive using any network interface.
#line 364
# netif_type is a type attribute for all network interface types.
#line 364
#
#line 364
allow httpd_suexec_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 364
#
#line 364
# Allow the domain to send to or receive from any node.
#line 364
# node_type is a type attribute for all node types.
#line 364
#
#line 364
allow httpd_suexec_t node_type:node { tcp_send rawip_send };
#line 364
allow httpd_suexec_t node_type:node { tcp_recv rawip_recv };
#line 364

#line 364
#
#line 364
# Allow the domain to send to or receive from any port.
#line 364
# port_type is a type attribute for all port types.
#line 364
#
#line 364

#line 364
allow httpd_suexec_t port_type:tcp_socket { send_msg recv_msg };
#line 364

#line 364

#line 364
# XXX Allow binding to any node type.  Remove once
#line 364
# individual rules have been added to all domains that 
#line 364
# bind sockets. 
#line 364
allow httpd_suexec_t node_type:tcp_socket node_bind;
#line 364
#
#line 364
# Allow access to network files including /etc/resolv.conf
#line 364
#
#line 364
allow httpd_suexec_t net_conf_t:file { read getattr lock ioctl };
#line 364

#line 364
allow httpd_suexec_t self:tcp_socket { listen accept };
#line 364

#line 364

#line 364

#line 364
#
#line 364
# Allow the domain to create and use tcp sockets.
#line 364
# Other kinds of sockets must be separately authorized for use.
#line 364
allow httpd_suexec_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 364

#line 364
allow httpd_suexec_t unlabeled_t:association { sendto recvfrom };
#line 364

#line 364
#
#line 364
# Allow the domain to send or receive using any network interface.
#line 364
# netif_type is a type attribute for all network interface types.
#line 364
#
#line 364
allow httpd_suexec_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 364
#
#line 364
# Allow the domain to send to or receive from any node.
#line 364
# node_type is a type attribute for all node types.
#line 364
#
#line 364
allow httpd_suexec_t node_type:node { tcp_send rawip_send };
#line 364
allow httpd_suexec_t node_type:node { tcp_recv rawip_recv };
#line 364

#line 364
#
#line 364
# Allow the domain to send to or receive from any port.
#line 364
# port_type is a type attribute for all port types.
#line 364
#
#line 364

#line 364
allow httpd_suexec_t port_type:tcp_socket { send_msg recv_msg };
#line 364

#line 364

#line 364
# XXX Allow binding to any node type.  Remove once
#line 364
# individual rules have been added to all domains that 
#line 364
# bind sockets. 
#line 364
allow httpd_suexec_t node_type:tcp_socket node_bind;
#line 364
#
#line 364
# Allow access to network files including /etc/resolv.conf
#line 364
#
#line 364
allow httpd_suexec_t net_conf_t:file { read getattr lock ioctl };
#line 364

#line 364
allow httpd_suexec_t self:tcp_socket { connect };
#line 364

#line 364

#line 364

#line 364

#line 364

#line 364
#
#line 364
# Allow the domain to create and use udp sockets.
#line 364
# Other kinds of sockets must be separately authorized for use.
#line 364
allow httpd_suexec_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 364

#line 364
allow httpd_suexec_t unlabeled_t:association { sendto recvfrom };
#line 364

#line 364
#
#line 364
# Allow the domain to send or receive using any network interface.
#line 364
# netif_type is a type attribute for all network interface types.
#line 364
#
#line 364
allow httpd_suexec_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 364
#
#line 364
# Allow the domain to send to or receive from any node.
#line 364
# node_type is a type attribute for all node types.
#line 364
#
#line 364
allow httpd_suexec_t node_type:node { udp_send rawip_send };
#line 364
allow httpd_suexec_t node_type:node { udp_recv rawip_recv };
#line 364

#line 364
#
#line 364
# Allow the domain to send to or receive from any port.
#line 364
# port_type is a type attribute for all port types.
#line 364
#
#line 364

#line 364
allow httpd_suexec_t port_type:udp_socket { send_msg recv_msg };
#line 364

#line 364

#line 364
# XXX Allow binding to any node type.  Remove once
#line 364
# individual rules have been added to all domains that 
#line 364
# bind sockets. 
#line 364
allow httpd_suexec_t node_type:udp_socket node_bind;
#line 364
#
#line 364
# Allow access to network files including /etc/resolv.conf
#line 364
#
#line 364
allow httpd_suexec_t net_conf_t:file { read getattr lock ioctl };
#line 364

#line 364
allow httpd_suexec_t self:udp_socket { connect };
#line 364

#line 364

#line 364

#line 364

#line 364

allow httpd_suexec_t port_type:tcp_socket name_connect;
}


#line 368

#line 368
if (allow_ypbind) {
#line 368

#line 368

#line 368

#line 368

#line 368

#line 368

#line 368

#line 368
#
#line 368
# Allow the domain to create and use tcp sockets.
#line 368
# Other kinds of sockets must be separately authorized for use.
#line 368
allow httpd_suexec_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 368

#line 368
allow httpd_suexec_t unlabeled_t:association { sendto recvfrom };
#line 368

#line 368
#
#line 368
# Allow the domain to send or receive using any network interface.
#line 368
# netif_type is a type attribute for all network interface types.
#line 368
#
#line 368
allow httpd_suexec_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 368
#
#line 368
# Allow the domain to send to or receive from any node.
#line 368
# node_type is a type attribute for all node types.
#line 368
#
#line 368
allow httpd_suexec_t node_type:node { tcp_send rawip_send };
#line 368
allow httpd_suexec_t node_type:node { tcp_recv rawip_recv };
#line 368

#line 368
#
#line 368
# Allow the domain to send to or receive from any port.
#line 368
# port_type is a type attribute for all port types.
#line 368
#
#line 368

#line 368
allow httpd_suexec_t port_type:tcp_socket { send_msg recv_msg };
#line 368

#line 368

#line 368
# XXX Allow binding to any node type.  Remove once
#line 368
# individual rules have been added to all domains that 
#line 368
# bind sockets. 
#line 368
allow httpd_suexec_t node_type:tcp_socket node_bind;
#line 368
#
#line 368
# Allow access to network files including /etc/resolv.conf
#line 368
#
#line 368
allow httpd_suexec_t net_conf_t:file { read getattr lock ioctl };
#line 368

#line 368
allow httpd_suexec_t self:tcp_socket { listen accept };
#line 368

#line 368

#line 368

#line 368
#
#line 368
# Allow the domain to create and use tcp sockets.
#line 368
# Other kinds of sockets must be separately authorized for use.
#line 368
allow httpd_suexec_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 368

#line 368
allow httpd_suexec_t unlabeled_t:association { sendto recvfrom };
#line 368

#line 368
#
#line 368
# Allow the domain to send or receive using any network interface.
#line 368
# netif_type is a type attribute for all network interface types.
#line 368
#
#line 368
allow httpd_suexec_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 368
#
#line 368
# Allow the domain to send to or receive from any node.
#line 368
# node_type is a type attribute for all node types.
#line 368
#
#line 368
allow httpd_suexec_t node_type:node { tcp_send rawip_send };
#line 368
allow httpd_suexec_t node_type:node { tcp_recv rawip_recv };
#line 368

#line 368
#
#line 368
# Allow the domain to send to or receive from any port.
#line 368
# port_type is a type attribute for all port types.
#line 368
#
#line 368

#line 368
allow httpd_suexec_t port_type:tcp_socket { send_msg recv_msg };
#line 368

#line 368

#line 368
# XXX Allow binding to any node type.  Remove once
#line 368
# individual rules have been added to all domains that 
#line 368
# bind sockets. 
#line 368
allow httpd_suexec_t node_type:tcp_socket node_bind;
#line 368
#
#line 368
# Allow access to network files including /etc/resolv.conf
#line 368
#
#line 368
allow httpd_suexec_t net_conf_t:file { read getattr lock ioctl };
#line 368

#line 368
allow httpd_suexec_t self:tcp_socket { connect };
#line 368

#line 368

#line 368

#line 368

#line 368

#line 368
#
#line 368
# Allow the domain to create and use udp sockets.
#line 368
# Other kinds of sockets must be separately authorized for use.
#line 368
allow httpd_suexec_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 368

#line 368
allow httpd_suexec_t unlabeled_t:association { sendto recvfrom };
#line 368

#line 368
#
#line 368
# Allow the domain to send or receive using any network interface.
#line 368
# netif_type is a type attribute for all network interface types.
#line 368
#
#line 368
allow httpd_suexec_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 368
#
#line 368
# Allow the domain to send to or receive from any node.
#line 368
# node_type is a type attribute for all node types.
#line 368
#
#line 368
allow httpd_suexec_t node_type:node { udp_send rawip_send };
#line 368
allow httpd_suexec_t node_type:node { udp_recv rawip_recv };
#line 368

#line 368
#
#line 368
# Allow the domain to send to or receive from any port.
#line 368
# port_type is a type attribute for all port types.
#line 368
#
#line 368

#line 368
allow httpd_suexec_t port_type:udp_socket { send_msg recv_msg };
#line 368

#line 368

#line 368
# XXX Allow binding to any node type.  Remove once
#line 368
# individual rules have been added to all domains that 
#line 368
# bind sockets. 
#line 368
allow httpd_suexec_t node_type:udp_socket node_bind;
#line 368
#
#line 368
# Allow access to network files including /etc/resolv.conf
#line 368
#
#line 368
allow httpd_suexec_t net_conf_t:file { read getattr lock ioctl };
#line 368

#line 368
allow httpd_suexec_t self:udp_socket { connect };
#line 368

#line 368

#line 368

#line 368

#line 368

#line 368

#line 368
allow httpd_suexec_t var_yp_t:dir { read getattr lock search ioctl };
#line 368
allow httpd_suexec_t var_yp_t:file { read getattr lock ioctl };
#line 368
allow httpd_suexec_t var_yp_t:lnk_file { getattr read };
#line 368

#line 368
allow httpd_suexec_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 368
allow httpd_suexec_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 368
dontaudit httpd_suexec_t self:capability net_bind_service;
#line 368
dontaudit httpd_suexec_t reserved_port_type:tcp_socket name_connect;
#line 368
dontaudit httpd_suexec_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 368

#line 368
} else {
#line 368
dontaudit httpd_suexec_t var_yp_t:dir search;
#line 368
}
#line 368
 
allow httpd_suexec_t { usr_t lib_t }:file { getattr read ioctl };

allow httpd_suexec_t autofs_t:dir { search getattr };

#line 372
type httpd_suexec_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 372

#line 372

#line 372

#line 372

#line 372
#
#line 372
# Allow the process to modify the directory.
#line 372
#
#line 372
allow httpd_suexec_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 372

#line 372
#
#line 372
# Allow the process to create the file.
#line 372
#
#line 372

#line 372

#line 372

#line 372

#line 372

#line 372
allow httpd_suexec_t httpd_suexec_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 372

#line 372

#line 372

#line 372

#line 372

#line 372

#line 372
allow httpd_suexec_t httpd_suexec_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 372

#line 372

#line 372

#line 372

#line 372

#line 372

#line 372

#line 372

#line 372

#line 372

#line 372

#line 372
type_transition httpd_suexec_t tmp_t:{ file dir } httpd_suexec_tmp_t;
#line 372

#line 372

#line 372


if (httpd_enable_cgi && httpd_unified) {

#line 375

#line 375

#line 375
#
#line 375
# Allow the process to transition to the new domain.
#line 375
#
#line 375
allow httpd_suexec_t httpd_sys_script_t:process transition;
#line 375

#line 375
#
#line 375
# Do not audit when glibc secure mode is enabled upon the transition.
#line 375
#
#line 375
dontaudit httpd_suexec_t httpd_sys_script_t:process noatsecure;
#line 375

#line 375
#
#line 375
# Do not audit when signal-related state is cleared upon the transition.
#line 375
#
#line 375
dontaudit httpd_suexec_t httpd_sys_script_t:process siginh;
#line 375

#line 375
#
#line 375
# Do not audit when resource limits are reset upon the transition.
#line 375
#
#line 375
dontaudit httpd_suexec_t httpd_sys_script_t:process rlimitinh;
#line 375

#line 375
#
#line 375
# Allow the process to execute the program.
#line 375
# 
#line 375
allow httpd_suexec_t httpdcontent:file { read { getattr execute } };
#line 375

#line 375
#
#line 375
# Allow the process to reap the new domain.
#line 375
#
#line 375
allow httpd_sys_script_t httpd_suexec_t:process sigchld;
#line 375

#line 375
#
#line 375
# Allow the new domain to inherit and use file 
#line 375
# descriptions from the creating process and vice versa.
#line 375
#
#line 375
allow httpd_sys_script_t httpd_suexec_t:fd use;
#line 375
allow httpd_suexec_t httpd_sys_script_t:fd use;
#line 375

#line 375
#
#line 375
# Allow the new domain to write back to the old domain via a pipe.
#line 375
#
#line 375
allow httpd_sys_script_t httpd_suexec_t:fifo_file { ioctl read getattr lock write append };
#line 375

#line 375
#
#line 375
# Allow the new domain to read and execute the program.
#line 375
#
#line 375
allow httpd_sys_script_t httpdcontent:file { read getattr lock execute ioctl };
#line 375

#line 375
#
#line 375
# Allow the new domain to be entered via the program.
#line 375
#
#line 375
allow httpd_sys_script_t httpdcontent:file entrypoint;
#line 375

#line 375
type_transition httpd_suexec_t httpdcontent:process httpd_sys_script_t;
#line 375

#line 378

}
if (httpd_enable_cgi && httpd_unified && httpd_builtin_scripting) {

#line 381

#line 381

#line 381
#
#line 381
# Allow the process to transition to the new domain.
#line 381
#
#line 381
allow httpd_t httpd_sys_script_t:process transition;
#line 381

#line 381
#
#line 381
# Do not audit when glibc secure mode is enabled upon the transition.
#line 381
#
#line 381
dontaudit httpd_t httpd_sys_script_t:process noatsecure;
#line 381

#line 381
#
#line 381
# Do not audit when signal-related state is cleared upon the transition.
#line 381
#
#line 381
dontaudit httpd_t httpd_sys_script_t:process siginh;
#line 381

#line 381
#
#line 381
# Do not audit when resource limits are reset upon the transition.
#line 381
#
#line 381
dontaudit httpd_t httpd_sys_script_t:process rlimitinh;
#line 381

#line 381
#
#line 381
# Allow the process to execute the program.
#line 381
# 
#line 381
allow httpd_t httpdcontent:file { read { getattr execute } };
#line 381

#line 381
#
#line 381
# Allow the process to reap the new domain.
#line 381
#
#line 381
allow httpd_sys_script_t httpd_t:process sigchld;
#line 381

#line 381
#
#line 381
# Allow the new domain to inherit and use file 
#line 381
# descriptions from the creating process and vice versa.
#line 381
#
#line 381
allow httpd_sys_script_t httpd_t:fd use;
#line 381
allow httpd_t httpd_sys_script_t:fd use;
#line 381

#line 381
#
#line 381
# Allow the new domain to write back to the old domain via a pipe.
#line 381
#
#line 381
allow httpd_sys_script_t httpd_t:fifo_file { ioctl read getattr lock write append };
#line 381

#line 381
#
#line 381
# Allow the new domain to read and execute the program.
#line 381
#
#line 381
allow httpd_sys_script_t httpdcontent:file { read getattr lock execute ioctl };
#line 381

#line 381
#
#line 381
# Allow the new domain to be entered via the program.
#line 381
#
#line 381
allow httpd_sys_script_t httpdcontent:file entrypoint;
#line 381

#line 381
type_transition httpd_t httpdcontent:process httpd_sys_script_t;
#line 381


#line 382
allow httpd_t httpdcontent:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 382
allow httpd_t httpdcontent:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 382
allow httpd_t httpdcontent:lnk_file { create read getattr setattr link unlink rename };
#line 382

}
if (httpd_enable_cgi) {

#line 385

#line 385

#line 385
#
#line 385
# Allow the process to transition to the new domain.
#line 385
#
#line 385
allow httpd_t httpd_unconfined_script_t:process transition;
#line 385

#line 385
#
#line 385
# Do not audit when glibc secure mode is enabled upon the transition.
#line 385
#
#line 385
dontaudit httpd_t httpd_unconfined_script_t:process noatsecure;
#line 385

#line 385
#
#line 385
# Do not audit when signal-related state is cleared upon the transition.
#line 385
#
#line 385
dontaudit httpd_t httpd_unconfined_script_t:process siginh;
#line 385

#line 385
#
#line 385
# Do not audit when resource limits are reset upon the transition.
#line 385
#
#line 385
dontaudit httpd_t httpd_unconfined_script_t:process rlimitinh;
#line 385

#line 385
#
#line 385
# Allow the process to execute the program.
#line 385
# 
#line 385
allow httpd_t httpd_unconfined_script_exec_t:file { read { getattr execute } };
#line 385

#line 385
#
#line 385
# Allow the process to reap the new domain.
#line 385
#
#line 385
allow httpd_unconfined_script_t httpd_t:process sigchld;
#line 385

#line 385
#
#line 385
# Allow the new domain to inherit and use file 
#line 385
# descriptions from the creating process and vice versa.
#line 385
#
#line 385
allow httpd_unconfined_script_t httpd_t:fd use;
#line 385
allow httpd_t httpd_unconfined_script_t:fd use;
#line 385

#line 385
#
#line 385
# Allow the new domain to write back to the old domain via a pipe.
#line 385
#
#line 385
allow httpd_unconfined_script_t httpd_t:fifo_file { ioctl read getattr lock write append };
#line 385

#line 385
#
#line 385
# Allow the new domain to read and execute the program.
#line 385
#
#line 385
allow httpd_unconfined_script_t httpd_unconfined_script_exec_t:file { read getattr lock execute ioctl };
#line 385

#line 385
#
#line 385
# Allow the new domain to be entered via the program.
#line 385
#
#line 385
allow httpd_unconfined_script_t httpd_unconfined_script_exec_t:file entrypoint;
#line 385

#line 385
type_transition httpd_t httpd_unconfined_script_exec_t:process httpd_unconfined_script_t;
#line 385


#line 386

#line 386

#line 386
#
#line 386
# Allow the process to transition to the new domain.
#line 386
#
#line 386
allow httpd_suexec_t httpd_unconfined_script_t:process transition;
#line 386

#line 386
#
#line 386
# Do not audit when glibc secure mode is enabled upon the transition.
#line 386
#
#line 386
dontaudit httpd_suexec_t httpd_unconfined_script_t:process noatsecure;
#line 386

#line 386
#
#line 386
# Do not audit when signal-related state is cleared upon the transition.
#line 386
#
#line 386
dontaudit httpd_suexec_t httpd_unconfined_script_t:process siginh;
#line 386

#line 386
#
#line 386
# Do not audit when resource limits are reset upon the transition.
#line 386
#
#line 386
dontaudit httpd_suexec_t httpd_unconfined_script_t:process rlimitinh;
#line 386

#line 386
#
#line 386
# Allow the process to execute the program.
#line 386
# 
#line 386
allow httpd_suexec_t httpd_unconfined_script_exec_t:file { read { getattr execute } };
#line 386

#line 386
#
#line 386
# Allow the process to reap the new domain.
#line 386
#
#line 386
allow httpd_unconfined_script_t httpd_suexec_t:process sigchld;
#line 386

#line 386
#
#line 386
# Allow the new domain to inherit and use file 
#line 386
# descriptions from the creating process and vice versa.
#line 386
#
#line 386
allow httpd_unconfined_script_t httpd_suexec_t:fd use;
#line 386
allow httpd_suexec_t httpd_unconfined_script_t:fd use;
#line 386

#line 386
#
#line 386
# Allow the new domain to write back to the old domain via a pipe.
#line 386
#
#line 386
allow httpd_unconfined_script_t httpd_suexec_t:fifo_file { ioctl read getattr lock write append };
#line 386

#line 386
#
#line 386
# Allow the new domain to read and execute the program.
#line 386
#
#line 386
allow httpd_unconfined_script_t httpd_unconfined_script_exec_t:file { read getattr lock execute ioctl };
#line 386

#line 386
#
#line 386
# Allow the new domain to be entered via the program.
#line 386
#
#line 386
allow httpd_unconfined_script_t httpd_unconfined_script_exec_t:file entrypoint;
#line 386

#line 386
type_transition httpd_suexec_t httpd_unconfined_script_exec_t:process httpd_unconfined_script_t;
#line 386

allow httpd_t httpd_unconfined_script_t:process { signal sigkill sigstop };
allow httpd_t httpd_unconfined_script_exec_t:dir { read getattr lock search ioctl };
}

#
# Types for squirrelmail
#
type httpd_squirrelmail_t, file_type, sysadmfile;

#line 395
allow httpd_t httpd_squirrelmail_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 395
allow httpd_t httpd_squirrelmail_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 395
allow httpd_t httpd_squirrelmail_t:lnk_file { create read getattr setattr link unlink rename };
#line 395

allow httpd_sys_script_t httpd_squirrelmail_t:file { append read };
# File Type of squirrelmail attachments
type squirrelmail_spool_t, file_type, sysadmfile, tmpfile;
allow { httpd_t httpd_sys_script_t } var_spool_t:dir { getattr search };

#line 400
allow httpd_t squirrelmail_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 400
allow httpd_t squirrelmail_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 400
allow httpd_t squirrelmail_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 400


#line 401
allow httpd_sys_script_t squirrelmail_spool_t:dir { read getattr lock search ioctl };
#line 401
allow httpd_sys_script_t squirrelmail_spool_t:file { read getattr lock ioctl };
#line 401
allow httpd_sys_script_t squirrelmail_spool_t:lnk_file { getattr read };
#line 401


#line 410

#line 410
# apache should set close-on-exec
#line 410
dontaudit httpd_suexec_t httpd_t:unix_stream_socket { read write };
#line 410
dontaudit { system_mail_t mta_user_agent } { httpd_t httpd_sys_script_t }:unix_stream_socket { read write };
#line 410
dontaudit system_mail_t httpd_log_t:file { append getattr };
#line 410
allow system_mail_t httpd_squirrelmail_t:file { append read };
#line 410
dontaudit system_mail_t httpd_t:tcp_socket { read write };
#line 410

bool httpd_enable_ftp_server false;
if (httpd_enable_ftp_server) {
allow httpd_t ftp_port_t:tcp_socket name_bind;
}

#line 1 "domains/program/apmd.te"
#DESC Apmd - Automatic Power Management daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#           Russell Coker <russell@coker.com.au>
# X-Debian-Packages: apmd
#

#################################
#
# Rules for the apmd_t domain.
#

#line 12

#line 12

#line 12

#line 12
type apmd_t, domain, privlog, daemon , privmodule, privmail, nscd_client_domain, transitionbool;
#line 12
type apmd_exec_t, file_type, sysadmfile, exec_type;
#line 12
dontaudit apmd_t self:capability sys_tty_config;
#line 12

#line 12
role system_r types apmd_t;
#line 12

#line 12
# Inherit and use descriptors from init.
#line 12
allow apmd_t init_t:fd use;
#line 12
allow apmd_t init_t:process sigchld;
#line 12
allow apmd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 12

#line 12

#line 12
allow apmd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 12
allow apmd_t lib_t:lnk_file { read getattr lock ioctl };
#line 12
allow apmd_t ld_so_t:file { read getattr lock execute ioctl };
#line 12
#allow apmd_t ld_so_t:file execute_no_trans;
#line 12
allow apmd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 12
allow apmd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 12
allow apmd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 12
allow apmd_t texrel_shlib_t:file execmod;
#line 12
allow apmd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 12
allow apmd_t device_t:dir search;
#line 12
allow apmd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
allow apmd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 12
allow apmd_t { self proc_t }:lnk_file { getattr read };
#line 12

#line 12
allow apmd_t device_t:dir { read getattr lock search ioctl };
#line 12

#line 12
allow apmd_t udev_tdb_t:file { read getattr lock ioctl };
#line 12
allow apmd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit apmd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit apmd_t unpriv_userdomain:fd use;
#line 12

#line 12

#line 12
allow apmd_t sysfs_t:dir { read getattr lock search ioctl };
#line 12
allow apmd_t sysfs_t:file { read getattr lock ioctl };
#line 12
allow apmd_t sysfs_t:lnk_file { getattr read };
#line 12
 
#line 12

#line 12
allow apmd_t autofs_t:dir { search getattr };
#line 12

#line 12
dontaudit apmd_t { tty_device_t devpts_t }:chr_file { read write };
#line 12
dontaudit apmd_t root_t:file { getattr read };
#line 12
 
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
# Read system variables in /sys.
#line 12

#line 12
allow apmd_t sysctl_t:dir search;
#line 12
allow apmd_t sysctl_kernel_t:dir search;
#line 12
allow apmd_t sysctl_kernel_t:file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allows user to define a tunable to disable domain transition
#line 12
#
#line 12

#line 12
bool apmd_disable_trans false;
#line 12
if (apmd_disable_trans) {
#line 12

#line 12
allow initrc_t apmd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12

#line 12
allow sysadm_t apmd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12
} else {
#line 12
 
#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow initrc_t apmd_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit initrc_t apmd_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit initrc_t apmd_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit initrc_t apmd_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow initrc_t apmd_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow apmd_t initrc_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow apmd_t initrc_t:fd use;
#line 12
allow initrc_t apmd_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow apmd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow apmd_t apmd_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow apmd_t apmd_exec_t:file entrypoint;
#line 12

#line 12
type_transition initrc_t apmd_exec_t:process apmd_t;
#line 12

#line 12

#line 12
allow initrc_t apmd_t:process { noatsecure siginh rlimitinh };
#line 12

#line 12
}
#line 12
 
#line 12
allow apmd_t privfd:fd use;
#line 12

#line 12
allow apmd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
# Create pid file.
#line 12
allow apmd_t var_t:dir { getattr search };
#line 12

#line 12
type apmd_var_run_t, file_type, sysadmfile, pidfile;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to modify the directory.
#line 12
#
#line 12
allow apmd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12
#
#line 12
# Allow the process to create the file.
#line 12
#
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow apmd_t apmd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
type_transition apmd_t var_run_t:file apmd_var_run_t;
#line 12

#line 12

#line 12

#line 12
allow apmd_t var_t:dir search;
#line 12
allow apmd_t apmd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12

#line 12
allow apmd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12
# for daemons that look at /root on startup
#line 12
dontaudit apmd_t sysadm_home_dir_t:dir search;
#line 12

#line 12
# for df
#line 12
allow apmd_t fs_type:filesystem getattr;
#line 12
allow apmd_t removable_t:filesystem getattr;
#line 12

#line 12

#line 12
allow apmd_t etc_t:lnk_file read;
#line 12
allow apmd_t lib_t:file { read getattr lock ioctl };
#line 12

#line 12
allow apmd_t locale_t:dir { read getattr lock search ioctl };
#line 12
allow apmd_t locale_t:file { read getattr lock ioctl };
#line 12
allow apmd_t locale_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12
# for localization
#line 12
allow apmd_t lib_t:file { getattr read };
#line 12


# for SSP
allow apmd_t urandom_device_t:chr_file read;

type apm_t, domain, privlog;
type apm_exec_t, file_type, sysadmfile, exec_type;
#line 21


#line 22
allow apm_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 22
allow apm_t lib_t:lnk_file { read getattr lock ioctl };
#line 22
allow apm_t ld_so_t:file { read getattr lock execute ioctl };
#line 22
#allow apm_t ld_so_t:file execute_no_trans;
#line 22
allow apm_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 22
allow apm_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 22
allow apm_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 22
allow apm_t texrel_shlib_t:file execmod;
#line 22
allow apm_t ld_so_cache_t:file { read getattr lock ioctl };
#line 22
allow apm_t device_t:dir search;
#line 22
allow apm_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 22

allow apm_t privfd:fd use;
allow apm_t admin_tty_type:chr_file { ioctl read getattr lock write append };
allow apm_t device_t:dir search;
allow apm_t self:capability { dac_override sys_admin };
allow apm_t proc_t:dir search;
allow apm_t proc_t:file { read getattr lock ioctl };
allow apm_t fs_t:filesystem getattr;
allow apm_t apm_bios_t:chr_file { ioctl read getattr lock write append };
role sysadm_r types apm_t;
role system_r types apm_t;

allow apmd_t device_t:lnk_file read;
allow apmd_t proc_t:file { getattr read write };

#line 36
allow apmd_t sysctl_type:dir { read getattr lock search ioctl };
#line 36
allow apmd_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 36

allow apmd_t sysfs_t:file write;

allow apmd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow apmd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow apmd_t self:fifo_file { ioctl read getattr lock write append };
allow apmd_t { etc_runtime_t modules_conf_t }:file { getattr read };
allow apmd_t etc_t:lnk_file read;

# acpid wants a socket

#line 46

#line 46

#line 46

#line 46
#
#line 46
# Allow the process to modify the directory.
#line 46
#
#line 46
allow apmd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 46

#line 46
#
#line 46
# Allow the process to create the file.
#line 46
#
#line 46

#line 46

#line 46

#line 46

#line 46

#line 46
allow apmd_t apmd_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 46

#line 46

#line 46

#line 46

#line 46

#line 46

#line 46

#line 46

#line 46

#line 46
type_transition apmd_t var_run_t:sock_file apmd_var_run_t;
#line 46

#line 46


# acpid also has a logfile

#line 49
type apmd_log_t, file_type, sysadmfile, logfile;
#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the process to modify the directory.
#line 49
#
#line 49
allow apmd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 49

#line 49
#
#line 49
# Allow the process to create the file.
#line 49
#
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow apmd_t apmd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
type_transition apmd_t var_log_t:file apmd_log_t;
#line 49

#line 49

#line 49


#line 50
type apmd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 50

#line 50

#line 50

#line 50

#line 50
#
#line 50
# Allow the process to modify the directory.
#line 50
#
#line 50
allow apmd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 50

#line 50
#
#line 50
# Allow the process to create the file.
#line 50
#
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow apmd_t apmd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow apmd_t apmd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
type_transition apmd_t tmp_t:{ file dir } apmd_tmp_t;
#line 50

#line 50

#line 50


#line 54


allow apmd_t self:file { getattr read ioctl };
allow apmd_t self:process getsession;

# Use capabilities.
allow apmd_t self:capability { sys_admin sys_nice sys_time kill };

# controlling an orderly resume of PCMCIA requires creating device
# nodes 254,{0,1,2} for some reason.
allow apmd_t self:capability mknod;

# Access /dev/apm_bios.
allow apmd_t apm_bios_t:chr_file { ioctl read getattr lock write append };

# Run helper programs.

#line 70
allow apmd_t { bin_t sbin_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 70
allow apmd_t { bin_t sbin_t etc_t }:lnk_file { getattr read };
#line 70

#line 70
allow apmd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 70
allow apmd_t lib_t:lnk_file { read getattr lock ioctl };
#line 70
allow apmd_t ld_so_t:file { read getattr lock execute ioctl };
#line 70
#allow apmd_t ld_so_t:file execute_no_trans;
#line 70
allow apmd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 70
allow apmd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 70
allow apmd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 70
allow apmd_t texrel_shlib_t:file execmod;
#line 70
allow apmd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 70
allow apmd_t device_t:dir search;
#line 70
allow apmd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 70

#line 70

#line 70
allow apmd_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 70

#line 70

#line 70
allow apmd_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 70

#line 70

#line 70
allow apmd_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 70

#line 70

#line 70
allow apmd_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 70

#line 70

#line 70
allow apmd_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 70

#line 70

#line 70
allow apmd_t ld_so_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 70

#line 70


# apmd calls hwclock.sh on suspend and resume
allow apmd_t clock_device_t:chr_file { read getattr lock ioctl };
#line 79

#line 79

#line 79

#line 79

#line 79
#
#line 79
# Allow the process to transition to the new domain.
#line 79
#
#line 79
allow apmd_t hwclock_t:process transition;
#line 79

#line 79
#
#line 79
# Do not audit when glibc secure mode is enabled upon the transition.
#line 79
#
#line 79
dontaudit apmd_t hwclock_t:process noatsecure;
#line 79

#line 79
#
#line 79
# Do not audit when signal-related state is cleared upon the transition.
#line 79
#
#line 79
dontaudit apmd_t hwclock_t:process siginh;
#line 79

#line 79
#
#line 79
# Do not audit when resource limits are reset upon the transition.
#line 79
#
#line 79
dontaudit apmd_t hwclock_t:process rlimitinh;
#line 79

#line 79
#
#line 79
# Allow the process to execute the program.
#line 79
# 
#line 79
allow apmd_t hwclock_exec_t:file { read { getattr execute } };
#line 79

#line 79
#
#line 79
# Allow the process to reap the new domain.
#line 79
#
#line 79
allow hwclock_t apmd_t:process sigchld;
#line 79

#line 79
#
#line 79
# Allow the new domain to inherit and use file 
#line 79
# descriptions from the creating process and vice versa.
#line 79
#
#line 79
allow hwclock_t apmd_t:fd use;
#line 79
allow apmd_t hwclock_t:fd use;
#line 79

#line 79
#
#line 79
# Allow the new domain to write back to the old domain via a pipe.
#line 79
#
#line 79
allow hwclock_t apmd_t:fifo_file { ioctl read getattr lock write append };
#line 79

#line 79
#
#line 79
# Allow the new domain to read and execute the program.
#line 79
#
#line 79
allow hwclock_t hwclock_exec_t:file { read getattr lock execute ioctl };
#line 79

#line 79
#
#line 79
# Allow the new domain to be entered via the program.
#line 79
#
#line 79
allow hwclock_t hwclock_exec_t:file entrypoint;
#line 79

#line 79
type_transition apmd_t hwclock_exec_t:process hwclock_t;
#line 79

#line 79
allow apmd_t adjtime_t:file { ioctl read getattr lock write append };
#line 79
allow hwclock_t apmd_log_t:file append;
#line 79
allow hwclock_t apmd_t:unix_stream_socket { read write };
#line 79



# to quiet fuser and ps
# setuid for fuser, dac* for ps
dontaudit apmd_t self:capability { setuid dac_override dac_read_search };
dontaudit apmd_t domain:{ tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } getattr;
dontaudit apmd_t { file_type fs_type }:{ file lnk_file sock_file fifo_file } getattr;
dontaudit apmd_t device_type:{ chr_file blk_file } getattr;
dontaudit apmd_t home_type:dir { search getattr };
dontaudit apmd_t domain:key_socket getattr;
dontaudit apmd_t domain:dir search;

#line 104

#line 104

#line 104
allow apmd_t apmd_var_run_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 104

#line 104
# for /var/lock/subsys/network
#line 104

#line 104
type apmd_lock_t, file_type, sysadmfile, lockfile;
#line 104

#line 104

#line 104

#line 104

#line 104
#
#line 104
# Allow the process to modify the directory.
#line 104
#
#line 104
allow apmd_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 104

#line 104
#
#line 104
# Allow the process to create the file.
#line 104
#
#line 104

#line 104

#line 104

#line 104

#line 104

#line 104
allow apmd_t apmd_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 104

#line 104

#line 104

#line 104

#line 104

#line 104

#line 104

#line 104

#line 104

#line 104
type_transition apmd_t var_lock_t:file apmd_lock_t;
#line 104

#line 104

#line 104

#line 104

#line 104
# ifconfig_exec_t needs to be run in its own domain for Red Hat
#line 104

#line 104

#line 104

#line 104
#
#line 104
# Allow the process to transition to the new domain.
#line 104
#
#line 104
allow apmd_t ifconfig_t:process transition;
#line 104

#line 104
#
#line 104
# Do not audit when glibc secure mode is enabled upon the transition.
#line 104
#
#line 104
dontaudit apmd_t ifconfig_t:process noatsecure;
#line 104

#line 104
#
#line 104
# Do not audit when signal-related state is cleared upon the transition.
#line 104
#
#line 104
dontaudit apmd_t ifconfig_t:process siginh;
#line 104

#line 104
#
#line 104
# Do not audit when resource limits are reset upon the transition.
#line 104
#
#line 104
dontaudit apmd_t ifconfig_t:process rlimitinh;
#line 104

#line 104
#
#line 104
# Allow the process to execute the program.
#line 104
# 
#line 104
allow apmd_t ifconfig_exec_t:file { read { getattr execute } };
#line 104

#line 104
#
#line 104
# Allow the process to reap the new domain.
#line 104
#
#line 104
allow ifconfig_t apmd_t:process sigchld;
#line 104

#line 104
#
#line 104
# Allow the new domain to inherit and use file 
#line 104
# descriptions from the creating process and vice versa.
#line 104
#
#line 104
allow ifconfig_t apmd_t:fd use;
#line 104
allow apmd_t ifconfig_t:fd use;
#line 104

#line 104
#
#line 104
# Allow the new domain to write back to the old domain via a pipe.
#line 104
#
#line 104
allow ifconfig_t apmd_t:fifo_file { ioctl read getattr lock write append };
#line 104

#line 104
#
#line 104
# Allow the new domain to read and execute the program.
#line 104
#
#line 104
allow ifconfig_t ifconfig_exec_t:file { read getattr lock execute ioctl };
#line 104

#line 104
#
#line 104
# Allow the new domain to be entered via the program.
#line 104
#
#line 104
allow ifconfig_t ifconfig_exec_t:file entrypoint;
#line 104

#line 104
type_transition apmd_t ifconfig_exec_t:process ifconfig_t;
#line 104

#line 104

#line 104

#line 104

#line 104

#line 104
#
#line 104
# Allow the process to transition to the new domain.
#line 104
#
#line 104
allow apmd_t netutils_t:process transition;
#line 104

#line 104
#
#line 104
# Do not audit when glibc secure mode is enabled upon the transition.
#line 104
#
#line 104
dontaudit apmd_t netutils_t:process noatsecure;
#line 104

#line 104
#
#line 104
# Do not audit when signal-related state is cleared upon the transition.
#line 104
#
#line 104
dontaudit apmd_t netutils_t:process siginh;
#line 104

#line 104
#
#line 104
# Do not audit when resource limits are reset upon the transition.
#line 104
#
#line 104
dontaudit apmd_t netutils_t:process rlimitinh;
#line 104

#line 104
#
#line 104
# Allow the process to execute the program.
#line 104
# 
#line 104
allow apmd_t netutils_exec_t:file { read { getattr execute } };
#line 104

#line 104
#
#line 104
# Allow the process to reap the new domain.
#line 104
#
#line 104
allow netutils_t apmd_t:process sigchld;
#line 104

#line 104
#
#line 104
# Allow the new domain to inherit and use file 
#line 104
# descriptions from the creating process and vice versa.
#line 104
#
#line 104
allow netutils_t apmd_t:fd use;
#line 104
allow apmd_t netutils_t:fd use;
#line 104

#line 104
#
#line 104
# Allow the new domain to write back to the old domain via a pipe.
#line 104
#
#line 104
allow netutils_t apmd_t:fifo_file { ioctl read getattr lock write append };
#line 104

#line 104
#
#line 104
# Allow the new domain to read and execute the program.
#line 104
#
#line 104
allow netutils_t netutils_exec_t:file { read getattr lock execute ioctl };
#line 104

#line 104
#
#line 104
# Allow the new domain to be entered via the program.
#line 104
#
#line 104
allow netutils_t netutils_exec_t:file entrypoint;
#line 104

#line 104
type_transition apmd_t netutils_exec_t:process netutils_t;
#line 104

#line 104


#line 109

#line 109
allow apmd_t udev_t:file { getattr read };
#line 109
allow apmd_t udev_t:lnk_file { getattr read };
#line 109

#
# apmd tells the machine to shutdown requires the following
#
allow apmd_t initctl_t:fifo_file write;
allow apmd_t initrc_var_run_t:file { read write lock };

#
# Allow it to run killof5 and pidof
#
typeattribute apmd_t unrestricted;

#line 120
allow apmd_t domain:dir { read getattr lock search ioctl };
#line 120
allow apmd_t domain:file { read getattr lock ioctl };
#line 120
allow apmd_t domain:lnk_file { getattr read };
#line 120


# Same for apm/acpid scripts

#line 123

#line 123

#line 123
#
#line 123
# Allow the process to transition to the new domain.
#line 123
#
#line 123
allow apmd_t initrc_t:process transition;
#line 123

#line 123
#
#line 123
# Do not audit when glibc secure mode is enabled upon the transition.
#line 123
#
#line 123
dontaudit apmd_t initrc_t:process noatsecure;
#line 123

#line 123
#
#line 123
# Do not audit when signal-related state is cleared upon the transition.
#line 123
#
#line 123
dontaudit apmd_t initrc_t:process siginh;
#line 123

#line 123
#
#line 123
# Do not audit when resource limits are reset upon the transition.
#line 123
#
#line 123
dontaudit apmd_t initrc_t:process rlimitinh;
#line 123

#line 123
#
#line 123
# Allow the process to execute the program.
#line 123
# 
#line 123
allow apmd_t initrc_exec_t:file { read { getattr execute } };
#line 123

#line 123
#
#line 123
# Allow the process to reap the new domain.
#line 123
#
#line 123
allow initrc_t apmd_t:process sigchld;
#line 123

#line 123
#
#line 123
# Allow the new domain to inherit and use file 
#line 123
# descriptions from the creating process and vice versa.
#line 123
#
#line 123
allow initrc_t apmd_t:fd use;
#line 123
allow apmd_t initrc_t:fd use;
#line 123

#line 123
#
#line 123
# Allow the new domain to write back to the old domain via a pipe.
#line 123
#
#line 123
allow initrc_t apmd_t:fifo_file { ioctl read getattr lock write append };
#line 123

#line 123
#
#line 123
# Allow the new domain to read and execute the program.
#line 123
#
#line 123
allow initrc_t initrc_exec_t:file { read getattr lock execute ioctl };
#line 123

#line 123
#
#line 123
# Allow the new domain to be entered via the program.
#line 123
#
#line 123
allow initrc_t initrc_exec_t:file entrypoint;
#line 123

#line 123
type_transition apmd_t initrc_exec_t:process initrc_t;
#line 123

#line 127

#line 127
allow consoletype_t apmd_t:fd use;
#line 127
allow consoletype_t apmd_t:fifo_file write;
#line 127


#line 132

#line 132

#line 132

#line 132

#line 132
#
#line 132
# Allow the process to transition to the new domain.
#line 132
#
#line 132
allow apmd_t system_crond_t:process transition;
#line 132

#line 132
#
#line 132
# Do not audit when glibc secure mode is enabled upon the transition.
#line 132
#
#line 132
dontaudit apmd_t system_crond_t:process noatsecure;
#line 132

#line 132
#
#line 132
# Do not audit when signal-related state is cleared upon the transition.
#line 132
#
#line 132
dontaudit apmd_t system_crond_t:process siginh;
#line 132

#line 132
#
#line 132
# Do not audit when resource limits are reset upon the transition.
#line 132
#
#line 132
dontaudit apmd_t system_crond_t:process rlimitinh;
#line 132

#line 132
#
#line 132
# Allow the process to execute the program.
#line 132
# 
#line 132
allow apmd_t anacron_exec_t:file { read { getattr execute } };
#line 132

#line 132
#
#line 132
# Allow the process to reap the new domain.
#line 132
#
#line 132
allow system_crond_t apmd_t:process sigchld;
#line 132

#line 132
#
#line 132
# Allow the new domain to inherit and use file 
#line 132
# descriptions from the creating process and vice versa.
#line 132
#
#line 132
allow system_crond_t apmd_t:fd use;
#line 132
allow apmd_t system_crond_t:fd use;
#line 132

#line 132
#
#line 132
# Allow the new domain to write back to the old domain via a pipe.
#line 132
#
#line 132
allow system_crond_t apmd_t:fifo_file { ioctl read getattr lock write append };
#line 132

#line 132
#
#line 132
# Allow the new domain to read and execute the program.
#line 132
#
#line 132
allow system_crond_t anacron_exec_t:file { read getattr lock execute ioctl };
#line 132

#line 132
#
#line 132
# Allow the new domain to be entered via the program.
#line 132
#
#line 132
allow system_crond_t anacron_exec_t:file entrypoint;
#line 132

#line 132
type_transition apmd_t anacron_exec_t:process system_crond_t;
#line 132

#line 132
allow apmd_t crond_t:fifo_file { getattr read write ioctl };
#line 132


# for a find /dev operation that gets /dev/shm
dontaudit apmd_t tmpfs_t:dir { read getattr lock search ioctl };
dontaudit apmd_t selinux_config_t:dir search;
allow apmd_t user_tty_type:chr_file { ioctl read getattr lock write append };
# Access /dev/apm_bios.
allow initrc_t apm_bios_t:chr_file { setattr getattr read };

#line 144
allow apmd_t devpts_t:dir { getattr search };
allow apmd_t security_t:dir search;
allow apmd_t usr_t:dir search;

#line 147
allow apmd_t hwdata_t:dir { read getattr lock search ioctl };
#line 147
allow apmd_t hwdata_t:file { read getattr lock ioctl };
#line 147
allow apmd_t hwdata_t:lnk_file { getattr read };
#line 147

#line 150

#line 150

#line 150

#line 150
typeattribute apmd_t unrestricted;
#line 150
typeattribute apmd_t privuser;
#line 150

#line 150
# Mount/unmount any filesystem. 
#line 150
allow apmd_t fs_type:filesystem *;
#line 150

#line 150
# Mount/unmount any filesystem with the context= option. 
#line 150
allow apmd_t file_type:filesystem *;
#line 150

#line 150
# Create/access any file in a labeled filesystem;
#line 150
allow apmd_t file_type:{ file chr_file } ~execmod;
#line 150
allow apmd_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 150
allow apmd_t sysctl_t:{ dir file } *;
#line 150
allow apmd_t device_type:{ chr_file blk_file } *;
#line 150
allow apmd_t mtrr_device_t:file *;
#line 150

#line 150
# Create/access other files.  fs_type is to pick up various
#line 150
# pseudo filesystem types that are applied to both the filesystem
#line 150
# and its files.
#line 150
allow apmd_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 150
allow apmd_t unlabeled_t:association { sendto recvfrom };
#line 150

#line 150
allow apmd_t proc_fs:{ dir file } *;
#line 150

#line 150
# For /proc/pid
#line 150

#line 150
allow apmd_t domain:dir { read getattr lock search ioctl };
#line 150
allow apmd_t domain:file { read getattr lock ioctl };
#line 150
allow apmd_t domain:lnk_file { getattr read };
#line 150

#line 150
# Write access is for setting attributes under /proc/self/attr.
#line 150
allow apmd_t self:file { ioctl read getattr lock write append };
#line 150

#line 150
# Read and write sysctls.
#line 150

#line 150
allow apmd_t sysctl_type:dir { read getattr lock search ioctl };
#line 150
allow apmd_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 150

#line 150

#line 150
# Access the network.
#line 150
allow apmd_t node_type:node *;
#line 150
allow apmd_t netif_type:netif *;
#line 150
allow apmd_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 150
allow apmd_t port_type:tcp_socket name_connect;
#line 150

#line 150
# Bind to any network address.
#line 150
allow apmd_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 150
allow apmd_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 150
allow apmd_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 150

#line 150
# Use/sendto/connectto sockets created by any domain.
#line 150
allow apmd_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 150

#line 150
# Use descriptors and pipes created by any domain.
#line 150
allow apmd_t domain:fd use;
#line 150
allow apmd_t domain:fifo_file { ioctl read getattr lock write append };
#line 150

#line 150
# Act upon any other process.
#line 150
allow apmd_t domain:process ~{ transition dyntransition execmem };
#line 150
# Transition to myself, to make get_ordered_context_list happy.
#line 150
allow apmd_t self:process transition;
#line 150

#line 150
if (allow_execmem) {
#line 150
# Allow making anonymous memory executable, e.g. 
#line 150
# for runtime-code generation or executable stack.
#line 150
allow apmd_t self:process execmem;
#line 150
}
#line 150

#line 150
if (allow_execmem && allow_execstack) {
#line 150
# Allow making the stack executable via mprotect.
#line 150
allow apmd_t self:process execstack;
#line 150
}
#line 150

#line 150
if (allow_execmod) {
#line 150
# Allow text relocations on system shared libraries, e.g. libGL.
#line 150

#line 150
allow apmd_t file_type:file execmod;
#line 150

#line 150
}
#line 150

#line 150
# Create/access any System V IPC objects.
#line 150
allow apmd_t domain:{ sem msgq shm } *;
#line 150
allow apmd_t domain:msg  { send receive };
#line 150

#line 150
# Access the security API.
#line 150
if (!secure_mode_policyload) {
#line 150
allow apmd_t security_t:security *;
#line 150
auditallow apmd_t security_t:security { load_policy setenforce setbool };
#line 150
}
#line 150
# Perform certain system operations that lacked individual capabilities.
#line 150
allow apmd_t kernel_t:system *;
#line 150

#line 150
# Use any Linux capability.
#line 150
allow apmd_t self:capability *;
#line 150

#line 150
# Set user information and skip authentication.
#line 150
allow apmd_t self:passwd *;
#line 150

#line 150
# Communicate via dbusd.
#line 150
allow apmd_t self:dbus *;
#line 150

#line 150
allow apmd_t system_dbusd_t:dbus *;
#line 150

#line 150

#line 150
# Get info via nscd.
#line 150
allow apmd_t self:nscd *;
#line 150

#line 150
allow apmd_t nscd_t:nscd *;
#line 150

#line 150

#line 150

#line 150


#line 157

#line 157

#line 157
allow apmd_t NetworkManager_t:dbus send_msg;
#line 157
allow NetworkManager_t apmd_t:dbus send_msg;
#line 157

#line 157

#line 1 "domains/program/arpwatch.te"
#DESC arpwatch -  keep track of ethernet/ip address pairings
#
# Author:  Dan Walsh <dwalsh@redhat.com>
#

#################################
#
# Rules for the arpwatch_t domain.
#
# arpwatch_exec_t is the type of the arpwatch executable.
#

#line 12

#line 12

#line 12

#line 12
type arpwatch_t, domain, privlog, daemon , privmail, transitionbool;
#line 12
type arpwatch_exec_t, file_type, sysadmfile, exec_type;
#line 12
dontaudit arpwatch_t self:capability sys_tty_config;
#line 12

#line 12
role system_r types arpwatch_t;
#line 12

#line 12
# Inherit and use descriptors from init.
#line 12
allow arpwatch_t init_t:fd use;
#line 12
allow arpwatch_t init_t:process sigchld;
#line 12
allow arpwatch_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 12

#line 12

#line 12
allow arpwatch_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 12
allow arpwatch_t lib_t:lnk_file { read getattr lock ioctl };
#line 12
allow arpwatch_t ld_so_t:file { read getattr lock execute ioctl };
#line 12
#allow arpwatch_t ld_so_t:file execute_no_trans;
#line 12
allow arpwatch_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 12
allow arpwatch_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 12
allow arpwatch_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 12
allow arpwatch_t texrel_shlib_t:file execmod;
#line 12
allow arpwatch_t ld_so_cache_t:file { read getattr lock ioctl };
#line 12
allow arpwatch_t device_t:dir search;
#line 12
allow arpwatch_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
allow arpwatch_t { self proc_t }:dir { read getattr lock search ioctl };
#line 12
allow arpwatch_t { self proc_t }:lnk_file { getattr read };
#line 12

#line 12
allow arpwatch_t device_t:dir { read getattr lock search ioctl };
#line 12

#line 12
allow arpwatch_t udev_tdb_t:file { read getattr lock ioctl };
#line 12
allow arpwatch_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit arpwatch_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit arpwatch_t unpriv_userdomain:fd use;
#line 12

#line 12

#line 12
allow arpwatch_t sysfs_t:dir { read getattr lock search ioctl };
#line 12
allow arpwatch_t sysfs_t:file { read getattr lock ioctl };
#line 12
allow arpwatch_t sysfs_t:lnk_file { getattr read };
#line 12
 
#line 12

#line 12
allow arpwatch_t autofs_t:dir { search getattr };
#line 12

#line 12
dontaudit arpwatch_t { tty_device_t devpts_t }:chr_file { read write };
#line 12
dontaudit arpwatch_t root_t:file { getattr read };
#line 12
 
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
# Read system variables in /sys.
#line 12

#line 12
allow arpwatch_t sysctl_t:dir search;
#line 12
allow arpwatch_t sysctl_kernel_t:dir search;
#line 12
allow arpwatch_t sysctl_kernel_t:file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allows user to define a tunable to disable domain transition
#line 12
#
#line 12

#line 12
bool arpwatch_disable_trans false;
#line 12
if (arpwatch_disable_trans) {
#line 12

#line 12
allow initrc_t arpwatch_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12

#line 12
allow sysadm_t arpwatch_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12
} else {
#line 12
 
#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow initrc_t arpwatch_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit initrc_t arpwatch_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit initrc_t arpwatch_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit initrc_t arpwatch_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow initrc_t arpwatch_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow arpwatch_t initrc_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow arpwatch_t initrc_t:fd use;
#line 12
allow initrc_t arpwatch_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow arpwatch_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow arpwatch_t arpwatch_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow arpwatch_t arpwatch_exec_t:file entrypoint;
#line 12

#line 12
type_transition initrc_t arpwatch_exec_t:process arpwatch_t;
#line 12

#line 12

#line 12
allow initrc_t arpwatch_t:process { noatsecure siginh rlimitinh };
#line 12

#line 12
}
#line 12
 
#line 12
allow arpwatch_t privfd:fd use;
#line 12

#line 12
allow arpwatch_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
# Create pid file.
#line 12
allow arpwatch_t var_t:dir { getattr search };
#line 12

#line 12
type arpwatch_var_run_t, file_type, sysadmfile, pidfile;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to modify the directory.
#line 12
#
#line 12
allow arpwatch_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12
#
#line 12
# Allow the process to create the file.
#line 12
#
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow arpwatch_t arpwatch_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
type_transition arpwatch_t var_run_t:file arpwatch_var_run_t;
#line 12

#line 12

#line 12

#line 12
allow arpwatch_t var_t:dir search;
#line 12
allow arpwatch_t arpwatch_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12

#line 12
allow arpwatch_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12
# for daemons that look at /root on startup
#line 12
dontaudit arpwatch_t sysadm_home_dir_t:dir search;
#line 12

#line 12
# for df
#line 12
allow arpwatch_t fs_type:filesystem getattr;
#line 12
allow arpwatch_t removable_t:filesystem getattr;
#line 12

#line 12

#line 12
allow arpwatch_t etc_t:lnk_file read;
#line 12
allow arpwatch_t lib_t:file { read getattr lock ioctl };
#line 12

#line 12
allow arpwatch_t locale_t:dir { read getattr lock search ioctl };
#line 12
allow arpwatch_t locale_t:file { read getattr lock ioctl };
#line 12
allow arpwatch_t locale_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12
# for localization
#line 12
allow arpwatch_t lib_t:file { getattr read };
#line 12


# for files created by arpwatch
type arpwatch_data_t, file_type, sysadmfile;

#line 16
allow arpwatch_t arpwatch_data_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 16
allow arpwatch_t arpwatch_data_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 16
allow arpwatch_t arpwatch_data_t:lnk_file { create read getattr setattr link unlink rename };
#line 16


#line 17
type arpwatch_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the process to modify the directory.
#line 17
#
#line 17
allow arpwatch_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17

#line 17
#
#line 17
# Allow the process to create the file.
#line 17
#
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow arpwatch_t arpwatch_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow arpwatch_t arpwatch_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
type_transition arpwatch_t tmp_t:{ file dir } arpwatch_tmp_t;
#line 17

#line 17

#line 17


allow arpwatch_t self:capability { net_admin net_raw setgid setuid };


#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use tcp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow arpwatch_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow arpwatch_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow arpwatch_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow arpwatch_t node_type:node { tcp_send rawip_send };
#line 21
allow arpwatch_t node_type:node { tcp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow arpwatch_t port_type:tcp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow arpwatch_t node_type:tcp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow arpwatch_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow arpwatch_t self:tcp_socket { listen accept };
#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use udp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow arpwatch_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow arpwatch_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow arpwatch_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow arpwatch_t node_type:node { udp_send rawip_send };
#line 21
allow arpwatch_t node_type:node { udp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow arpwatch_t port_type:udp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow arpwatch_t node_type:udp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow arpwatch_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow arpwatch_t self:udp_socket { connect };
#line 21

#line 21

#line 21

allow arpwatch_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
allow arpwatch_t self:udp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow arpwatch_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow arpwatch_t self:packet_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow arpwatch_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

allow arpwatch_t { sbin_t var_lib_t }:dir search;
allow arpwatch_t sbin_t:lnk_file read;

#line 30
allow arpwatch_t etc_t:dir { read getattr lock search ioctl };
#line 30
allow arpwatch_t etc_t:file { read getattr lock ioctl };
#line 30
allow arpwatch_t etc_t:lnk_file { getattr read };
#line 30


#line 31
allow arpwatch_t usr_t:dir { read getattr lock search ioctl };
#line 31
allow arpwatch_t usr_t:file { read getattr lock ioctl };
#line 31
allow arpwatch_t usr_t:lnk_file { getattr read };
#line 31


#line 32

#line 32
if (allow_ypbind) {
#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32
#
#line 32
# Allow the domain to create and use tcp sockets.
#line 32
# Other kinds of sockets must be separately authorized for use.
#line 32
allow arpwatch_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 32

#line 32
allow arpwatch_t unlabeled_t:association { sendto recvfrom };
#line 32

#line 32
#
#line 32
# Allow the domain to send or receive using any network interface.
#line 32
# netif_type is a type attribute for all network interface types.
#line 32
#
#line 32
allow arpwatch_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 32
#
#line 32
# Allow the domain to send to or receive from any node.
#line 32
# node_type is a type attribute for all node types.
#line 32
#
#line 32
allow arpwatch_t node_type:node { tcp_send rawip_send };
#line 32
allow arpwatch_t node_type:node { tcp_recv rawip_recv };
#line 32

#line 32
#
#line 32
# Allow the domain to send to or receive from any port.
#line 32
# port_type is a type attribute for all port types.
#line 32
#
#line 32

#line 32
allow arpwatch_t port_type:tcp_socket { send_msg recv_msg };
#line 32

#line 32

#line 32
# XXX Allow binding to any node type.  Remove once
#line 32
# individual rules have been added to all domains that 
#line 32
# bind sockets. 
#line 32
allow arpwatch_t node_type:tcp_socket node_bind;
#line 32
#
#line 32
# Allow access to network files including /etc/resolv.conf
#line 32
#
#line 32
allow arpwatch_t net_conf_t:file { read getattr lock ioctl };
#line 32

#line 32
allow arpwatch_t self:tcp_socket { listen accept };
#line 32

#line 32

#line 32

#line 32
#
#line 32
# Allow the domain to create and use tcp sockets.
#line 32
# Other kinds of sockets must be separately authorized for use.
#line 32
allow arpwatch_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 32

#line 32
allow arpwatch_t unlabeled_t:association { sendto recvfrom };
#line 32

#line 32
#
#line 32
# Allow the domain to send or receive using any network interface.
#line 32
# netif_type is a type attribute for all network interface types.
#line 32
#
#line 32
allow arpwatch_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 32
#
#line 32
# Allow the domain to send to or receive from any node.
#line 32
# node_type is a type attribute for all node types.
#line 32
#
#line 32
allow arpwatch_t node_type:node { tcp_send rawip_send };
#line 32
allow arpwatch_t node_type:node { tcp_recv rawip_recv };
#line 32

#line 32
#
#line 32
# Allow the domain to send to or receive from any port.
#line 32
# port_type is a type attribute for all port types.
#line 32
#
#line 32

#line 32
allow arpwatch_t port_type:tcp_socket { send_msg recv_msg };
#line 32

#line 32

#line 32
# XXX Allow binding to any node type.  Remove once
#line 32
# individual rules have been added to all domains that 
#line 32
# bind sockets. 
#line 32
allow arpwatch_t node_type:tcp_socket node_bind;
#line 32
#
#line 32
# Allow access to network files including /etc/resolv.conf
#line 32
#
#line 32
allow arpwatch_t net_conf_t:file { read getattr lock ioctl };
#line 32

#line 32
allow arpwatch_t self:tcp_socket { connect };
#line 32

#line 32

#line 32

#line 32

#line 32

#line 32
#
#line 32
# Allow the domain to create and use udp sockets.
#line 32
# Other kinds of sockets must be separately authorized for use.
#line 32
allow arpwatch_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 32

#line 32
allow arpwatch_t unlabeled_t:association { sendto recvfrom };
#line 32

#line 32
#
#line 32
# Allow the domain to send or receive using any network interface.
#line 32
# netif_type is a type attribute for all network interface types.
#line 32
#
#line 32
allow arpwatch_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 32
#
#line 32
# Allow the domain to send to or receive from any node.
#line 32
# node_type is a type attribute for all node types.
#line 32
#
#line 32
allow arpwatch_t node_type:node { udp_send rawip_send };
#line 32
allow arpwatch_t node_type:node { udp_recv rawip_recv };
#line 32

#line 32
#
#line 32
# Allow the domain to send to or receive from any port.
#line 32
# port_type is a type attribute for all port types.
#line 32
#
#line 32

#line 32
allow arpwatch_t port_type:udp_socket { send_msg recv_msg };
#line 32

#line 32

#line 32
# XXX Allow binding to any node type.  Remove once
#line 32
# individual rules have been added to all domains that 
#line 32
# bind sockets. 
#line 32
allow arpwatch_t node_type:udp_socket node_bind;
#line 32
#
#line 32
# Allow access to network files including /etc/resolv.conf
#line 32
#
#line 32
allow arpwatch_t net_conf_t:file { read getattr lock ioctl };
#line 32

#line 32
allow arpwatch_t self:udp_socket { connect };
#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32
allow arpwatch_t var_yp_t:dir { read getattr lock search ioctl };
#line 32
allow arpwatch_t var_yp_t:file { read getattr lock ioctl };
#line 32
allow arpwatch_t var_yp_t:lnk_file { getattr read };
#line 32

#line 32
allow arpwatch_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 32
allow arpwatch_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 32
dontaudit arpwatch_t self:capability net_bind_service;
#line 32
dontaudit arpwatch_t reserved_port_type:tcp_socket name_connect;
#line 32
dontaudit arpwatch_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 32

#line 32
} else {
#line 32
dontaudit arpwatch_t var_yp_t:dir search;
#line 32
}
#line 32
 

#line 36


#line 42

# why is mail delivered to a directory of type arpwatch_data_t?
allow mta_delivery_agent arpwatch_data_t:dir search;
allow { system_mail_t mta_user_agent } arpwatch_tmp_t:file { ioctl read getattr lock write append };
#line 48

#line 48
dontaudit { system_mail_t mta_user_agent } arpwatch_t:packet_socket { read write };
#line 48

#line 1 "domains/program/auditd.te"
#DESC auditd - System auditing daemon
#
# Authors: Colin Walters <walters@verbum.org>
#
# Some fixes by Paul Moore <paul.moore@hp.com>
# 
#line 11



#line 13

#line 13

#line 13

#line 13
type auditd_t, domain, privlog, daemon , transitionbool;
#line 13
type auditd_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit auditd_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types auditd_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow auditd_t init_t:fd use;
#line 13
allow auditd_t init_t:process sigchld;
#line 13
allow auditd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow auditd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow auditd_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow auditd_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow auditd_t ld_so_t:file execute_no_trans;
#line 13
allow auditd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow auditd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow auditd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow auditd_t texrel_shlib_t:file execmod;
#line 13
allow auditd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow auditd_t device_t:dir search;
#line 13
allow auditd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow auditd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow auditd_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow auditd_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow auditd_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow auditd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit auditd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit auditd_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow auditd_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow auditd_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow auditd_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow auditd_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit auditd_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit auditd_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow auditd_t sysctl_t:dir search;
#line 13
allow auditd_t sysctl_kernel_t:dir search;
#line 13
allow auditd_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13

#line 13
bool auditd_disable_trans false;
#line 13
if (auditd_disable_trans) {
#line 13

#line 13
allow initrc_t auditd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13

#line 13
allow sysadm_t auditd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13
} else {
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t auditd_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t auditd_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t auditd_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t auditd_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t auditd_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow auditd_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow auditd_t initrc_t:fd use;
#line 13
allow initrc_t auditd_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow auditd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow auditd_t auditd_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow auditd_t auditd_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t auditd_exec_t:process auditd_t;
#line 13

#line 13

#line 13
allow initrc_t auditd_t:process { noatsecure siginh rlimitinh };
#line 13

#line 13
}
#line 13
 
#line 13
allow auditd_t privfd:fd use;
#line 13

#line 13
allow auditd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
# Create pid file.
#line 13
allow auditd_t var_t:dir { getattr search };
#line 13

#line 13
type auditd_var_run_t, file_type, sysadmfile, pidfile;
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow auditd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow auditd_t auditd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition auditd_t var_run_t:file auditd_var_run_t;
#line 13

#line 13

#line 13

#line 13
allow auditd_t var_t:dir search;
#line 13
allow auditd_t auditd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13

#line 13
allow auditd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13
# for daemons that look at /root on startup
#line 13
dontaudit auditd_t sysadm_home_dir_t:dir search;
#line 13

#line 13
# for df
#line 13
allow auditd_t fs_type:filesystem getattr;
#line 13
allow auditd_t removable_t:filesystem getattr;
#line 13

#line 13

#line 13
allow auditd_t etc_t:lnk_file read;
#line 13
allow auditd_t lib_t:file { read getattr lock ioctl };
#line 13

#line 13
allow auditd_t locale_t:dir { read getattr lock search ioctl };
#line 13
allow auditd_t locale_t:file { read getattr lock ioctl };
#line 13
allow auditd_t locale_t:lnk_file { getattr read };
#line 13

#line 13

#line 13

#line 13
# for localization
#line 13
allow auditd_t lib_t:file { getattr read };
#line 13


#line 19


allow auditd_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay nlmsg_readpriv };
allow auditd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow auditd_t self:capability { audit_write audit_control sys_nice sys_resource };
allow auditd_t self:process setsched;
allow auditd_t self:file { getattr read write };
allow auditd_t etc_t:file { getattr read };

# Do not use logdir_domain since this is a security file
type auditd_log_t, file_type, secure_file_type;
allow auditd_t var_log_t:dir search;

#line 31
allow auditd_t auditd_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 31
allow auditd_t auditd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 31
allow auditd_t auditd_log_t:lnk_file { create read getattr setattr link unlink rename };
#line 31



#line 33
allow auditd_t init_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 33

allow auditd_t initctl_t:fifo_file write;

#line 38

#line 38
dontaudit auditd_t unconfined_t:fifo_file read;
#line 38


type auditctl_t, domain, privlog;
type auditctl_exec_t, file_type, exec_type, sysadmfile;

#line 42
allow auditctl_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 42
allow auditctl_t lib_t:lnk_file { read getattr lock ioctl };
#line 42
allow auditctl_t ld_so_t:file { read getattr lock execute ioctl };
#line 42
#allow auditctl_t ld_so_t:file execute_no_trans;
#line 42
allow auditctl_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 42
allow auditctl_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 42
allow auditctl_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 42
allow auditctl_t texrel_shlib_t:file execmod;
#line 42
allow auditctl_t ld_so_cache_t:file { read getattr lock ioctl };
#line 42
allow auditctl_t device_t:dir search;
#line 42
allow auditctl_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 42

allow auditctl_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay nlmsg_readpriv };
allow auditctl_t self:capability { audit_write audit_control };
allow auditctl_t etc_t:file { getattr read };
allow auditctl_t admin_tty_type:chr_file { ioctl read getattr lock write append };

type auditd_etc_t, file_type, secure_file_type;
allow { auditd_t auditctl_t } auditd_etc_t:file { read getattr lock ioctl };
allow initrc_t auditd_etc_t:file { read getattr lock ioctl };

role secadm_r types auditctl_t;
role sysadm_r types auditctl_t;

#line 54
allow secadm_t auditd_etc_t:file { ioctl read getattr lock write append };
#line 54

#line 54
allow secadm_t auditd_log_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 54
allow secadm_t auditd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 54
allow secadm_t auditd_log_t:lnk_file { create read getattr setattr link unlink rename };
#line 54

#line 54

#line 54

#line 54

#line 54
#
#line 54
# Allow the process to transition to the new domain.
#line 54
#
#line 54
allow secadm_t auditctl_t:process transition;
#line 54

#line 54
#
#line 54
# Do not audit when glibc secure mode is enabled upon the transition.
#line 54
#
#line 54
dontaudit secadm_t auditctl_t:process noatsecure;
#line 54

#line 54
#
#line 54
# Do not audit when signal-related state is cleared upon the transition.
#line 54
#
#line 54
dontaudit secadm_t auditctl_t:process siginh;
#line 54

#line 54
#
#line 54
# Do not audit when resource limits are reset upon the transition.
#line 54
#
#line 54
dontaudit secadm_t auditctl_t:process rlimitinh;
#line 54

#line 54
#
#line 54
# Allow the process to execute the program.
#line 54
# 
#line 54
allow secadm_t auditctl_exec_t:file { read { getattr execute } };
#line 54

#line 54
#
#line 54
# Allow the process to reap the new domain.
#line 54
#
#line 54
allow auditctl_t secadm_t:process sigchld;
#line 54

#line 54
#
#line 54
# Allow the new domain to inherit and use file 
#line 54
# descriptions from the creating process and vice versa.
#line 54
#
#line 54
allow auditctl_t secadm_t:fd use;
#line 54
allow secadm_t auditctl_t:fd use;
#line 54

#line 54
#
#line 54
# Allow the new domain to write back to the old domain via a pipe.
#line 54
#
#line 54
allow auditctl_t secadm_t:fifo_file { ioctl read getattr lock write append };
#line 54

#line 54
#
#line 54
# Allow the new domain to read and execute the program.
#line 54
#
#line 54
allow auditctl_t auditctl_exec_t:file { read getattr lock execute ioctl };
#line 54

#line 54
#
#line 54
# Allow the new domain to be entered via the program.
#line 54
#
#line 54
allow auditctl_t auditctl_exec_t:file entrypoint;
#line 54

#line 54
type_transition secadm_t auditctl_exec_t:process auditctl_t;
#line 54

#line 54


#line 60


role system_r types auditctl_t;

#line 63

#line 63

#line 63
#
#line 63
# Allow the process to transition to the new domain.
#line 63
#
#line 63
allow initrc_t auditctl_t:process transition;
#line 63

#line 63
#
#line 63
# Do not audit when glibc secure mode is enabled upon the transition.
#line 63
#
#line 63
dontaudit initrc_t auditctl_t:process noatsecure;
#line 63

#line 63
#
#line 63
# Do not audit when signal-related state is cleared upon the transition.
#line 63
#
#line 63
dontaudit initrc_t auditctl_t:process siginh;
#line 63

#line 63
#
#line 63
# Do not audit when resource limits are reset upon the transition.
#line 63
#
#line 63
dontaudit initrc_t auditctl_t:process rlimitinh;
#line 63

#line 63
#
#line 63
# Allow the process to execute the program.
#line 63
# 
#line 63
allow initrc_t auditctl_exec_t:file { read { getattr execute } };
#line 63

#line 63
#
#line 63
# Allow the process to reap the new domain.
#line 63
#
#line 63
allow auditctl_t initrc_t:process sigchld;
#line 63

#line 63
#
#line 63
# Allow the new domain to inherit and use file 
#line 63
# descriptions from the creating process and vice versa.
#line 63
#
#line 63
allow auditctl_t initrc_t:fd use;
#line 63
allow initrc_t auditctl_t:fd use;
#line 63

#line 63
#
#line 63
# Allow the new domain to write back to the old domain via a pipe.
#line 63
#
#line 63
allow auditctl_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 63

#line 63
#
#line 63
# Allow the new domain to read and execute the program.
#line 63
#
#line 63
allow auditctl_t auditctl_exec_t:file { read getattr lock execute ioctl };
#line 63

#line 63
#
#line 63
# Allow the new domain to be entered via the program.
#line 63
#
#line 63
allow auditctl_t auditctl_exec_t:file entrypoint;
#line 63

#line 63
type_transition initrc_t auditctl_exec_t:process auditctl_t;
#line 63


dontaudit auditctl_t local_login_t:fd use;
allow auditctl_t proc_t:dir search;
allow auditctl_t proc_t:lnk_file { getattr read };
allow auditctl_t sysctl_kernel_t:dir search;
allow auditctl_t sysctl_kernel_t:file { getattr read };
dontaudit auditctl_t init_t:fd use; 
allow auditctl_t device_t:dir { read getattr lock search ioctl };
allow auditctl_t devpts_t:dir { read getattr lock search ioctl };
allow auditctl_t initrc_devpts_t:chr_file { read write };
allow auditctl_t privfd:fd use;


allow auditd_t sbin_t:dir search;

#line 78
allow auditd_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 78

allow auditd_t self:fifo_file { ioctl read getattr lock write append };
#line 1 "domains/program/bluetooth.te"
#DESC Bluetooth 
#
# Authors:  Dan Walsh
# RH-Packages: Bluetooth
#

#################################
#
# Rules for the bluetooth_t domain.
#

#line 11

#line 11

#line 11

#line 11
type bluetooth_t, domain, privlog, daemon , transitionbool;
#line 11
type bluetooth_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit bluetooth_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types bluetooth_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow bluetooth_t init_t:fd use;
#line 11
allow bluetooth_t init_t:process sigchld;
#line 11
allow bluetooth_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow bluetooth_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow bluetooth_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow bluetooth_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow bluetooth_t ld_so_t:file execute_no_trans;
#line 11
allow bluetooth_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow bluetooth_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow bluetooth_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow bluetooth_t texrel_shlib_t:file execmod;
#line 11
allow bluetooth_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow bluetooth_t device_t:dir search;
#line 11
allow bluetooth_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow bluetooth_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow bluetooth_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow bluetooth_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow bluetooth_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow bluetooth_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit bluetooth_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit bluetooth_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow bluetooth_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow bluetooth_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow bluetooth_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow bluetooth_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit bluetooth_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit bluetooth_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
# Read system variables in /sys.
#line 11

#line 11
allow bluetooth_t sysctl_t:dir search;
#line 11
allow bluetooth_t sysctl_kernel_t:dir search;
#line 11
allow bluetooth_t sysctl_kernel_t:file { getattr read };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allows user to define a tunable to disable domain transition
#line 11
#
#line 11

#line 11
bool bluetooth_disable_trans false;
#line 11
if (bluetooth_disable_trans) {
#line 11

#line 11
allow initrc_t bluetooth_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11

#line 11
allow sysadm_t bluetooth_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11
 
#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow initrc_t bluetooth_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit initrc_t bluetooth_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit initrc_t bluetooth_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit initrc_t bluetooth_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow initrc_t bluetooth_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow bluetooth_t initrc_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow bluetooth_t initrc_t:fd use;
#line 11
allow initrc_t bluetooth_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow bluetooth_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow bluetooth_t bluetooth_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow bluetooth_t bluetooth_exec_t:file entrypoint;
#line 11

#line 11
type_transition initrc_t bluetooth_exec_t:process bluetooth_t;
#line 11

#line 11

#line 11
allow initrc_t bluetooth_t:process { noatsecure siginh rlimitinh };
#line 11

#line 11
}
#line 11
 
#line 11
allow bluetooth_t privfd:fd use;
#line 11

#line 11
allow bluetooth_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
# Create pid file.
#line 11
allow bluetooth_t var_t:dir { getattr search };
#line 11

#line 11
type bluetooth_var_run_t, file_type, sysadmfile, pidfile;
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow bluetooth_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow bluetooth_t bluetooth_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition bluetooth_t var_run_t:file bluetooth_var_run_t;
#line 11

#line 11

#line 11

#line 11
allow bluetooth_t var_t:dir search;
#line 11
allow bluetooth_t bluetooth_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11

#line 11
allow bluetooth_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11
# for daemons that look at /root on startup
#line 11
dontaudit bluetooth_t sysadm_home_dir_t:dir search;
#line 11

#line 11
# for df
#line 11
allow bluetooth_t fs_type:filesystem getattr;
#line 11
allow bluetooth_t removable_t:filesystem getattr;
#line 11

#line 11

#line 11
allow bluetooth_t etc_t:lnk_file read;
#line 11
allow bluetooth_t lib_t:file { read getattr lock ioctl };
#line 11

#line 11
allow bluetooth_t locale_t:dir { read getattr lock search ioctl };
#line 11
allow bluetooth_t locale_t:file { read getattr lock ioctl };
#line 11
allow bluetooth_t locale_t:lnk_file { getattr read };
#line 11

#line 11

#line 11

#line 11
# for localization
#line 11
allow bluetooth_t lib_t:file { getattr read };
#line 11



#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow bluetooth_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow bluetooth_t bluetooth_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition bluetooth_t var_run_t:sock_file bluetooth_var_run_t;
#line 13

#line 13


#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow bluetooth_t bluetooth_conf_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow bluetooth_t bluetooth_conf_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow bluetooth_t bluetooth_conf_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow bluetooth_t bluetooth_conf_rw_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow bluetooth_t bluetooth_conf_rw_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow bluetooth_t bluetooth_conf_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition bluetooth_t bluetooth_conf_t:dir bluetooth_conf_rw_t;
#line 14
type_transition bluetooth_t bluetooth_conf_t:{ file lnk_file sock_file fifo_file } bluetooth_conf_rw_t;
#line 14

#line 14



#line 16
type bluetooth_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the process to modify the directory.
#line 16
#
#line 16
allow bluetooth_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 16

#line 16
#
#line 16
# Allow the process to create the file.
#line 16
#
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
allow bluetooth_t bluetooth_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
allow bluetooth_t bluetooth_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
type_transition bluetooth_t tmp_t:{ file dir } bluetooth_tmp_t;
#line 16

#line 16

#line 16


#line 17
type bluetooth_var_lib_t, file_type, sysadmfile;
#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the process to modify the directory.
#line 17
#
#line 17
allow bluetooth_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17

#line 17
#
#line 17
# Allow the process to create the file.
#line 17
#
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow bluetooth_t bluetooth_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
type_transition bluetooth_t var_lib_t:file bluetooth_var_lib_t;
#line 17

#line 17

#line 17
allow bluetooth_t bluetooth_var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17


# Use capabilities.
allow bluetooth_t self:file read;
allow bluetooth_t self:capability { net_admin net_raw sys_tty_config };
allow bluetooth_t self:process getsched;
allow bluetooth_t proc_t:file { getattr read };

allow bluetooth_t self:shm { associate getattr setattr create destroy read write lock unix_read unix_write };


#line 27
type bluetooth_lock_t, file_type, sysadmfile, lockfile;
#line 27

#line 27

#line 27

#line 27

#line 27
#
#line 27
# Allow the process to modify the directory.
#line 27
#
#line 27
allow bluetooth_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 27

#line 27
#
#line 27
# Allow the process to create the file.
#line 27
#
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
allow bluetooth_t bluetooth_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
type_transition bluetooth_t var_lock_t:file bluetooth_lock_t;
#line 27

#line 27

#line 27


# Use the network.

#line 30

#line 30

#line 30

#line 30

#line 30

#line 30
#
#line 30
# Allow the domain to create and use tcp sockets.
#line 30
# Other kinds of sockets must be separately authorized for use.
#line 30
allow bluetooth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 30

#line 30
allow bluetooth_t unlabeled_t:association { sendto recvfrom };
#line 30

#line 30
#
#line 30
# Allow the domain to send or receive using any network interface.
#line 30
# netif_type is a type attribute for all network interface types.
#line 30
#
#line 30
allow bluetooth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 30
#
#line 30
# Allow the domain to send to or receive from any node.
#line 30
# node_type is a type attribute for all node types.
#line 30
#
#line 30
allow bluetooth_t node_type:node { tcp_send rawip_send };
#line 30
allow bluetooth_t node_type:node { tcp_recv rawip_recv };
#line 30

#line 30
#
#line 30
# Allow the domain to send to or receive from any port.
#line 30
# port_type is a type attribute for all port types.
#line 30
#
#line 30

#line 30
allow bluetooth_t port_type:tcp_socket { send_msg recv_msg };
#line 30

#line 30

#line 30
# XXX Allow binding to any node type.  Remove once
#line 30
# individual rules have been added to all domains that 
#line 30
# bind sockets. 
#line 30
allow bluetooth_t node_type:tcp_socket node_bind;
#line 30
#
#line 30
# Allow access to network files including /etc/resolv.conf
#line 30
#
#line 30
allow bluetooth_t net_conf_t:file { read getattr lock ioctl };
#line 30

#line 30
allow bluetooth_t self:tcp_socket { listen accept };
#line 30

#line 30

#line 30

#line 30
#
#line 30
# Allow the domain to create and use tcp sockets.
#line 30
# Other kinds of sockets must be separately authorized for use.
#line 30
allow bluetooth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 30

#line 30
allow bluetooth_t unlabeled_t:association { sendto recvfrom };
#line 30

#line 30
#
#line 30
# Allow the domain to send or receive using any network interface.
#line 30
# netif_type is a type attribute for all network interface types.
#line 30
#
#line 30
allow bluetooth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 30
#
#line 30
# Allow the domain to send to or receive from any node.
#line 30
# node_type is a type attribute for all node types.
#line 30
#
#line 30
allow bluetooth_t node_type:node { tcp_send rawip_send };
#line 30
allow bluetooth_t node_type:node { tcp_recv rawip_recv };
#line 30

#line 30
#
#line 30
# Allow the domain to send to or receive from any port.
#line 30
# port_type is a type attribute for all port types.
#line 30
#
#line 30

#line 30
allow bluetooth_t port_type:tcp_socket { send_msg recv_msg };
#line 30

#line 30

#line 30
# XXX Allow binding to any node type.  Remove once
#line 30
# individual rules have been added to all domains that 
#line 30
# bind sockets. 
#line 30
allow bluetooth_t node_type:tcp_socket node_bind;
#line 30
#
#line 30
# Allow access to network files including /etc/resolv.conf
#line 30
#
#line 30
allow bluetooth_t net_conf_t:file { read getattr lock ioctl };
#line 30

#line 30
allow bluetooth_t self:tcp_socket { connect };
#line 30

#line 30

#line 30

#line 30

#line 30

#line 30
#
#line 30
# Allow the domain to create and use udp sockets.
#line 30
# Other kinds of sockets must be separately authorized for use.
#line 30
allow bluetooth_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 30

#line 30
allow bluetooth_t unlabeled_t:association { sendto recvfrom };
#line 30

#line 30
#
#line 30
# Allow the domain to send or receive using any network interface.
#line 30
# netif_type is a type attribute for all network interface types.
#line 30
#
#line 30
allow bluetooth_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 30
#
#line 30
# Allow the domain to send to or receive from any node.
#line 30
# node_type is a type attribute for all node types.
#line 30
#
#line 30
allow bluetooth_t node_type:node { udp_send rawip_send };
#line 30
allow bluetooth_t node_type:node { udp_recv rawip_recv };
#line 30

#line 30
#
#line 30
# Allow the domain to send to or receive from any port.
#line 30
# port_type is a type attribute for all port types.
#line 30
#
#line 30

#line 30
allow bluetooth_t port_type:udp_socket { send_msg recv_msg };
#line 30

#line 30

#line 30
# XXX Allow binding to any node type.  Remove once
#line 30
# individual rules have been added to all domains that 
#line 30
# bind sockets. 
#line 30
allow bluetooth_t node_type:udp_socket node_bind;
#line 30
#
#line 30
# Allow access to network files including /etc/resolv.conf
#line 30
#
#line 30
allow bluetooth_t net_conf_t:file { read getattr lock ioctl };
#line 30

#line 30
allow bluetooth_t self:udp_socket { connect };
#line 30

#line 30

#line 30

#line 30

#line 30


#line 31

#line 31
if (allow_ypbind) {
#line 31

#line 31

#line 31

#line 31

#line 31

#line 31

#line 31

#line 31
#
#line 31
# Allow the domain to create and use tcp sockets.
#line 31
# Other kinds of sockets must be separately authorized for use.
#line 31
allow bluetooth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 31

#line 31
allow bluetooth_t unlabeled_t:association { sendto recvfrom };
#line 31

#line 31
#
#line 31
# Allow the domain to send or receive using any network interface.
#line 31
# netif_type is a type attribute for all network interface types.
#line 31
#
#line 31
allow bluetooth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 31
#
#line 31
# Allow the domain to send to or receive from any node.
#line 31
# node_type is a type attribute for all node types.
#line 31
#
#line 31
allow bluetooth_t node_type:node { tcp_send rawip_send };
#line 31
allow bluetooth_t node_type:node { tcp_recv rawip_recv };
#line 31

#line 31
#
#line 31
# Allow the domain to send to or receive from any port.
#line 31
# port_type is a type attribute for all port types.
#line 31
#
#line 31

#line 31
allow bluetooth_t port_type:tcp_socket { send_msg recv_msg };
#line 31

#line 31

#line 31
# XXX Allow binding to any node type.  Remove once
#line 31
# individual rules have been added to all domains that 
#line 31
# bind sockets. 
#line 31
allow bluetooth_t node_type:tcp_socket node_bind;
#line 31
#
#line 31
# Allow access to network files including /etc/resolv.conf
#line 31
#
#line 31
allow bluetooth_t net_conf_t:file { read getattr lock ioctl };
#line 31

#line 31
allow bluetooth_t self:tcp_socket { listen accept };
#line 31

#line 31

#line 31

#line 31
#
#line 31
# Allow the domain to create and use tcp sockets.
#line 31
# Other kinds of sockets must be separately authorized for use.
#line 31
allow bluetooth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 31

#line 31
allow bluetooth_t unlabeled_t:association { sendto recvfrom };
#line 31

#line 31
#
#line 31
# Allow the domain to send or receive using any network interface.
#line 31
# netif_type is a type attribute for all network interface types.
#line 31
#
#line 31
allow bluetooth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 31
#
#line 31
# Allow the domain to send to or receive from any node.
#line 31
# node_type is a type attribute for all node types.
#line 31
#
#line 31
allow bluetooth_t node_type:node { tcp_send rawip_send };
#line 31
allow bluetooth_t node_type:node { tcp_recv rawip_recv };
#line 31

#line 31
#
#line 31
# Allow the domain to send to or receive from any port.
#line 31
# port_type is a type attribute for all port types.
#line 31
#
#line 31

#line 31
allow bluetooth_t port_type:tcp_socket { send_msg recv_msg };
#line 31

#line 31

#line 31
# XXX Allow binding to any node type.  Remove once
#line 31
# individual rules have been added to all domains that 
#line 31
# bind sockets. 
#line 31
allow bluetooth_t node_type:tcp_socket node_bind;
#line 31
#
#line 31
# Allow access to network files including /etc/resolv.conf
#line 31
#
#line 31
allow bluetooth_t net_conf_t:file { read getattr lock ioctl };
#line 31

#line 31
allow bluetooth_t self:tcp_socket { connect };
#line 31

#line 31

#line 31

#line 31

#line 31

#line 31
#
#line 31
# Allow the domain to create and use udp sockets.
#line 31
# Other kinds of sockets must be separately authorized for use.
#line 31
allow bluetooth_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 31

#line 31
allow bluetooth_t unlabeled_t:association { sendto recvfrom };
#line 31

#line 31
#
#line 31
# Allow the domain to send or receive using any network interface.
#line 31
# netif_type is a type attribute for all network interface types.
#line 31
#
#line 31
allow bluetooth_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 31
#
#line 31
# Allow the domain to send to or receive from any node.
#line 31
# node_type is a type attribute for all node types.
#line 31
#
#line 31
allow bluetooth_t node_type:node { udp_send rawip_send };
#line 31
allow bluetooth_t node_type:node { udp_recv rawip_recv };
#line 31

#line 31
#
#line 31
# Allow the domain to send to or receive from any port.
#line 31
# port_type is a type attribute for all port types.
#line 31
#
#line 31

#line 31
allow bluetooth_t port_type:udp_socket { send_msg recv_msg };
#line 31

#line 31

#line 31
# XXX Allow binding to any node type.  Remove once
#line 31
# individual rules have been added to all domains that 
#line 31
# bind sockets. 
#line 31
allow bluetooth_t node_type:udp_socket node_bind;
#line 31
#
#line 31
# Allow access to network files including /etc/resolv.conf
#line 31
#
#line 31
allow bluetooth_t net_conf_t:file { read getattr lock ioctl };
#line 31

#line 31
allow bluetooth_t self:udp_socket { connect };
#line 31

#line 31

#line 31

#line 31

#line 31

#line 31

#line 31
allow bluetooth_t var_yp_t:dir { read getattr lock search ioctl };
#line 31
allow bluetooth_t var_yp_t:file { read getattr lock ioctl };
#line 31
allow bluetooth_t var_yp_t:lnk_file { getattr read };
#line 31

#line 31
allow bluetooth_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 31
allow bluetooth_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 31
dontaudit bluetooth_t self:capability net_bind_service;
#line 31
dontaudit bluetooth_t reserved_port_type:tcp_socket name_connect;
#line 31
dontaudit bluetooth_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 31

#line 31
} else {
#line 31
dontaudit bluetooth_t var_yp_t:dir search;
#line 31
}
#line 31
 
#line 35

#line 35

#line 35

#line 35

#line 35
# Derived type used for connection
#line 35
type bluetooth_dbusd_system_t;
#line 35
type_change bluetooth_t system_dbusd_t:dbus bluetooth_dbusd_system_t;
#line 35

#line 35
# SE-DBus specific permissions
#line 35
allow bluetooth_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 35

#line 35
# For connecting to the bus
#line 35
allow bluetooth_t system_dbusd_t:unix_stream_socket connectto;
#line 35

#line 35

#line 35
allow { bluetooth_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 35
allow { bluetooth_t } system_dbusd_var_run_t:sock_file write;
#line 35
  
#line 35
allow bluetooth_t system_dbusd_t:dbus send_msg;
#line 35

allow bluetooth_t self:socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

allow bluetooth_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow bluetooth_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

dontaudit bluetooth_t sysadm_devpts_t:chr_file { read write };

# bluetooth_conf_t is the type of the /etc/bluetooth dir.
type bluetooth_conf_t, file_type, sysadmfile;
type bluetooth_conf_rw_t, file_type, sysadmfile;

# Read /etc/bluetooth
allow bluetooth_t bluetooth_conf_t:dir search;
allow bluetooth_t bluetooth_conf_t:file { getattr read ioctl };
#/usr/sbin/hid2hci causes the following
allow initrc_t usbfs_t:file { getattr read };
allow bluetooth_t usbfs_t:dir { read getattr lock search ioctl };
allow bluetooth_t usbfs_t:file { ioctl read getattr lock write append }; 
allow bluetooth_t bin_t:dir search;

#line 55
allow bluetooth_t { bin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 55

allow bluetooth_t bin_t:lnk_file read;

#Handle bluetooth serial devices
allow bluetooth_t tty_device_t:chr_file { ioctl read getattr lock write append };
allow bluetooth_t self:fifo_file { ioctl read getattr lock write append };
allow bluetooth_t { etc_t etc_runtime_t }:file { getattr read };

#line 62
allow bluetooth_t fonts_t:dir { read getattr lock search ioctl };
#line 62
allow bluetooth_t fonts_t:file { read getattr lock ioctl };
#line 62
allow bluetooth_t fonts_t:lnk_file { getattr read };
#line 62

allow bluetooth_t urandom_device_t:chr_file { read getattr lock ioctl };
allow bluetooth_t usr_t:file { getattr read };


#line 66
type bluetooth_helper_t, domain, privlog , nscd_client_domain;
#line 66
type bluetooth_helper_exec_t, file_type, sysadmfile, exec_type;
#line 66
role sysadm_r types bluetooth_helper_t;
#line 66

#line 66
role system_r types bluetooth_helper_t;
#line 66

#line 66

#line 66

#line 66

#line 66
#
#line 66
# Allow the process to transition to the new domain.
#line 66
#
#line 66
allow sysadm_t bluetooth_helper_t:process transition;
#line 66

#line 66
#
#line 66
# Do not audit when glibc secure mode is enabled upon the transition.
#line 66
#
#line 66
dontaudit sysadm_t bluetooth_helper_t:process noatsecure;
#line 66

#line 66
#
#line 66
# Do not audit when signal-related state is cleared upon the transition.
#line 66
#
#line 66
dontaudit sysadm_t bluetooth_helper_t:process siginh;
#line 66

#line 66
#
#line 66
# Do not audit when resource limits are reset upon the transition.
#line 66
#
#line 66
dontaudit sysadm_t bluetooth_helper_t:process rlimitinh;
#line 66

#line 66
#
#line 66
# Allow the process to execute the program.
#line 66
# 
#line 66
allow sysadm_t bluetooth_helper_exec_t:file { read { getattr execute } };
#line 66

#line 66
#
#line 66
# Allow the process to reap the new domain.
#line 66
#
#line 66
allow bluetooth_helper_t sysadm_t:process sigchld;
#line 66

#line 66
#
#line 66
# Allow the new domain to inherit and use file 
#line 66
# descriptions from the creating process and vice versa.
#line 66
#
#line 66
allow bluetooth_helper_t sysadm_t:fd use;
#line 66
allow sysadm_t bluetooth_helper_t:fd use;
#line 66

#line 66
#
#line 66
# Allow the new domain to write back to the old domain via a pipe.
#line 66
#
#line 66
allow bluetooth_helper_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 66

#line 66
#
#line 66
# Allow the new domain to read and execute the program.
#line 66
#
#line 66
allow bluetooth_helper_t bluetooth_helper_exec_t:file { read getattr lock execute ioctl };
#line 66

#line 66
#
#line 66
# Allow the new domain to be entered via the program.
#line 66
#
#line 66
allow bluetooth_helper_t bluetooth_helper_exec_t:file entrypoint;
#line 66

#line 66
type_transition sysadm_t bluetooth_helper_exec_t:process bluetooth_helper_t;
#line 66

#line 66

#line 66
allow bluetooth_helper_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 66
allow bluetooth_helper_t lib_t:lnk_file { read getattr lock ioctl };
#line 66
allow bluetooth_helper_t ld_so_t:file { read getattr lock execute ioctl };
#line 66
#allow bluetooth_helper_t ld_so_t:file execute_no_trans;
#line 66
allow bluetooth_helper_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 66
allow bluetooth_helper_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 66
allow bluetooth_helper_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 66
allow bluetooth_helper_t texrel_shlib_t:file execmod;
#line 66
allow bluetooth_helper_t ld_so_cache_t:file { read getattr lock ioctl };
#line 66
allow bluetooth_helper_t device_t:dir search;
#line 66
allow bluetooth_helper_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 66

#line 66


#line 67

#line 67

#line 67
#
#line 67
# Allow the process to transition to the new domain.
#line 67
#
#line 67
allow bluetooth_t bluetooth_helper_t:process transition;
#line 67

#line 67
#
#line 67
# Do not audit when glibc secure mode is enabled upon the transition.
#line 67
#
#line 67
dontaudit bluetooth_t bluetooth_helper_t:process noatsecure;
#line 67

#line 67
#
#line 67
# Do not audit when signal-related state is cleared upon the transition.
#line 67
#
#line 67
dontaudit bluetooth_t bluetooth_helper_t:process siginh;
#line 67

#line 67
#
#line 67
# Do not audit when resource limits are reset upon the transition.
#line 67
#
#line 67
dontaudit bluetooth_t bluetooth_helper_t:process rlimitinh;
#line 67

#line 67
#
#line 67
# Allow the process to execute the program.
#line 67
# 
#line 67
allow bluetooth_t bluetooth_helper_exec_t:file { read { getattr execute } };
#line 67

#line 67
#
#line 67
# Allow the process to reap the new domain.
#line 67
#
#line 67
allow bluetooth_helper_t bluetooth_t:process sigchld;
#line 67

#line 67
#
#line 67
# Allow the new domain to inherit and use file 
#line 67
# descriptions from the creating process and vice versa.
#line 67
#
#line 67
allow bluetooth_helper_t bluetooth_t:fd use;
#line 67
allow bluetooth_t bluetooth_helper_t:fd use;
#line 67

#line 67
#
#line 67
# Allow the new domain to write back to the old domain via a pipe.
#line 67
#
#line 67
allow bluetooth_helper_t bluetooth_t:fifo_file { ioctl read getattr lock write append };
#line 67

#line 67
#
#line 67
# Allow the new domain to read and execute the program.
#line 67
#
#line 67
allow bluetooth_helper_t bluetooth_helper_exec_t:file { read getattr lock execute ioctl };
#line 67

#line 67
#
#line 67
# Allow the new domain to be entered via the program.
#line 67
#
#line 67
allow bluetooth_helper_t bluetooth_helper_exec_t:file entrypoint;
#line 67

#line 67
type_transition bluetooth_t bluetooth_helper_exec_t:process bluetooth_helper_t;
#line 67

role system_r types bluetooth_helper_t;

#line 69
allow bluetooth_helper_t etc_t:lnk_file read;
#line 69
allow bluetooth_helper_t lib_t:file { read getattr lock ioctl };
#line 69

#line 69
allow bluetooth_helper_t locale_t:dir { read getattr lock search ioctl };
#line 69
allow bluetooth_helper_t locale_t:file { read getattr lock ioctl };
#line 69
allow bluetooth_helper_t locale_t:lnk_file { getattr read };
#line 69

#line 69
 
typeattribute bluetooth_helper_t unrestricted;

#line 71
allow bluetooth_helper_t domain:dir { read getattr lock search ioctl };
#line 71
allow bluetooth_helper_t domain:file { read getattr lock ioctl };
#line 71
allow bluetooth_helper_t domain:lnk_file { getattr read };
#line 71

allow bluetooth_helper_t bin_t:dir { getattr search };

#line 73
allow bluetooth_helper_t { bin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 73

allow bluetooth_helper_t bin_t:lnk_file read;
allow bluetooth_helper_t self:capability sys_nice;
allow bluetooth_helper_t self:fifo_file { ioctl read getattr lock write append };
allow bluetooth_helper_t self:process { fork getsched sigchld };
allow bluetooth_helper_t self:shm { associate getattr setattr create destroy read write lock unix_read unix_write };
allow bluetooth_helper_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow bluetooth_helper_t { etc_t etc_runtime_t }:file { getattr read };

#line 81
allow bluetooth_helper_t fonts_t:dir { read getattr lock search ioctl };
#line 81
allow bluetooth_helper_t fonts_t:file { read getattr lock ioctl };
#line 81
allow bluetooth_helper_t fonts_t:lnk_file { getattr read };
#line 81


#line 82
allow bluetooth_helper_t proc_t:dir { read getattr lock search ioctl };
#line 82
allow bluetooth_helper_t proc_t:file { read getattr lock ioctl };
#line 82
allow bluetooth_helper_t proc_t:lnk_file { getattr read };
#line 82


#line 83
# Read system variables in /sys.
#line 83

#line 83
allow bluetooth_helper_t sysctl_t:dir search;
#line 83
allow bluetooth_helper_t sysctl_kernel_t:dir search;
#line 83
allow bluetooth_helper_t sysctl_kernel_t:file { getattr read };
#line 83

#line 83

#line 83

allow bluetooth_helper_t tmp_t:dir search;
allow bluetooth_helper_t usr_t:file { getattr read };
allow bluetooth_helper_t home_dir_type:dir search;
#line 90

#line 103

#line 103
allow bluetooth_helper_t tmp_t:sock_file { read write };
#line 103
allow bluetooth_helper_t tmpfs_t:file { read write };
#line 103
allow bluetooth_helper_t unconfined_t:unix_stream_socket connectto;
#line 103
allow bluetooth_t unconfined_t:dbus send_msg;
#line 103
allow unconfined_t bluetooth_t:dbus send_msg;
#line 103

allow bluetooth_helper_t bluetooth_t:socket { read write };
allow bluetooth_helper_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow bluetooth_helper_t self:unix_stream_socket connectto;

#line 107
type bluetooth_helper_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 107

#line 107

#line 107

#line 107

#line 107
#
#line 107
# Allow the process to modify the directory.
#line 107
#
#line 107
allow bluetooth_helper_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 107

#line 107
#
#line 107
# Allow the process to create the file.
#line 107
#
#line 107

#line 107

#line 107

#line 107

#line 107

#line 107
allow bluetooth_helper_t bluetooth_helper_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107
allow bluetooth_helper_t bluetooth_helper_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107
type_transition bluetooth_helper_t tmp_t:{ file dir } bluetooth_helper_tmp_t;
#line 107

#line 107

#line 107

allow bluetooth_helper_t urandom_device_t:chr_file { read getattr lock ioctl };

dontaudit bluetooth_helper_t default_t:dir { read search };
dontaudit bluetooth_helper_t { devtty_t ttyfile }:chr_file { read write };
dontaudit bluetooth_helper_t home_dir_type:dir { read getattr lock search ioctl };
#line 116

#line 1 "domains/program/canna.te"
#DESC canna - A Japanese character set input system.
#
# Authors: Dan Walsh <dwalsh@redhat.com>
#
#

#################################
#
# Rules for the canna_t domain.
#

#line 11

#line 11

#line 11

#line 11
type canna_t, domain, privlog, daemon , transitionbool;
#line 11
type canna_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit canna_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types canna_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow canna_t init_t:fd use;
#line 11
allow canna_t init_t:process sigchld;
#line 11
allow canna_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow canna_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow canna_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow canna_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow canna_t ld_so_t:file execute_no_trans;
#line 11
allow canna_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow canna_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow canna_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow canna_t texrel_shlib_t:file execmod;
#line 11
allow canna_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow canna_t device_t:dir search;
#line 11
allow canna_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow canna_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow canna_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow canna_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow canna_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow canna_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit canna_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit canna_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow canna_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow canna_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow canna_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow canna_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit canna_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit canna_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
# Read system variables in /sys.
#line 11

#line 11
allow canna_t sysctl_t:dir search;
#line 11
allow canna_t sysctl_kernel_t:dir search;
#line 11
allow canna_t sysctl_kernel_t:file { getattr read };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allows user to define a tunable to disable domain transition
#line 11
#
#line 11

#line 11
bool canna_disable_trans false;
#line 11
if (canna_disable_trans) {
#line 11

#line 11
allow initrc_t canna_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11

#line 11
allow sysadm_t canna_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11
 
#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow initrc_t canna_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit initrc_t canna_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit initrc_t canna_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit initrc_t canna_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow initrc_t canna_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow canna_t initrc_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow canna_t initrc_t:fd use;
#line 11
allow initrc_t canna_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow canna_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow canna_t canna_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow canna_t canna_exec_t:file entrypoint;
#line 11

#line 11
type_transition initrc_t canna_exec_t:process canna_t;
#line 11

#line 11

#line 11
allow initrc_t canna_t:process { noatsecure siginh rlimitinh };
#line 11

#line 11
}
#line 11
 
#line 11
allow canna_t privfd:fd use;
#line 11

#line 11
allow canna_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
# Create pid file.
#line 11
allow canna_t var_t:dir { getattr search };
#line 11

#line 11
type canna_var_run_t, file_type, sysadmfile, pidfile;
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow canna_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow canna_t canna_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition canna_t var_run_t:file canna_var_run_t;
#line 11

#line 11

#line 11

#line 11
allow canna_t var_t:dir search;
#line 11
allow canna_t canna_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11

#line 11
allow canna_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11
# for daemons that look at /root on startup
#line 11
dontaudit canna_t sysadm_home_dir_t:dir search;
#line 11

#line 11
# for df
#line 11
allow canna_t fs_type:filesystem getattr;
#line 11
allow canna_t removable_t:filesystem getattr;
#line 11

#line 11

#line 11
allow canna_t etc_t:lnk_file read;
#line 11
allow canna_t lib_t:file { read getattr lock ioctl };
#line 11

#line 11
allow canna_t locale_t:dir { read getattr lock search ioctl };
#line 11
allow canna_t locale_t:file { read getattr lock ioctl };
#line 11
allow canna_t locale_t:lnk_file { getattr read };
#line 11

#line 11

#line 11

#line 11
# for localization
#line 11
allow canna_t lib_t:file { getattr read };
#line 11



#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow canna_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow canna_t canna_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition canna_t var_run_t:sock_file canna_var_run_t;
#line 13

#line 13



#line 15

#line 15
type canna_log_t, file_type, sysadmfile, logfile;
#line 15

#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the process to modify the directory.
#line 15
#
#line 15
allow canna_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 15

#line 15
#
#line 15
# Allow the process to create the file.
#line 15
#
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
allow canna_t canna_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
type_transition canna_t var_log_t:file canna_log_t;
#line 15

#line 15

#line 15

#line 15
allow canna_t canna_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 15


#line 16
type canna_var_lib_t, file_type, sysadmfile;
#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the process to modify the directory.
#line 16
#
#line 16
allow canna_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 16

#line 16
#
#line 16
# Allow the process to create the file.
#line 16
#
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
allow canna_t canna_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
type_transition canna_t var_lib_t:file canna_var_lib_t;
#line 16

#line 16

#line 16
allow canna_t canna_var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 16


allow canna_t self:capability { setgid setuid net_bind_service };
allow canna_t tmp_t:dir { search };
allow canna_t self:unix_stream_socket { connectto { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept }};
allow canna_t self:unix_dgram_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow canna_t etc_t:file { getattr read };
allow canna_t usr_t:file { getattr read };

allow canna_t proc_t:file { read getattr lock ioctl };
allow canna_t etc_runtime_t:file { read getattr lock ioctl };
allow canna_t canna_var_lib_t:dir create;


#line 29
allow canna_t canna_var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 29
allow canna_t canna_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 29
allow canna_t canna_var_lib_t:lnk_file { create read getattr setattr link unlink rename };
#line 29



#line 31

#line 31

#line 31

#line 31
#
#line 31
# Allow the domain to create and use tcp sockets.
#line 31
# Other kinds of sockets must be separately authorized for use.
#line 31
allow canna_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 31

#line 31
allow canna_t unlabeled_t:association { sendto recvfrom };
#line 31

#line 31
#
#line 31
# Allow the domain to send or receive using any network interface.
#line 31
# netif_type is a type attribute for all network interface types.
#line 31
#
#line 31
allow canna_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 31
#
#line 31
# Allow the domain to send to or receive from any node.
#line 31
# node_type is a type attribute for all node types.
#line 31
#
#line 31
allow canna_t node_type:node { tcp_send rawip_send };
#line 31
allow canna_t node_type:node { tcp_recv rawip_recv };
#line 31

#line 31
#
#line 31
# Allow the domain to send to or receive from any port.
#line 31
# port_type is a type attribute for all port types.
#line 31
#
#line 31

#line 31
allow canna_t port_type:tcp_socket { send_msg recv_msg };
#line 31

#line 31

#line 31
# XXX Allow binding to any node type.  Remove once
#line 31
# individual rules have been added to all domains that 
#line 31
# bind sockets. 
#line 31
allow canna_t node_type:tcp_socket node_bind;
#line 31
#
#line 31
# Allow access to network files including /etc/resolv.conf
#line 31
#
#line 31
allow canna_t net_conf_t:file { read getattr lock ioctl };
#line 31

#line 31
allow canna_t self:tcp_socket { listen accept };
#line 31

#line 31

#line 31

#line 31
#
#line 31
# Allow the domain to create and use tcp sockets.
#line 31
# Other kinds of sockets must be separately authorized for use.
#line 31
allow canna_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 31

#line 31
allow canna_t unlabeled_t:association { sendto recvfrom };
#line 31

#line 31
#
#line 31
# Allow the domain to send or receive using any network interface.
#line 31
# netif_type is a type attribute for all network interface types.
#line 31
#
#line 31
allow canna_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 31
#
#line 31
# Allow the domain to send to or receive from any node.
#line 31
# node_type is a type attribute for all node types.
#line 31
#
#line 31
allow canna_t node_type:node { tcp_send rawip_send };
#line 31
allow canna_t node_type:node { tcp_recv rawip_recv };
#line 31

#line 31
#
#line 31
# Allow the domain to send to or receive from any port.
#line 31
# port_type is a type attribute for all port types.
#line 31
#
#line 31

#line 31
allow canna_t port_type:tcp_socket { send_msg recv_msg };
#line 31

#line 31

#line 31
# XXX Allow binding to any node type.  Remove once
#line 31
# individual rules have been added to all domains that 
#line 31
# bind sockets. 
#line 31
allow canna_t node_type:tcp_socket node_bind;
#line 31
#
#line 31
# Allow access to network files including /etc/resolv.conf
#line 31
#
#line 31
allow canna_t net_conf_t:file { read getattr lock ioctl };
#line 31

#line 31
allow canna_t self:tcp_socket { connect };
#line 31

#line 31

#line 31

allow canna_t port_type:tcp_socket name_connect;

#line 33

#line 33
if (allow_ypbind) {
#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33
#
#line 33
# Allow the domain to create and use tcp sockets.
#line 33
# Other kinds of sockets must be separately authorized for use.
#line 33
allow canna_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 33

#line 33
allow canna_t unlabeled_t:association { sendto recvfrom };
#line 33

#line 33
#
#line 33
# Allow the domain to send or receive using any network interface.
#line 33
# netif_type is a type attribute for all network interface types.
#line 33
#
#line 33
allow canna_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 33
#
#line 33
# Allow the domain to send to or receive from any node.
#line 33
# node_type is a type attribute for all node types.
#line 33
#
#line 33
allow canna_t node_type:node { tcp_send rawip_send };
#line 33
allow canna_t node_type:node { tcp_recv rawip_recv };
#line 33

#line 33
#
#line 33
# Allow the domain to send to or receive from any port.
#line 33
# port_type is a type attribute for all port types.
#line 33
#
#line 33

#line 33
allow canna_t port_type:tcp_socket { send_msg recv_msg };
#line 33

#line 33

#line 33
# XXX Allow binding to any node type.  Remove once
#line 33
# individual rules have been added to all domains that 
#line 33
# bind sockets. 
#line 33
allow canna_t node_type:tcp_socket node_bind;
#line 33
#
#line 33
# Allow access to network files including /etc/resolv.conf
#line 33
#
#line 33
allow canna_t net_conf_t:file { read getattr lock ioctl };
#line 33

#line 33
allow canna_t self:tcp_socket { listen accept };
#line 33

#line 33

#line 33

#line 33
#
#line 33
# Allow the domain to create and use tcp sockets.
#line 33
# Other kinds of sockets must be separately authorized for use.
#line 33
allow canna_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 33

#line 33
allow canna_t unlabeled_t:association { sendto recvfrom };
#line 33

#line 33
#
#line 33
# Allow the domain to send or receive using any network interface.
#line 33
# netif_type is a type attribute for all network interface types.
#line 33
#
#line 33
allow canna_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 33
#
#line 33
# Allow the domain to send to or receive from any node.
#line 33
# node_type is a type attribute for all node types.
#line 33
#
#line 33
allow canna_t node_type:node { tcp_send rawip_send };
#line 33
allow canna_t node_type:node { tcp_recv rawip_recv };
#line 33

#line 33
#
#line 33
# Allow the domain to send to or receive from any port.
#line 33
# port_type is a type attribute for all port types.
#line 33
#
#line 33

#line 33
allow canna_t port_type:tcp_socket { send_msg recv_msg };
#line 33

#line 33

#line 33
# XXX Allow binding to any node type.  Remove once
#line 33
# individual rules have been added to all domains that 
#line 33
# bind sockets. 
#line 33
allow canna_t node_type:tcp_socket node_bind;
#line 33
#
#line 33
# Allow access to network files including /etc/resolv.conf
#line 33
#
#line 33
allow canna_t net_conf_t:file { read getattr lock ioctl };
#line 33

#line 33
allow canna_t self:tcp_socket { connect };
#line 33

#line 33

#line 33

#line 33

#line 33

#line 33
#
#line 33
# Allow the domain to create and use udp sockets.
#line 33
# Other kinds of sockets must be separately authorized for use.
#line 33
allow canna_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 33

#line 33
allow canna_t unlabeled_t:association { sendto recvfrom };
#line 33

#line 33
#
#line 33
# Allow the domain to send or receive using any network interface.
#line 33
# netif_type is a type attribute for all network interface types.
#line 33
#
#line 33
allow canna_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 33
#
#line 33
# Allow the domain to send to or receive from any node.
#line 33
# node_type is a type attribute for all node types.
#line 33
#
#line 33
allow canna_t node_type:node { udp_send rawip_send };
#line 33
allow canna_t node_type:node { udp_recv rawip_recv };
#line 33

#line 33
#
#line 33
# Allow the domain to send to or receive from any port.
#line 33
# port_type is a type attribute for all port types.
#line 33
#
#line 33

#line 33
allow canna_t port_type:udp_socket { send_msg recv_msg };
#line 33

#line 33

#line 33
# XXX Allow binding to any node type.  Remove once
#line 33
# individual rules have been added to all domains that 
#line 33
# bind sockets. 
#line 33
allow canna_t node_type:udp_socket node_bind;
#line 33
#
#line 33
# Allow access to network files including /etc/resolv.conf
#line 33
#
#line 33
allow canna_t net_conf_t:file { read getattr lock ioctl };
#line 33

#line 33
allow canna_t self:udp_socket { connect };
#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33
allow canna_t var_yp_t:dir { read getattr lock search ioctl };
#line 33
allow canna_t var_yp_t:file { read getattr lock ioctl };
#line 33
allow canna_t var_yp_t:lnk_file { getattr read };
#line 33

#line 33
allow canna_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 33
allow canna_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 33
dontaudit canna_t self:capability net_bind_service;
#line 33
dontaudit canna_t reserved_port_type:tcp_socket name_connect;
#line 33
dontaudit canna_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 33

#line 33
} else {
#line 33
dontaudit canna_t var_yp_t:dir search;
#line 33
}
#line 33
 

allow userdomain canna_var_run_t:dir search;
allow userdomain canna_var_run_t:sock_file write;

#line 37
allow userdomain canna_t:unix_stream_socket connectto;
#line 37


#line 43


dontaudit canna_t kernel_t:fd use;
dontaudit canna_t root_t:file read;
#line 1 "domains/program/cardmgr.te"
#DESC Cardmgr - PCMCIA control programs
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#           Russell Coker <russell@coker.com.au>
# X-Debian-Packages: pcmcia-cs
#

#################################
#
# Rules for the cardmgr_t domain.
#

#line 12

#line 12

#line 12

#line 12
type cardmgr_t, domain, privlog, daemon , privmodule, transitionbool;
#line 12
type cardmgr_exec_t, file_type, sysadmfile, exec_type;
#line 12
dontaudit cardmgr_t self:capability sys_tty_config;
#line 12

#line 12
role system_r types cardmgr_t;
#line 12

#line 12
# Inherit and use descriptors from init.
#line 12
allow cardmgr_t init_t:fd use;
#line 12
allow cardmgr_t init_t:process sigchld;
#line 12
allow cardmgr_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 12

#line 12

#line 12
allow cardmgr_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 12
allow cardmgr_t lib_t:lnk_file { read getattr lock ioctl };
#line 12
allow cardmgr_t ld_so_t:file { read getattr lock execute ioctl };
#line 12
#allow cardmgr_t ld_so_t:file execute_no_trans;
#line 12
allow cardmgr_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 12
allow cardmgr_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 12
allow cardmgr_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 12
allow cardmgr_t texrel_shlib_t:file execmod;
#line 12
allow cardmgr_t ld_so_cache_t:file { read getattr lock ioctl };
#line 12
allow cardmgr_t device_t:dir search;
#line 12
allow cardmgr_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
allow cardmgr_t { self proc_t }:dir { read getattr lock search ioctl };
#line 12
allow cardmgr_t { self proc_t }:lnk_file { getattr read };
#line 12

#line 12
allow cardmgr_t device_t:dir { read getattr lock search ioctl };
#line 12

#line 12
allow cardmgr_t udev_tdb_t:file { read getattr lock ioctl };
#line 12
allow cardmgr_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit cardmgr_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit cardmgr_t unpriv_userdomain:fd use;
#line 12

#line 12

#line 12
allow cardmgr_t sysfs_t:dir { read getattr lock search ioctl };
#line 12
allow cardmgr_t sysfs_t:file { read getattr lock ioctl };
#line 12
allow cardmgr_t sysfs_t:lnk_file { getattr read };
#line 12
 
#line 12

#line 12
allow cardmgr_t autofs_t:dir { search getattr };
#line 12

#line 12
dontaudit cardmgr_t { tty_device_t devpts_t }:chr_file { read write };
#line 12
dontaudit cardmgr_t root_t:file { getattr read };
#line 12
 
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
# Read system variables in /sys.
#line 12

#line 12
allow cardmgr_t sysctl_t:dir search;
#line 12
allow cardmgr_t sysctl_kernel_t:dir search;
#line 12
allow cardmgr_t sysctl_kernel_t:file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allows user to define a tunable to disable domain transition
#line 12
#
#line 12

#line 12
bool cardmgr_disable_trans false;
#line 12
if (cardmgr_disable_trans) {
#line 12

#line 12
allow initrc_t cardmgr_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12

#line 12
allow sysadm_t cardmgr_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12
} else {
#line 12
 
#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow initrc_t cardmgr_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit initrc_t cardmgr_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit initrc_t cardmgr_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit initrc_t cardmgr_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow initrc_t cardmgr_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow cardmgr_t initrc_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow cardmgr_t initrc_t:fd use;
#line 12
allow initrc_t cardmgr_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow cardmgr_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow cardmgr_t cardmgr_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow cardmgr_t cardmgr_exec_t:file entrypoint;
#line 12

#line 12
type_transition initrc_t cardmgr_exec_t:process cardmgr_t;
#line 12

#line 12

#line 12
allow initrc_t cardmgr_t:process { noatsecure siginh rlimitinh };
#line 12

#line 12
}
#line 12
 
#line 12
allow cardmgr_t privfd:fd use;
#line 12

#line 12
allow cardmgr_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
# Create pid file.
#line 12
allow cardmgr_t var_t:dir { getattr search };
#line 12

#line 12
type cardmgr_var_run_t, file_type, sysadmfile, pidfile;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to modify the directory.
#line 12
#
#line 12
allow cardmgr_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12
#
#line 12
# Allow the process to create the file.
#line 12
#
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow cardmgr_t cardmgr_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
type_transition cardmgr_t var_run_t:file cardmgr_var_run_t;
#line 12

#line 12

#line 12

#line 12
allow cardmgr_t var_t:dir search;
#line 12
allow cardmgr_t cardmgr_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12

#line 12
allow cardmgr_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12
# for daemons that look at /root on startup
#line 12
dontaudit cardmgr_t sysadm_home_dir_t:dir search;
#line 12

#line 12
# for df
#line 12
allow cardmgr_t fs_type:filesystem getattr;
#line 12
allow cardmgr_t removable_t:filesystem getattr;
#line 12

#line 12

#line 12
allow cardmgr_t etc_t:lnk_file read;
#line 12
allow cardmgr_t lib_t:file { read getattr lock ioctl };
#line 12

#line 12
allow cardmgr_t locale_t:dir { read getattr lock search ioctl };
#line 12
allow cardmgr_t locale_t:file { read getattr lock ioctl };
#line 12
allow cardmgr_t locale_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12
# for localization
#line 12
allow cardmgr_t lib_t:file { getattr read };
#line 12


# for SSP
allow cardmgr_t urandom_device_t:chr_file read;

type cardctl_exec_t, file_type, sysadmfile, exec_type;
#line 20

role sysadm_r types cardmgr_t;
allow cardmgr_t admin_tty_type:chr_file { read write };

allow cardmgr_t sysfs_t:dir search;
allow cardmgr_t home_root_t:dir search;

# Use capabilities (net_admin for route), setuid for cardctl
allow cardmgr_t self:capability { dac_read_search dac_override setuid net_admin sys_admin sys_nice sys_tty_config mknod };

# for /etc/resolv.conf

#line 31

#line 31

#line 31

#line 31
#
#line 31
# Allow the process to modify the directory.
#line 31
#
#line 31
allow cardmgr_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 31

#line 31
#
#line 31
# Allow the process to create the file.
#line 31
#
#line 31

#line 31

#line 31

#line 31

#line 31

#line 31
allow cardmgr_t net_conf_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 31

#line 31

#line 31

#line 31

#line 31

#line 31

#line 31

#line 31

#line 31

#line 31
type_transition cardmgr_t etc_t:file net_conf_t;
#line 31

#line 31


allow cardmgr_t etc_runtime_t:file { getattr read };

allow cardmgr_t modules_object_t:dir search;
allow cardmgr_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow cardmgr_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow cardmgr_t self:fifo_file { ioctl read getattr lock write append };

# Create stab file

#line 41
type cardmgr_var_lib_t, file_type, sysadmfile;
#line 41

#line 41

#line 41

#line 41

#line 41
#
#line 41
# Allow the process to modify the directory.
#line 41
#
#line 41
allow cardmgr_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 41

#line 41
#
#line 41
# Allow the process to create the file.
#line 41
#
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
allow cardmgr_t cardmgr_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
type_transition cardmgr_t var_lib_t:file cardmgr_var_lib_t;
#line 41

#line 41

#line 41
allow cardmgr_t cardmgr_var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 41


# for /var/lib/misc/pcmcia-scheme
# would be better to have it in a different type if I knew how it was created..
allow cardmgr_t var_lib_t:file { getattr read };

# Create device files in /tmp.
type cardmgr_dev_t, file_type, sysadmfile, tmpfile, device_type, dev_fs;

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the process to modify the directory.
#line 49
#
#line 49
allow cardmgr_t { var_run_t cardmgr_var_run_t device_t tmp_t }:dir { read getattr lock search ioctl add_name remove_name write };
#line 49

#line 49
#
#line 49
# Allow the process to create the file.
#line 49
#
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow cardmgr_t cardmgr_dev_t:blk_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow cardmgr_t cardmgr_dev_t:chr_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
type_transition cardmgr_t { var_run_t cardmgr_var_run_t device_t tmp_t }:{ blk_file chr_file } cardmgr_dev_t;
#line 49

#line 49


# Create symbolic links in /dev.
type cardmgr_lnk_t, file_type, sysadmfile;

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the process to modify the directory.
#line 53
#
#line 53
allow cardmgr_t device_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 53

#line 53
#
#line 53
# Allow the process to create the file.
#line 53
#
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
allow cardmgr_t cardmgr_lnk_t:lnk_file { create read getattr setattr link unlink rename };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
type_transition cardmgr_t device_t:lnk_file cardmgr_lnk_t;
#line 53

#line 53


# Run a shell, normal commands, /etc/pcmcia scripts. 

#line 56
allow cardmgr_t { bin_t sbin_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 56
allow cardmgr_t { bin_t sbin_t etc_t }:lnk_file { getattr read };
#line 56

#line 56
allow cardmgr_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 56
allow cardmgr_t lib_t:lnk_file { read getattr lock ioctl };
#line 56
allow cardmgr_t ld_so_t:file { read getattr lock execute ioctl };
#line 56
#allow cardmgr_t ld_so_t:file execute_no_trans;
#line 56
allow cardmgr_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 56
allow cardmgr_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 56
allow cardmgr_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 56
allow cardmgr_t texrel_shlib_t:file execmod;
#line 56
allow cardmgr_t ld_so_cache_t:file { read getattr lock ioctl };
#line 56
allow cardmgr_t device_t:dir search;
#line 56
allow cardmgr_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 56

#line 56

#line 56
allow cardmgr_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 56

#line 56

#line 56
allow cardmgr_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 56

#line 56

#line 56
allow cardmgr_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 56

#line 56

#line 56
allow cardmgr_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 56

#line 56

#line 56
allow cardmgr_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 56

#line 56

#line 56
allow cardmgr_t ld_so_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 56

#line 56

allow cardmgr_t etc_t:lnk_file read;

# Run ifconfig.

#line 60

#line 60

#line 60
#
#line 60
# Allow the process to transition to the new domain.
#line 60
#
#line 60
allow cardmgr_t ifconfig_t:process transition;
#line 60

#line 60
#
#line 60
# Do not audit when glibc secure mode is enabled upon the transition.
#line 60
#
#line 60
dontaudit cardmgr_t ifconfig_t:process noatsecure;
#line 60

#line 60
#
#line 60
# Do not audit when signal-related state is cleared upon the transition.
#line 60
#
#line 60
dontaudit cardmgr_t ifconfig_t:process siginh;
#line 60

#line 60
#
#line 60
# Do not audit when resource limits are reset upon the transition.
#line 60
#
#line 60
dontaudit cardmgr_t ifconfig_t:process rlimitinh;
#line 60

#line 60
#
#line 60
# Allow the process to execute the program.
#line 60
# 
#line 60
allow cardmgr_t ifconfig_exec_t:file { read { getattr execute } };
#line 60

#line 60
#
#line 60
# Allow the process to reap the new domain.
#line 60
#
#line 60
allow ifconfig_t cardmgr_t:process sigchld;
#line 60

#line 60
#
#line 60
# Allow the new domain to inherit and use file 
#line 60
# descriptions from the creating process and vice versa.
#line 60
#
#line 60
allow ifconfig_t cardmgr_t:fd use;
#line 60
allow cardmgr_t ifconfig_t:fd use;
#line 60

#line 60
#
#line 60
# Allow the new domain to write back to the old domain via a pipe.
#line 60
#
#line 60
allow ifconfig_t cardmgr_t:fifo_file { ioctl read getattr lock write append };
#line 60

#line 60
#
#line 60
# Allow the new domain to read and execute the program.
#line 60
#
#line 60
allow ifconfig_t ifconfig_exec_t:file { read getattr lock execute ioctl };
#line 60

#line 60
#
#line 60
# Allow the new domain to be entered via the program.
#line 60
#
#line 60
allow ifconfig_t ifconfig_exec_t:file entrypoint;
#line 60

#line 60
type_transition cardmgr_t ifconfig_exec_t:process ifconfig_t;
#line 60

allow ifconfig_t cardmgr_t:fd use;

allow cardmgr_t proc_t:file { getattr read ioctl };

# Read /proc/PID directories for all domains (for fuser).

#line 66
allow cardmgr_t domain -unrestricted:dir { search getattr read };
#line 66
allow cardmgr_t domain -unrestricted:{ file lnk_file } { read getattr };
#line 66
allow cardmgr_t domain -unrestricted:process getattr;
#line 66
# We need to suppress this denial because procps tries to access
#line 66
# /proc/pid/environ and this now triggers a ptrace check in recent kernels
#line 66
# (2.4 and 2.6).  Might want to change procps to not do this, or only if
#line 66
# running in a privileged domain.
#line 66
dontaudit cardmgr_t domain -unrestricted:process ptrace;
#line 66

dontaudit cardmgr_t unrestricted:dir search;

allow cardmgr_t device_type:{ chr_file blk_file } getattr;
allow cardmgr_t ttyfile:chr_file getattr;
dontaudit cardmgr_t ptyfile:chr_file getattr;
dontaudit cardmgr_t file_type:{ dir { file lnk_file sock_file fifo_file } } getattr;
dontaudit cardmgr_t domain:{ fifo_file { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } } getattr;
dontaudit cardmgr_t proc_kmsg_t:file getattr;

allow cardmgr_t tty_device_t:chr_file { ioctl read getattr lock write append };

#line 80

#line 80

#line 80

#line 80

#line 80
#
#line 80
# Allow the process to transition to the new domain.
#line 80
#
#line 80
allow apmd_t cardmgr_t:process transition;
#line 80

#line 80
#
#line 80
# Do not audit when glibc secure mode is enabled upon the transition.
#line 80
#
#line 80
dontaudit apmd_t cardmgr_t:process noatsecure;
#line 80

#line 80
#
#line 80
# Do not audit when signal-related state is cleared upon the transition.
#line 80
#
#line 80
dontaudit apmd_t cardmgr_t:process siginh;
#line 80

#line 80
#
#line 80
# Do not audit when resource limits are reset upon the transition.
#line 80
#
#line 80
dontaudit apmd_t cardmgr_t:process rlimitinh;
#line 80

#line 80
#
#line 80
# Allow the process to execute the program.
#line 80
# 
#line 80
allow apmd_t { cardctl_exec_t cardmgr_exec_t }:file { read { getattr execute } };
#line 80

#line 80
#
#line 80
# Allow the process to reap the new domain.
#line 80
#
#line 80
allow cardmgr_t apmd_t:process sigchld;
#line 80

#line 80
#
#line 80
# Allow the new domain to inherit and use file 
#line 80
# descriptions from the creating process and vice versa.
#line 80
#
#line 80
allow cardmgr_t apmd_t:fd use;
#line 80
allow apmd_t cardmgr_t:fd use;
#line 80

#line 80
#
#line 80
# Allow the new domain to write back to the old domain via a pipe.
#line 80
#
#line 80
allow cardmgr_t apmd_t:fifo_file { ioctl read getattr lock write append };
#line 80

#line 80
#
#line 80
# Allow the new domain to read and execute the program.
#line 80
#
#line 80
allow cardmgr_t { cardctl_exec_t cardmgr_exec_t }:file { read getattr lock execute ioctl };
#line 80

#line 80
#
#line 80
# Allow the new domain to be entered via the program.
#line 80
#
#line 80
allow cardmgr_t { cardctl_exec_t cardmgr_exec_t }:file entrypoint;
#line 80

#line 80
type_transition apmd_t { cardctl_exec_t cardmgr_exec_t }:process cardmgr_t;
#line 80

#line 80


#line 85

#line 85
dontaudit insmod_t cardmgr_dev_t:chr_file { read write };
#line 85
dontaudit ifconfig_t cardmgr_dev_t:chr_file { read write };
#line 85

#line 89

#line 89

#line 89
allow hald_t cardmgr_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 89
allow hald_t cardmgr_var_run_t:file { ioctl read getattr lock write append };
#line 89
allow hald_t cardmgr_var_run_t:lnk_file { getattr read };
#line 89

#line 89
allow hald_t cardmgr_var_run_t:chr_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 89

allow cardmgr_t device_t:lnk_file { getattr read };
#line 1 "domains/program/checkpolicy.te"
#DESC Checkpolicy - SELinux policy compliler
#
# Authors:  Frank Mayer, mayerf@tresys.com
# X-Debian-Packages: checkpolicy
#

###########################
# 
# checkpolicy_t is the domain type for checkpolicy
# checkpolicy_exec_t if file type for the executable

type checkpolicy_t, domain;
role sysadm_r types checkpolicy_t;
role system_r types checkpolicy_t;
role secadm_r types checkpolicy_t;

type checkpolicy_exec_t, file_type, exec_type, sysadmfile;

##########################
# 
# Rules


#line 23

#line 23

#line 23
#
#line 23
# Allow the process to transition to the new domain.
#line 23
#
#line 23
allow secadmin checkpolicy_t:process transition;
#line 23

#line 23
#
#line 23
# Do not audit when glibc secure mode is enabled upon the transition.
#line 23
#
#line 23
dontaudit secadmin checkpolicy_t:process noatsecure;
#line 23

#line 23
#
#line 23
# Do not audit when signal-related state is cleared upon the transition.
#line 23
#
#line 23
dontaudit secadmin checkpolicy_t:process siginh;
#line 23

#line 23
#
#line 23
# Do not audit when resource limits are reset upon the transition.
#line 23
#
#line 23
dontaudit secadmin checkpolicy_t:process rlimitinh;
#line 23

#line 23
#
#line 23
# Allow the process to execute the program.
#line 23
# 
#line 23
allow secadmin checkpolicy_exec_t:file { read { getattr execute } };
#line 23

#line 23
#
#line 23
# Allow the process to reap the new domain.
#line 23
#
#line 23
allow checkpolicy_t secadmin:process sigchld;
#line 23

#line 23
#
#line 23
# Allow the new domain to inherit and use file 
#line 23
# descriptions from the creating process and vice versa.
#line 23
#
#line 23
allow checkpolicy_t secadmin:fd use;
#line 23
allow secadmin checkpolicy_t:fd use;
#line 23

#line 23
#
#line 23
# Allow the new domain to write back to the old domain via a pipe.
#line 23
#
#line 23
allow checkpolicy_t secadmin:fifo_file { ioctl read getattr lock write append };
#line 23

#line 23
#
#line 23
# Allow the new domain to read and execute the program.
#line 23
#
#line 23
allow checkpolicy_t checkpolicy_exec_t:file { read getattr lock execute ioctl };
#line 23

#line 23
#
#line 23
# Allow the new domain to be entered via the program.
#line 23
#
#line 23
allow checkpolicy_t checkpolicy_exec_t:file entrypoint;
#line 23

#line 23
type_transition secadmin checkpolicy_exec_t:process checkpolicy_t;
#line 23


# able to create and modify binary policy files
allow checkpolicy_t policy_config_t:dir { read getattr lock search ioctl add_name remove_name write };
allow checkpolicy_t policy_config_t:file { create ioctl read getattr lock write setattr append link unlink rename };

###########################
# constrain what checkpolicy can use as source files
#

# only allow read of policy source files
allow checkpolicy_t policy_src_t:dir { read getattr lock search ioctl };
allow checkpolicy_t policy_src_t:{ file lnk_file } { read getattr lock ioctl };

# allow test policies to be created in src directories

#line 38

#line 38

#line 38

#line 38
#
#line 38
# Allow the process to modify the directory.
#line 38
#
#line 38
allow checkpolicy_t policy_src_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 38

#line 38
#
#line 38
# Allow the process to create the file.
#line 38
#
#line 38

#line 38

#line 38

#line 38

#line 38

#line 38
allow checkpolicy_t policy_config_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38
type_transition checkpolicy_t policy_src_t:file policy_config_t;
#line 38

#line 38


# directory search permissions for path to source and binary policy files
allow checkpolicy_t root_t:dir search;
allow checkpolicy_t etc_t:dir search;

# Read the devpts root directory.  
allow checkpolicy_t devpts_t:dir { read getattr lock search ioctl };
#line 47


# Other access
allow checkpolicy_t { initrc_devpts_t admin_tty_type devtty_t }:chr_file { read write ioctl getattr };

#line 51
allow checkpolicy_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 51
allow checkpolicy_t lib_t:lnk_file { read getattr lock ioctl };
#line 51
allow checkpolicy_t ld_so_t:file { read getattr lock execute ioctl };
#line 51
#allow checkpolicy_t ld_so_t:file execute_no_trans;
#line 51
allow checkpolicy_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 51
allow checkpolicy_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 51
allow checkpolicy_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 51
allow checkpolicy_t texrel_shlib_t:file execmod;
#line 51
allow checkpolicy_t ld_so_cache_t:file { read getattr lock ioctl };
#line 51
allow checkpolicy_t device_t:dir search;
#line 51
allow checkpolicy_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 51

allow checkpolicy_t self:capability dac_override;

##########################
# Allow users to execute checkpolicy without a domain transition
# so it can be used without privilege to write real binary policy file

#line 57
allow unpriv_userdomain checkpolicy_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 57


allow checkpolicy_t { userdomain privfd }:fd use;

allow checkpolicy_t fs_t:filesystem getattr;
allow checkpolicy_t console_device_t:chr_file { read write };
allow checkpolicy_t init_t:fd use;
allow checkpolicy_t selinux_config_t:dir search;
#line 1 "domains/program/chkpwd.te"
#DESC Chkpwd - PAM password checking programs
# X-Debian-Packages: libpam-modules
#
# Domains for the /sbin/.*_chkpwd utilities.
#

#
# chkpwd_exec_t is the type of the /sbin/.*_chkpwd executables.
#
type chkpwd_exec_t, file_type, sysadmfile, exec_type;


#line 12
# Derived domain based on the calling user domain and the program.
#line 12
type system_chkpwd_t, domain, privlog, nscd_client_domain, auth;
#line 12

#line 12
role system_r types system_chkpwd_t;
#line 12

#line 12
# read /selinux/mls
#line 12
allow system_chkpwd_t security_t:dir search;
#line 12
allow system_chkpwd_t security_t:file read;
#line 12
# is_selinux_enabled
#line 12
allow system_chkpwd_t proc_t:file read;
#line 12

#line 12

#line 12
allow system_chkpwd_t proc_t:dir search;
#line 12
allow system_chkpwd_t proc_t:{ file lnk_file } read;
#line 12
allow system_chkpwd_t self:dir search;
#line 12
allow system_chkpwd_t self:file { getattr read };
#line 12
allow system_chkpwd_t self:process getattr;
#line 12

#line 12

#line 12

#line 12

#line 12
if (allow_ypbind) {
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { tcp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:tcp_socket { listen accept };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { tcp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { udp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t port_type:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow system_chkpwd_t var_yp_t:dir { read getattr lock search ioctl };
#line 12
allow system_chkpwd_t var_yp_t:file { read getattr lock ioctl };
#line 12
allow system_chkpwd_t var_yp_t:lnk_file { getattr read };
#line 12

#line 12
allow system_chkpwd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 12
allow system_chkpwd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 12
dontaudit system_chkpwd_t self:capability net_bind_service;
#line 12
dontaudit system_chkpwd_t reserved_port_type:tcp_socket name_connect;
#line 12
dontaudit system_chkpwd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 12

#line 12
} else {
#line 12
dontaudit system_chkpwd_t var_yp_t:dir search;
#line 12
}
#line 12
 
#line 12

#line 12

#line 12
if (allow_kerberos) {
#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { tcp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { udp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12
allow system_chkpwd_t kerberos_port_t:tcp_socket name_connect;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { tcp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { udp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12
allow system_chkpwd_t dns_port_t:tcp_socket name_connect;
#line 12

#line 12
}
#line 12
 dontaudit system_chkpwd_t krb5_conf_t:file write;
#line 12
allow system_chkpwd_t krb5_conf_t:file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { tcp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:tcp_socket { connect };
#line 12

#line 12
allow system_chkpwd_t ldap_port_t:tcp_socket name_connect;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { tcp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow system_chkpwd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow system_chkpwd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow system_chkpwd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow system_chkpwd_t node_type:node { udp_send rawip_send };
#line 12
allow system_chkpwd_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow system_chkpwd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow system_chkpwd_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow system_chkpwd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12
allow system_chkpwd_t dns_port_t:tcp_socket name_connect;
#line 12

#line 12

#line 12

#line 12
allow system_chkpwd_t winbind_var_run_t:dir { getattr search };
#line 12
allow system_chkpwd_t winbind_t:unix_stream_socket connectto;
#line 12
allow system_chkpwd_t winbind_var_run_t:sock_file { getattr read write };
#line 12

#line 12

#line 12

#line 12
allow system_chkpwd_t cert_t:dir { read getattr lock search ioctl };
#line 12
allow system_chkpwd_t cert_t:file { read getattr lock ioctl };
#line 12
allow system_chkpwd_t cert_t:lnk_file { getattr read };
#line 12

#line 12
allow system_chkpwd_t { random_device_t urandom_device_t }:chr_file { getattr read };
#line 12
allow system_chkpwd_t self:capability { audit_write audit_control };
#line 12
dontaudit system_chkpwd_t shadow_t:file { getattr read };
#line 12
allow system_chkpwd_t sbin_t:dir search;
#line 12
allow system_chkpwd_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };
#line 12
allow system_chkpwd_t var_lib_t:dir { read getattr lock search ioctl };
#line 12

#line 12
allow system_chkpwd_t var_auth_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12
allow system_chkpwd_t var_auth_t:file { ioctl read getattr lock write append };
#line 12
allow system_chkpwd_t var_auth_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow auth_chkpwd system_chkpwd_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit auth_chkpwd system_chkpwd_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit auth_chkpwd system_chkpwd_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit auth_chkpwd system_chkpwd_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow auth_chkpwd chkpwd_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow system_chkpwd_t auth_chkpwd:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow system_chkpwd_t auth_chkpwd:fd use;
#line 12
allow auth_chkpwd system_chkpwd_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow system_chkpwd_t auth_chkpwd:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow system_chkpwd_t chkpwd_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow system_chkpwd_t chkpwd_exec_t:file entrypoint;
#line 12

#line 12
type_transition auth_chkpwd chkpwd_exec_t:process system_chkpwd_t;
#line 12

#line 12
dontaudit system_chkpwd_t { user_tty_type tty_device_t }:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12

#line 12
if (allow_ypbind) {
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { tcp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:tcp_socket { listen accept };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { tcp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { udp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd port_type:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow auth_chkpwd var_yp_t:dir { read getattr lock search ioctl };
#line 12
allow auth_chkpwd var_yp_t:file { read getattr lock ioctl };
#line 12
allow auth_chkpwd var_yp_t:lnk_file { getattr read };
#line 12

#line 12
allow auth_chkpwd { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 12
allow auth_chkpwd { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 12
dontaudit auth_chkpwd self:capability net_bind_service;
#line 12
dontaudit auth_chkpwd reserved_port_type:tcp_socket name_connect;
#line 12
dontaudit auth_chkpwd reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 12

#line 12
} else {
#line 12
dontaudit auth_chkpwd var_yp_t:dir search;
#line 12
}
#line 12
 
#line 12

#line 12

#line 12
if (allow_kerberos) {
#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { tcp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { udp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd kerberos_port_t:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12
allow auth_chkpwd kerberos_port_t:tcp_socket name_connect;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { tcp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd dns_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { udp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd dns_port_t:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12
allow auth_chkpwd dns_port_t:tcp_socket name_connect;
#line 12

#line 12
}
#line 12
 dontaudit auth_chkpwd krb5_conf_t:file write;
#line 12
allow auth_chkpwd krb5_conf_t:file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { tcp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd ldap_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:tcp_socket { connect };
#line 12

#line 12
allow auth_chkpwd ldap_port_t:tcp_socket name_connect;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { tcp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd dns_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow auth_chkpwd self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow auth_chkpwd unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow auth_chkpwd netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow auth_chkpwd node_type:node { udp_send rawip_send };
#line 12
allow auth_chkpwd node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow auth_chkpwd dns_port_t:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow auth_chkpwd node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow auth_chkpwd net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow auth_chkpwd self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12
allow auth_chkpwd dns_port_t:tcp_socket name_connect;
#line 12

#line 12

#line 12

#line 12
allow auth_chkpwd winbind_var_run_t:dir { getattr search };
#line 12
allow auth_chkpwd winbind_t:unix_stream_socket connectto;
#line 12
allow auth_chkpwd winbind_var_run_t:sock_file { getattr read write };
#line 12

#line 12

#line 12

#line 12
allow auth_chkpwd cert_t:dir { read getattr lock search ioctl };
#line 12
allow auth_chkpwd cert_t:file { read getattr lock ioctl };
#line 12
allow auth_chkpwd cert_t:lnk_file { getattr read };
#line 12

#line 12
allow auth_chkpwd { random_device_t urandom_device_t }:chr_file { getattr read };
#line 12
allow auth_chkpwd self:capability { audit_write audit_control };
#line 12
dontaudit auth_chkpwd shadow_t:file { getattr read };
#line 12
allow auth_chkpwd sbin_t:dir search;
#line 12
allow auth_chkpwd self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };
#line 12
allow auth_chkpwd var_lib_t:dir { read getattr lock search ioctl };
#line 12

#line 12
allow auth_chkpwd var_auth_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12
allow auth_chkpwd var_auth_t:file { ioctl read getattr lock write append };
#line 12
allow auth_chkpwd var_auth_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow system_chkpwd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 12
allow system_chkpwd_t lib_t:lnk_file { read getattr lock ioctl };
#line 12
allow system_chkpwd_t ld_so_t:file { read getattr lock execute ioctl };
#line 12
#allow system_chkpwd_t ld_so_t:file execute_no_trans;
#line 12
allow system_chkpwd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 12
allow system_chkpwd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 12
allow system_chkpwd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 12
allow system_chkpwd_t texrel_shlib_t:file execmod;
#line 12
allow system_chkpwd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 12
allow system_chkpwd_t device_t:dir search;
#line 12
allow system_chkpwd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12
allow system_chkpwd_t etc_t:file { getattr read };
#line 12
allow system_chkpwd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 12
allow system_chkpwd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 12

#line 12
allow system_chkpwd_t etc_t:lnk_file read;
#line 12
allow system_chkpwd_t lib_t:file { read getattr lock ioctl };
#line 12

#line 12
allow system_chkpwd_t locale_t:dir { read getattr lock search ioctl };
#line 12
allow system_chkpwd_t locale_t:file { read getattr lock ioctl };
#line 12
allow system_chkpwd_t locale_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12
# Use capabilities.
#line 12
allow system_chkpwd_t self:capability setuid;
#line 12

#line 12
allow system_chkpwd_t selinux_config_t:dir { read getattr lock search ioctl };
#line 12
allow system_chkpwd_t selinux_config_t:file { read getattr lock ioctl };
#line 12
allow system_chkpwd_t selinux_config_t:lnk_file { getattr read };
#line 12

#line 12

#line 12
# for nscd
#line 12

#line 12

#line 12
dontaudit system_chkpwd_t fs_t:filesystem getattr;
#line 12

dontaudit system_chkpwd_t privfd:fd use;
role sysadm_r types system_chkpwd_t;

#line 15
role user_r types system_chkpwd_t;
#line 15
role staff_r types system_chkpwd_t;
#line 15


# Everything else is in the chkpwd_domain macro in
# macros/program/chkpwd_macros.te.
#line 1 "domains/program/compat.te"
typealias bin_t alias mount_exec_t;
typealias bin_t alias dmesg_exec_t;
typealias bin_t alias loadkeys_exec_t;
typealias sbin_t alias lvm_exec_t;
#line 1 "domains/program/comsat.te"
#DESC comsat - biff server
#
# Author:  Dan Walsh <dwalsh@redhat.com>
# Depends: inetd.te
#

#################################
#
# Rules for the comsat_t domain.
#
# comsat_exec_t is the type of the comsat executable.
#


#line 14
type comsat_t, domain, privlog, nscd_client_domain;
#line 14
role system_r types comsat_t;
#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14
bool comsat_disable_trans false;
#line 14
if (comsat_disable_trans) {
#line 14

#line 14
allow initrc_t comsat_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t comsat_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow inetd_t comsat_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit inetd_t comsat_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit inetd_t comsat_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit inetd_t comsat_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow inetd_t comsat_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow comsat_t inetd_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow comsat_t inetd_t:fd use;
#line 14
allow inetd_t comsat_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow comsat_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow comsat_t comsat_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow comsat_t comsat_exec_t:file entrypoint;
#line 14

#line 14
type_transition inetd_t comsat_exec_t:process comsat_t;
#line 14

#line 14
allow inetd_t comsat_t:process sigkill;
#line 14
}
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow comsat_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow comsat_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow comsat_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow comsat_t node_type:node { tcp_send rawip_send };
#line 14
allow comsat_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow comsat_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow comsat_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow comsat_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow comsat_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow comsat_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow comsat_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow comsat_t node_type:node { udp_send rawip_send };
#line 14
allow comsat_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow comsat_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow comsat_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow comsat_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
if (allow_ypbind) {
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow comsat_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow comsat_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow comsat_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow comsat_t node_type:node { tcp_send rawip_send };
#line 14
allow comsat_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow comsat_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow comsat_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow comsat_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow comsat_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow comsat_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow comsat_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow comsat_t node_type:node { tcp_send rawip_send };
#line 14
allow comsat_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow comsat_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow comsat_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow comsat_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow comsat_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow comsat_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow comsat_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow comsat_t node_type:node { udp_send rawip_send };
#line 14
allow comsat_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow comsat_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow comsat_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow comsat_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow comsat_t var_yp_t:dir { read getattr lock search ioctl };
#line 14
allow comsat_t var_yp_t:file { read getattr lock ioctl };
#line 14
allow comsat_t var_yp_t:lnk_file { getattr read };
#line 14

#line 14
allow comsat_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 14
allow comsat_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 14
dontaudit comsat_t self:capability net_bind_service;
#line 14
dontaudit comsat_t reserved_port_type:tcp_socket name_connect;
#line 14
dontaudit comsat_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 14

#line 14
} else {
#line 14
dontaudit comsat_t var_yp_t:dir search;
#line 14
}
#line 14
 
#line 14

#line 14
allow comsat_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow comsat_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow comsat_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow comsat_t ld_so_t:file execute_no_trans;
#line 14
allow comsat_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow comsat_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow comsat_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow comsat_t texrel_shlib_t:file execmod;
#line 14
allow comsat_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow comsat_t device_t:dir search;
#line 14
allow comsat_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
allow comsat_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow comsat_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow comsat_t self:fifo_file { ioctl read getattr lock write append };
#line 14
type comsat_exec_t, file_type, sysadmfile, exec_type;
#line 14

#line 14
allow comsat_t etc_t:lnk_file read;
#line 14
allow comsat_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow comsat_t locale_t:file { read getattr lock ioctl };
#line 14
allow comsat_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14
allow comsat_t device_t:dir search;
#line 14
allow comsat_t proc_t:dir search;
#line 14
allow comsat_t proc_t:{ file lnk_file } { getattr read };
#line 14
allow comsat_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 14
allow comsat_t fs_t:filesystem getattr;
#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow comsat_t sysctl_t:dir search;
#line 14
allow comsat_t sysctl_kernel_t:dir search;
#line 14
allow comsat_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14
allow comsat_t etc_t:file { getattr read };
#line 14

#line 14

#line 14
type comsat_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow comsat_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow comsat_t comsat_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow comsat_t comsat_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition comsat_t tmp_t:{ file dir } comsat_tmp_t;
#line 14

#line 14

#line 14

#line 14
allow comsat_t var_t:dir search;
#line 14

#line 14
type comsat_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow comsat_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow comsat_t comsat_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition comsat_t var_run_t:file comsat_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow comsat_t var_t:dir search;
#line 14
allow comsat_t comsat_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
# Inherit and use descriptors from inetd.
#line 14
allow comsat_t inetd_t:fd use;
#line 14

#line 14
# for identd
#line 14
allow comsat_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 14
allow comsat_t self:capability { setuid setgid };
#line 14
allow comsat_t home_root_t:dir search;
#line 14
allow comsat_t self:dir search;
#line 14
allow comsat_t self:{ lnk_file file } { getattr read };
#line 14

#line 14

#line 14
if (allow_kerberos) {
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow comsat_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow comsat_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow comsat_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow comsat_t node_type:node { tcp_send rawip_send };
#line 14
allow comsat_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow comsat_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow comsat_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow comsat_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow comsat_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow comsat_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow comsat_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow comsat_t node_type:node { udp_send rawip_send };
#line 14
allow comsat_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow comsat_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow comsat_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow comsat_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow comsat_t kerberos_port_t:tcp_socket name_connect;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow comsat_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow comsat_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow comsat_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow comsat_t node_type:node { tcp_send rawip_send };
#line 14
allow comsat_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow comsat_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow comsat_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow comsat_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow comsat_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow comsat_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow comsat_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow comsat_t node_type:node { udp_send rawip_send };
#line 14
allow comsat_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow comsat_t dns_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow comsat_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow comsat_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow comsat_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow comsat_t dns_port_t:tcp_socket name_connect;
#line 14

#line 14
}
#line 14
 dontaudit comsat_t krb5_conf_t:file write;
#line 14
allow comsat_t krb5_conf_t:file { getattr read };
#line 14

#line 14
allow comsat_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 14
# Use sockets inherited from inetd.
#line 14

#line 14

#line 14

#line 14
allow inetd_t comsat_port_t:udp_socket name_bind;
#line 14
allow comsat_t inetd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
#line 14

#line 14

#line 14
allow comsat_t proc_net_t:dir { read getattr lock search ioctl };
#line 14
allow comsat_t proc_net_t:file { read getattr lock ioctl };
#line 14
allow comsat_t proc_net_t:lnk_file { getattr read };
#line 14

#line 14

allow comsat_t initrc_var_run_t:file { read getattr lock ioctl };
dontaudit comsat_t initrc_var_run_t:file write;
allow comsat_t mail_spool_t:dir { read getattr lock search ioctl };
allow comsat_t mail_spool_t:lnk_file read;
allow comsat_t var_spool_t:dir search;
dontaudit comsat_t sysadm_tty_device_t:chr_file getattr;
#line 1 "domains/program/consoletype.te"
#DESC consoletype - determine the type of a console device
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: 
#

#################################
#
# Rules for the consoletype_t domain.
#
# consoletype_t is the domain for the consoletype program.
# consoletype_exec_t is the type of the corresponding program.
#
type consoletype_t, domain, mlsfileread, mlsfilewrite;
type consoletype_exec_t, file_type, sysadmfile, exec_type;

role system_r types consoletype_t;


#line 19
allow consoletype_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 19
allow consoletype_t lib_t:lnk_file { read getattr lock ioctl };
#line 19
allow consoletype_t ld_so_t:file { read getattr lock execute ioctl };
#line 19
#allow consoletype_t ld_so_t:file execute_no_trans;
#line 19
allow consoletype_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 19
allow consoletype_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 19
allow consoletype_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 19
allow consoletype_t texrel_shlib_t:file execmod;
#line 19
allow consoletype_t ld_so_cache_t:file { read getattr lock ioctl };
#line 19
allow consoletype_t device_t:dir search;
#line 19
allow consoletype_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 19


#line 20
# Access other processes in the same domain.
#line 20
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 20
# These must be granted separately if desired.
#line 20
allow consoletype_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 20

#line 20
# Access /proc/PID files for processes in the same domain.
#line 20
allow consoletype_t self:dir { read getattr lock search ioctl };
#line 20
allow consoletype_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 20

#line 20
# Access file descriptions, pipes, and sockets
#line 20
# created by processes in the same domain.
#line 20
allow consoletype_t self:fd *;
#line 20
allow consoletype_t self:fifo_file { ioctl read getattr lock write append };
#line 20
allow consoletype_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 20
allow consoletype_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 20

#line 20
# Allow the domain to communicate with other processes in the same domain.
#line 20
allow consoletype_t self:unix_dgram_socket sendto;
#line 20
allow consoletype_t self:unix_stream_socket connectto;
#line 20

#line 20
# Access System V IPC objects created by processes in the same domain.
#line 20
allow consoletype_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 20
allow consoletype_t self:msg  { send receive };
#line 20
allow consoletype_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 20
allow consoletype_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 20
allow consoletype_t unpriv_userdomain:fd use;
#line 20
#
#line 20
# Every app is asking for ypbind so I am adding this here, 
#line 20
# eventually this should become can_nsswitch
#line 20
#
#line 20

#line 20

#line 20
if (allow_ypbind) {
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use tcp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow consoletype_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow consoletype_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow consoletype_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow consoletype_t node_type:node { tcp_send rawip_send };
#line 20
allow consoletype_t node_type:node { tcp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow consoletype_t port_type:tcp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow consoletype_t node_type:tcp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow consoletype_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow consoletype_t self:tcp_socket { listen accept };
#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use tcp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow consoletype_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow consoletype_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow consoletype_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow consoletype_t node_type:node { tcp_send rawip_send };
#line 20
allow consoletype_t node_type:node { tcp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow consoletype_t port_type:tcp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow consoletype_t node_type:tcp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow consoletype_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow consoletype_t self:tcp_socket { connect };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use udp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow consoletype_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow consoletype_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow consoletype_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow consoletype_t node_type:node { udp_send rawip_send };
#line 20
allow consoletype_t node_type:node { udp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow consoletype_t port_type:udp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow consoletype_t node_type:udp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow consoletype_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow consoletype_t self:udp_socket { connect };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
allow consoletype_t var_yp_t:dir { read getattr lock search ioctl };
#line 20
allow consoletype_t var_yp_t:file { read getattr lock ioctl };
#line 20
allow consoletype_t var_yp_t:lnk_file { getattr read };
#line 20

#line 20
allow consoletype_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 20
allow consoletype_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 20
dontaudit consoletype_t self:capability net_bind_service;
#line 20
dontaudit consoletype_t reserved_port_type:tcp_socket name_connect;
#line 20
dontaudit consoletype_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 20

#line 20
} else {
#line 20
dontaudit consoletype_t var_yp_t:dir search;
#line 20
}
#line 20
 
#line 20
allow consoletype_t autofs_t:dir { search getattr };
#line 20


#line 33


allow consoletype_t {admin_tty_type tty_device_t devtty_t initrc_devpts_t }:chr_file { ioctl read getattr lock write append };

allow consoletype_t { kernel_t init_t initrc_t privfd sysadm_t }:fd use;

# Use capabilities.
allow consoletype_t self:capability sys_admin;

allow consoletype_t console_device_t:chr_file { getattr ioctl read write };
allow consoletype_t initrc_t:fifo_file write;
allow consoletype_t nfs_t:file write;
allow consoletype_t sysadm_t:fifo_file { ioctl read getattr lock write append };

#line 49

#line 49
allow consoletype_t printconf_t:file { getattr read };
#line 49


#line 53

#line 56

#line 56
allow consoletype_t tmpfs_t:chr_file { ioctl read getattr lock write append };
#line 56

#line 59

#line 59
allow consoletype_t firstboot_t:fifo_file write;
#line 59

dontaudit consoletype_t proc_t:dir search;
dontaudit consoletype_t proc_t:file read;
dontaudit consoletype_t root_t:file read;
allow consoletype_t crond_t:fifo_file { read getattr ioctl };
allow consoletype_t system_crond_t:fd use;
allow consoletype_t fs_t:filesystem getattr;
#line 1 "domains/program/cpucontrol.te"
#DESC cpucontrol - domain for microcode_ctl and other programs to control CPU
#
# Author:  Russell Coker <russell@coker.com.au>
#

type cpucontrol_conf_t, file_type, sysadmfile;


#line 8

#line 8
type cpucontrol_t, domain, privlog, daemon ;
#line 8
type cpucontrol_exec_t, file_type, sysadmfile, exec_type;
#line 8
dontaudit cpucontrol_t self:capability sys_tty_config;
#line 8

#line 8
role system_r types cpucontrol_t;
#line 8

#line 8
# Inherit and use descriptors from init.
#line 8
allow cpucontrol_t init_t:fd use;
#line 8
allow cpucontrol_t init_t:process sigchld;
#line 8
allow cpucontrol_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 8

#line 8

#line 8
allow cpucontrol_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 8
allow cpucontrol_t lib_t:lnk_file { read getattr lock ioctl };
#line 8
allow cpucontrol_t ld_so_t:file { read getattr lock execute ioctl };
#line 8
#allow cpucontrol_t ld_so_t:file execute_no_trans;
#line 8
allow cpucontrol_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 8
allow cpucontrol_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 8
allow cpucontrol_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 8
allow cpucontrol_t texrel_shlib_t:file execmod;
#line 8
allow cpucontrol_t ld_so_cache_t:file { read getattr lock ioctl };
#line 8
allow cpucontrol_t device_t:dir search;
#line 8
allow cpucontrol_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 8

#line 8

#line 8
allow cpucontrol_t { self proc_t }:dir { read getattr lock search ioctl };
#line 8
allow cpucontrol_t { self proc_t }:lnk_file { getattr read };
#line 8

#line 8
allow cpucontrol_t device_t:dir { read getattr lock search ioctl };
#line 8

#line 8
allow cpucontrol_t udev_tdb_t:file { read getattr lock ioctl };
#line 8
allow cpucontrol_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 8
dontaudit cpucontrol_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 8
dontaudit cpucontrol_t unpriv_userdomain:fd use;
#line 8

#line 8

#line 8
allow cpucontrol_t sysfs_t:dir { read getattr lock search ioctl };
#line 8
allow cpucontrol_t sysfs_t:file { read getattr lock ioctl };
#line 8
allow cpucontrol_t sysfs_t:lnk_file { getattr read };
#line 8
 
#line 8

#line 8
allow cpucontrol_t autofs_t:dir { search getattr };
#line 8

#line 8
dontaudit cpucontrol_t { tty_device_t devpts_t }:chr_file { read write };
#line 8
dontaudit cpucontrol_t root_t:file { getattr read };
#line 8
 
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
# Read system variables in /sys.
#line 8

#line 8
allow cpucontrol_t sysctl_t:dir search;
#line 8
allow cpucontrol_t sysctl_kernel_t:dir search;
#line 8
allow cpucontrol_t sysctl_kernel_t:file { getattr read };
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
#
#line 8
# Allows user to define a tunable to disable domain transition
#line 8
#
#line 8
 
#line 8

#line 8

#line 8
#
#line 8
# Allow the process to transition to the new domain.
#line 8
#
#line 8
allow initrc_t cpucontrol_t:process transition;
#line 8

#line 8
#
#line 8
# Do not audit when glibc secure mode is enabled upon the transition.
#line 8
#
#line 8
dontaudit initrc_t cpucontrol_t:process noatsecure;
#line 8

#line 8
#
#line 8
# Do not audit when signal-related state is cleared upon the transition.
#line 8
#
#line 8
dontaudit initrc_t cpucontrol_t:process siginh;
#line 8

#line 8
#
#line 8
# Do not audit when resource limits are reset upon the transition.
#line 8
#
#line 8
dontaudit initrc_t cpucontrol_t:process rlimitinh;
#line 8

#line 8
#
#line 8
# Allow the process to execute the program.
#line 8
# 
#line 8
allow initrc_t cpucontrol_exec_t:file { read { getattr execute } };
#line 8

#line 8
#
#line 8
# Allow the process to reap the new domain.
#line 8
#
#line 8
allow cpucontrol_t initrc_t:process sigchld;
#line 8

#line 8
#
#line 8
# Allow the new domain to inherit and use file 
#line 8
# descriptions from the creating process and vice versa.
#line 8
#
#line 8
allow cpucontrol_t initrc_t:fd use;
#line 8
allow initrc_t cpucontrol_t:fd use;
#line 8

#line 8
#
#line 8
# Allow the new domain to write back to the old domain via a pipe.
#line 8
#
#line 8
allow cpucontrol_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 8

#line 8
#
#line 8
# Allow the new domain to read and execute the program.
#line 8
#
#line 8
allow cpucontrol_t cpucontrol_exec_t:file { read getattr lock execute ioctl };
#line 8

#line 8
#
#line 8
# Allow the new domain to be entered via the program.
#line 8
#
#line 8
allow cpucontrol_t cpucontrol_exec_t:file entrypoint;
#line 8

#line 8
type_transition initrc_t cpucontrol_exec_t:process cpucontrol_t;
#line 8

#line 8

#line 8
allow initrc_t cpucontrol_t:process { noatsecure siginh rlimitinh };
#line 8
 
#line 8
allow cpucontrol_t privfd:fd use;
#line 8

#line 8
allow cpucontrol_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 8


# Access cpu devices.
allow cpucontrol_t cpu_device_t:chr_file { ioctl read getattr lock write append };
allow cpucontrol_t device_t:lnk_file { getattr read };
allow initrc_t cpu_device_t:chr_file getattr;

allow cpucontrol_t self:capability sys_rawio;


#line 17
allow cpucontrol_t cpucontrol_conf_t:dir { read getattr lock search ioctl };
#line 17
allow cpucontrol_t cpucontrol_conf_t:file { read getattr lock ioctl };
#line 17
allow cpucontrol_t cpucontrol_conf_t:lnk_file { getattr read };
#line 17

#line 1 "domains/program/cpuspeed.te"
#DESC cpuspeed - domain for microcode_ctl, powernowd, etc
#
# Authors:  Russell Coker <russell@coker.com.au>
#           Thomas Bleher <ThomasBleher@gmx.de>
#


#line 7

#line 7
type cpuspeed_t, domain, privlog, daemon ;
#line 7
type cpuspeed_exec_t, file_type, sysadmfile, exec_type;
#line 7
dontaudit cpuspeed_t self:capability sys_tty_config;
#line 7

#line 7
role system_r types cpuspeed_t;
#line 7

#line 7
# Inherit and use descriptors from init.
#line 7
allow cpuspeed_t init_t:fd use;
#line 7
allow cpuspeed_t init_t:process sigchld;
#line 7
allow cpuspeed_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 7

#line 7

#line 7
allow cpuspeed_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 7
allow cpuspeed_t lib_t:lnk_file { read getattr lock ioctl };
#line 7
allow cpuspeed_t ld_so_t:file { read getattr lock execute ioctl };
#line 7
#allow cpuspeed_t ld_so_t:file execute_no_trans;
#line 7
allow cpuspeed_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 7
allow cpuspeed_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 7
allow cpuspeed_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 7
allow cpuspeed_t texrel_shlib_t:file execmod;
#line 7
allow cpuspeed_t ld_so_cache_t:file { read getattr lock ioctl };
#line 7
allow cpuspeed_t device_t:dir search;
#line 7
allow cpuspeed_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 7

#line 7

#line 7
allow cpuspeed_t { self proc_t }:dir { read getattr lock search ioctl };
#line 7
allow cpuspeed_t { self proc_t }:lnk_file { getattr read };
#line 7

#line 7
allow cpuspeed_t device_t:dir { read getattr lock search ioctl };
#line 7

#line 7
allow cpuspeed_t udev_tdb_t:file { read getattr lock ioctl };
#line 7
allow cpuspeed_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 7
dontaudit cpuspeed_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 7
dontaudit cpuspeed_t unpriv_userdomain:fd use;
#line 7

#line 7

#line 7
allow cpuspeed_t sysfs_t:dir { read getattr lock search ioctl };
#line 7
allow cpuspeed_t sysfs_t:file { read getattr lock ioctl };
#line 7
allow cpuspeed_t sysfs_t:lnk_file { getattr read };
#line 7
 
#line 7

#line 7
allow cpuspeed_t autofs_t:dir { search getattr };
#line 7

#line 7
dontaudit cpuspeed_t { tty_device_t devpts_t }:chr_file { read write };
#line 7
dontaudit cpuspeed_t root_t:file { getattr read };
#line 7
 
#line 7

#line 7

#line 7

#line 7

#line 7

#line 7

#line 7
# Read system variables in /sys.
#line 7

#line 7
allow cpuspeed_t sysctl_t:dir search;
#line 7
allow cpuspeed_t sysctl_kernel_t:dir search;
#line 7
allow cpuspeed_t sysctl_kernel_t:file { getattr read };
#line 7

#line 7

#line 7

#line 7

#line 7

#line 7

#line 7
#
#line 7
# Allows user to define a tunable to disable domain transition
#line 7
#
#line 7
 
#line 7

#line 7

#line 7
#
#line 7
# Allow the process to transition to the new domain.
#line 7
#
#line 7
allow initrc_t cpuspeed_t:process transition;
#line 7

#line 7
#
#line 7
# Do not audit when glibc secure mode is enabled upon the transition.
#line 7
#
#line 7
dontaudit initrc_t cpuspeed_t:process noatsecure;
#line 7

#line 7
#
#line 7
# Do not audit when signal-related state is cleared upon the transition.
#line 7
#
#line 7
dontaudit initrc_t cpuspeed_t:process siginh;
#line 7

#line 7
#
#line 7
# Do not audit when resource limits are reset upon the transition.
#line 7
#
#line 7
dontaudit initrc_t cpuspeed_t:process rlimitinh;
#line 7

#line 7
#
#line 7
# Allow the process to execute the program.
#line 7
# 
#line 7
allow initrc_t cpuspeed_exec_t:file { read { getattr execute } };
#line 7

#line 7
#
#line 7
# Allow the process to reap the new domain.
#line 7
#
#line 7
allow cpuspeed_t initrc_t:process sigchld;
#line 7

#line 7
#
#line 7
# Allow the new domain to inherit and use file 
#line 7
# descriptions from the creating process and vice versa.
#line 7
#
#line 7
allow cpuspeed_t initrc_t:fd use;
#line 7
allow initrc_t cpuspeed_t:fd use;
#line 7

#line 7
#
#line 7
# Allow the new domain to write back to the old domain via a pipe.
#line 7
#
#line 7
allow cpuspeed_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 7

#line 7
#
#line 7
# Allow the new domain to read and execute the program.
#line 7
#
#line 7
allow cpuspeed_t cpuspeed_exec_t:file { read getattr lock execute ioctl };
#line 7

#line 7
#
#line 7
# Allow the new domain to be entered via the program.
#line 7
#
#line 7
allow cpuspeed_t cpuspeed_exec_t:file entrypoint;
#line 7

#line 7
type_transition initrc_t cpuspeed_exec_t:process cpuspeed_t;
#line 7

#line 7

#line 7
allow initrc_t cpuspeed_t:process { noatsecure siginh rlimitinh };
#line 7
 
#line 7
allow cpuspeed_t privfd:fd use;
#line 7

#line 7
allow cpuspeed_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 7


#line 8
allow cpuspeed_t etc_t:lnk_file read;
#line 8
allow cpuspeed_t lib_t:file { read getattr lock ioctl };
#line 8

#line 8
allow cpuspeed_t locale_t:dir { read getattr lock search ioctl };
#line 8
allow cpuspeed_t locale_t:file { read getattr lock ioctl };
#line 8
allow cpuspeed_t locale_t:lnk_file { getattr read };
#line 8

#line 8


allow cpuspeed_t sysfs_t:dir search;
allow cpuspeed_t sysfs_t:file { ioctl read getattr lock write append };
allow cpuspeed_t proc_t:dir { read getattr lock search ioctl };
allow cpuspeed_t proc_t:file { getattr read };
allow cpuspeed_t { etc_t etc_runtime_t }:file { getattr read };

allow cpuspeed_t self:process setsched;
allow cpuspeed_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 1 "domains/program/crond.te"
#DESC crond 
#
# Authors:  Daniel Walsh <dwalsh@redhat.com>
#

#################################
#
# Rules for the crond domain.
#
# crond_exec_t is the type of the /usr/sbin/crond and other programs.
# This domain is defined just for targeted policy.
#
type crond_exec_t, file_type, sysadmfile, exec_type;
type crond_t, domain, privuser, privrole, privfd, privowner;
typealias crond_t alias system_crond_t;
type anacron_exec_t, file_type, sysadmfile, exec_type;
type system_crond_tmp_t, file_type, tmpfile, sysadmfile;
type system_cron_spool_t, file_type, sysadmfile;
type sysadm_cron_spool_t, file_type, sysadmfile;
role system_r types crond_t;

#line 21

#line 21

#line 21
#
#line 21
# Allow the process to transition to the new domain.
#line 21
#
#line 21
allow initrc_t crond_t:process transition;
#line 21

#line 21
#
#line 21
# Do not audit when glibc secure mode is enabled upon the transition.
#line 21
#
#line 21
dontaudit initrc_t crond_t:process noatsecure;
#line 21

#line 21
#
#line 21
# Do not audit when signal-related state is cleared upon the transition.
#line 21
#
#line 21
dontaudit initrc_t crond_t:process siginh;
#line 21

#line 21
#
#line 21
# Do not audit when resource limits are reset upon the transition.
#line 21
#
#line 21
dontaudit initrc_t crond_t:process rlimitinh;
#line 21

#line 21
#
#line 21
# Allow the process to execute the program.
#line 21
# 
#line 21
allow initrc_t crond_exec_t:file { read { getattr execute } };
#line 21

#line 21
#
#line 21
# Allow the process to reap the new domain.
#line 21
#
#line 21
allow crond_t initrc_t:process sigchld;
#line 21

#line 21
#
#line 21
# Allow the new domain to inherit and use file 
#line 21
# descriptions from the creating process and vice versa.
#line 21
#
#line 21
allow crond_t initrc_t:fd use;
#line 21
allow initrc_t crond_t:fd use;
#line 21

#line 21
#
#line 21
# Allow the new domain to write back to the old domain via a pipe.
#line 21
#
#line 21
allow crond_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 21

#line 21
#
#line 21
# Allow the new domain to read and execute the program.
#line 21
#
#line 21
allow crond_t crond_exec_t:file { read getattr lock execute ioctl };
#line 21

#line 21
#
#line 21
# Allow the new domain to be entered via the program.
#line 21
#
#line 21
allow crond_t crond_exec_t:file entrypoint;
#line 21

#line 21
type_transition initrc_t crond_exec_t:process crond_t;
#line 21


#line 22

#line 22

#line 22
#
#line 22
# Allow the process to transition to the new domain.
#line 22
#
#line 22
allow initrc_t crond_t:process transition;
#line 22

#line 22
#
#line 22
# Do not audit when glibc secure mode is enabled upon the transition.
#line 22
#
#line 22
dontaudit initrc_t crond_t:process noatsecure;
#line 22

#line 22
#
#line 22
# Do not audit when signal-related state is cleared upon the transition.
#line 22
#
#line 22
dontaudit initrc_t crond_t:process siginh;
#line 22

#line 22
#
#line 22
# Do not audit when resource limits are reset upon the transition.
#line 22
#
#line 22
dontaudit initrc_t crond_t:process rlimitinh;
#line 22

#line 22
#
#line 22
# Allow the process to execute the program.
#line 22
# 
#line 22
allow initrc_t anacron_exec_t:file { read { getattr execute } };
#line 22

#line 22
#
#line 22
# Allow the process to reap the new domain.
#line 22
#
#line 22
allow crond_t initrc_t:process sigchld;
#line 22

#line 22
#
#line 22
# Allow the new domain to inherit and use file 
#line 22
# descriptions from the creating process and vice versa.
#line 22
#
#line 22
allow crond_t initrc_t:fd use;
#line 22
allow initrc_t crond_t:fd use;
#line 22

#line 22
#
#line 22
# Allow the new domain to write back to the old domain via a pipe.
#line 22
#
#line 22
allow crond_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 22

#line 22
#
#line 22
# Allow the new domain to read and execute the program.
#line 22
#
#line 22
allow crond_t anacron_exec_t:file { read getattr lock execute ioctl };
#line 22

#line 22
#
#line 22
# Allow the new domain to be entered via the program.
#line 22
#
#line 22
allow crond_t anacron_exec_t:file entrypoint;
#line 22

#line 22
type_transition initrc_t anacron_exec_t:process crond_t;
#line 22

# Access log files

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the process to modify the directory.
#line 24
#
#line 24
allow crond_t user_home_dir_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 24

#line 24
#
#line 24
# Allow the process to create the file.
#line 24
#
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
allow crond_t user_home_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
allow crond_t user_home_t:lnk_file { create read getattr setattr link unlink rename };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
allow crond_t user_home_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
allow crond_t user_home_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
allow crond_t user_home_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
type_transition crond_t user_home_dir_t:dir user_home_t;
#line 24
type_transition crond_t user_home_dir_t:{ file lnk_file sock_file fifo_file } user_home_t;
#line 24

#line 24


#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the process to modify the directory.
#line 25
#
#line 25
allow crond_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 25

#line 25
#
#line 25
# Allow the process to create the file.
#line 25
#
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow crond_t system_crond_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow crond_t system_crond_tmp_t:lnk_file { create read getattr setattr link unlink rename };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow crond_t system_crond_tmp_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow crond_t system_crond_tmp_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow crond_t system_crond_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
type_transition crond_t tmp_t:dir system_crond_tmp_t;
#line 25
type_transition crond_t tmp_t:{ file lnk_file sock_file fifo_file } system_crond_tmp_t;
#line 25

#line 25


#line 26
type crond_var_run_t, file_type, sysadmfile, pidfile;
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
#
#line 26
# Allow the process to modify the directory.
#line 26
#
#line 26
allow crond_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 26

#line 26
#
#line 26
# Allow the process to create the file.
#line 26
#
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
allow crond_t crond_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
type_transition crond_t var_run_t:file crond_var_run_t;
#line 26

#line 26

#line 26

#line 26
allow crond_t var_t:dir search;
#line 26
allow crond_t crond_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 26


#line 33

#line 33

#line 33

#line 33
typeattribute crond_t unrestricted;
#line 33
typeattribute crond_t privuser;
#line 33

#line 33
# Mount/unmount any filesystem. 
#line 33
allow crond_t fs_type:filesystem *;
#line 33

#line 33
# Mount/unmount any filesystem with the context= option. 
#line 33
allow crond_t file_type:filesystem *;
#line 33

#line 33
# Create/access any file in a labeled filesystem;
#line 33
allow crond_t file_type:{ file chr_file } ~execmod;
#line 33
allow crond_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 33
allow crond_t sysctl_t:{ dir file } *;
#line 33
allow crond_t device_type:{ chr_file blk_file } *;
#line 33
allow crond_t mtrr_device_t:file *;
#line 33

#line 33
# Create/access other files.  fs_type is to pick up various
#line 33
# pseudo filesystem types that are applied to both the filesystem
#line 33
# and its files.
#line 33
allow crond_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 33
allow crond_t unlabeled_t:association { sendto recvfrom };
#line 33

#line 33
allow crond_t proc_fs:{ dir file } *;
#line 33

#line 33
# For /proc/pid
#line 33

#line 33
allow crond_t domain:dir { read getattr lock search ioctl };
#line 33
allow crond_t domain:file { read getattr lock ioctl };
#line 33
allow crond_t domain:lnk_file { getattr read };
#line 33

#line 33
# Write access is for setting attributes under /proc/self/attr.
#line 33
allow crond_t self:file { ioctl read getattr lock write append };
#line 33

#line 33
# Read and write sysctls.
#line 33

#line 33
allow crond_t sysctl_type:dir { read getattr lock search ioctl };
#line 33
allow crond_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 33

#line 33

#line 33
# Access the network.
#line 33
allow crond_t node_type:node *;
#line 33
allow crond_t netif_type:netif *;
#line 33
allow crond_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 33
allow crond_t port_type:tcp_socket name_connect;
#line 33

#line 33
# Bind to any network address.
#line 33
allow crond_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 33
allow crond_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 33
allow crond_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 33

#line 33
# Use/sendto/connectto sockets created by any domain.
#line 33
allow crond_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 33

#line 33
# Use descriptors and pipes created by any domain.
#line 33
allow crond_t domain:fd use;
#line 33
allow crond_t domain:fifo_file { ioctl read getattr lock write append };
#line 33

#line 33
# Act upon any other process.
#line 33
allow crond_t domain:process ~{ transition dyntransition execmem };
#line 33
# Transition to myself, to make get_ordered_context_list happy.
#line 33
allow crond_t self:process transition;
#line 33

#line 33
if (allow_execmem) {
#line 33
# Allow making anonymous memory executable, e.g. 
#line 33
# for runtime-code generation or executable stack.
#line 33
allow crond_t self:process execmem;
#line 33
}
#line 33

#line 33
if (allow_execmem && allow_execstack) {
#line 33
# Allow making the stack executable via mprotect.
#line 33
allow crond_t self:process execstack;
#line 33
}
#line 33

#line 33
if (allow_execmod) {
#line 33
# Allow text relocations on system shared libraries, e.g. libGL.
#line 33

#line 33
allow crond_t file_type:file execmod;
#line 33

#line 33
}
#line 33

#line 33
# Create/access any System V IPC objects.
#line 33
allow crond_t domain:{ sem msgq shm } *;
#line 33
allow crond_t domain:msg  { send receive };
#line 33

#line 33
# Access the security API.
#line 33
if (!secure_mode_policyload) {
#line 33
allow crond_t security_t:security *;
#line 33
auditallow crond_t security_t:security { load_policy setenforce setbool };
#line 33
}
#line 33
# Perform certain system operations that lacked individual capabilities.
#line 33
allow crond_t kernel_t:system *;
#line 33

#line 33
# Use any Linux capability.
#line 33
allow crond_t self:capability *;
#line 33

#line 33
# Set user information and skip authentication.
#line 33
allow crond_t self:passwd *;
#line 33

#line 33
# Communicate via dbusd.
#line 33
allow crond_t self:dbus *;
#line 33

#line 33
allow crond_t system_dbusd_t:dbus *;
#line 33

#line 33

#line 33
# Get info via nscd.
#line 33
allow crond_t self:nscd *;
#line 33

#line 33
allow crond_t nscd_t:nscd *;
#line 33

#line 33

#line 33

#line 33
allow crond_t initrc_t:dbus send_msg;
#line 33
allow crond_t unconfined_t:dbus send_msg;
#line 33
allow crond_t unconfined_t:process transition;
#line 33

#line 1 "domains/program/cups.te"
#DESC Cups - Common Unix Printing System
#
# Created cups policy from lpd policy: Russell Coker <russell@coker.com.au>
# X-Debian-Packages: cupsys cupsys-client cupsys-bsd
# Depends: lpd.te lpr.te

#################################
#
# Rules for the cupsd_t domain.
#
# cupsd_t is the domain of cupsd.
# cupsd_exec_t is the type of the cupsd executable.
#

#line 14

#line 14

#line 14

#line 14
type cupsd_t, domain, privlog, daemon , auth_chkpwd, nscd_client_domain, transitionbool;
#line 14
type cupsd_exec_t, file_type, sysadmfile, exec_type;
#line 14
dontaudit cupsd_t self:capability sys_tty_config;
#line 14

#line 14
role system_r types cupsd_t;
#line 14

#line 14
# Inherit and use descriptors from init.
#line 14
allow cupsd_t init_t:fd use;
#line 14
allow cupsd_t init_t:process sigchld;
#line 14
allow cupsd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 14

#line 14

#line 14
allow cupsd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow cupsd_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow cupsd_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow cupsd_t ld_so_t:file execute_no_trans;
#line 14
allow cupsd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow cupsd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow cupsd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow cupsd_t texrel_shlib_t:file execmod;
#line 14
allow cupsd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow cupsd_t device_t:dir search;
#line 14
allow cupsd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
allow cupsd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 14
allow cupsd_t { self proc_t }:lnk_file { getattr read };
#line 14

#line 14
allow cupsd_t device_t:dir { read getattr lock search ioctl };
#line 14

#line 14
allow cupsd_t udev_tdb_t:file { read getattr lock ioctl };
#line 14
allow cupsd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit cupsd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit cupsd_t unpriv_userdomain:fd use;
#line 14

#line 14

#line 14
allow cupsd_t sysfs_t:dir { read getattr lock search ioctl };
#line 14
allow cupsd_t sysfs_t:file { read getattr lock ioctl };
#line 14
allow cupsd_t sysfs_t:lnk_file { getattr read };
#line 14
 
#line 14

#line 14
allow cupsd_t autofs_t:dir { search getattr };
#line 14

#line 14
dontaudit cupsd_t { tty_device_t devpts_t }:chr_file { read write };
#line 14
dontaudit cupsd_t root_t:file { getattr read };
#line 14
 
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow cupsd_t sysctl_t:dir search;
#line 14
allow cupsd_t sysctl_kernel_t:dir search;
#line 14
allow cupsd_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14

#line 14
bool cupsd_disable_trans false;
#line 14
if (cupsd_disable_trans) {
#line 14

#line 14
allow initrc_t cupsd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t cupsd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14
 
#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow initrc_t cupsd_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit initrc_t cupsd_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit initrc_t cupsd_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit initrc_t cupsd_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow initrc_t cupsd_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow cupsd_t initrc_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow cupsd_t initrc_t:fd use;
#line 14
allow initrc_t cupsd_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow cupsd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow cupsd_t cupsd_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow cupsd_t cupsd_exec_t:file entrypoint;
#line 14

#line 14
type_transition initrc_t cupsd_exec_t:process cupsd_t;
#line 14

#line 14

#line 14
allow initrc_t cupsd_t:process { noatsecure siginh rlimitinh };
#line 14

#line 14
}
#line 14
 
#line 14
allow cupsd_t privfd:fd use;
#line 14

#line 14
allow cupsd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
# Create pid file.
#line 14
allow cupsd_t var_t:dir { getattr search };
#line 14

#line 14
type cupsd_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow cupsd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow cupsd_t cupsd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition cupsd_t var_run_t:file cupsd_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow cupsd_t var_t:dir search;
#line 14
allow cupsd_t cupsd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
allow cupsd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
# for daemons that look at /root on startup
#line 14
dontaudit cupsd_t sysadm_home_dir_t:dir search;
#line 14

#line 14
# for df
#line 14
allow cupsd_t fs_type:filesystem getattr;
#line 14
allow cupsd_t removable_t:filesystem getattr;
#line 14

#line 14

#line 14
allow cupsd_t etc_t:lnk_file read;
#line 14
allow cupsd_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cupsd_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow cupsd_t locale_t:file { read getattr lock ioctl };
#line 14
allow cupsd_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14

#line 14
# for localization
#line 14
allow cupsd_t lib_t:file { getattr read };
#line 14


#line 15

#line 15
type cupsd_etc_t, file_type, sysadmfile, usercanread;
#line 15
allow cupsd_t cupsd_etc_t:file { read getattr lock ioctl };
#line 15

#line 15
allow cupsd_t cupsd_etc_t:dir { read getattr lock search ioctl };
#line 15
allow cupsd_t cupsd_etc_t:lnk_file { getattr read };
#line 15

type cupsd_rw_etc_t, file_type, sysadmfile, usercanread;


#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow cupsd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow cupsd_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow cupsd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow cupsd_t node_type:node { tcp_send rawip_send };
#line 18
allow cupsd_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow cupsd_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow cupsd_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow cupsd_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow cupsd_t self:tcp_socket { listen accept };
#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow cupsd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow cupsd_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow cupsd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow cupsd_t node_type:node { tcp_send rawip_send };
#line 18
allow cupsd_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow cupsd_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow cupsd_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow cupsd_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow cupsd_t self:tcp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use udp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow cupsd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow cupsd_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow cupsd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow cupsd_t node_type:node { udp_send rawip_send };
#line 18
allow cupsd_t node_type:node { udp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow cupsd_t port_type:udp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow cupsd_t node_type:udp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow cupsd_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow cupsd_t self:udp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

allow cupsd_t port_type:tcp_socket name_connect;

#line 20

#line 20
type cupsd_log_t, file_type, sysadmfile, logfile;
#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the process to modify the directory.
#line 20
#
#line 20
allow cupsd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 20

#line 20
#
#line 20
# Allow the process to create the file.
#line 20
#
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
allow cupsd_t cupsd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
type_transition cupsd_t var_log_t:file cupsd_log_t;
#line 20

#line 20

#line 20

#line 20
allow cupsd_t cupsd_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 20



#line 22
type cupsd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 22

#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the process to modify the directory.
#line 22
#
#line 22
allow cupsd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 22

#line 22
#
#line 22
# Allow the process to create the file.
#line 22
#
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
allow cupsd_t cupsd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
allow cupsd_t cupsd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
allow cupsd_t cupsd_tmp_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
type_transition cupsd_t tmp_t:{ file dir fifo_file } cupsd_tmp_t;
#line 22

#line 22

#line 22


allow cupsd_t devpts_t:dir search;

allow cupsd_t device_t:lnk_file read;
allow cupsd_t printer_device_t:chr_file { ioctl read getattr lock write append };
allow cupsd_t urandom_device_t:chr_file { getattr read };
dontaudit cupsd_t random_device_t:chr_file ioctl;

# temporary solution, we need something better
allow cupsd_t serial_device:chr_file { ioctl read getattr lock write append };


#line 34
allow cupsd_t usbdevfs_t:dir { read getattr lock search ioctl };
#line 34
allow cupsd_t usbdevfs_t:file { read getattr lock ioctl };
#line 34
allow cupsd_t usbdevfs_t:lnk_file { getattr read };
#line 34


#line 35
allow cupsd_t usbfs_t:dir { read getattr lock search ioctl };
#line 35
allow cupsd_t usbfs_t:file { read getattr lock ioctl };
#line 35
allow cupsd_t usbfs_t:lnk_file { getattr read };
#line 35


#line 39


#line 44

#line 44
allow inetd_t printer_port_t:tcp_socket name_bind;
#line 44

#line 44

#line 44

#line 44
#
#line 44
# Allow the process to transition to the new domain.
#line 44
#
#line 44
allow inetd_t cupsd_t:process transition;
#line 44

#line 44
#
#line 44
# Do not audit when glibc secure mode is enabled upon the transition.
#line 44
#
#line 44
dontaudit inetd_t cupsd_t:process noatsecure;
#line 44

#line 44
#
#line 44
# Do not audit when signal-related state is cleared upon the transition.
#line 44
#
#line 44
dontaudit inetd_t cupsd_t:process siginh;
#line 44

#line 44
#
#line 44
# Do not audit when resource limits are reset upon the transition.
#line 44
#
#line 44
dontaudit inetd_t cupsd_t:process rlimitinh;
#line 44

#line 44
#
#line 44
# Allow the process to execute the program.
#line 44
# 
#line 44
allow inetd_t cupsd_exec_t:file { read { getattr execute } };
#line 44

#line 44
#
#line 44
# Allow the process to reap the new domain.
#line 44
#
#line 44
allow cupsd_t inetd_t:process sigchld;
#line 44

#line 44
#
#line 44
# Allow the new domain to inherit and use file 
#line 44
# descriptions from the creating process and vice versa.
#line 44
#
#line 44
allow cupsd_t inetd_t:fd use;
#line 44
allow inetd_t cupsd_t:fd use;
#line 44

#line 44
#
#line 44
# Allow the new domain to write back to the old domain via a pipe.
#line 44
#
#line 44
allow cupsd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 44

#line 44
#
#line 44
# Allow the new domain to read and execute the program.
#line 44
#
#line 44
allow cupsd_t cupsd_exec_t:file { read getattr lock execute ioctl };
#line 44

#line 44
#
#line 44
# Allow the new domain to be entered via the program.
#line 44
#
#line 44
allow cupsd_t cupsd_exec_t:file entrypoint;
#line 44

#line 44
type_transition inetd_t cupsd_exec_t:process cupsd_t;
#line 44

#line 44


# write to spool
allow cupsd_t var_spool_t:dir { getattr search };

# this is not ideal, and allowing setattr access to cupsd_etc_t is wrong

#line 50

#line 50

#line 50

#line 50
#
#line 50
# Allow the process to modify the directory.
#line 50
#
#line 50
allow cupsd_t cupsd_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 50

#line 50
#
#line 50
# Allow the process to create the file.
#line 50
#
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow cupsd_t cupsd_rw_etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
type_transition cupsd_t cupsd_etc_t:file cupsd_rw_etc_t;
#line 50

#line 50


#line 51

#line 51

#line 51

#line 51
#
#line 51
# Allow the process to modify the directory.
#line 51
#
#line 51
allow cupsd_t var_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 51

#line 51
#
#line 51
# Allow the process to create the file.
#line 51
#
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
allow cupsd_t cupsd_rw_etc_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
allow cupsd_t cupsd_rw_etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
type_transition cupsd_t var_t:{ dir file } cupsd_rw_etc_t;
#line 51

#line 51

allow cupsd_t cupsd_rw_etc_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
allow cupsd_t cupsd_etc_t:file setattr;
allow cupsd_t cupsd_etc_t:dir setattr;

allow cupsd_t { etc_t etc_runtime_t }:file { getattr read ioctl };

#line 57
allow cupsd_t initrc_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 57

allow cupsd_t proc_t:file { read getattr lock ioctl };
allow cupsd_t proc_t:dir { read getattr lock search ioctl };
allow cupsd_t self:file { getattr read };

#line 61
# Read system variables in /sys.
#line 61

#line 61
allow cupsd_t sysctl_t:dir search;
#line 61
allow cupsd_t sysctl_kernel_t:dir search;
#line 61
allow cupsd_t sysctl_kernel_t:file { getattr read };
#line 61

#line 61

#line 61

allow cupsd_t sysctl_dev_t:dir search;
allow cupsd_t sysctl_dev_t:file { getattr read };

# for /etc/printcap
dontaudit cupsd_t etc_t:file write;

# allow cups to execute its backend scripts

#line 69
allow cupsd_t cupsd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 69

allow cupsd_t cupsd_exec_t:dir search;
allow cupsd_t cupsd_exec_t:lnk_file read;
allow cupsd_t reserved_port_t:tcp_socket name_bind;
dontaudit cupsd_t reserved_port_type:tcp_socket name_bind;

allow cupsd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow cupsd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow cupsd_t self:fifo_file { ioctl read getattr lock write append };

# Use capabilities.
allow cupsd_t self:capability { dac_read_search kill setgid setuid fsetid net_bind_service fowner chown dac_override sys_tty_config audit_write };
dontaudit cupsd_t self:capability net_admin;

#
# /usr/lib/cups/backend/serial needs sys_admin
# Need new context to run under???
allow cupsd_t self:capability sys_admin;

allow cupsd_t self:process setsched;

# for /var/lib/defoma
allow cupsd_t var_lib_t:dir search;

#line 92
allow cupsd_t readable_t:dir { read getattr lock search ioctl };
#line 92
allow cupsd_t readable_t:file { read getattr lock ioctl };
#line 92
allow cupsd_t readable_t:lnk_file { getattr read };
#line 92


# Bind to the cups/ipp port (631).
allow cupsd_t ipp_port_t:{ udp_socket tcp_socket } name_bind;


#line 97
#allow web_client_domain cupsd_t:tcp_socket { connectto recvfrom };
#line 97
#allow cupsd_t web_client_domain:tcp_socket { acceptfrom recvfrom };
#line 97
#allow cupsd_t kernel_t:tcp_socket recvfrom;
#line 97
#allow web_client_domain kernel_t:tcp_socket recvfrom;
#line 97


#line 98
#allow cupsd_t cupsd_t:tcp_socket { connectto recvfrom };
#line 98
#allow cupsd_t cupsd_t:tcp_socket { acceptfrom recvfrom };
#line 98
#allow cupsd_t kernel_t:tcp_socket recvfrom;
#line 98
#allow cupsd_t kernel_t:tcp_socket recvfrom;
#line 98


# Send to portmap.
#line 104

#line 104

#line 104
#allow cupsd_t portmap_t:udp_socket sendto;
#line 104
#allow portmap_t cupsd_t:udp_socket recvfrom;
#line 104

#line 104

#line 104
#allow portmap_t cupsd_t:udp_socket sendto;
#line 104
#allow cupsd_t portmap_t:udp_socket recvfrom;
#line 104

#line 104


# Write to /var/spool/cups.
allow cupsd_t print_spool_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
allow cupsd_t print_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
allow cupsd_t print_spool_t:file { ioctl read getattr lock write append };

# Filter scripts may be shell scripts, and may invoke progs like /bin/mktemp
allow cupsd_t { bin_t sbin_t }:dir { search getattr };
allow cupsd_t bin_t:lnk_file read;

#line 114
allow cupsd_t { shell_exec_t bin_t sbin_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 114


# They will also invoke ghostscript, which needs to read fonts

#line 117

#line 117
# Read global fonts and font config
#line 117

#line 117
allow cupsd_t fonts_t:dir { read getattr lock search ioctl };
#line 117
allow cupsd_t fonts_t:file { read getattr lock ioctl };
#line 117
allow cupsd_t fonts_t:lnk_file { getattr read };
#line 117

#line 117

#line 117
allow cupsd_t etc_t:dir { read getattr lock search ioctl };
#line 117
allow cupsd_t etc_t:file { read getattr lock ioctl };
#line 117
allow cupsd_t etc_t:lnk_file { getattr read };
#line 117

#line 117

#line 117
 

# Read /usr/lib/gconv/gconv-modules.* and /usr/lib/python2.2/.*
allow cupsd_t lib_t:file { read getattr };

# read python modules
allow cupsd_t usr_t:{ file lnk_file } { read getattr ioctl };

#
# lots of errors generated requiring the following
#
allow cupsd_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };
allow cupsd_t self:netlink_route_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read } };

#
# Satisfy readahead
#
allow initrc_t cupsd_log_t:file { getattr read };

#line 135
allow cupsd_t var_t:dir { read getattr lock search ioctl };
#line 135
allow cupsd_t var_t:file { read getattr lock ioctl };
#line 135
allow cupsd_t var_t:lnk_file { getattr read };
#line 135



#line 137
allow cupsd_t usercanread:dir { read getattr lock search ioctl };
#line 137
allow cupsd_t usercanread:file { read getattr lock ioctl };
#line 137
allow cupsd_t usercanread:lnk_file { getattr read };
#line 137

#line 141

#line 141

#line 141
allow cupsd_t samba_var_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 141
allow cupsd_t samba_var_t:file { ioctl read getattr lock write append };
#line 141
allow cupsd_t samba_var_t:lnk_file { getattr read };
#line 141

#line 141
allow smbd_t cupsd_etc_t:dir search;
#line 141


#line 145

dontaudit cupsd_t { sysadm_home_dir_t staff_home_dir_t }:dir { getattr search };
# PTAL

#line 148

#line 148

#line 148

#line 148
type ptal_t, domain, privlog, daemon , transitionbool;
#line 148
type ptal_exec_t, file_type, sysadmfile, exec_type;
#line 148
dontaudit ptal_t self:capability sys_tty_config;
#line 148

#line 148
role system_r types ptal_t;
#line 148

#line 148
# Inherit and use descriptors from init.
#line 148
allow ptal_t init_t:fd use;
#line 148
allow ptal_t init_t:process sigchld;
#line 148
allow ptal_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 148

#line 148

#line 148
allow ptal_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 148
allow ptal_t lib_t:lnk_file { read getattr lock ioctl };
#line 148
allow ptal_t ld_so_t:file { read getattr lock execute ioctl };
#line 148
#allow ptal_t ld_so_t:file execute_no_trans;
#line 148
allow ptal_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 148
allow ptal_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 148
allow ptal_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 148
allow ptal_t texrel_shlib_t:file execmod;
#line 148
allow ptal_t ld_so_cache_t:file { read getattr lock ioctl };
#line 148
allow ptal_t device_t:dir search;
#line 148
allow ptal_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 148

#line 148

#line 148
allow ptal_t { self proc_t }:dir { read getattr lock search ioctl };
#line 148
allow ptal_t { self proc_t }:lnk_file { getattr read };
#line 148

#line 148
allow ptal_t device_t:dir { read getattr lock search ioctl };
#line 148

#line 148
allow ptal_t udev_tdb_t:file { read getattr lock ioctl };
#line 148
allow ptal_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 148
dontaudit ptal_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 148
dontaudit ptal_t unpriv_userdomain:fd use;
#line 148

#line 148

#line 148
allow ptal_t sysfs_t:dir { read getattr lock search ioctl };
#line 148
allow ptal_t sysfs_t:file { read getattr lock ioctl };
#line 148
allow ptal_t sysfs_t:lnk_file { getattr read };
#line 148
 
#line 148

#line 148
allow ptal_t autofs_t:dir { search getattr };
#line 148

#line 148
dontaudit ptal_t { tty_device_t devpts_t }:chr_file { read write };
#line 148
dontaudit ptal_t root_t:file { getattr read };
#line 148
 
#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148
# Read system variables in /sys.
#line 148

#line 148
allow ptal_t sysctl_t:dir search;
#line 148
allow ptal_t sysctl_kernel_t:dir search;
#line 148
allow ptal_t sysctl_kernel_t:file { getattr read };
#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148
#
#line 148
# Allows user to define a tunable to disable domain transition
#line 148
#
#line 148

#line 148
bool ptal_disable_trans false;
#line 148
if (ptal_disable_trans) {
#line 148

#line 148
allow initrc_t ptal_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 148

#line 148

#line 148
allow sysadm_t ptal_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 148

#line 148
} else {
#line 148
 
#line 148

#line 148

#line 148
#
#line 148
# Allow the process to transition to the new domain.
#line 148
#
#line 148
allow initrc_t ptal_t:process transition;
#line 148

#line 148
#
#line 148
# Do not audit when glibc secure mode is enabled upon the transition.
#line 148
#
#line 148
dontaudit initrc_t ptal_t:process noatsecure;
#line 148

#line 148
#
#line 148
# Do not audit when signal-related state is cleared upon the transition.
#line 148
#
#line 148
dontaudit initrc_t ptal_t:process siginh;
#line 148

#line 148
#
#line 148
# Do not audit when resource limits are reset upon the transition.
#line 148
#
#line 148
dontaudit initrc_t ptal_t:process rlimitinh;
#line 148

#line 148
#
#line 148
# Allow the process to execute the program.
#line 148
# 
#line 148
allow initrc_t ptal_exec_t:file { read { getattr execute } };
#line 148

#line 148
#
#line 148
# Allow the process to reap the new domain.
#line 148
#
#line 148
allow ptal_t initrc_t:process sigchld;
#line 148

#line 148
#
#line 148
# Allow the new domain to inherit and use file 
#line 148
# descriptions from the creating process and vice versa.
#line 148
#
#line 148
allow ptal_t initrc_t:fd use;
#line 148
allow initrc_t ptal_t:fd use;
#line 148

#line 148
#
#line 148
# Allow the new domain to write back to the old domain via a pipe.
#line 148
#
#line 148
allow ptal_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 148

#line 148
#
#line 148
# Allow the new domain to read and execute the program.
#line 148
#
#line 148
allow ptal_t ptal_exec_t:file { read getattr lock execute ioctl };
#line 148

#line 148
#
#line 148
# Allow the new domain to be entered via the program.
#line 148
#
#line 148
allow ptal_t ptal_exec_t:file entrypoint;
#line 148

#line 148
type_transition initrc_t ptal_exec_t:process ptal_t;
#line 148

#line 148

#line 148
allow initrc_t ptal_t:process { noatsecure siginh rlimitinh };
#line 148

#line 148
}
#line 148
 
#line 148
allow ptal_t privfd:fd use;
#line 148

#line 148
allow ptal_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 148

#line 148

#line 148
# Create pid file.
#line 148
allow ptal_t var_t:dir { getattr search };
#line 148

#line 148
type ptal_var_run_t, file_type, sysadmfile, pidfile;
#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148
#
#line 148
# Allow the process to modify the directory.
#line 148
#
#line 148
allow ptal_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 148

#line 148
#
#line 148
# Allow the process to create the file.
#line 148
#
#line 148

#line 148

#line 148

#line 148

#line 148

#line 148
allow ptal_t ptal_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148
type_transition ptal_t var_run_t:file ptal_var_run_t;
#line 148

#line 148

#line 148

#line 148
allow ptal_t var_t:dir search;
#line 148
allow ptal_t ptal_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 148

#line 148

#line 148
allow ptal_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 148

#line 148
# for daemons that look at /root on startup
#line 148
dontaudit ptal_t sysadm_home_dir_t:dir search;
#line 148

#line 148
# for df
#line 148
allow ptal_t fs_type:filesystem getattr;
#line 148
allow ptal_t removable_t:filesystem getattr;
#line 148

#line 148

#line 148
allow ptal_t etc_t:lnk_file read;
#line 148
allow ptal_t lib_t:file { read getattr lock ioctl };
#line 148

#line 148
allow ptal_t locale_t:dir { read getattr lock search ioctl };
#line 148
allow ptal_t locale_t:file { read getattr lock ioctl };
#line 148
allow ptal_t locale_t:lnk_file { getattr read };
#line 148

#line 148

#line 148

#line 148
# for localization
#line 148
allow ptal_t lib_t:file { getattr read };
#line 148


#line 149

#line 149
type ptal_etc_t, file_type, sysadmfile, usercanread;
#line 149
allow ptal_t ptal_etc_t:file { read getattr lock ioctl };
#line 149

#line 149
allow ptal_t ptal_etc_t:dir { read getattr lock search ioctl };
#line 149
allow ptal_t ptal_etc_t:lnk_file { getattr read };
#line 149



#line 151

#line 151

#line 151

#line 151
#
#line 151
# Allow the process to modify the directory.
#line 151
#
#line 151
allow ptal_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 151

#line 151
#
#line 151
# Allow the process to create the file.
#line 151
#
#line 151

#line 151

#line 151

#line 151

#line 151

#line 151
allow ptal_t ptal_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151
allow ptal_t ptal_var_run_t:lnk_file { create read getattr setattr link unlink rename };
#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151
allow ptal_t ptal_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151
allow ptal_t ptal_var_run_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151
allow ptal_t ptal_var_run_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151
type_transition ptal_t var_run_t:dir ptal_var_run_t;
#line 151
type_transition ptal_t var_run_t:{ file lnk_file sock_file fifo_file } ptal_var_run_t;
#line 151

#line 151

allow ptal_t self:capability { chown sys_rawio };
allow ptal_t self:{ unix_dgram_socket unix_stream_socket } { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow ptal_t self:unix_stream_socket { listen accept };

#line 155

#line 155
#
#line 155
# Allow the domain to create and use tcp sockets.
#line 155
# Other kinds of sockets must be separately authorized for use.
#line 155
allow ptal_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 155

#line 155
allow ptal_t unlabeled_t:association { sendto recvfrom };
#line 155

#line 155
#
#line 155
# Allow the domain to send or receive using any network interface.
#line 155
# netif_type is a type attribute for all network interface types.
#line 155
#
#line 155
allow ptal_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 155
#
#line 155
# Allow the domain to send to or receive from any node.
#line 155
# node_type is a type attribute for all node types.
#line 155
#
#line 155
allow ptal_t node_type:node { tcp_send rawip_send };
#line 155
allow ptal_t node_type:node { tcp_recv rawip_recv };
#line 155

#line 155
#
#line 155
# Allow the domain to send to or receive from any port.
#line 155
# port_type is a type attribute for all port types.
#line 155
#
#line 155

#line 155
allow ptal_t port_type:tcp_socket { send_msg recv_msg };
#line 155

#line 155

#line 155
# XXX Allow binding to any node type.  Remove once
#line 155
# individual rules have been added to all domains that 
#line 155
# bind sockets. 
#line 155
allow ptal_t node_type:tcp_socket node_bind;
#line 155
#
#line 155
# Allow access to network files including /etc/resolv.conf
#line 155
#
#line 155
allow ptal_t net_conf_t:file { read getattr lock ioctl };
#line 155

#line 155
allow ptal_t self:tcp_socket { listen accept };
#line 155

allow ptal_t ptal_port_t:tcp_socket name_bind;
allow userdomain ptal_t:unix_stream_socket connectto;
allow userdomain ptal_var_run_t:sock_file write;
allow userdomain ptal_var_run_t:dir search;
allow ptal_t self:fifo_file { ioctl read getattr lock write append };
allow ptal_t device_t:dir read;
allow ptal_t printer_device_t:chr_file { ioctl read getattr lock write append };
allow initrc_t printer_device_t:chr_file getattr;
allow ptal_t { etc_t etc_runtime_t }:file { getattr read };

#line 165
allow ptal_t usbdevfs_t:dir { read getattr lock search ioctl };
#line 165
allow ptal_t usbdevfs_t:file { read getattr lock ioctl };
#line 165
allow ptal_t usbdevfs_t:lnk_file { getattr read };
#line 165


#line 166
allow ptal_t usbfs_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 166
allow ptal_t usbfs_t:file { ioctl read getattr lock write append };
#line 166
allow ptal_t usbfs_t:lnk_file { getattr read };
#line 166

allow cupsd_t ptal_var_run_t:sock_file { write setattr };
allow cupsd_t ptal_t:unix_stream_socket connectto;
allow cupsd_t ptal_var_run_t:dir search;
dontaudit ptal_t { sysadm_home_dir_t staff_home_dir_t }:dir { getattr search };

allow initrc_t ptal_var_run_t:dir rmdir;
allow initrc_t ptal_var_run_t:fifo_file unlink;


# HPLIP

#line 177

#line 177

#line 177

#line 177
type hplip_t, domain, privlog, daemon , transitionbool;
#line 177
type hplip_exec_t, file_type, sysadmfile, exec_type;
#line 177
dontaudit hplip_t self:capability sys_tty_config;
#line 177

#line 177
role system_r types hplip_t;
#line 177

#line 177
# Inherit and use descriptors from init.
#line 177
allow hplip_t init_t:fd use;
#line 177
allow hplip_t init_t:process sigchld;
#line 177
allow hplip_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 177

#line 177

#line 177
allow hplip_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 177
allow hplip_t lib_t:lnk_file { read getattr lock ioctl };
#line 177
allow hplip_t ld_so_t:file { read getattr lock execute ioctl };
#line 177
#allow hplip_t ld_so_t:file execute_no_trans;
#line 177
allow hplip_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 177
allow hplip_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 177
allow hplip_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 177
allow hplip_t texrel_shlib_t:file execmod;
#line 177
allow hplip_t ld_so_cache_t:file { read getattr lock ioctl };
#line 177
allow hplip_t device_t:dir search;
#line 177
allow hplip_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 177

#line 177

#line 177
allow hplip_t { self proc_t }:dir { read getattr lock search ioctl };
#line 177
allow hplip_t { self proc_t }:lnk_file { getattr read };
#line 177

#line 177
allow hplip_t device_t:dir { read getattr lock search ioctl };
#line 177

#line 177
allow hplip_t udev_tdb_t:file { read getattr lock ioctl };
#line 177
allow hplip_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 177
dontaudit hplip_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 177
dontaudit hplip_t unpriv_userdomain:fd use;
#line 177

#line 177

#line 177
allow hplip_t sysfs_t:dir { read getattr lock search ioctl };
#line 177
allow hplip_t sysfs_t:file { read getattr lock ioctl };
#line 177
allow hplip_t sysfs_t:lnk_file { getattr read };
#line 177
 
#line 177

#line 177
allow hplip_t autofs_t:dir { search getattr };
#line 177

#line 177
dontaudit hplip_t { tty_device_t devpts_t }:chr_file { read write };
#line 177
dontaudit hplip_t root_t:file { getattr read };
#line 177
 
#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177
# Read system variables in /sys.
#line 177

#line 177
allow hplip_t sysctl_t:dir search;
#line 177
allow hplip_t sysctl_kernel_t:dir search;
#line 177
allow hplip_t sysctl_kernel_t:file { getattr read };
#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177
#
#line 177
# Allows user to define a tunable to disable domain transition
#line 177
#
#line 177

#line 177
bool hplip_disable_trans false;
#line 177
if (hplip_disable_trans) {
#line 177

#line 177
allow initrc_t hplip_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 177

#line 177

#line 177
allow sysadm_t hplip_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 177

#line 177
} else {
#line 177
 
#line 177

#line 177

#line 177
#
#line 177
# Allow the process to transition to the new domain.
#line 177
#
#line 177
allow initrc_t hplip_t:process transition;
#line 177

#line 177
#
#line 177
# Do not audit when glibc secure mode is enabled upon the transition.
#line 177
#
#line 177
dontaudit initrc_t hplip_t:process noatsecure;
#line 177

#line 177
#
#line 177
# Do not audit when signal-related state is cleared upon the transition.
#line 177
#
#line 177
dontaudit initrc_t hplip_t:process siginh;
#line 177

#line 177
#
#line 177
# Do not audit when resource limits are reset upon the transition.
#line 177
#
#line 177
dontaudit initrc_t hplip_t:process rlimitinh;
#line 177

#line 177
#
#line 177
# Allow the process to execute the program.
#line 177
# 
#line 177
allow initrc_t hplip_exec_t:file { read { getattr execute } };
#line 177

#line 177
#
#line 177
# Allow the process to reap the new domain.
#line 177
#
#line 177
allow hplip_t initrc_t:process sigchld;
#line 177

#line 177
#
#line 177
# Allow the new domain to inherit and use file 
#line 177
# descriptions from the creating process and vice versa.
#line 177
#
#line 177
allow hplip_t initrc_t:fd use;
#line 177
allow initrc_t hplip_t:fd use;
#line 177

#line 177
#
#line 177
# Allow the new domain to write back to the old domain via a pipe.
#line 177
#
#line 177
allow hplip_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 177

#line 177
#
#line 177
# Allow the new domain to read and execute the program.
#line 177
#
#line 177
allow hplip_t hplip_exec_t:file { read getattr lock execute ioctl };
#line 177

#line 177
#
#line 177
# Allow the new domain to be entered via the program.
#line 177
#
#line 177
allow hplip_t hplip_exec_t:file entrypoint;
#line 177

#line 177
type_transition initrc_t hplip_exec_t:process hplip_t;
#line 177

#line 177

#line 177
allow initrc_t hplip_t:process { noatsecure siginh rlimitinh };
#line 177

#line 177
}
#line 177
 
#line 177
allow hplip_t privfd:fd use;
#line 177

#line 177
allow hplip_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 177

#line 177

#line 177
# Create pid file.
#line 177
allow hplip_t var_t:dir { getattr search };
#line 177

#line 177
type hplip_var_run_t, file_type, sysadmfile, pidfile;
#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177
#
#line 177
# Allow the process to modify the directory.
#line 177
#
#line 177
allow hplip_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 177

#line 177
#
#line 177
# Allow the process to create the file.
#line 177
#
#line 177

#line 177

#line 177

#line 177

#line 177

#line 177
allow hplip_t hplip_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177
type_transition hplip_t var_run_t:file hplip_var_run_t;
#line 177

#line 177

#line 177

#line 177
allow hplip_t var_t:dir search;
#line 177
allow hplip_t hplip_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 177

#line 177

#line 177
allow hplip_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 177

#line 177
# for daemons that look at /root on startup
#line 177
dontaudit hplip_t sysadm_home_dir_t:dir search;
#line 177

#line 177
# for df
#line 177
allow hplip_t fs_type:filesystem getattr;
#line 177
allow hplip_t removable_t:filesystem getattr;
#line 177

#line 177

#line 177
allow hplip_t etc_t:lnk_file read;
#line 177
allow hplip_t lib_t:file { read getattr lock ioctl };
#line 177

#line 177
allow hplip_t locale_t:dir { read getattr lock search ioctl };
#line 177
allow hplip_t locale_t:file { read getattr lock ioctl };
#line 177
allow hplip_t locale_t:lnk_file { getattr read };
#line 177

#line 177

#line 177

#line 177
# for localization
#line 177
allow hplip_t lib_t:file { getattr read };
#line 177


#line 178

#line 178
type hplip_etc_t, file_type, sysadmfile, usercanread;
#line 178
allow hplip_t hplip_etc_t:file { read getattr lock ioctl };
#line 178

#line 178
allow hplip_t hplip_etc_t:dir { read getattr lock search ioctl };
#line 178
allow hplip_t hplip_etc_t:lnk_file { getattr read };
#line 178

allow hplip_t etc_t:file { read getattr lock ioctl };
allow hplip_t etc_runtime_t:file { read getattr };
allow hplip_t printer_device_t:chr_file { ioctl read getattr lock write append };
allow cupsd_t hplip_var_run_t:file { read getattr };
allow hplip_t cupsd_etc_t:dir search;

#line 184

#line 184

#line 184

#line 184

#line 184

#line 184
#
#line 184
# Allow the domain to create and use tcp sockets.
#line 184
# Other kinds of sockets must be separately authorized for use.
#line 184
allow hplip_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 184

#line 184
allow hplip_t unlabeled_t:association { sendto recvfrom };
#line 184

#line 184
#
#line 184
# Allow the domain to send or receive using any network interface.
#line 184
# netif_type is a type attribute for all network interface types.
#line 184
#
#line 184
allow hplip_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 184
#
#line 184
# Allow the domain to send to or receive from any node.
#line 184
# node_type is a type attribute for all node types.
#line 184
#
#line 184
allow hplip_t node_type:node { tcp_send rawip_send };
#line 184
allow hplip_t node_type:node { tcp_recv rawip_recv };
#line 184

#line 184
#
#line 184
# Allow the domain to send to or receive from any port.
#line 184
# port_type is a type attribute for all port types.
#line 184
#
#line 184

#line 184
allow hplip_t port_type:tcp_socket { send_msg recv_msg };
#line 184

#line 184

#line 184
# XXX Allow binding to any node type.  Remove once
#line 184
# individual rules have been added to all domains that 
#line 184
# bind sockets. 
#line 184
allow hplip_t node_type:tcp_socket node_bind;
#line 184
#
#line 184
# Allow access to network files including /etc/resolv.conf
#line 184
#
#line 184
allow hplip_t net_conf_t:file { read getattr lock ioctl };
#line 184

#line 184
allow hplip_t self:tcp_socket { listen accept };
#line 184

#line 184

#line 184

#line 184
#
#line 184
# Allow the domain to create and use tcp sockets.
#line 184
# Other kinds of sockets must be separately authorized for use.
#line 184
allow hplip_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 184

#line 184
allow hplip_t unlabeled_t:association { sendto recvfrom };
#line 184

#line 184
#
#line 184
# Allow the domain to send or receive using any network interface.
#line 184
# netif_type is a type attribute for all network interface types.
#line 184
#
#line 184
allow hplip_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 184
#
#line 184
# Allow the domain to send to or receive from any node.
#line 184
# node_type is a type attribute for all node types.
#line 184
#
#line 184
allow hplip_t node_type:node { tcp_send rawip_send };
#line 184
allow hplip_t node_type:node { tcp_recv rawip_recv };
#line 184

#line 184
#
#line 184
# Allow the domain to send to or receive from any port.
#line 184
# port_type is a type attribute for all port types.
#line 184
#
#line 184

#line 184
allow hplip_t port_type:tcp_socket { send_msg recv_msg };
#line 184

#line 184

#line 184
# XXX Allow binding to any node type.  Remove once
#line 184
# individual rules have been added to all domains that 
#line 184
# bind sockets. 
#line 184
allow hplip_t node_type:tcp_socket node_bind;
#line 184
#
#line 184
# Allow access to network files including /etc/resolv.conf
#line 184
#
#line 184
allow hplip_t net_conf_t:file { read getattr lock ioctl };
#line 184

#line 184
allow hplip_t self:tcp_socket { connect };
#line 184

#line 184

#line 184

#line 184

#line 184

#line 184
#
#line 184
# Allow the domain to create and use udp sockets.
#line 184
# Other kinds of sockets must be separately authorized for use.
#line 184
allow hplip_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 184

#line 184
allow hplip_t unlabeled_t:association { sendto recvfrom };
#line 184

#line 184
#
#line 184
# Allow the domain to send or receive using any network interface.
#line 184
# netif_type is a type attribute for all network interface types.
#line 184
#
#line 184
allow hplip_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 184
#
#line 184
# Allow the domain to send to or receive from any node.
#line 184
# node_type is a type attribute for all node types.
#line 184
#
#line 184
allow hplip_t node_type:node { udp_send rawip_send };
#line 184
allow hplip_t node_type:node { udp_recv rawip_recv };
#line 184

#line 184
#
#line 184
# Allow the domain to send to or receive from any port.
#line 184
# port_type is a type attribute for all port types.
#line 184
#
#line 184

#line 184
allow hplip_t port_type:udp_socket { send_msg recv_msg };
#line 184

#line 184

#line 184
# XXX Allow binding to any node type.  Remove once
#line 184
# individual rules have been added to all domains that 
#line 184
# bind sockets. 
#line 184
allow hplip_t node_type:udp_socket node_bind;
#line 184
#
#line 184
# Allow access to network files including /etc/resolv.conf
#line 184
#
#line 184
allow hplip_t net_conf_t:file { read getattr lock ioctl };
#line 184

#line 184
allow hplip_t self:udp_socket { connect };
#line 184

#line 184

#line 184

#line 184

#line 184

allow hplip_t { hplip_port_t ipp_port_t }:tcp_socket name_connect;
allow hplip_t hplip_port_t:tcp_socket name_bind;

# Uses networking to talk to the daemons
allow hplip_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow hplip_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow hplip_t self:rawip_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# for python

#line 194
allow hplip_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 194

allow hplip_t { sbin_t bin_t }:dir search;
allow hplip_t self:file { getattr read };
allow hplip_t proc_t:file { read getattr lock ioctl };
allow hplip_t urandom_device_t:chr_file { getattr read };
allow hplip_t usr_t:{ file lnk_file } { read getattr lock ioctl };
allow hplip_t devpts_t:dir search;
allow hplip_t devpts_t:chr_file { getattr ioctl };


dontaudit cupsd_t selinux_config_t:dir search;
dontaudit cupsd_t selinux_config_t:file { getattr read };

allow cupsd_t printconf_t:file { getattr read };

#line 213

#line 213

#line 213

#line 213

#line 213
# Derived type used for connection
#line 213
type cupsd_dbusd_system_t;
#line 213
type_change cupsd_t system_dbusd_t:dbus cupsd_dbusd_system_t;
#line 213

#line 213
# SE-DBus specific permissions
#line 213
allow cupsd_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 213

#line 213
# For connecting to the bus
#line 213
allow cupsd_t system_dbusd_t:unix_stream_socket connectto;
#line 213

#line 213

#line 213
allow { cupsd_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 213
allow { cupsd_t } system_dbusd_var_run_t:sock_file write;
#line 213
  
#line 213
allow cupsd_t system_dbusd_t:dbus send_msg;
#line 213
allow cupsd_t userdomain:dbus send_msg;
#line 213


# CUPS configuration daemon

#line 216

#line 216

#line 216

#line 216
type cupsd_config_t, domain, privlog, daemon , nscd_client_domain, transitionbool;
#line 216
type cupsd_config_exec_t, file_type, sysadmfile, exec_type;
#line 216
dontaudit cupsd_config_t self:capability sys_tty_config;
#line 216

#line 216
role system_r types cupsd_config_t;
#line 216

#line 216
# Inherit and use descriptors from init.
#line 216
allow cupsd_config_t init_t:fd use;
#line 216
allow cupsd_config_t init_t:process sigchld;
#line 216
allow cupsd_config_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 216

#line 216

#line 216
allow cupsd_config_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 216
allow cupsd_config_t lib_t:lnk_file { read getattr lock ioctl };
#line 216
allow cupsd_config_t ld_so_t:file { read getattr lock execute ioctl };
#line 216
#allow cupsd_config_t ld_so_t:file execute_no_trans;
#line 216
allow cupsd_config_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 216
allow cupsd_config_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 216
allow cupsd_config_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 216
allow cupsd_config_t texrel_shlib_t:file execmod;
#line 216
allow cupsd_config_t ld_so_cache_t:file { read getattr lock ioctl };
#line 216
allow cupsd_config_t device_t:dir search;
#line 216
allow cupsd_config_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 216

#line 216

#line 216
allow cupsd_config_t { self proc_t }:dir { read getattr lock search ioctl };
#line 216
allow cupsd_config_t { self proc_t }:lnk_file { getattr read };
#line 216

#line 216
allow cupsd_config_t device_t:dir { read getattr lock search ioctl };
#line 216

#line 216
allow cupsd_config_t udev_tdb_t:file { read getattr lock ioctl };
#line 216
allow cupsd_config_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 216
dontaudit cupsd_config_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 216
dontaudit cupsd_config_t unpriv_userdomain:fd use;
#line 216

#line 216

#line 216
allow cupsd_config_t sysfs_t:dir { read getattr lock search ioctl };
#line 216
allow cupsd_config_t sysfs_t:file { read getattr lock ioctl };
#line 216
allow cupsd_config_t sysfs_t:lnk_file { getattr read };
#line 216
 
#line 216

#line 216
allow cupsd_config_t autofs_t:dir { search getattr };
#line 216

#line 216
dontaudit cupsd_config_t { tty_device_t devpts_t }:chr_file { read write };
#line 216
dontaudit cupsd_config_t root_t:file { getattr read };
#line 216
 
#line 216

#line 216

#line 216

#line 216

#line 216

#line 216

#line 216
# Read system variables in /sys.
#line 216

#line 216
allow cupsd_config_t sysctl_t:dir search;
#line 216
allow cupsd_config_t sysctl_kernel_t:dir search;
#line 216
allow cupsd_config_t sysctl_kernel_t:file { getattr read };
#line 216

#line 216

#line 216

#line 216

#line 216

#line 216

#line 216
#
#line 216
# Allows user to define a tunable to disable domain transition
#line 216
#
#line 216

#line 216
bool cupsd_config_disable_trans false;
#line 216
if (cupsd_config_disable_trans) {
#line 216

#line 216
allow initrc_t cupsd_config_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 216

#line 216

#line 216
allow sysadm_t cupsd_config_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 216

#line 216
} else {
#line 216
 
#line 216

#line 216

#line 216
#
#line 216
# Allow the process to transition to the new domain.
#line 216
#
#line 216
allow initrc_t cupsd_config_t:process transition;
#line 216

#line 216
#
#line 216
# Do not audit when glibc secure mode is enabled upon the transition.
#line 216
#
#line 216
dontaudit initrc_t cupsd_config_t:process noatsecure;
#line 216

#line 216
#
#line 216
# Do not audit when signal-related state is cleared upon the transition.
#line 216
#
#line 216
dontaudit initrc_t cupsd_config_t:process siginh;
#line 216

#line 216
#
#line 216
# Do not audit when resource limits are reset upon the transition.
#line 216
#
#line 216
dontaudit initrc_t cupsd_config_t:process rlimitinh;
#line 216

#line 216
#
#line 216
# Allow the process to execute the program.
#line 216
# 
#line 216
allow initrc_t cupsd_config_exec_t:file { read { getattr execute } };
#line 216

#line 216
#
#line 216
# Allow the process to reap the new domain.
#line 216
#
#line 216
allow cupsd_config_t initrc_t:process sigchld;
#line 216

#line 216
#
#line 216
# Allow the new domain to inherit and use file 
#line 216
# descriptions from the creating process and vice versa.
#line 216
#
#line 216
allow cupsd_config_t initrc_t:fd use;
#line 216
allow initrc_t cupsd_config_t:fd use;
#line 216

#line 216
#
#line 216
# Allow the new domain to write back to the old domain via a pipe.
#line 216
#
#line 216
allow cupsd_config_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 216

#line 216
#
#line 216
# Allow the new domain to read and execute the program.
#line 216
#
#line 216
allow cupsd_config_t cupsd_config_exec_t:file { read getattr lock execute ioctl };
#line 216

#line 216
#
#line 216
# Allow the new domain to be entered via the program.
#line 216
#
#line 216
allow cupsd_config_t cupsd_config_exec_t:file entrypoint;
#line 216

#line 216
type_transition initrc_t cupsd_config_exec_t:process cupsd_config_t;
#line 216

#line 216

#line 216
allow initrc_t cupsd_config_t:process { noatsecure siginh rlimitinh };
#line 216

#line 216
}
#line 216
 
#line 216
allow cupsd_config_t privfd:fd use;
#line 216

#line 216
allow cupsd_config_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 216

#line 216

#line 216
# Create pid file.
#line 216
allow cupsd_config_t var_t:dir { getattr search };
#line 216

#line 216
type cupsd_config_var_run_t, file_type, sysadmfile, pidfile;
#line 216

#line 216

#line 216

#line 216

#line 216

#line 216

#line 216
#
#line 216
# Allow the process to modify the directory.
#line 216
#
#line 216
allow cupsd_config_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 216

#line 216
#
#line 216
# Allow the process to create the file.
#line 216
#
#line 216

#line 216

#line 216

#line 216

#line 216

#line 216
allow cupsd_config_t cupsd_config_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 216

#line 216

#line 216

#line 216

#line 216

#line 216

#line 216

#line 216

#line 216

#line 216
type_transition cupsd_config_t var_run_t:file cupsd_config_var_run_t;
#line 216

#line 216

#line 216

#line 216
allow cupsd_config_t var_t:dir search;
#line 216
allow cupsd_config_t cupsd_config_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 216

#line 216

#line 216
allow cupsd_config_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 216

#line 216
# for daemons that look at /root on startup
#line 216
dontaudit cupsd_config_t sysadm_home_dir_t:dir search;
#line 216

#line 216
# for df
#line 216
allow cupsd_config_t fs_type:filesystem getattr;
#line 216
allow cupsd_config_t removable_t:filesystem getattr;
#line 216

#line 216

#line 216
allow cupsd_config_t etc_t:lnk_file read;
#line 216
allow cupsd_config_t lib_t:file { read getattr lock ioctl };
#line 216

#line 216
allow cupsd_config_t locale_t:dir { read getattr lock search ioctl };
#line 216
allow cupsd_config_t locale_t:file { read getattr lock ioctl };
#line 216
allow cupsd_config_t locale_t:lnk_file { getattr read };
#line 216

#line 216

#line 216

#line 216
# for localization
#line 216
allow cupsd_config_t lib_t:file { getattr read };
#line 216


allow cupsd_config_t devpts_t:dir search;
allow cupsd_config_t devpts_t:chr_file { getattr ioctl };

#line 227

#line 227

#line 227
allow cupsd_config_t rpm_var_lib_t:dir { getattr search };
#line 227
allow cupsd_config_t rpm_var_lib_t:file { getattr read };
#line 227

#line 227
allow cupsd_config_t initrc_exec_t:file getattr;

allow cupsd_config_t { etc_t etc_runtime_t net_conf_t }:file { getattr read };
allow cupsd_config_t self:file { getattr read };

allow cupsd_config_t proc_t:file { getattr read };
allow cupsd_config_t cupsd_var_run_t:file { getattr read };
allow cupsd_config_t cupsd_t:process { signal };
allow cupsd_config_t cupsd_t:{ file lnk_file } { getattr read };

#line 236
allow cupsd_config_t cupsd_t:dir { search getattr read };
#line 236
allow cupsd_config_t cupsd_t:{ file lnk_file } { read getattr };
#line 236
allow cupsd_config_t cupsd_t:process getattr;
#line 236
# We need to suppress this denial because procps tries to access
#line 236
# /proc/pid/environ and this now triggers a ptrace check in recent kernels
#line 236
# (2.4 and 2.6).  Might want to change procps to not do this, or only if
#line 236
# running in a privileged domain.
#line 236
dontaudit cupsd_config_t cupsd_t:process ptrace;
#line 236


allow cupsd_config_t self:capability { chown sys_tty_config };


#line 240
allow cupsd_config_t cupsd_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 240
allow cupsd_config_t cupsd_etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 240
allow cupsd_config_t cupsd_etc_t:lnk_file { create read getattr setattr link unlink rename };
#line 240


#line 241
allow cupsd_config_t cupsd_rw_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 241
allow cupsd_config_t cupsd_rw_etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 241
allow cupsd_config_t cupsd_rw_etc_t:lnk_file { create read getattr setattr link unlink rename };
#line 241


#line 242

#line 242

#line 242

#line 242
#
#line 242
# Allow the process to modify the directory.
#line 242
#
#line 242
allow cupsd_config_t cupsd_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 242

#line 242
#
#line 242
# Allow the process to create the file.
#line 242
#
#line 242

#line 242

#line 242

#line 242

#line 242

#line 242
allow cupsd_config_t cupsd_rw_etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 242

#line 242

#line 242

#line 242

#line 242

#line 242

#line 242

#line 242

#line 242

#line 242
type_transition cupsd_config_t cupsd_etc_t:file cupsd_rw_etc_t;
#line 242

#line 242


#line 243

#line 243

#line 243

#line 243
#
#line 243
# Allow the process to modify the directory.
#line 243
#
#line 243
allow cupsd_config_t var_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 243

#line 243
#
#line 243
# Allow the process to create the file.
#line 243
#
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
allow cupsd_config_t cupsd_rw_etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
type_transition cupsd_config_t var_t:file cupsd_rw_etc_t;
#line 243

#line 243

allow cupsd_config_t var_t:lnk_file read;


#line 246

#line 246

#line 246

#line 246
#
#line 246
# Allow the domain to create and use tcp sockets.
#line 246
# Other kinds of sockets must be separately authorized for use.
#line 246
allow cupsd_config_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 246

#line 246
allow cupsd_config_t unlabeled_t:association { sendto recvfrom };
#line 246

#line 246
#
#line 246
# Allow the domain to send or receive using any network interface.
#line 246
# netif_type is a type attribute for all network interface types.
#line 246
#
#line 246
allow cupsd_config_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 246
#
#line 246
# Allow the domain to send to or receive from any node.
#line 246
# node_type is a type attribute for all node types.
#line 246
#
#line 246
allow cupsd_config_t node_type:node { tcp_send rawip_send };
#line 246
allow cupsd_config_t node_type:node { tcp_recv rawip_recv };
#line 246

#line 246
#
#line 246
# Allow the domain to send to or receive from any port.
#line 246
# port_type is a type attribute for all port types.
#line 246
#
#line 246

#line 246
allow cupsd_config_t port_type:tcp_socket { send_msg recv_msg };
#line 246

#line 246

#line 246
# XXX Allow binding to any node type.  Remove once
#line 246
# individual rules have been added to all domains that 
#line 246
# bind sockets. 
#line 246
allow cupsd_config_t node_type:tcp_socket node_bind;
#line 246
#
#line 246
# Allow access to network files including /etc/resolv.conf
#line 246
#
#line 246
allow cupsd_config_t net_conf_t:file { read getattr lock ioctl };
#line 246

#line 246
allow cupsd_config_t self:tcp_socket { listen accept };
#line 246

#line 246

#line 246

#line 246
#
#line 246
# Allow the domain to create and use tcp sockets.
#line 246
# Other kinds of sockets must be separately authorized for use.
#line 246
allow cupsd_config_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 246

#line 246
allow cupsd_config_t unlabeled_t:association { sendto recvfrom };
#line 246

#line 246
#
#line 246
# Allow the domain to send or receive using any network interface.
#line 246
# netif_type is a type attribute for all network interface types.
#line 246
#
#line 246
allow cupsd_config_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 246
#
#line 246
# Allow the domain to send to or receive from any node.
#line 246
# node_type is a type attribute for all node types.
#line 246
#
#line 246
allow cupsd_config_t node_type:node { tcp_send rawip_send };
#line 246
allow cupsd_config_t node_type:node { tcp_recv rawip_recv };
#line 246

#line 246
#
#line 246
# Allow the domain to send to or receive from any port.
#line 246
# port_type is a type attribute for all port types.
#line 246
#
#line 246

#line 246
allow cupsd_config_t port_type:tcp_socket { send_msg recv_msg };
#line 246

#line 246

#line 246
# XXX Allow binding to any node type.  Remove once
#line 246
# individual rules have been added to all domains that 
#line 246
# bind sockets. 
#line 246
allow cupsd_config_t node_type:tcp_socket node_bind;
#line 246
#
#line 246
# Allow access to network files including /etc/resolv.conf
#line 246
#
#line 246
allow cupsd_config_t net_conf_t:file { read getattr lock ioctl };
#line 246

#line 246
allow cupsd_config_t self:tcp_socket { connect };
#line 246

#line 246

#line 246


#line 247

#line 247
if (allow_ypbind) {
#line 247

#line 247

#line 247

#line 247

#line 247

#line 247

#line 247

#line 247
#
#line 247
# Allow the domain to create and use tcp sockets.
#line 247
# Other kinds of sockets must be separately authorized for use.
#line 247
allow cupsd_config_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 247

#line 247
allow cupsd_config_t unlabeled_t:association { sendto recvfrom };
#line 247

#line 247
#
#line 247
# Allow the domain to send or receive using any network interface.
#line 247
# netif_type is a type attribute for all network interface types.
#line 247
#
#line 247
allow cupsd_config_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 247
#
#line 247
# Allow the domain to send to or receive from any node.
#line 247
# node_type is a type attribute for all node types.
#line 247
#
#line 247
allow cupsd_config_t node_type:node { tcp_send rawip_send };
#line 247
allow cupsd_config_t node_type:node { tcp_recv rawip_recv };
#line 247

#line 247
#
#line 247
# Allow the domain to send to or receive from any port.
#line 247
# port_type is a type attribute for all port types.
#line 247
#
#line 247

#line 247
allow cupsd_config_t port_type:tcp_socket { send_msg recv_msg };
#line 247

#line 247

#line 247
# XXX Allow binding to any node type.  Remove once
#line 247
# individual rules have been added to all domains that 
#line 247
# bind sockets. 
#line 247
allow cupsd_config_t node_type:tcp_socket node_bind;
#line 247
#
#line 247
# Allow access to network files including /etc/resolv.conf
#line 247
#
#line 247
allow cupsd_config_t net_conf_t:file { read getattr lock ioctl };
#line 247

#line 247
allow cupsd_config_t self:tcp_socket { listen accept };
#line 247

#line 247

#line 247

#line 247
#
#line 247
# Allow the domain to create and use tcp sockets.
#line 247
# Other kinds of sockets must be separately authorized for use.
#line 247
allow cupsd_config_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 247

#line 247
allow cupsd_config_t unlabeled_t:association { sendto recvfrom };
#line 247

#line 247
#
#line 247
# Allow the domain to send or receive using any network interface.
#line 247
# netif_type is a type attribute for all network interface types.
#line 247
#
#line 247
allow cupsd_config_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 247
#
#line 247
# Allow the domain to send to or receive from any node.
#line 247
# node_type is a type attribute for all node types.
#line 247
#
#line 247
allow cupsd_config_t node_type:node { tcp_send rawip_send };
#line 247
allow cupsd_config_t node_type:node { tcp_recv rawip_recv };
#line 247

#line 247
#
#line 247
# Allow the domain to send to or receive from any port.
#line 247
# port_type is a type attribute for all port types.
#line 247
#
#line 247

#line 247
allow cupsd_config_t port_type:tcp_socket { send_msg recv_msg };
#line 247

#line 247

#line 247
# XXX Allow binding to any node type.  Remove once
#line 247
# individual rules have been added to all domains that 
#line 247
# bind sockets. 
#line 247
allow cupsd_config_t node_type:tcp_socket node_bind;
#line 247
#
#line 247
# Allow access to network files including /etc/resolv.conf
#line 247
#
#line 247
allow cupsd_config_t net_conf_t:file { read getattr lock ioctl };
#line 247

#line 247
allow cupsd_config_t self:tcp_socket { connect };
#line 247

#line 247

#line 247

#line 247

#line 247

#line 247
#
#line 247
# Allow the domain to create and use udp sockets.
#line 247
# Other kinds of sockets must be separately authorized for use.
#line 247
allow cupsd_config_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 247

#line 247
allow cupsd_config_t unlabeled_t:association { sendto recvfrom };
#line 247

#line 247
#
#line 247
# Allow the domain to send or receive using any network interface.
#line 247
# netif_type is a type attribute for all network interface types.
#line 247
#
#line 247
allow cupsd_config_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 247
#
#line 247
# Allow the domain to send to or receive from any node.
#line 247
# node_type is a type attribute for all node types.
#line 247
#
#line 247
allow cupsd_config_t node_type:node { udp_send rawip_send };
#line 247
allow cupsd_config_t node_type:node { udp_recv rawip_recv };
#line 247

#line 247
#
#line 247
# Allow the domain to send to or receive from any port.
#line 247
# port_type is a type attribute for all port types.
#line 247
#
#line 247

#line 247
allow cupsd_config_t port_type:udp_socket { send_msg recv_msg };
#line 247

#line 247

#line 247
# XXX Allow binding to any node type.  Remove once
#line 247
# individual rules have been added to all domains that 
#line 247
# bind sockets. 
#line 247
allow cupsd_config_t node_type:udp_socket node_bind;
#line 247
#
#line 247
# Allow access to network files including /etc/resolv.conf
#line 247
#
#line 247
allow cupsd_config_t net_conf_t:file { read getattr lock ioctl };
#line 247

#line 247
allow cupsd_config_t self:udp_socket { connect };
#line 247

#line 247

#line 247

#line 247

#line 247

#line 247

#line 247
allow cupsd_config_t var_yp_t:dir { read getattr lock search ioctl };
#line 247
allow cupsd_config_t var_yp_t:file { read getattr lock ioctl };
#line 247
allow cupsd_config_t var_yp_t:lnk_file { getattr read };
#line 247

#line 247
allow cupsd_config_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 247
allow cupsd_config_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 247
dontaudit cupsd_config_t self:capability net_bind_service;
#line 247
dontaudit cupsd_config_t reserved_port_type:tcp_socket name_connect;
#line 247
dontaudit cupsd_config_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 247

#line 247
} else {
#line 247
dontaudit cupsd_config_t var_yp_t:dir search;
#line 247
}
#line 247
 
allow cupsd_config_t port_type:tcp_socket name_connect;

#line 249
#allow cupsd_config_t cupsd_t:tcp_socket { connectto recvfrom };
#line 249
#allow cupsd_t cupsd_config_t:tcp_socket { acceptfrom recvfrom };
#line 249
#allow cupsd_t kernel_t:tcp_socket recvfrom;
#line 249
#allow cupsd_config_t kernel_t:tcp_socket recvfrom;
#line 249

allow cupsd_config_t self:fifo_file { ioctl read getattr lock write append };

allow cupsd_config_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow cupsd_config_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 259

#line 259

#line 259

#line 259

#line 259
# Derived type used for connection
#line 259
type cupsd_config_dbusd_system_t;
#line 259
type_change cupsd_config_t system_dbusd_t:dbus cupsd_config_dbusd_system_t;
#line 259

#line 259
# SE-DBus specific permissions
#line 259
allow cupsd_config_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 259

#line 259
# For connecting to the bus
#line 259
allow cupsd_config_t system_dbusd_t:unix_stream_socket connectto;
#line 259

#line 259

#line 259
allow { cupsd_config_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 259
allow { cupsd_config_t } system_dbusd_var_run_t:sock_file write;
#line 259
  
#line 259
allow cupsd_config_t userdomain:dbus send_msg;
#line 259
allow cupsd_config_t system_dbusd_t:dbus { send_msg acquire_svc };
#line 259
allow userdomain cupsd_config_t:dbus send_msg;

#line 271

#line 271

#line 271

#line 271
allow { cupsd_t cupsd_config_t } hald_t:dbus send_msg;
#line 271
allow hald_t { cupsd_t cupsd_config_t }:dbus send_msg;
#line 271

#line 271
allow hald_t cupsd_config_t:process signal;
#line 271

#line 271

#line 271

#line 271
#
#line 271
# Allow the process to transition to the new domain.
#line 271
#
#line 271
allow hald_t cupsd_config_t:process transition;
#line 271

#line 271
#
#line 271
# Do not audit when glibc secure mode is enabled upon the transition.
#line 271
#
#line 271
dontaudit hald_t cupsd_config_t:process noatsecure;
#line 271

#line 271
#
#line 271
# Do not audit when signal-related state is cleared upon the transition.
#line 271
#
#line 271
dontaudit hald_t cupsd_config_t:process siginh;
#line 271

#line 271
#
#line 271
# Do not audit when resource limits are reset upon the transition.
#line 271
#
#line 271
dontaudit hald_t cupsd_config_t:process rlimitinh;
#line 271

#line 271
#
#line 271
# Allow the process to execute the program.
#line 271
# 
#line 271
allow hald_t cupsd_config_exec_t:file { read { getattr execute } };
#line 271

#line 271
#
#line 271
# Allow the process to reap the new domain.
#line 271
#
#line 271
allow cupsd_config_t hald_t:process sigchld;
#line 271

#line 271
#
#line 271
# Allow the new domain to inherit and use file 
#line 271
# descriptions from the creating process and vice versa.
#line 271
#
#line 271
allow cupsd_config_t hald_t:fd use;
#line 271
allow hald_t cupsd_config_t:fd use;
#line 271

#line 271
#
#line 271
# Allow the new domain to write back to the old domain via a pipe.
#line 271
#
#line 271
allow cupsd_config_t hald_t:fifo_file { ioctl read getattr lock write append };
#line 271

#line 271
#
#line 271
# Allow the new domain to read and execute the program.
#line 271
#
#line 271
allow cupsd_config_t cupsd_config_exec_t:file { read getattr lock execute ioctl };
#line 271

#line 271
#
#line 271
# Allow the new domain to be entered via the program.
#line 271
#
#line 271
allow cupsd_config_t cupsd_config_exec_t:file entrypoint;
#line 271

#line 271
type_transition hald_t cupsd_config_exec_t:process cupsd_config_t;
#line 271

#line 271

#line 271
 
#line 273


#line 274
allow cupsd_config_t { bin_t sbin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 274

#line 278

#line 278

#line 278
allow cupsd_t hostname_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 278

#line 278

#line 278
allow cupsd_config_t hostname_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 278

#line 278

allow cupsd_config_t { bin_t sbin_t }:dir { search getattr };
allow cupsd_config_t { bin_t sbin_t }:lnk_file read;
# killall causes the following
dontaudit cupsd_config_t domain:dir { getattr search };
dontaudit cupsd_config_t selinux_config_t:dir search;


#line 285
allow cupsd_config_t cupsd_config_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 285
 

allow cupsd_config_t usr_t:file { getattr read };
allow cupsd_config_t var_lib_t:dir { getattr search };
allow cupsd_config_t rpm_var_lib_t:file { getattr read };
allow cupsd_config_t printconf_t:file { getattr read };

allow cupsd_config_t urandom_device_t:chr_file { getattr read };

#line 297
allow cupsd_config_t system_crond_t:fd use;
allow cupsd_config_t crond_t:fifo_file { read getattr lock ioctl };
allow cupsd_t crond_t:fifo_file read;
allow cupsd_t crond_t:fd use;

# Alternatives asks for this
allow cupsd_config_t initrc_exec_t:file getattr;
#line 311

#line 311

#line 311
allow cupsd_t initrc_t:unix_stream_socket connectto;
#line 311

#line 311
allow cupsd_t initrc_t:dbus send_msg;
#line 311
allow initrc_t cupsd_t:dbus send_msg;
#line 311
allow { cupsd_config_t cupsd_t } unconfined_t:dbus send_msg;
#line 311
allow unconfined_t cupsd_config_t:dbus send_msg;
#line 311
allow { cupsd_t cupsd_config_t } unconfined_t:fifo_file { read getattr lock ioctl };
#line 311

typealias printer_port_t alias cupsd_lpd_port_t;

#line 313
type cupsd_lpd_t, domain, privlog, nscd_client_domain;
#line 313
role system_r types cupsd_lpd_t;
#line 313

#line 313
#
#line 313
# Allows user to define a tunable to disable domain transition
#line 313
#
#line 313
bool cupsd_lpd_disable_trans false;
#line 313
if (cupsd_lpd_disable_trans) {
#line 313

#line 313
allow initrc_t cupsd_lpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 313

#line 313

#line 313
allow sysadm_t cupsd_lpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 313

#line 313
} else {
#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the process to transition to the new domain.
#line 313
#
#line 313
allow inetd_t cupsd_lpd_t:process transition;
#line 313

#line 313
#
#line 313
# Do not audit when glibc secure mode is enabled upon the transition.
#line 313
#
#line 313
dontaudit inetd_t cupsd_lpd_t:process noatsecure;
#line 313

#line 313
#
#line 313
# Do not audit when signal-related state is cleared upon the transition.
#line 313
#
#line 313
dontaudit inetd_t cupsd_lpd_t:process siginh;
#line 313

#line 313
#
#line 313
# Do not audit when resource limits are reset upon the transition.
#line 313
#
#line 313
dontaudit inetd_t cupsd_lpd_t:process rlimitinh;
#line 313

#line 313
#
#line 313
# Allow the process to execute the program.
#line 313
# 
#line 313
allow inetd_t cupsd_lpd_exec_t:file { read { getattr execute } };
#line 313

#line 313
#
#line 313
# Allow the process to reap the new domain.
#line 313
#
#line 313
allow cupsd_lpd_t inetd_t:process sigchld;
#line 313

#line 313
#
#line 313
# Allow the new domain to inherit and use file 
#line 313
# descriptions from the creating process and vice versa.
#line 313
#
#line 313
allow cupsd_lpd_t inetd_t:fd use;
#line 313
allow inetd_t cupsd_lpd_t:fd use;
#line 313

#line 313
#
#line 313
# Allow the new domain to write back to the old domain via a pipe.
#line 313
#
#line 313
allow cupsd_lpd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 313

#line 313
#
#line 313
# Allow the new domain to read and execute the program.
#line 313
#
#line 313
allow cupsd_lpd_t cupsd_lpd_exec_t:file { read getattr lock execute ioctl };
#line 313

#line 313
#
#line 313
# Allow the new domain to be entered via the program.
#line 313
#
#line 313
allow cupsd_lpd_t cupsd_lpd_exec_t:file entrypoint;
#line 313

#line 313
type_transition inetd_t cupsd_lpd_exec_t:process cupsd_lpd_t;
#line 313

#line 313
allow inetd_t cupsd_lpd_t:process sigkill;
#line 313
}
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the domain to create and use tcp sockets.
#line 313
# Other kinds of sockets must be separately authorized for use.
#line 313
allow cupsd_lpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 313

#line 313
allow cupsd_lpd_t unlabeled_t:association { sendto recvfrom };
#line 313

#line 313
#
#line 313
# Allow the domain to send or receive using any network interface.
#line 313
# netif_type is a type attribute for all network interface types.
#line 313
#
#line 313
allow cupsd_lpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 313
#
#line 313
# Allow the domain to send to or receive from any node.
#line 313
# node_type is a type attribute for all node types.
#line 313
#
#line 313
allow cupsd_lpd_t node_type:node { tcp_send rawip_send };
#line 313
allow cupsd_lpd_t node_type:node { tcp_recv rawip_recv };
#line 313

#line 313
#
#line 313
# Allow the domain to send to or receive from any port.
#line 313
# port_type is a type attribute for all port types.
#line 313
#
#line 313

#line 313
allow cupsd_lpd_t port_type:tcp_socket { send_msg recv_msg };
#line 313

#line 313

#line 313
# XXX Allow binding to any node type.  Remove once
#line 313
# individual rules have been added to all domains that 
#line 313
# bind sockets. 
#line 313
allow cupsd_lpd_t node_type:tcp_socket node_bind;
#line 313
#
#line 313
# Allow access to network files including /etc/resolv.conf
#line 313
#
#line 313
allow cupsd_lpd_t net_conf_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t self:tcp_socket { listen accept };
#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the domain to create and use udp sockets.
#line 313
# Other kinds of sockets must be separately authorized for use.
#line 313
allow cupsd_lpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 313

#line 313
allow cupsd_lpd_t unlabeled_t:association { sendto recvfrom };
#line 313

#line 313
#
#line 313
# Allow the domain to send or receive using any network interface.
#line 313
# netif_type is a type attribute for all network interface types.
#line 313
#
#line 313
allow cupsd_lpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 313
#
#line 313
# Allow the domain to send to or receive from any node.
#line 313
# node_type is a type attribute for all node types.
#line 313
#
#line 313
allow cupsd_lpd_t node_type:node { udp_send rawip_send };
#line 313
allow cupsd_lpd_t node_type:node { udp_recv rawip_recv };
#line 313

#line 313
#
#line 313
# Allow the domain to send to or receive from any port.
#line 313
# port_type is a type attribute for all port types.
#line 313
#
#line 313

#line 313
allow cupsd_lpd_t port_type:udp_socket { send_msg recv_msg };
#line 313

#line 313

#line 313
# XXX Allow binding to any node type.  Remove once
#line 313
# individual rules have been added to all domains that 
#line 313
# bind sockets. 
#line 313
allow cupsd_lpd_t node_type:udp_socket node_bind;
#line 313
#
#line 313
# Allow access to network files including /etc/resolv.conf
#line 313
#
#line 313
allow cupsd_lpd_t net_conf_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t self:udp_socket { connect };
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
if (allow_ypbind) {
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the domain to create and use tcp sockets.
#line 313
# Other kinds of sockets must be separately authorized for use.
#line 313
allow cupsd_lpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 313

#line 313
allow cupsd_lpd_t unlabeled_t:association { sendto recvfrom };
#line 313

#line 313
#
#line 313
# Allow the domain to send or receive using any network interface.
#line 313
# netif_type is a type attribute for all network interface types.
#line 313
#
#line 313
allow cupsd_lpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 313
#
#line 313
# Allow the domain to send to or receive from any node.
#line 313
# node_type is a type attribute for all node types.
#line 313
#
#line 313
allow cupsd_lpd_t node_type:node { tcp_send rawip_send };
#line 313
allow cupsd_lpd_t node_type:node { tcp_recv rawip_recv };
#line 313

#line 313
#
#line 313
# Allow the domain to send to or receive from any port.
#line 313
# port_type is a type attribute for all port types.
#line 313
#
#line 313

#line 313
allow cupsd_lpd_t port_type:tcp_socket { send_msg recv_msg };
#line 313

#line 313

#line 313
# XXX Allow binding to any node type.  Remove once
#line 313
# individual rules have been added to all domains that 
#line 313
# bind sockets. 
#line 313
allow cupsd_lpd_t node_type:tcp_socket node_bind;
#line 313
#
#line 313
# Allow access to network files including /etc/resolv.conf
#line 313
#
#line 313
allow cupsd_lpd_t net_conf_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t self:tcp_socket { listen accept };
#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the domain to create and use tcp sockets.
#line 313
# Other kinds of sockets must be separately authorized for use.
#line 313
allow cupsd_lpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 313

#line 313
allow cupsd_lpd_t unlabeled_t:association { sendto recvfrom };
#line 313

#line 313
#
#line 313
# Allow the domain to send or receive using any network interface.
#line 313
# netif_type is a type attribute for all network interface types.
#line 313
#
#line 313
allow cupsd_lpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 313
#
#line 313
# Allow the domain to send to or receive from any node.
#line 313
# node_type is a type attribute for all node types.
#line 313
#
#line 313
allow cupsd_lpd_t node_type:node { tcp_send rawip_send };
#line 313
allow cupsd_lpd_t node_type:node { tcp_recv rawip_recv };
#line 313

#line 313
#
#line 313
# Allow the domain to send to or receive from any port.
#line 313
# port_type is a type attribute for all port types.
#line 313
#
#line 313

#line 313
allow cupsd_lpd_t port_type:tcp_socket { send_msg recv_msg };
#line 313

#line 313

#line 313
# XXX Allow binding to any node type.  Remove once
#line 313
# individual rules have been added to all domains that 
#line 313
# bind sockets. 
#line 313
allow cupsd_lpd_t node_type:tcp_socket node_bind;
#line 313
#
#line 313
# Allow access to network files including /etc/resolv.conf
#line 313
#
#line 313
allow cupsd_lpd_t net_conf_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t self:tcp_socket { connect };
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the domain to create and use udp sockets.
#line 313
# Other kinds of sockets must be separately authorized for use.
#line 313
allow cupsd_lpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 313

#line 313
allow cupsd_lpd_t unlabeled_t:association { sendto recvfrom };
#line 313

#line 313
#
#line 313
# Allow the domain to send or receive using any network interface.
#line 313
# netif_type is a type attribute for all network interface types.
#line 313
#
#line 313
allow cupsd_lpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 313
#
#line 313
# Allow the domain to send to or receive from any node.
#line 313
# node_type is a type attribute for all node types.
#line 313
#
#line 313
allow cupsd_lpd_t node_type:node { udp_send rawip_send };
#line 313
allow cupsd_lpd_t node_type:node { udp_recv rawip_recv };
#line 313

#line 313
#
#line 313
# Allow the domain to send to or receive from any port.
#line 313
# port_type is a type attribute for all port types.
#line 313
#
#line 313

#line 313
allow cupsd_lpd_t port_type:udp_socket { send_msg recv_msg };
#line 313

#line 313

#line 313
# XXX Allow binding to any node type.  Remove once
#line 313
# individual rules have been added to all domains that 
#line 313
# bind sockets. 
#line 313
allow cupsd_lpd_t node_type:udp_socket node_bind;
#line 313
#
#line 313
# Allow access to network files including /etc/resolv.conf
#line 313
#
#line 313
allow cupsd_lpd_t net_conf_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t self:udp_socket { connect };
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t var_yp_t:dir { read getattr lock search ioctl };
#line 313
allow cupsd_lpd_t var_yp_t:file { read getattr lock ioctl };
#line 313
allow cupsd_lpd_t var_yp_t:lnk_file { getattr read };
#line 313

#line 313
allow cupsd_lpd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 313
allow cupsd_lpd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 313
dontaudit cupsd_lpd_t self:capability net_bind_service;
#line 313
dontaudit cupsd_lpd_t reserved_port_type:tcp_socket name_connect;
#line 313
dontaudit cupsd_lpd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 313

#line 313
} else {
#line 313
dontaudit cupsd_lpd_t var_yp_t:dir search;
#line 313
}
#line 313
 
#line 313

#line 313
allow cupsd_lpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 313
allow cupsd_lpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 313
allow cupsd_lpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 313
#allow cupsd_lpd_t ld_so_t:file execute_no_trans;
#line 313
allow cupsd_lpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 313
allow cupsd_lpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 313
allow cupsd_lpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 313
allow cupsd_lpd_t texrel_shlib_t:file execmod;
#line 313
allow cupsd_lpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 313
allow cupsd_lpd_t device_t:dir search;
#line 313
allow cupsd_lpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 313

#line 313
allow cupsd_lpd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 313
allow cupsd_lpd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 313
allow cupsd_lpd_t self:fifo_file { ioctl read getattr lock write append };
#line 313
type cupsd_lpd_exec_t, file_type, sysadmfile, exec_type;
#line 313

#line 313
allow cupsd_lpd_t etc_t:lnk_file read;
#line 313
allow cupsd_lpd_t lib_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t locale_t:dir { read getattr lock search ioctl };
#line 313
allow cupsd_lpd_t locale_t:file { read getattr lock ioctl };
#line 313
allow cupsd_lpd_t locale_t:lnk_file { getattr read };
#line 313

#line 313

#line 313
allow cupsd_lpd_t device_t:dir search;
#line 313
allow cupsd_lpd_t proc_t:dir search;
#line 313
allow cupsd_lpd_t proc_t:{ file lnk_file } { getattr read };
#line 313
allow cupsd_lpd_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 313
allow cupsd_lpd_t fs_t:filesystem getattr;
#line 313

#line 313

#line 313
# Read system variables in /sys.
#line 313

#line 313
allow cupsd_lpd_t sysctl_t:dir search;
#line 313
allow cupsd_lpd_t sysctl_kernel_t:dir search;
#line 313
allow cupsd_lpd_t sysctl_kernel_t:file { getattr read };
#line 313

#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t etc_t:file { getattr read };
#line 313

#line 313

#line 313
type cupsd_lpd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 313

#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the process to modify the directory.
#line 313
#
#line 313
allow cupsd_lpd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 313

#line 313
#
#line 313
# Allow the process to create the file.
#line 313
#
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t cupsd_lpd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t cupsd_lpd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
type_transition cupsd_lpd_t tmp_t:{ file dir } cupsd_lpd_tmp_t;
#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t var_t:dir search;
#line 313

#line 313
type cupsd_lpd_var_run_t, file_type, sysadmfile, pidfile;
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the process to modify the directory.
#line 313
#
#line 313
allow cupsd_lpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 313

#line 313
#
#line 313
# Allow the process to create the file.
#line 313
#
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t cupsd_lpd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
type_transition cupsd_lpd_t var_run_t:file cupsd_lpd_var_run_t;
#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t var_t:dir search;
#line 313
allow cupsd_lpd_t cupsd_lpd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 313

#line 313

#line 313
# Inherit and use descriptors from inetd.
#line 313
allow cupsd_lpd_t inetd_t:fd use;
#line 313

#line 313
# for identd
#line 313
allow cupsd_lpd_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 313
allow cupsd_lpd_t self:capability { setuid setgid };
#line 313
allow cupsd_lpd_t home_root_t:dir search;
#line 313
allow cupsd_lpd_t self:dir search;
#line 313
allow cupsd_lpd_t self:{ lnk_file file } { getattr read };
#line 313

#line 313

#line 313
if (allow_kerberos) {
#line 313

#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the domain to create and use tcp sockets.
#line 313
# Other kinds of sockets must be separately authorized for use.
#line 313
allow cupsd_lpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 313

#line 313
allow cupsd_lpd_t unlabeled_t:association { sendto recvfrom };
#line 313

#line 313
#
#line 313
# Allow the domain to send or receive using any network interface.
#line 313
# netif_type is a type attribute for all network interface types.
#line 313
#
#line 313
allow cupsd_lpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 313
#
#line 313
# Allow the domain to send to or receive from any node.
#line 313
# node_type is a type attribute for all node types.
#line 313
#
#line 313
allow cupsd_lpd_t node_type:node { tcp_send rawip_send };
#line 313
allow cupsd_lpd_t node_type:node { tcp_recv rawip_recv };
#line 313

#line 313
#
#line 313
# Allow the domain to send to or receive from any port.
#line 313
# port_type is a type attribute for all port types.
#line 313
#
#line 313

#line 313
allow cupsd_lpd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 313

#line 313

#line 313
# XXX Allow binding to any node type.  Remove once
#line 313
# individual rules have been added to all domains that 
#line 313
# bind sockets. 
#line 313
allow cupsd_lpd_t node_type:tcp_socket node_bind;
#line 313
#
#line 313
# Allow access to network files including /etc/resolv.conf
#line 313
#
#line 313
allow cupsd_lpd_t net_conf_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t self:tcp_socket { connect };
#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the domain to create and use udp sockets.
#line 313
# Other kinds of sockets must be separately authorized for use.
#line 313
allow cupsd_lpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 313

#line 313
allow cupsd_lpd_t unlabeled_t:association { sendto recvfrom };
#line 313

#line 313
#
#line 313
# Allow the domain to send or receive using any network interface.
#line 313
# netif_type is a type attribute for all network interface types.
#line 313
#
#line 313
allow cupsd_lpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 313
#
#line 313
# Allow the domain to send to or receive from any node.
#line 313
# node_type is a type attribute for all node types.
#line 313
#
#line 313
allow cupsd_lpd_t node_type:node { udp_send rawip_send };
#line 313
allow cupsd_lpd_t node_type:node { udp_recv rawip_recv };
#line 313

#line 313
#
#line 313
# Allow the domain to send to or receive from any port.
#line 313
# port_type is a type attribute for all port types.
#line 313
#
#line 313

#line 313
allow cupsd_lpd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 313

#line 313

#line 313
# XXX Allow binding to any node type.  Remove once
#line 313
# individual rules have been added to all domains that 
#line 313
# bind sockets. 
#line 313
allow cupsd_lpd_t node_type:udp_socket node_bind;
#line 313
#
#line 313
# Allow access to network files including /etc/resolv.conf
#line 313
#
#line 313
allow cupsd_lpd_t net_conf_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t self:udp_socket { connect };
#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t kerberos_port_t:tcp_socket name_connect;
#line 313

#line 313

#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the domain to create and use tcp sockets.
#line 313
# Other kinds of sockets must be separately authorized for use.
#line 313
allow cupsd_lpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 313

#line 313
allow cupsd_lpd_t unlabeled_t:association { sendto recvfrom };
#line 313

#line 313
#
#line 313
# Allow the domain to send or receive using any network interface.
#line 313
# netif_type is a type attribute for all network interface types.
#line 313
#
#line 313
allow cupsd_lpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 313
#
#line 313
# Allow the domain to send to or receive from any node.
#line 313
# node_type is a type attribute for all node types.
#line 313
#
#line 313
allow cupsd_lpd_t node_type:node { tcp_send rawip_send };
#line 313
allow cupsd_lpd_t node_type:node { tcp_recv rawip_recv };
#line 313

#line 313
#
#line 313
# Allow the domain to send to or receive from any port.
#line 313
# port_type is a type attribute for all port types.
#line 313
#
#line 313

#line 313
allow cupsd_lpd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 313

#line 313

#line 313
# XXX Allow binding to any node type.  Remove once
#line 313
# individual rules have been added to all domains that 
#line 313
# bind sockets. 
#line 313
allow cupsd_lpd_t node_type:tcp_socket node_bind;
#line 313
#
#line 313
# Allow access to network files including /etc/resolv.conf
#line 313
#
#line 313
allow cupsd_lpd_t net_conf_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t self:tcp_socket { connect };
#line 313

#line 313

#line 313

#line 313
#
#line 313
# Allow the domain to create and use udp sockets.
#line 313
# Other kinds of sockets must be separately authorized for use.
#line 313
allow cupsd_lpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 313

#line 313
allow cupsd_lpd_t unlabeled_t:association { sendto recvfrom };
#line 313

#line 313
#
#line 313
# Allow the domain to send or receive using any network interface.
#line 313
# netif_type is a type attribute for all network interface types.
#line 313
#
#line 313
allow cupsd_lpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 313
#
#line 313
# Allow the domain to send to or receive from any node.
#line 313
# node_type is a type attribute for all node types.
#line 313
#
#line 313
allow cupsd_lpd_t node_type:node { udp_send rawip_send };
#line 313
allow cupsd_lpd_t node_type:node { udp_recv rawip_recv };
#line 313

#line 313
#
#line 313
# Allow the domain to send to or receive from any port.
#line 313
# port_type is a type attribute for all port types.
#line 313
#
#line 313

#line 313
allow cupsd_lpd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 313

#line 313

#line 313
# XXX Allow binding to any node type.  Remove once
#line 313
# individual rules have been added to all domains that 
#line 313
# bind sockets. 
#line 313
allow cupsd_lpd_t node_type:udp_socket node_bind;
#line 313
#
#line 313
# Allow access to network files including /etc/resolv.conf
#line 313
#
#line 313
allow cupsd_lpd_t net_conf_t:file { read getattr lock ioctl };
#line 313

#line 313
allow cupsd_lpd_t self:udp_socket { connect };
#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t dns_port_t:tcp_socket name_connect;
#line 313

#line 313
}
#line 313
 dontaudit cupsd_lpd_t krb5_conf_t:file write;
#line 313
allow cupsd_lpd_t krb5_conf_t:file { getattr read };
#line 313

#line 313
allow cupsd_lpd_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 313
# Use sockets inherited from inetd.
#line 313

#line 313
allow inetd_t cupsd_lpd_port_t:udp_socket name_bind;
#line 313
allow cupsd_lpd_t inetd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
#line 313
allow inetd_t cupsd_lpd_port_t:tcp_socket name_bind;
#line 313
allow cupsd_lpd_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 313

#line 313

#line 313

#line 313

#line 313
allow cupsd_lpd_t proc_net_t:dir { read getattr lock search ioctl };
#line 313
allow cupsd_lpd_t proc_net_t:file { read getattr lock ioctl };
#line 313
allow cupsd_lpd_t proc_net_t:lnk_file { getattr read };
#line 313

#line 313

allow inetd_t printer_port_t:tcp_socket name_bind;

#line 315
allow cupsd_lpd_t cupsd_etc_t:dir { read getattr lock search ioctl };
#line 315
allow cupsd_lpd_t cupsd_etc_t:file { read getattr lock ioctl };
#line 315
allow cupsd_lpd_t cupsd_etc_t:lnk_file { getattr read };
#line 315


#line 316
allow cupsd_lpd_t cupsd_rw_etc_t:dir { read getattr lock search ioctl };
#line 316
allow cupsd_lpd_t cupsd_rw_etc_t:file { read getattr lock ioctl };
#line 316
allow cupsd_lpd_t cupsd_rw_etc_t:lnk_file { getattr read };
#line 316

allow cupsd_lpd_t ipp_port_t:tcp_socket name_connect;
#line 320


#line 1 "domains/program/cvs.te"
#DESC cvs - Concurrent Versions System
#
# Author:  Dan Walsh <dwalsh@redhat.com>
#
# Depends: inetd.te

#################################
#
# Rules for the cvs_t domain.
#
# cvs_exec_t is the type of the cvs executable.
#


#line 14
type cvs_t, domain, privlog, nscd_client_domain;
#line 14
role system_r types cvs_t;
#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14
bool cvs_disable_trans false;
#line 14
if (cvs_disable_trans) {
#line 14

#line 14
allow initrc_t cvs_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t cvs_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow inetd_t cvs_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit inetd_t cvs_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit inetd_t cvs_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit inetd_t cvs_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow inetd_t cvs_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow cvs_t inetd_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow cvs_t inetd_t:fd use;
#line 14
allow inetd_t cvs_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow cvs_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow cvs_t cvs_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow cvs_t cvs_exec_t:file entrypoint;
#line 14

#line 14
type_transition inetd_t cvs_exec_t:process cvs_t;
#line 14

#line 14
allow inetd_t cvs_t:process sigkill;
#line 14
}
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow cvs_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow cvs_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow cvs_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow cvs_t node_type:node { tcp_send rawip_send };
#line 14
allow cvs_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow cvs_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow cvs_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow cvs_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow cvs_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow cvs_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow cvs_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow cvs_t node_type:node { udp_send rawip_send };
#line 14
allow cvs_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow cvs_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow cvs_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow cvs_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
if (allow_ypbind) {
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow cvs_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow cvs_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow cvs_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow cvs_t node_type:node { tcp_send rawip_send };
#line 14
allow cvs_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow cvs_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow cvs_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow cvs_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow cvs_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow cvs_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow cvs_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow cvs_t node_type:node { tcp_send rawip_send };
#line 14
allow cvs_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow cvs_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow cvs_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow cvs_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow cvs_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow cvs_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow cvs_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow cvs_t node_type:node { udp_send rawip_send };
#line 14
allow cvs_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow cvs_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow cvs_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow cvs_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow cvs_t var_yp_t:dir { read getattr lock search ioctl };
#line 14
allow cvs_t var_yp_t:file { read getattr lock ioctl };
#line 14
allow cvs_t var_yp_t:lnk_file { getattr read };
#line 14

#line 14
allow cvs_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 14
allow cvs_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 14
dontaudit cvs_t self:capability net_bind_service;
#line 14
dontaudit cvs_t reserved_port_type:tcp_socket name_connect;
#line 14
dontaudit cvs_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 14

#line 14
} else {
#line 14
dontaudit cvs_t var_yp_t:dir search;
#line 14
}
#line 14
 
#line 14

#line 14
allow cvs_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow cvs_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow cvs_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow cvs_t ld_so_t:file execute_no_trans;
#line 14
allow cvs_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow cvs_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow cvs_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow cvs_t texrel_shlib_t:file execmod;
#line 14
allow cvs_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow cvs_t device_t:dir search;
#line 14
allow cvs_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
allow cvs_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow cvs_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow cvs_t self:fifo_file { ioctl read getattr lock write append };
#line 14
type cvs_exec_t, file_type, sysadmfile, exec_type;
#line 14

#line 14
allow cvs_t etc_t:lnk_file read;
#line 14
allow cvs_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow cvs_t locale_t:file { read getattr lock ioctl };
#line 14
allow cvs_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14
allow cvs_t device_t:dir search;
#line 14
allow cvs_t proc_t:dir search;
#line 14
allow cvs_t proc_t:{ file lnk_file } { getattr read };
#line 14
allow cvs_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 14
allow cvs_t fs_t:filesystem getattr;
#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow cvs_t sysctl_t:dir search;
#line 14
allow cvs_t sysctl_kernel_t:dir search;
#line 14
allow cvs_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14
allow cvs_t etc_t:file { getattr read };
#line 14

#line 14

#line 14
type cvs_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow cvs_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow cvs_t cvs_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow cvs_t cvs_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition cvs_t tmp_t:{ file dir } cvs_tmp_t;
#line 14

#line 14

#line 14

#line 14
allow cvs_t var_t:dir search;
#line 14

#line 14
type cvs_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow cvs_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow cvs_t cvs_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition cvs_t var_run_t:file cvs_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow cvs_t var_t:dir search;
#line 14
allow cvs_t cvs_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
# Inherit and use descriptors from inetd.
#line 14
allow cvs_t inetd_t:fd use;
#line 14

#line 14
# for identd
#line 14
allow cvs_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 14
allow cvs_t self:capability { setuid setgid };
#line 14
allow cvs_t home_root_t:dir search;
#line 14
allow cvs_t self:dir search;
#line 14
allow cvs_t self:{ lnk_file file } { getattr read };
#line 14

#line 14

#line 14
if (allow_kerberos) {
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow cvs_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow cvs_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow cvs_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow cvs_t node_type:node { tcp_send rawip_send };
#line 14
allow cvs_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow cvs_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow cvs_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow cvs_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow cvs_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow cvs_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow cvs_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow cvs_t node_type:node { udp_send rawip_send };
#line 14
allow cvs_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow cvs_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow cvs_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow cvs_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow cvs_t kerberos_port_t:tcp_socket name_connect;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow cvs_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow cvs_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow cvs_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow cvs_t node_type:node { tcp_send rawip_send };
#line 14
allow cvs_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow cvs_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow cvs_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow cvs_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow cvs_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow cvs_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow cvs_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow cvs_t node_type:node { udp_send rawip_send };
#line 14
allow cvs_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow cvs_t dns_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow cvs_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow cvs_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow cvs_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow cvs_t dns_port_t:tcp_socket name_connect;
#line 14

#line 14
}
#line 14
 dontaudit cvs_t krb5_conf_t:file write;
#line 14
allow cvs_t krb5_conf_t:file { getattr read };
#line 14

#line 14
allow cvs_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 14
# Use sockets inherited from inetd.
#line 14

#line 14

#line 14
allow inetd_t cvs_port_t:tcp_socket name_bind;
#line 14
allow cvs_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 14

#line 14

#line 14

#line 14
allow cvs_t proc_net_t:dir { read getattr lock search ioctl };
#line 14
allow cvs_t proc_net_t:file { read getattr lock ioctl };
#line 14
allow cvs_t proc_net_t:lnk_file { getattr read };
#line 14

#line 14

typeattribute cvs_t privmail;
typeattribute cvs_t auth_chkpwd;

type cvs_data_t, file_type, sysadmfile, customizable;

#line 19
allow cvs_t cvs_data_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 19
allow cvs_t cvs_data_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19
allow cvs_t cvs_data_t:lnk_file { create read getattr setattr link unlink rename };
#line 19


#line 20
allow cvs_t { bin_t sbin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 20

allow cvs_t bin_t:dir search;
allow cvs_t { bin_t sbin_t }:lnk_file read;
allow cvs_t etc_runtime_t:file { getattr read };
allow system_mail_t cvs_data_t:file { getattr read };
dontaudit cvs_t devtty_t:chr_file { read write };
#line 30

#line 30
# Allow kerberos to work
#line 30
allow cvs_t { krb5_keytab_t krb5_conf_t }:file { read getattr lock ioctl };
#line 30
dontaudit cvs_t krb5_conf_t:file write;
#line 30

#line 1 "domains/program/cyrus.te"
#DESC cyrus-imapd
#
# Authors:  Dan Walsh <dwalsh@redhat.com>
#

# cyrusd_exec_t is the type of the cyrusd executable.
# cyrusd_key_t is the type of the cyrus private key files

#line 8

#line 8

#line 8

#line 8
type cyrus_t, domain, privlog, daemon , transitionbool;
#line 8
type cyrus_exec_t, file_type, sysadmfile, exec_type;
#line 8
dontaudit cyrus_t self:capability sys_tty_config;
#line 8

#line 8
role system_r types cyrus_t;
#line 8

#line 8
# Inherit and use descriptors from init.
#line 8
allow cyrus_t init_t:fd use;
#line 8
allow cyrus_t init_t:process sigchld;
#line 8
allow cyrus_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 8

#line 8

#line 8
allow cyrus_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 8
allow cyrus_t lib_t:lnk_file { read getattr lock ioctl };
#line 8
allow cyrus_t ld_so_t:file { read getattr lock execute ioctl };
#line 8
#allow cyrus_t ld_so_t:file execute_no_trans;
#line 8
allow cyrus_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 8
allow cyrus_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 8
allow cyrus_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 8
allow cyrus_t texrel_shlib_t:file execmod;
#line 8
allow cyrus_t ld_so_cache_t:file { read getattr lock ioctl };
#line 8
allow cyrus_t device_t:dir search;
#line 8
allow cyrus_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 8

#line 8

#line 8
allow cyrus_t { self proc_t }:dir { read getattr lock search ioctl };
#line 8
allow cyrus_t { self proc_t }:lnk_file { getattr read };
#line 8

#line 8
allow cyrus_t device_t:dir { read getattr lock search ioctl };
#line 8

#line 8
allow cyrus_t udev_tdb_t:file { read getattr lock ioctl };
#line 8
allow cyrus_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 8
dontaudit cyrus_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 8
dontaudit cyrus_t unpriv_userdomain:fd use;
#line 8

#line 8

#line 8
allow cyrus_t sysfs_t:dir { read getattr lock search ioctl };
#line 8
allow cyrus_t sysfs_t:file { read getattr lock ioctl };
#line 8
allow cyrus_t sysfs_t:lnk_file { getattr read };
#line 8
 
#line 8

#line 8
allow cyrus_t autofs_t:dir { search getattr };
#line 8

#line 8
dontaudit cyrus_t { tty_device_t devpts_t }:chr_file { read write };
#line 8
dontaudit cyrus_t root_t:file { getattr read };
#line 8
 
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
# Read system variables in /sys.
#line 8

#line 8
allow cyrus_t sysctl_t:dir search;
#line 8
allow cyrus_t sysctl_kernel_t:dir search;
#line 8
allow cyrus_t sysctl_kernel_t:file { getattr read };
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
#
#line 8
# Allows user to define a tunable to disable domain transition
#line 8
#
#line 8

#line 8
bool cyrus_disable_trans false;
#line 8
if (cyrus_disable_trans) {
#line 8

#line 8
allow initrc_t cyrus_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 8

#line 8

#line 8
allow sysadm_t cyrus_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 8

#line 8
} else {
#line 8
 
#line 8

#line 8

#line 8
#
#line 8
# Allow the process to transition to the new domain.
#line 8
#
#line 8
allow initrc_t cyrus_t:process transition;
#line 8

#line 8
#
#line 8
# Do not audit when glibc secure mode is enabled upon the transition.
#line 8
#
#line 8
dontaudit initrc_t cyrus_t:process noatsecure;
#line 8

#line 8
#
#line 8
# Do not audit when signal-related state is cleared upon the transition.
#line 8
#
#line 8
dontaudit initrc_t cyrus_t:process siginh;
#line 8

#line 8
#
#line 8
# Do not audit when resource limits are reset upon the transition.
#line 8
#
#line 8
dontaudit initrc_t cyrus_t:process rlimitinh;
#line 8

#line 8
#
#line 8
# Allow the process to execute the program.
#line 8
# 
#line 8
allow initrc_t cyrus_exec_t:file { read { getattr execute } };
#line 8

#line 8
#
#line 8
# Allow the process to reap the new domain.
#line 8
#
#line 8
allow cyrus_t initrc_t:process sigchld;
#line 8

#line 8
#
#line 8
# Allow the new domain to inherit and use file 
#line 8
# descriptions from the creating process and vice versa.
#line 8
#
#line 8
allow cyrus_t initrc_t:fd use;
#line 8
allow initrc_t cyrus_t:fd use;
#line 8

#line 8
#
#line 8
# Allow the new domain to write back to the old domain via a pipe.
#line 8
#
#line 8
allow cyrus_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 8

#line 8
#
#line 8
# Allow the new domain to read and execute the program.
#line 8
#
#line 8
allow cyrus_t cyrus_exec_t:file { read getattr lock execute ioctl };
#line 8

#line 8
#
#line 8
# Allow the new domain to be entered via the program.
#line 8
#
#line 8
allow cyrus_t cyrus_exec_t:file entrypoint;
#line 8

#line 8
type_transition initrc_t cyrus_exec_t:process cyrus_t;
#line 8

#line 8

#line 8
allow initrc_t cyrus_t:process { noatsecure siginh rlimitinh };
#line 8

#line 8
}
#line 8
 
#line 8
allow cyrus_t privfd:fd use;
#line 8

#line 8
allow cyrus_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 8

#line 8

#line 8
# Create pid file.
#line 8
allow cyrus_t var_t:dir { getattr search };
#line 8

#line 8
type cyrus_var_run_t, file_type, sysadmfile, pidfile;
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
#
#line 8
# Allow the process to modify the directory.
#line 8
#
#line 8
allow cyrus_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 8

#line 8
#
#line 8
# Allow the process to create the file.
#line 8
#
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
allow cyrus_t cyrus_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
type_transition cyrus_t var_run_t:file cyrus_var_run_t;
#line 8

#line 8

#line 8

#line 8
allow cyrus_t var_t:dir search;
#line 8
allow cyrus_t cyrus_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 8

#line 8

#line 8
allow cyrus_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 8

#line 8
# for daemons that look at /root on startup
#line 8
dontaudit cyrus_t sysadm_home_dir_t:dir search;
#line 8

#line 8
# for df
#line 8
allow cyrus_t fs_type:filesystem getattr;
#line 8
allow cyrus_t removable_t:filesystem getattr;
#line 8

#line 8

#line 8
allow cyrus_t etc_t:lnk_file read;
#line 8
allow cyrus_t lib_t:file { read getattr lock ioctl };
#line 8

#line 8
allow cyrus_t locale_t:dir { read getattr lock search ioctl };
#line 8
allow cyrus_t locale_t:file { read getattr lock ioctl };
#line 8
allow cyrus_t locale_t:lnk_file { getattr read };
#line 8

#line 8

#line 8

#line 8
# for localization
#line 8
allow cyrus_t lib_t:file { getattr read };
#line 8



#line 10
# Access other processes in the same domain.
#line 10
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 10
# These must be granted separately if desired.
#line 10
allow cyrus_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 10

#line 10
# Access /proc/PID files for processes in the same domain.
#line 10
allow cyrus_t self:dir { read getattr lock search ioctl };
#line 10
allow cyrus_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 10

#line 10
# Access file descriptions, pipes, and sockets
#line 10
# created by processes in the same domain.
#line 10
allow cyrus_t self:fd *;
#line 10
allow cyrus_t self:fifo_file { ioctl read getattr lock write append };
#line 10
allow cyrus_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 10
allow cyrus_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 10

#line 10
# Allow the domain to communicate with other processes in the same domain.
#line 10
allow cyrus_t self:unix_dgram_socket sendto;
#line 10
allow cyrus_t self:unix_stream_socket connectto;
#line 10

#line 10
# Access System V IPC objects created by processes in the same domain.
#line 10
allow cyrus_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 10
allow cyrus_t self:msg  { send receive };
#line 10
allow cyrus_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 10
allow cyrus_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 10
allow cyrus_t unpriv_userdomain:fd use;
#line 10
#
#line 10
# Every app is asking for ypbind so I am adding this here, 
#line 10
# eventually this should become can_nsswitch
#line 10
#
#line 10

#line 10

#line 10
if (allow_ypbind) {
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
#
#line 10
# Allow the domain to create and use tcp sockets.
#line 10
# Other kinds of sockets must be separately authorized for use.
#line 10
allow cyrus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 10

#line 10
allow cyrus_t unlabeled_t:association { sendto recvfrom };
#line 10

#line 10
#
#line 10
# Allow the domain to send or receive using any network interface.
#line 10
# netif_type is a type attribute for all network interface types.
#line 10
#
#line 10
allow cyrus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 10
#
#line 10
# Allow the domain to send to or receive from any node.
#line 10
# node_type is a type attribute for all node types.
#line 10
#
#line 10
allow cyrus_t node_type:node { tcp_send rawip_send };
#line 10
allow cyrus_t node_type:node { tcp_recv rawip_recv };
#line 10

#line 10
#
#line 10
# Allow the domain to send to or receive from any port.
#line 10
# port_type is a type attribute for all port types.
#line 10
#
#line 10

#line 10
allow cyrus_t port_type:tcp_socket { send_msg recv_msg };
#line 10

#line 10

#line 10
# XXX Allow binding to any node type.  Remove once
#line 10
# individual rules have been added to all domains that 
#line 10
# bind sockets. 
#line 10
allow cyrus_t node_type:tcp_socket node_bind;
#line 10
#
#line 10
# Allow access to network files including /etc/resolv.conf
#line 10
#
#line 10
allow cyrus_t net_conf_t:file { read getattr lock ioctl };
#line 10

#line 10
allow cyrus_t self:tcp_socket { listen accept };
#line 10

#line 10

#line 10

#line 10
#
#line 10
# Allow the domain to create and use tcp sockets.
#line 10
# Other kinds of sockets must be separately authorized for use.
#line 10
allow cyrus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 10

#line 10
allow cyrus_t unlabeled_t:association { sendto recvfrom };
#line 10

#line 10
#
#line 10
# Allow the domain to send or receive using any network interface.
#line 10
# netif_type is a type attribute for all network interface types.
#line 10
#
#line 10
allow cyrus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 10
#
#line 10
# Allow the domain to send to or receive from any node.
#line 10
# node_type is a type attribute for all node types.
#line 10
#
#line 10
allow cyrus_t node_type:node { tcp_send rawip_send };
#line 10
allow cyrus_t node_type:node { tcp_recv rawip_recv };
#line 10

#line 10
#
#line 10
# Allow the domain to send to or receive from any port.
#line 10
# port_type is a type attribute for all port types.
#line 10
#
#line 10

#line 10
allow cyrus_t port_type:tcp_socket { send_msg recv_msg };
#line 10

#line 10

#line 10
# XXX Allow binding to any node type.  Remove once
#line 10
# individual rules have been added to all domains that 
#line 10
# bind sockets. 
#line 10
allow cyrus_t node_type:tcp_socket node_bind;
#line 10
#
#line 10
# Allow access to network files including /etc/resolv.conf
#line 10
#
#line 10
allow cyrus_t net_conf_t:file { read getattr lock ioctl };
#line 10

#line 10
allow cyrus_t self:tcp_socket { connect };
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
#
#line 10
# Allow the domain to create and use udp sockets.
#line 10
# Other kinds of sockets must be separately authorized for use.
#line 10
allow cyrus_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 10

#line 10
allow cyrus_t unlabeled_t:association { sendto recvfrom };
#line 10

#line 10
#
#line 10
# Allow the domain to send or receive using any network interface.
#line 10
# netif_type is a type attribute for all network interface types.
#line 10
#
#line 10
allow cyrus_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 10
#
#line 10
# Allow the domain to send to or receive from any node.
#line 10
# node_type is a type attribute for all node types.
#line 10
#
#line 10
allow cyrus_t node_type:node { udp_send rawip_send };
#line 10
allow cyrus_t node_type:node { udp_recv rawip_recv };
#line 10

#line 10
#
#line 10
# Allow the domain to send to or receive from any port.
#line 10
# port_type is a type attribute for all port types.
#line 10
#
#line 10

#line 10
allow cyrus_t port_type:udp_socket { send_msg recv_msg };
#line 10

#line 10

#line 10
# XXX Allow binding to any node type.  Remove once
#line 10
# individual rules have been added to all domains that 
#line 10
# bind sockets. 
#line 10
allow cyrus_t node_type:udp_socket node_bind;
#line 10
#
#line 10
# Allow access to network files including /etc/resolv.conf
#line 10
#
#line 10
allow cyrus_t net_conf_t:file { read getattr lock ioctl };
#line 10

#line 10
allow cyrus_t self:udp_socket { connect };
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
allow cyrus_t var_yp_t:dir { read getattr lock search ioctl };
#line 10
allow cyrus_t var_yp_t:file { read getattr lock ioctl };
#line 10
allow cyrus_t var_yp_t:lnk_file { getattr read };
#line 10

#line 10
allow cyrus_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 10
allow cyrus_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 10
dontaudit cyrus_t self:capability net_bind_service;
#line 10
dontaudit cyrus_t reserved_port_type:tcp_socket name_connect;
#line 10
dontaudit cyrus_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 10

#line 10
} else {
#line 10
dontaudit cyrus_t var_yp_t:dir search;
#line 10
}
#line 10
 
#line 10
allow cyrus_t autofs_t:dir { search getattr };
#line 10


#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow cyrus_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow cyrus_t cyrus_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition cyrus_t var_run_t:sock_file cyrus_var_run_t;
#line 11

#line 11


type cyrus_var_lib_t, file_type, sysadmfile;

allow cyrus_t self:capability { dac_override net_bind_service setgid setuid sys_resource };
allow cyrus_t self:process setrlimit;


#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow cyrus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow cyrus_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow cyrus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow cyrus_t node_type:node { tcp_send rawip_send };
#line 18
allow cyrus_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow cyrus_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow cyrus_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow cyrus_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow cyrus_t self:tcp_socket { listen accept };
#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow cyrus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow cyrus_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow cyrus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow cyrus_t node_type:node { tcp_send rawip_send };
#line 18
allow cyrus_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow cyrus_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow cyrus_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow cyrus_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow cyrus_t self:tcp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use udp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow cyrus_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow cyrus_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow cyrus_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow cyrus_t node_type:node { udp_send rawip_send };
#line 18
allow cyrus_t node_type:node { udp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow cyrus_t port_type:udp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow cyrus_t node_type:udp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow cyrus_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow cyrus_t self:udp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

allow cyrus_t port_type:tcp_socket name_connect;

#line 20

#line 20
if (allow_ypbind) {
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use tcp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow cyrus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow cyrus_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow cyrus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow cyrus_t node_type:node { tcp_send rawip_send };
#line 20
allow cyrus_t node_type:node { tcp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow cyrus_t port_type:tcp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow cyrus_t node_type:tcp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow cyrus_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow cyrus_t self:tcp_socket { listen accept };
#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use tcp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow cyrus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow cyrus_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow cyrus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow cyrus_t node_type:node { tcp_send rawip_send };
#line 20
allow cyrus_t node_type:node { tcp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow cyrus_t port_type:tcp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow cyrus_t node_type:tcp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow cyrus_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow cyrus_t self:tcp_socket { connect };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use udp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow cyrus_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow cyrus_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow cyrus_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow cyrus_t node_type:node { udp_send rawip_send };
#line 20
allow cyrus_t node_type:node { udp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow cyrus_t port_type:udp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow cyrus_t node_type:udp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow cyrus_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow cyrus_t self:udp_socket { connect };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
allow cyrus_t var_yp_t:dir { read getattr lock search ioctl };
#line 20
allow cyrus_t var_yp_t:file { read getattr lock ioctl };
#line 20
allow cyrus_t var_yp_t:lnk_file { getattr read };
#line 20

#line 20
allow cyrus_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 20
allow cyrus_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 20
dontaudit cyrus_t self:capability net_bind_service;
#line 20
dontaudit cyrus_t reserved_port_type:tcp_socket name_connect;
#line 20
dontaudit cyrus_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 20

#line 20
} else {
#line 20
dontaudit cyrus_t var_yp_t:dir search;
#line 20
}
#line 20
 

#line 21
allow cyrus_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 21

allow cyrus_t cyrus_var_lib_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
allow cyrus_t cyrus_var_lib_t:{file sock_file lnk_file} { create ioctl read getattr lock write setattr append link unlink rename };
allow cyrus_t etc_t:file { getattr read };
allow cyrus_t lib_t:file { execute execute_no_trans getattr read };

#line 26
allow cyrus_t etc_t:lnk_file read;
#line 26
allow cyrus_t lib_t:file { read getattr lock ioctl };
#line 26

#line 26
allow cyrus_t locale_t:dir { read getattr lock search ioctl };
#line 26
allow cyrus_t locale_t:file { read getattr lock ioctl };
#line 26
allow cyrus_t locale_t:lnk_file { getattr read };
#line 26

#line 26


#line 27
# Read system variables in /sys.
#line 27

#line 27
allow cyrus_t sysctl_t:dir search;
#line 27
allow cyrus_t sysctl_kernel_t:dir search;
#line 27
allow cyrus_t sysctl_kernel_t:file { getattr read };
#line 27

#line 27

#line 27


#line 28
type cyrus_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the process to modify the directory.
#line 28
#
#line 28
allow cyrus_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 28

#line 28
#
#line 28
# Allow the process to create the file.
#line 28
#
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
allow cyrus_t cyrus_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
allow cyrus_t cyrus_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
type_transition cyrus_t tmp_t:{ file dir } cyrus_tmp_t;
#line 28

#line 28

#line 28

allow cyrus_t { mail_port_t pop_port_t }:tcp_socket name_bind;
allow cyrus_t proc_t:dir search;
allow cyrus_t proc_t:file { getattr read };
allow cyrus_t sysadm_devpts_t:chr_file { read write };

allow cyrus_t var_lib_t:dir search;

allow cyrus_t etc_runtime_t:file { read getattr };
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
#
#line 41
# Allow the process to transition to the new domain.
#line 41
#
#line 41
allow system_crond_t cyrus_t:process transition;
#line 41

#line 41
#
#line 41
# Do not audit when glibc secure mode is enabled upon the transition.
#line 41
#
#line 41
dontaudit system_crond_t cyrus_t:process noatsecure;
#line 41

#line 41
#
#line 41
# Do not audit when signal-related state is cleared upon the transition.
#line 41
#
#line 41
dontaudit system_crond_t cyrus_t:process siginh;
#line 41

#line 41
#
#line 41
# Do not audit when resource limits are reset upon the transition.
#line 41
#
#line 41
dontaudit system_crond_t cyrus_t:process rlimitinh;
#line 41

#line 41
#
#line 41
# Allow the process to execute the program.
#line 41
# 
#line 41
allow system_crond_t cyrus_exec_t:file { read { getattr execute } };
#line 41

#line 41
#
#line 41
# Allow the process to reap the new domain.
#line 41
#
#line 41
allow cyrus_t system_crond_t:process sigchld;
#line 41

#line 41
#
#line 41
# Allow the new domain to inherit and use file 
#line 41
# descriptions from the creating process and vice versa.
#line 41
#
#line 41
allow cyrus_t system_crond_t:fd use;
#line 41
allow system_crond_t cyrus_t:fd use;
#line 41

#line 41
#
#line 41
# Allow the new domain to write back to the old domain via a pipe.
#line 41
#
#line 41
allow cyrus_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 41

#line 41
#
#line 41
# Allow the new domain to read and execute the program.
#line 41
#
#line 41
allow cyrus_t cyrus_exec_t:file { read getattr lock execute ioctl };
#line 41

#line 41
#
#line 41
# Allow the new domain to be entered via the program.
#line 41
#
#line 41
allow cyrus_t cyrus_exec_t:file entrypoint;
#line 41

#line 41
type_transition system_crond_t cyrus_exec_t:process cyrus_t;
#line 41

#line 41
allow cyrus_t crond_t:fifo_file { getattr read write ioctl };
#line 41
# a rule for privfd may make this obsolete
#line 41
allow cyrus_t crond_t:fd use;
#line 41
allow cyrus_t crond_t:process sigchld;
#line 41

#line 41
allow system_crond_t cyrus_var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 41
allow system_crond_t cyrus_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 41


#line 42
allow cyrus_t mail_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 42
allow cyrus_t mail_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 42
allow cyrus_t mail_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 42

allow cyrus_t var_spool_t:dir search;

#line 49

#line 49
allow cyrus_t saslauthd_var_run_t:dir search;
#line 49
allow cyrus_t saslauthd_var_run_t:sock_file { read write };
#line 49
allow cyrus_t saslauthd_t:unix_stream_socket { connectto };
#line 49



#line 51
allow cyrus_t cert_t:dir { read getattr lock search ioctl };
#line 51
allow cyrus_t cert_t:file { read getattr lock ioctl };
#line 51
allow cyrus_t cert_t:lnk_file { getattr read };
#line 51

allow cyrus_t { urandom_device_t random_device_t }:chr_file { read getattr };

#line 59

#line 59
allow postfix_master_t cyrus_t:unix_stream_socket connectto;
#line 59
allow postfix_master_t var_lib_t:dir search;
#line 59
allow postfix_master_t cyrus_var_lib_t:dir search;
#line 59
allow postfix_master_t cyrus_var_lib_t:sock_file write;
#line 59


#line 1 "domains/program/dbskkd.te"
#DESC dbskkd - A dictionary server for the SKK Japanese input method system.
#
# Author:  Dan Walsh <dwalsh@redhat.com>
#

#################################
#
# Rules for the dbskkd_t domain.
#
# dbskkd_exec_t is the type of the dbskkd executable.
#
# Depends: inetd.te


#line 14
type dbskkd_t, domain, privlog, nscd_client_domain;
#line 14
role system_r types dbskkd_t;
#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14
bool dbskkd_disable_trans false;
#line 14
if (dbskkd_disable_trans) {
#line 14

#line 14
allow initrc_t dbskkd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t dbskkd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow inetd_t dbskkd_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit inetd_t dbskkd_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit inetd_t dbskkd_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit inetd_t dbskkd_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow inetd_t dbskkd_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow dbskkd_t inetd_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow dbskkd_t inetd_t:fd use;
#line 14
allow inetd_t dbskkd_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow dbskkd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow dbskkd_t dbskkd_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow dbskkd_t dbskkd_exec_t:file entrypoint;
#line 14

#line 14
type_transition inetd_t dbskkd_exec_t:process dbskkd_t;
#line 14

#line 14
allow inetd_t dbskkd_t:process sigkill;
#line 14
}
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow dbskkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow dbskkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow dbskkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow dbskkd_t node_type:node { tcp_send rawip_send };
#line 14
allow dbskkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow dbskkd_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow dbskkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow dbskkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow dbskkd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow dbskkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow dbskkd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow dbskkd_t node_type:node { udp_send rawip_send };
#line 14
allow dbskkd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow dbskkd_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow dbskkd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow dbskkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
if (allow_ypbind) {
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow dbskkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow dbskkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow dbskkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow dbskkd_t node_type:node { tcp_send rawip_send };
#line 14
allow dbskkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow dbskkd_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow dbskkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow dbskkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow dbskkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow dbskkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow dbskkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow dbskkd_t node_type:node { tcp_send rawip_send };
#line 14
allow dbskkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow dbskkd_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow dbskkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow dbskkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow dbskkd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow dbskkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow dbskkd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow dbskkd_t node_type:node { udp_send rawip_send };
#line 14
allow dbskkd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow dbskkd_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow dbskkd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow dbskkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow dbskkd_t var_yp_t:dir { read getattr lock search ioctl };
#line 14
allow dbskkd_t var_yp_t:file { read getattr lock ioctl };
#line 14
allow dbskkd_t var_yp_t:lnk_file { getattr read };
#line 14

#line 14
allow dbskkd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 14
allow dbskkd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 14
dontaudit dbskkd_t self:capability net_bind_service;
#line 14
dontaudit dbskkd_t reserved_port_type:tcp_socket name_connect;
#line 14
dontaudit dbskkd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 14

#line 14
} else {
#line 14
dontaudit dbskkd_t var_yp_t:dir search;
#line 14
}
#line 14
 
#line 14

#line 14
allow dbskkd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow dbskkd_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow dbskkd_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow dbskkd_t ld_so_t:file execute_no_trans;
#line 14
allow dbskkd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow dbskkd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow dbskkd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow dbskkd_t texrel_shlib_t:file execmod;
#line 14
allow dbskkd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow dbskkd_t device_t:dir search;
#line 14
allow dbskkd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
allow dbskkd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow dbskkd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow dbskkd_t self:fifo_file { ioctl read getattr lock write append };
#line 14
type dbskkd_exec_t, file_type, sysadmfile, exec_type;
#line 14

#line 14
allow dbskkd_t etc_t:lnk_file read;
#line 14
allow dbskkd_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow dbskkd_t locale_t:file { read getattr lock ioctl };
#line 14
allow dbskkd_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14
allow dbskkd_t device_t:dir search;
#line 14
allow dbskkd_t proc_t:dir search;
#line 14
allow dbskkd_t proc_t:{ file lnk_file } { getattr read };
#line 14
allow dbskkd_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 14
allow dbskkd_t fs_t:filesystem getattr;
#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow dbskkd_t sysctl_t:dir search;
#line 14
allow dbskkd_t sysctl_kernel_t:dir search;
#line 14
allow dbskkd_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14
allow dbskkd_t etc_t:file { getattr read };
#line 14

#line 14

#line 14
type dbskkd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow dbskkd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow dbskkd_t dbskkd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow dbskkd_t dbskkd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition dbskkd_t tmp_t:{ file dir } dbskkd_tmp_t;
#line 14

#line 14

#line 14

#line 14
allow dbskkd_t var_t:dir search;
#line 14

#line 14
type dbskkd_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow dbskkd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow dbskkd_t dbskkd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition dbskkd_t var_run_t:file dbskkd_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow dbskkd_t var_t:dir search;
#line 14
allow dbskkd_t dbskkd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
# Inherit and use descriptors from inetd.
#line 14
allow dbskkd_t inetd_t:fd use;
#line 14

#line 14
# for identd
#line 14
allow dbskkd_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 14
allow dbskkd_t self:capability { setuid setgid };
#line 14
allow dbskkd_t home_root_t:dir search;
#line 14
allow dbskkd_t self:dir search;
#line 14
allow dbskkd_t self:{ lnk_file file } { getattr read };
#line 14

#line 14

#line 14
if (allow_kerberos) {
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow dbskkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow dbskkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow dbskkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow dbskkd_t node_type:node { tcp_send rawip_send };
#line 14
allow dbskkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow dbskkd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow dbskkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow dbskkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow dbskkd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow dbskkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow dbskkd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow dbskkd_t node_type:node { udp_send rawip_send };
#line 14
allow dbskkd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow dbskkd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow dbskkd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow dbskkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow dbskkd_t kerberos_port_t:tcp_socket name_connect;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow dbskkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow dbskkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow dbskkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow dbskkd_t node_type:node { tcp_send rawip_send };
#line 14
allow dbskkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow dbskkd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow dbskkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow dbskkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow dbskkd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow dbskkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow dbskkd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow dbskkd_t node_type:node { udp_send rawip_send };
#line 14
allow dbskkd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow dbskkd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow dbskkd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow dbskkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow dbskkd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow dbskkd_t dns_port_t:tcp_socket name_connect;
#line 14

#line 14
}
#line 14
 dontaudit dbskkd_t krb5_conf_t:file write;
#line 14
allow dbskkd_t krb5_conf_t:file { getattr read };
#line 14

#line 14
allow dbskkd_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 14
# Use sockets inherited from inetd.
#line 14

#line 14
allow inetd_t dbskkd_port_t:udp_socket name_bind;
#line 14
allow dbskkd_t inetd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
#line 14
allow inetd_t dbskkd_port_t:tcp_socket name_bind;
#line 14
allow dbskkd_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 14

#line 14

#line 14

#line 14

#line 14
allow dbskkd_t proc_net_t:dir { read getattr lock search ioctl };
#line 14
allow dbskkd_t proc_net_t:file { read getattr lock ioctl };
#line 14
allow dbskkd_t proc_net_t:lnk_file { getattr read };
#line 14

#line 14

#line 1 "domains/program/dbusd.te"
#DESC dbus-daemon-1 server for dbus desktop bus protocol
#
# Author:  Russell Coker <russell@coker.com.au>


#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
type system_dbusd_t, domain, privlog, daemon , userspace_objmgr, nscd_client_domain, transitionbool;
#line 5
type system_dbusd_exec_t, file_type, sysadmfile, exec_type;
#line 5
dontaudit system_dbusd_t self:capability sys_tty_config;
#line 5

#line 5
role system_r types system_dbusd_t;
#line 5

#line 5
# Inherit and use descriptors from init.
#line 5
allow system_dbusd_t init_t:fd use;
#line 5
allow system_dbusd_t init_t:process sigchld;
#line 5
allow system_dbusd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 5

#line 5

#line 5
allow system_dbusd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t lib_t:lnk_file { read getattr lock ioctl };
#line 5
allow system_dbusd_t ld_so_t:file { read getattr lock execute ioctl };
#line 5
#allow system_dbusd_t ld_so_t:file execute_no_trans;
#line 5
allow system_dbusd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 5
allow system_dbusd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 5
allow system_dbusd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 5
allow system_dbusd_t texrel_shlib_t:file execmod;
#line 5
allow system_dbusd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 5
allow system_dbusd_t device_t:dir search;
#line 5
allow system_dbusd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 5

#line 5

#line 5
allow system_dbusd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t { self proc_t }:lnk_file { getattr read };
#line 5

#line 5
allow system_dbusd_t device_t:dir { read getattr lock search ioctl };
#line 5

#line 5
allow system_dbusd_t udev_tdb_t:file { read getattr lock ioctl };
#line 5
allow system_dbusd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 5
dontaudit system_dbusd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 5
dontaudit system_dbusd_t unpriv_userdomain:fd use;
#line 5

#line 5

#line 5
allow system_dbusd_t sysfs_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t sysfs_t:file { read getattr lock ioctl };
#line 5
allow system_dbusd_t sysfs_t:lnk_file { getattr read };
#line 5
 
#line 5

#line 5
allow system_dbusd_t autofs_t:dir { search getattr };
#line 5

#line 5
dontaudit system_dbusd_t { tty_device_t devpts_t }:chr_file { read write };
#line 5
dontaudit system_dbusd_t root_t:file { getattr read };
#line 5
 
#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
# Read system variables in /sys.
#line 5

#line 5
allow system_dbusd_t sysctl_t:dir search;
#line 5
allow system_dbusd_t sysctl_kernel_t:dir search;
#line 5
allow system_dbusd_t sysctl_kernel_t:file { getattr read };
#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
#
#line 5
# Allows user to define a tunable to disable domain transition
#line 5
#
#line 5

#line 5
bool system_dbusd_disable_trans false;
#line 5
if (system_dbusd_disable_trans) {
#line 5

#line 5
allow initrc_t system_dbusd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 5

#line 5

#line 5
allow sysadm_t system_dbusd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 5

#line 5
} else {
#line 5
 
#line 5

#line 5

#line 5
#
#line 5
# Allow the process to transition to the new domain.
#line 5
#
#line 5
allow initrc_t system_dbusd_t:process transition;
#line 5

#line 5
#
#line 5
# Do not audit when glibc secure mode is enabled upon the transition.
#line 5
#
#line 5
dontaudit initrc_t system_dbusd_t:process noatsecure;
#line 5

#line 5
#
#line 5
# Do not audit when signal-related state is cleared upon the transition.
#line 5
#
#line 5
dontaudit initrc_t system_dbusd_t:process siginh;
#line 5

#line 5
#
#line 5
# Do not audit when resource limits are reset upon the transition.
#line 5
#
#line 5
dontaudit initrc_t system_dbusd_t:process rlimitinh;
#line 5

#line 5
#
#line 5
# Allow the process to execute the program.
#line 5
# 
#line 5
allow initrc_t system_dbusd_exec_t:file { read { getattr execute } };
#line 5

#line 5
#
#line 5
# Allow the process to reap the new domain.
#line 5
#
#line 5
allow system_dbusd_t initrc_t:process sigchld;
#line 5

#line 5
#
#line 5
# Allow the new domain to inherit and use file 
#line 5
# descriptions from the creating process and vice versa.
#line 5
#
#line 5
allow system_dbusd_t initrc_t:fd use;
#line 5
allow initrc_t system_dbusd_t:fd use;
#line 5

#line 5
#
#line 5
# Allow the new domain to write back to the old domain via a pipe.
#line 5
#
#line 5
allow system_dbusd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 5

#line 5
#
#line 5
# Allow the new domain to read and execute the program.
#line 5
#
#line 5
allow system_dbusd_t system_dbusd_exec_t:file { read getattr lock execute ioctl };
#line 5

#line 5
#
#line 5
# Allow the new domain to be entered via the program.
#line 5
#
#line 5
allow system_dbusd_t system_dbusd_exec_t:file entrypoint;
#line 5

#line 5
type_transition initrc_t system_dbusd_exec_t:process system_dbusd_t;
#line 5

#line 5

#line 5
allow initrc_t system_dbusd_t:process { noatsecure siginh rlimitinh };
#line 5

#line 5
}
#line 5
 
#line 5
allow system_dbusd_t privfd:fd use;
#line 5

#line 5
allow system_dbusd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 5

#line 5

#line 5
# Create pid file.
#line 5
allow system_dbusd_t var_t:dir { getattr search };
#line 5

#line 5
type system_dbusd_var_run_t, file_type, sysadmfile, pidfile;
#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
#
#line 5
# Allow the process to modify the directory.
#line 5
#
#line 5
allow system_dbusd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 5

#line 5
#
#line 5
# Allow the process to create the file.
#line 5
#
#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
allow system_dbusd_t system_dbusd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
type_transition system_dbusd_t var_run_t:file system_dbusd_var_run_t;
#line 5

#line 5

#line 5

#line 5
allow system_dbusd_t var_t:dir search;
#line 5
allow system_dbusd_t system_dbusd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 5

#line 5

#line 5
allow system_dbusd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 5

#line 5
# for daemons that look at /root on startup
#line 5
dontaudit system_dbusd_t sysadm_home_dir_t:dir search;
#line 5

#line 5
# for df
#line 5
allow system_dbusd_t fs_type:filesystem getattr;
#line 5
allow system_dbusd_t removable_t:filesystem getattr;
#line 5

#line 5

#line 5
allow system_dbusd_t etc_t:lnk_file read;
#line 5
allow system_dbusd_t lib_t:file { read getattr lock ioctl };
#line 5

#line 5
allow system_dbusd_t locale_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t locale_t:file { read getattr lock ioctl };
#line 5
allow system_dbusd_t locale_t:lnk_file { getattr read };
#line 5

#line 5

#line 5

#line 5
# for localization
#line 5
allow system_dbusd_t lib_t:file { getattr read };
#line 5

#line 5
# For backwards compatibility
#line 5
typealias system_dbusd_t alias dbusd_t;
#line 5
type etc_dbusd_t, file_type, sysadmfile;
#line 5

#line 5

#line 5
# Read /.
#line 5
allow system_dbusd_t root_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t root_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 5

#line 5
# Read /home.
#line 5
allow system_dbusd_t home_root_t:dir { read getattr lock search ioctl };
#line 5

#line 5
# Read /usr.
#line 5
allow system_dbusd_t usr_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t usr_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 5

#line 5
# Read bin and sbin directories.
#line 5
allow system_dbusd_t bin_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t bin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 5
allow system_dbusd_t sbin_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t sbin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 5

#line 5
# Read system variables in /sys.
#line 5

#line 5
allow system_dbusd_t sysctl_t:dir search;
#line 5
allow system_dbusd_t sysctl_kernel_t:dir search;
#line 5
allow system_dbusd_t sysctl_kernel_t:file { getattr read };
#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
allow system_dbusd_t selinux_config_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t selinux_config_t:file { read getattr lock ioctl };
#line 5
allow system_dbusd_t selinux_config_t:lnk_file { getattr read };
#line 5

#line 5

#line 5
if (read_default_t) {
#line 5
#
#line 5
# Read default_t
#line 5
#.
#line 5
allow system_dbusd_t default_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t default_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 5
}
#line 5

#line 5

#line 5

#line 5
allow system_dbusd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t lib_t:lnk_file { read getattr lock ioctl };
#line 5
allow system_dbusd_t ld_so_t:file { read getattr lock execute ioctl };
#line 5
#allow system_dbusd_t ld_so_t:file execute_no_trans;
#line 5
allow system_dbusd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 5
allow system_dbusd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 5
allow system_dbusd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 5
allow system_dbusd_t texrel_shlib_t:file execmod;
#line 5
allow system_dbusd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 5
allow system_dbusd_t device_t:dir search;
#line 5
allow system_dbusd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 5

#line 5
allow system_dbusd_t etc_t:file { getattr read };
#line 5

#line 5
allow system_dbusd_t etc_dbusd_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t etc_dbusd_t:file { read getattr lock ioctl };
#line 5
allow system_dbusd_t etc_dbusd_t:lnk_file { getattr read };
#line 5

#line 5

#line 5
type system_dbusd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 5

#line 5

#line 5

#line 5

#line 5
#
#line 5
# Allow the process to modify the directory.
#line 5
#
#line 5
allow system_dbusd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 5

#line 5
#
#line 5
# Allow the process to create the file.
#line 5
#
#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
allow system_dbusd_t system_dbusd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
allow system_dbusd_t system_dbusd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5

#line 5
type_transition system_dbusd_t tmp_t:{ file dir } system_dbusd_tmp_t;
#line 5

#line 5

#line 5
 
#line 5
allow system_dbusd_t self:process fork;
#line 5

#line 5

#line 5
allow system_dbusd_t xdm_t:fd use;
#line 5
allow system_dbusd_t xdm_t:fifo_file { getattr read write ioctl };
#line 5

#line 5

#line 5

#line 5
allow system_dbusd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 5
allow system_dbusd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 5

#line 5
allow system_dbusd_t urandom_device_t:chr_file { getattr read };
#line 5
allow system_dbusd_t self:file { getattr read write };
#line 5
allow system_dbusd_t proc_t:file read;
#line 5

#line 5

#line 5
# Get the selinuxfs mount point via /proc/self/mounts.
#line 5
allow system_dbusd_t proc_t:dir search;
#line 5
allow system_dbusd_t proc_t:{ file lnk_file } { getattr read };
#line 5
allow system_dbusd_t self:dir search;
#line 5
allow system_dbusd_t self:file { getattr read };
#line 5
# Access selinuxfs.
#line 5
allow system_dbusd_t security_t:dir { read search getattr };
#line 5
allow system_dbusd_t security_t:file { getattr read write };
#line 5
allow system_dbusd_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 5

#line 5

#line 5
allow system_dbusd_t default_context_t:dir { read getattr lock search ioctl };
#line 5
allow system_dbusd_t default_context_t:file { read getattr lock ioctl };
#line 5
allow system_dbusd_t default_context_t:lnk_file { getattr read };
#line 5

#line 5
allow system_dbusd_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };
#line 5
allow system_dbusd_t self:netlink_selinux_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 5

#line 5

#line 5

#line 5
allow system_dbusd_t self:dbus { send_msg acquire_svc };
#line 5

#line 5


allow system_dbusd_t system_dbusd_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };

#line 11


# dac_override: /var/run/dbus is owned by messagebus on Debian
allow system_dbusd_t self:capability { dac_override setgid setuid };

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the domain to create and use tcp sockets.
#line 15
# Other kinds of sockets must be separately authorized for use.
#line 15
allow system_dbusd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 15

#line 15
allow system_dbusd_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
#
#line 15
# Allow the domain to send or receive using any network interface.
#line 15
# netif_type is a type attribute for all network interface types.
#line 15
#
#line 15
allow system_dbusd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 15
#
#line 15
# Allow the domain to send to or receive from any node.
#line 15
# node_type is a type attribute for all node types.
#line 15
#
#line 15
allow system_dbusd_t node_type:node { tcp_send rawip_send };
#line 15
allow system_dbusd_t node_type:node { tcp_recv rawip_recv };
#line 15

#line 15
#
#line 15
# Allow the domain to send to or receive from any port.
#line 15
# port_type is a type attribute for all port types.
#line 15
#
#line 15

#line 15
allow system_dbusd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 15

#line 15

#line 15
# XXX Allow binding to any node type.  Remove once
#line 15
# individual rules have been added to all domains that 
#line 15
# bind sockets. 
#line 15
allow system_dbusd_t node_type:tcp_socket node_bind;
#line 15
#
#line 15
# Allow access to network files including /etc/resolv.conf
#line 15
#
#line 15
allow system_dbusd_t net_conf_t:file { read getattr lock ioctl };
#line 15

#line 15
allow system_dbusd_t self:tcp_socket { connect };
#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the domain to create and use udp sockets.
#line 15
# Other kinds of sockets must be separately authorized for use.
#line 15
allow system_dbusd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 15

#line 15
allow system_dbusd_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
#
#line 15
# Allow the domain to send or receive using any network interface.
#line 15
# netif_type is a type attribute for all network interface types.
#line 15
#
#line 15
allow system_dbusd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 15
#
#line 15
# Allow the domain to send to or receive from any node.
#line 15
# node_type is a type attribute for all node types.
#line 15
#
#line 15
allow system_dbusd_t node_type:node { udp_send rawip_send };
#line 15
allow system_dbusd_t node_type:node { udp_recv rawip_recv };
#line 15

#line 15
#
#line 15
# Allow the domain to send to or receive from any port.
#line 15
# port_type is a type attribute for all port types.
#line 15
#
#line 15

#line 15
allow system_dbusd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 15

#line 15

#line 15
# XXX Allow binding to any node type.  Remove once
#line 15
# individual rules have been added to all domains that 
#line 15
# bind sockets. 
#line 15
allow system_dbusd_t node_type:udp_socket node_bind;
#line 15
#
#line 15
# Allow access to network files including /etc/resolv.conf
#line 15
#
#line 15
allow system_dbusd_t net_conf_t:file { read getattr lock ioctl };
#line 15

#line 15
allow system_dbusd_t self:udp_socket { connect };
#line 15

#line 15

#line 15

#line 15
allow system_dbusd_t dns_port_t:tcp_socket name_connect;
#line 15

#line 15

#line 15

#line 15
if (allow_ypbind) {
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the domain to create and use tcp sockets.
#line 15
# Other kinds of sockets must be separately authorized for use.
#line 15
allow system_dbusd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 15

#line 15
allow system_dbusd_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
#
#line 15
# Allow the domain to send or receive using any network interface.
#line 15
# netif_type is a type attribute for all network interface types.
#line 15
#
#line 15
allow system_dbusd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 15
#
#line 15
# Allow the domain to send to or receive from any node.
#line 15
# node_type is a type attribute for all node types.
#line 15
#
#line 15
allow system_dbusd_t node_type:node { tcp_send rawip_send };
#line 15
allow system_dbusd_t node_type:node { tcp_recv rawip_recv };
#line 15

#line 15
#
#line 15
# Allow the domain to send to or receive from any port.
#line 15
# port_type is a type attribute for all port types.
#line 15
#
#line 15

#line 15
allow system_dbusd_t port_type:tcp_socket { send_msg recv_msg };
#line 15

#line 15

#line 15
# XXX Allow binding to any node type.  Remove once
#line 15
# individual rules have been added to all domains that 
#line 15
# bind sockets. 
#line 15
allow system_dbusd_t node_type:tcp_socket node_bind;
#line 15
#
#line 15
# Allow access to network files including /etc/resolv.conf
#line 15
#
#line 15
allow system_dbusd_t net_conf_t:file { read getattr lock ioctl };
#line 15

#line 15
allow system_dbusd_t self:tcp_socket { listen accept };
#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the domain to create and use tcp sockets.
#line 15
# Other kinds of sockets must be separately authorized for use.
#line 15
allow system_dbusd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 15

#line 15
allow system_dbusd_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
#
#line 15
# Allow the domain to send or receive using any network interface.
#line 15
# netif_type is a type attribute for all network interface types.
#line 15
#
#line 15
allow system_dbusd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 15
#
#line 15
# Allow the domain to send to or receive from any node.
#line 15
# node_type is a type attribute for all node types.
#line 15
#
#line 15
allow system_dbusd_t node_type:node { tcp_send rawip_send };
#line 15
allow system_dbusd_t node_type:node { tcp_recv rawip_recv };
#line 15

#line 15
#
#line 15
# Allow the domain to send to or receive from any port.
#line 15
# port_type is a type attribute for all port types.
#line 15
#
#line 15

#line 15
allow system_dbusd_t port_type:tcp_socket { send_msg recv_msg };
#line 15

#line 15

#line 15
# XXX Allow binding to any node type.  Remove once
#line 15
# individual rules have been added to all domains that 
#line 15
# bind sockets. 
#line 15
allow system_dbusd_t node_type:tcp_socket node_bind;
#line 15
#
#line 15
# Allow access to network files including /etc/resolv.conf
#line 15
#
#line 15
allow system_dbusd_t net_conf_t:file { read getattr lock ioctl };
#line 15

#line 15
allow system_dbusd_t self:tcp_socket { connect };
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the domain to create and use udp sockets.
#line 15
# Other kinds of sockets must be separately authorized for use.
#line 15
allow system_dbusd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 15

#line 15
allow system_dbusd_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
#
#line 15
# Allow the domain to send or receive using any network interface.
#line 15
# netif_type is a type attribute for all network interface types.
#line 15
#
#line 15
allow system_dbusd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 15
#
#line 15
# Allow the domain to send to or receive from any node.
#line 15
# node_type is a type attribute for all node types.
#line 15
#
#line 15
allow system_dbusd_t node_type:node { udp_send rawip_send };
#line 15
allow system_dbusd_t node_type:node { udp_recv rawip_recv };
#line 15

#line 15
#
#line 15
# Allow the domain to send to or receive from any port.
#line 15
# port_type is a type attribute for all port types.
#line 15
#
#line 15

#line 15
allow system_dbusd_t port_type:udp_socket { send_msg recv_msg };
#line 15

#line 15

#line 15
# XXX Allow binding to any node type.  Remove once
#line 15
# individual rules have been added to all domains that 
#line 15
# bind sockets. 
#line 15
allow system_dbusd_t node_type:udp_socket node_bind;
#line 15
#
#line 15
# Allow access to network files including /etc/resolv.conf
#line 15
#
#line 15
allow system_dbusd_t net_conf_t:file { read getattr lock ioctl };
#line 15

#line 15
allow system_dbusd_t self:udp_socket { connect };
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
allow system_dbusd_t var_yp_t:dir { read getattr lock search ioctl };
#line 15
allow system_dbusd_t var_yp_t:file { read getattr lock ioctl };
#line 15
allow system_dbusd_t var_yp_t:lnk_file { getattr read };
#line 15

#line 15
allow system_dbusd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 15
allow system_dbusd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 15
dontaudit system_dbusd_t self:capability net_bind_service;
#line 15
dontaudit system_dbusd_t reserved_port_type:tcp_socket name_connect;
#line 15
dontaudit system_dbusd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 15

#line 15
} else {
#line 15
dontaudit system_dbusd_t var_yp_t:dir search;
#line 15
}
#line 15
 
#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the domain to create and use tcp sockets.
#line 15
# Other kinds of sockets must be separately authorized for use.
#line 15
allow system_dbusd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 15

#line 15
allow system_dbusd_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
#
#line 15
# Allow the domain to send or receive using any network interface.
#line 15
# netif_type is a type attribute for all network interface types.
#line 15
#
#line 15
allow system_dbusd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 15
#
#line 15
# Allow the domain to send to or receive from any node.
#line 15
# node_type is a type attribute for all node types.
#line 15
#
#line 15
allow system_dbusd_t node_type:node { tcp_send rawip_send };
#line 15
allow system_dbusd_t node_type:node { tcp_recv rawip_recv };
#line 15

#line 15
#
#line 15
# Allow the domain to send to or receive from any port.
#line 15
# port_type is a type attribute for all port types.
#line 15
#
#line 15

#line 15
allow system_dbusd_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 15

#line 15

#line 15
# XXX Allow binding to any node type.  Remove once
#line 15
# individual rules have been added to all domains that 
#line 15
# bind sockets. 
#line 15
allow system_dbusd_t node_type:tcp_socket node_bind;
#line 15
#
#line 15
# Allow access to network files including /etc/resolv.conf
#line 15
#
#line 15
allow system_dbusd_t net_conf_t:file { read getattr lock ioctl };
#line 15

#line 15
allow system_dbusd_t self:tcp_socket { connect };
#line 15

#line 15
allow system_dbusd_t ldap_port_t:tcp_socket name_connect;
#line 15

#line 15

#line 15

#line 15
allow system_dbusd_t winbind_var_run_t:dir { getattr search };
#line 15
allow system_dbusd_t winbind_t:unix_stream_socket connectto;
#line 15
allow system_dbusd_t winbind_var_run_t:sock_file { getattr read write };
#line 15

#line 15

#line 15


# I expect we need more than this

allow initrc_t system_dbusd_t:dbus { send_msg acquire_svc };
allow initrc_t system_dbusd_t:unix_stream_socket connectto;
allow initrc_t system_dbusd_var_run_t:sock_file write;


#line 23
allow system_dbusd_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23

allow system_dbusd_t self:fifo_file { read write };
allow system_dbusd_t self:unix_stream_socket connectto;
allow system_dbusd_t self:unix_stream_socket connectto;
allow system_dbusd_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };
#line 1 "domains/program/dhcpc.te"
#DESC DHCPC - DHCP client
#
# Authors:  Wayne Salamon (NAI Labs) <wsalamon@tislabs.com>
#           Russell Coker <russell@coker.com.au>
# X-Debian-Packages: pump dhcp-client udhcpc
#

#################################
#
# Rules for the dhcpc_t domain.
#
# dhcpc_t is the domain for the client side of DHCP. dhcpcd, the DHCP 
# network configurator daemon started by /etc/sysconfig/network-scripts 
# rc scripts, runs in this domain.
# dhcpc_exec_t is the type of the dhcpcd executable.
# The dhcpc_t can be used for other DHCPC related files as well.
#

#line 18

#line 18

#line 18

#line 18
type dhcpc_t, domain, privlog, daemon , transitionbool;
#line 18
type dhcpc_exec_t, file_type, sysadmfile, exec_type;
#line 18
dontaudit dhcpc_t self:capability sys_tty_config;
#line 18

#line 18
role system_r types dhcpc_t;
#line 18

#line 18
# Inherit and use descriptors from init.
#line 18
allow dhcpc_t init_t:fd use;
#line 18
allow dhcpc_t init_t:process sigchld;
#line 18
allow dhcpc_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 18

#line 18

#line 18
allow dhcpc_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 18
allow dhcpc_t lib_t:lnk_file { read getattr lock ioctl };
#line 18
allow dhcpc_t ld_so_t:file { read getattr lock execute ioctl };
#line 18
#allow dhcpc_t ld_so_t:file execute_no_trans;
#line 18
allow dhcpc_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 18
allow dhcpc_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 18
allow dhcpc_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 18
allow dhcpc_t texrel_shlib_t:file execmod;
#line 18
allow dhcpc_t ld_so_cache_t:file { read getattr lock ioctl };
#line 18
allow dhcpc_t device_t:dir search;
#line 18
allow dhcpc_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18

#line 18
allow dhcpc_t { self proc_t }:dir { read getattr lock search ioctl };
#line 18
allow dhcpc_t { self proc_t }:lnk_file { getattr read };
#line 18

#line 18
allow dhcpc_t device_t:dir { read getattr lock search ioctl };
#line 18

#line 18
allow dhcpc_t udev_tdb_t:file { read getattr lock ioctl };
#line 18
allow dhcpc_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 18
dontaudit dhcpc_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 18
dontaudit dhcpc_t unpriv_userdomain:fd use;
#line 18

#line 18

#line 18
allow dhcpc_t sysfs_t:dir { read getattr lock search ioctl };
#line 18
allow dhcpc_t sysfs_t:file { read getattr lock ioctl };
#line 18
allow dhcpc_t sysfs_t:lnk_file { getattr read };
#line 18
 
#line 18

#line 18
allow dhcpc_t autofs_t:dir { search getattr };
#line 18

#line 18
dontaudit dhcpc_t { tty_device_t devpts_t }:chr_file { read write };
#line 18
dontaudit dhcpc_t root_t:file { getattr read };
#line 18
 
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
# Read system variables in /sys.
#line 18

#line 18
allow dhcpc_t sysctl_t:dir search;
#line 18
allow dhcpc_t sysctl_kernel_t:dir search;
#line 18
allow dhcpc_t sysctl_kernel_t:file { getattr read };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allows user to define a tunable to disable domain transition
#line 18
#
#line 18

#line 18
bool dhcpc_disable_trans false;
#line 18
if (dhcpc_disable_trans) {
#line 18

#line 18
allow initrc_t dhcpc_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 18

#line 18

#line 18
allow sysadm_t dhcpc_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 18

#line 18
} else {
#line 18
 
#line 18

#line 18

#line 18
#
#line 18
# Allow the process to transition to the new domain.
#line 18
#
#line 18
allow initrc_t dhcpc_t:process transition;
#line 18

#line 18
#
#line 18
# Do not audit when glibc secure mode is enabled upon the transition.
#line 18
#
#line 18
dontaudit initrc_t dhcpc_t:process noatsecure;
#line 18

#line 18
#
#line 18
# Do not audit when signal-related state is cleared upon the transition.
#line 18
#
#line 18
dontaudit initrc_t dhcpc_t:process siginh;
#line 18

#line 18
#
#line 18
# Do not audit when resource limits are reset upon the transition.
#line 18
#
#line 18
dontaudit initrc_t dhcpc_t:process rlimitinh;
#line 18

#line 18
#
#line 18
# Allow the process to execute the program.
#line 18
# 
#line 18
allow initrc_t dhcpc_exec_t:file { read { getattr execute } };
#line 18

#line 18
#
#line 18
# Allow the process to reap the new domain.
#line 18
#
#line 18
allow dhcpc_t initrc_t:process sigchld;
#line 18

#line 18
#
#line 18
# Allow the new domain to inherit and use file 
#line 18
# descriptions from the creating process and vice versa.
#line 18
#
#line 18
allow dhcpc_t initrc_t:fd use;
#line 18
allow initrc_t dhcpc_t:fd use;
#line 18

#line 18
#
#line 18
# Allow the new domain to write back to the old domain via a pipe.
#line 18
#
#line 18
allow dhcpc_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 18

#line 18
#
#line 18
# Allow the new domain to read and execute the program.
#line 18
#
#line 18
allow dhcpc_t dhcpc_exec_t:file { read getattr lock execute ioctl };
#line 18

#line 18
#
#line 18
# Allow the new domain to be entered via the program.
#line 18
#
#line 18
allow dhcpc_t dhcpc_exec_t:file entrypoint;
#line 18

#line 18
type_transition initrc_t dhcpc_exec_t:process dhcpc_t;
#line 18

#line 18

#line 18
allow initrc_t dhcpc_t:process { noatsecure siginh rlimitinh };
#line 18

#line 18
}
#line 18
 
#line 18
allow dhcpc_t privfd:fd use;
#line 18

#line 18
allow dhcpc_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18

#line 18
# Create pid file.
#line 18
allow dhcpc_t var_t:dir { getattr search };
#line 18

#line 18
type dhcpc_var_run_t, file_type, sysadmfile, pidfile;
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the process to modify the directory.
#line 18
#
#line 18
allow dhcpc_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 18

#line 18
#
#line 18
# Allow the process to create the file.
#line 18
#
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
allow dhcpc_t dhcpc_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
type_transition dhcpc_t var_run_t:file dhcpc_var_run_t;
#line 18

#line 18

#line 18

#line 18
allow dhcpc_t var_t:dir search;
#line 18
allow dhcpc_t dhcpc_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 18

#line 18

#line 18
allow dhcpc_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18
# for daemons that look at /root on startup
#line 18
dontaudit dhcpc_t sysadm_home_dir_t:dir search;
#line 18

#line 18
# for df
#line 18
allow dhcpc_t fs_type:filesystem getattr;
#line 18
allow dhcpc_t removable_t:filesystem getattr;
#line 18

#line 18

#line 18
allow dhcpc_t etc_t:lnk_file read;
#line 18
allow dhcpc_t lib_t:file { read getattr lock ioctl };
#line 18

#line 18
allow dhcpc_t locale_t:dir { read getattr lock search ioctl };
#line 18
allow dhcpc_t locale_t:file { read getattr lock ioctl };
#line 18
allow dhcpc_t locale_t:lnk_file { getattr read };
#line 18

#line 18

#line 18

#line 18
# for localization
#line 18
allow dhcpc_t lib_t:file { getattr read };
#line 18


# for SSP
allow dhcpc_t urandom_device_t:chr_file read;


#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use tcp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow dhcpc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow dhcpc_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow dhcpc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow dhcpc_t node_type:node { tcp_send rawip_send };
#line 23
allow dhcpc_t node_type:node { tcp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow dhcpc_t port_type:tcp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow dhcpc_t node_type:tcp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow dhcpc_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow dhcpc_t self:tcp_socket { listen accept };
#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use tcp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow dhcpc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow dhcpc_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow dhcpc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow dhcpc_t node_type:node { tcp_send rawip_send };
#line 23
allow dhcpc_t node_type:node { tcp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow dhcpc_t port_type:tcp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow dhcpc_t node_type:tcp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow dhcpc_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow dhcpc_t self:tcp_socket { connect };
#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use udp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow dhcpc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow dhcpc_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow dhcpc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow dhcpc_t node_type:node { udp_send rawip_send };
#line 23
allow dhcpc_t node_type:node { udp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow dhcpc_t port_type:udp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow dhcpc_t node_type:udp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow dhcpc_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow dhcpc_t self:udp_socket { connect };
#line 23

#line 23

#line 23

#line 23

#line 23

allow dhcpc_t port_type:tcp_socket name_connect;

#line 25

#line 25
if (allow_ypbind) {
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use tcp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow dhcpc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow dhcpc_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow dhcpc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow dhcpc_t node_type:node { tcp_send rawip_send };
#line 25
allow dhcpc_t node_type:node { tcp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow dhcpc_t port_type:tcp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow dhcpc_t node_type:tcp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow dhcpc_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow dhcpc_t self:tcp_socket { listen accept };
#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use tcp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow dhcpc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow dhcpc_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow dhcpc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow dhcpc_t node_type:node { tcp_send rawip_send };
#line 25
allow dhcpc_t node_type:node { tcp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow dhcpc_t port_type:tcp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow dhcpc_t node_type:tcp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow dhcpc_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow dhcpc_t self:tcp_socket { connect };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use udp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow dhcpc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow dhcpc_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow dhcpc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow dhcpc_t node_type:node { udp_send rawip_send };
#line 25
allow dhcpc_t node_type:node { udp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow dhcpc_t port_type:udp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow dhcpc_t node_type:udp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow dhcpc_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow dhcpc_t self:udp_socket { connect };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow dhcpc_t var_yp_t:dir { read getattr lock search ioctl };
#line 25
allow dhcpc_t var_yp_t:file { read getattr lock ioctl };
#line 25
allow dhcpc_t var_yp_t:lnk_file { getattr read };
#line 25

#line 25
allow dhcpc_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 25
allow dhcpc_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 25
dontaudit dhcpc_t self:capability net_bind_service;
#line 25
dontaudit dhcpc_t reserved_port_type:tcp_socket name_connect;
#line 25
dontaudit dhcpc_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 25

#line 25
} else {
#line 25
dontaudit dhcpc_t var_yp_t:dir search;
#line 25
}
#line 25
 
allow dhcpc_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow dhcpc_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow dhcpc_t self:fifo_file { ioctl read getattr lock write append };

allow dhcpc_t devpts_t:dir search;

# for localization
allow dhcpc_t lib_t:file { getattr read };

#line 37

#line 37

#line 37

#line 37

#line 37
#
#line 37
# Allow the process to transition to the new domain.
#line 37
#
#line 37
allow dhcpc_t consoletype_t:process transition;
#line 37

#line 37
#
#line 37
# Do not audit when glibc secure mode is enabled upon the transition.
#line 37
#
#line 37
dontaudit dhcpc_t consoletype_t:process noatsecure;
#line 37

#line 37
#
#line 37
# Do not audit when signal-related state is cleared upon the transition.
#line 37
#
#line 37
dontaudit dhcpc_t consoletype_t:process siginh;
#line 37

#line 37
#
#line 37
# Do not audit when resource limits are reset upon the transition.
#line 37
#
#line 37
dontaudit dhcpc_t consoletype_t:process rlimitinh;
#line 37

#line 37
#
#line 37
# Allow the process to execute the program.
#line 37
# 
#line 37
allow dhcpc_t consoletype_exec_t:file { read { getattr execute } };
#line 37

#line 37
#
#line 37
# Allow the process to reap the new domain.
#line 37
#
#line 37
allow consoletype_t dhcpc_t:process sigchld;
#line 37

#line 37
#
#line 37
# Allow the new domain to inherit and use file 
#line 37
# descriptions from the creating process and vice versa.
#line 37
#
#line 37
allow consoletype_t dhcpc_t:fd use;
#line 37
allow dhcpc_t consoletype_t:fd use;
#line 37

#line 37
#
#line 37
# Allow the new domain to write back to the old domain via a pipe.
#line 37
#
#line 37
allow consoletype_t dhcpc_t:fifo_file { ioctl read getattr lock write append };
#line 37

#line 37
#
#line 37
# Allow the new domain to read and execute the program.
#line 37
#
#line 37
allow consoletype_t consoletype_exec_t:file { read getattr lock execute ioctl };
#line 37

#line 37
#
#line 37
# Allow the new domain to be entered via the program.
#line 37
#
#line 37
allow consoletype_t consoletype_exec_t:file entrypoint;
#line 37

#line 37
type_transition dhcpc_t consoletype_exec_t:process consoletype_t;
#line 37

#line 37

#line 41

#line 41

#line 41

#line 41

#line 41
#
#line 41
# Allow the process to transition to the new domain.
#line 41
#
#line 41
allow dhcpc_t nscd_t:process transition;
#line 41

#line 41
#
#line 41
# Do not audit when glibc secure mode is enabled upon the transition.
#line 41
#
#line 41
dontaudit dhcpc_t nscd_t:process noatsecure;
#line 41

#line 41
#
#line 41
# Do not audit when signal-related state is cleared upon the transition.
#line 41
#
#line 41
dontaudit dhcpc_t nscd_t:process siginh;
#line 41

#line 41
#
#line 41
# Do not audit when resource limits are reset upon the transition.
#line 41
#
#line 41
dontaudit dhcpc_t nscd_t:process rlimitinh;
#line 41

#line 41
#
#line 41
# Allow the process to execute the program.
#line 41
# 
#line 41
allow dhcpc_t nscd_exec_t:file { read { getattr execute } };
#line 41

#line 41
#
#line 41
# Allow the process to reap the new domain.
#line 41
#
#line 41
allow nscd_t dhcpc_t:process sigchld;
#line 41

#line 41
#
#line 41
# Allow the new domain to inherit and use file 
#line 41
# descriptions from the creating process and vice versa.
#line 41
#
#line 41
allow nscd_t dhcpc_t:fd use;
#line 41
allow dhcpc_t nscd_t:fd use;
#line 41

#line 41
#
#line 41
# Allow the new domain to write back to the old domain via a pipe.
#line 41
#
#line 41
allow nscd_t dhcpc_t:fifo_file { ioctl read getattr lock write append };
#line 41

#line 41
#
#line 41
# Allow the new domain to read and execute the program.
#line 41
#
#line 41
allow nscd_t nscd_exec_t:file { read getattr lock execute ioctl };
#line 41

#line 41
#
#line 41
# Allow the new domain to be entered via the program.
#line 41
#
#line 41
allow nscd_t nscd_exec_t:file entrypoint;
#line 41

#line 41
type_transition dhcpc_t nscd_exec_t:process nscd_t;
#line 41

#line 41
allow dhcpc_t nscd_var_run_t:file { getattr read };
#line 41

#line 48

#line 48

#line 48

#line 48

#line 48
#
#line 48
# Allow the process to transition to the new domain.
#line 48
#
#line 48
allow cardmgr_t dhcpc_t:process transition;
#line 48

#line 48
#
#line 48
# Do not audit when glibc secure mode is enabled upon the transition.
#line 48
#
#line 48
dontaudit cardmgr_t dhcpc_t:process noatsecure;
#line 48

#line 48
#
#line 48
# Do not audit when signal-related state is cleared upon the transition.
#line 48
#
#line 48
dontaudit cardmgr_t dhcpc_t:process siginh;
#line 48

#line 48
#
#line 48
# Do not audit when resource limits are reset upon the transition.
#line 48
#
#line 48
dontaudit cardmgr_t dhcpc_t:process rlimitinh;
#line 48

#line 48
#
#line 48
# Allow the process to execute the program.
#line 48
# 
#line 48
allow cardmgr_t dhcpc_exec_t:file { read { getattr execute } };
#line 48

#line 48
#
#line 48
# Allow the process to reap the new domain.
#line 48
#
#line 48
allow dhcpc_t cardmgr_t:process sigchld;
#line 48

#line 48
#
#line 48
# Allow the new domain to inherit and use file 
#line 48
# descriptions from the creating process and vice versa.
#line 48
#
#line 48
allow dhcpc_t cardmgr_t:fd use;
#line 48
allow cardmgr_t dhcpc_t:fd use;
#line 48

#line 48
#
#line 48
# Allow the new domain to write back to the old domain via a pipe.
#line 48
#
#line 48
allow dhcpc_t cardmgr_t:fifo_file { ioctl read getattr lock write append };
#line 48

#line 48
#
#line 48
# Allow the new domain to read and execute the program.
#line 48
#
#line 48
allow dhcpc_t dhcpc_exec_t:file { read getattr lock execute ioctl };
#line 48

#line 48
#
#line 48
# Allow the new domain to be entered via the program.
#line 48
#
#line 48
allow dhcpc_t dhcpc_exec_t:file entrypoint;
#line 48

#line 48
type_transition cardmgr_t dhcpc_exec_t:process dhcpc_t;
#line 48

#line 48
allow cardmgr_t dhcpc_var_run_t:file { getattr read };
#line 48
allow cardmgr_t dhcpc_t:process { sigchld sigkill sigstop signull signal };
#line 48
allow cardmgr_t dhcpc_var_run_t:file unlink;
#line 48
allow dhcpc_t cardmgr_dev_t:chr_file { read write };
#line 48

#line 58

#line 58

#line 58

#line 58

#line 58
#
#line 58
# Allow the process to transition to the new domain.
#line 58
#
#line 58
allow hotplug_t dhcpc_t:process transition;
#line 58

#line 58
#
#line 58
# Do not audit when glibc secure mode is enabled upon the transition.
#line 58
#
#line 58
dontaudit hotplug_t dhcpc_t:process noatsecure;
#line 58

#line 58
#
#line 58
# Do not audit when signal-related state is cleared upon the transition.
#line 58
#
#line 58
dontaudit hotplug_t dhcpc_t:process siginh;
#line 58

#line 58
#
#line 58
# Do not audit when resource limits are reset upon the transition.
#line 58
#
#line 58
dontaudit hotplug_t dhcpc_t:process rlimitinh;
#line 58

#line 58
#
#line 58
# Allow the process to execute the program.
#line 58
# 
#line 58
allow hotplug_t dhcpc_exec_t:file { read { getattr execute } };
#line 58

#line 58
#
#line 58
# Allow the process to reap the new domain.
#line 58
#
#line 58
allow dhcpc_t hotplug_t:process sigchld;
#line 58

#line 58
#
#line 58
# Allow the new domain to inherit and use file 
#line 58
# descriptions from the creating process and vice versa.
#line 58
#
#line 58
allow dhcpc_t hotplug_t:fd use;
#line 58
allow hotplug_t dhcpc_t:fd use;
#line 58

#line 58
#
#line 58
# Allow the new domain to write back to the old domain via a pipe.
#line 58
#
#line 58
allow dhcpc_t hotplug_t:fifo_file { ioctl read getattr lock write append };
#line 58

#line 58
#
#line 58
# Allow the new domain to read and execute the program.
#line 58
#
#line 58
allow dhcpc_t dhcpc_exec_t:file { read getattr lock execute ioctl };
#line 58

#line 58
#
#line 58
# Allow the new domain to be entered via the program.
#line 58
#
#line 58
allow dhcpc_t dhcpc_exec_t:file entrypoint;
#line 58

#line 58
type_transition hotplug_t dhcpc_exec_t:process dhcpc_t;
#line 58

#line 58
allow hotplug_t dhcpc_t:process { sigchld sigkill sigstop signull signal };
#line 58
allow hotplug_t dhcpc_var_run_t:file { getattr read };
#line 58
allow hotplug_t dhcp_etc_t:file { ioctl read getattr lock write append };
#line 58
allow dhcpc_t hotplug_etc_t:dir { getattr search };
#line 58

#line 58

#line 58

#line 58

#line 58
#
#line 58
# Allow the process to transition to the new domain.
#line 58
#
#line 58
allow dhcpc_t syslogd_t:process transition;
#line 58

#line 58
#
#line 58
# Do not audit when glibc secure mode is enabled upon the transition.
#line 58
#
#line 58
dontaudit dhcpc_t syslogd_t:process noatsecure;
#line 58

#line 58
#
#line 58
# Do not audit when signal-related state is cleared upon the transition.
#line 58
#
#line 58
dontaudit dhcpc_t syslogd_t:process siginh;
#line 58

#line 58
#
#line 58
# Do not audit when resource limits are reset upon the transition.
#line 58
#
#line 58
dontaudit dhcpc_t syslogd_t:process rlimitinh;
#line 58

#line 58
#
#line 58
# Allow the process to execute the program.
#line 58
# 
#line 58
allow dhcpc_t syslogd_exec_t:file { read { getattr execute } };
#line 58

#line 58
#
#line 58
# Allow the process to reap the new domain.
#line 58
#
#line 58
allow syslogd_t dhcpc_t:process sigchld;
#line 58

#line 58
#
#line 58
# Allow the new domain to inherit and use file 
#line 58
# descriptions from the creating process and vice versa.
#line 58
#
#line 58
allow syslogd_t dhcpc_t:fd use;
#line 58
allow dhcpc_t syslogd_t:fd use;
#line 58

#line 58
#
#line 58
# Allow the new domain to write back to the old domain via a pipe.
#line 58
#
#line 58
allow syslogd_t dhcpc_t:fifo_file { ioctl read getattr lock write append };
#line 58

#line 58
#
#line 58
# Allow the new domain to read and execute the program.
#line 58
#
#line 58
allow syslogd_t syslogd_exec_t:file { read getattr lock execute ioctl };
#line 58

#line 58
#
#line 58
# Allow the new domain to be entered via the program.
#line 58
#
#line 58
allow syslogd_t syslogd_exec_t:file entrypoint;
#line 58

#line 58
type_transition dhcpc_t syslogd_exec_t:process syslogd_t;
#line 58

#line 58


# for the dhcp client to run ping to check IP addresses
#line 72

#line 72

#line 72

#line 72

#line 72
#
#line 72
# Allow the process to transition to the new domain.
#line 72
#
#line 72
allow dhcpc_t ping_t:process transition;
#line 72

#line 72
#
#line 72
# Do not audit when glibc secure mode is enabled upon the transition.
#line 72
#
#line 72
dontaudit dhcpc_t ping_t:process noatsecure;
#line 72

#line 72
#
#line 72
# Do not audit when signal-related state is cleared upon the transition.
#line 72
#
#line 72
dontaudit dhcpc_t ping_t:process siginh;
#line 72

#line 72
#
#line 72
# Do not audit when resource limits are reset upon the transition.
#line 72
#
#line 72
dontaudit dhcpc_t ping_t:process rlimitinh;
#line 72

#line 72
#
#line 72
# Allow the process to execute the program.
#line 72
# 
#line 72
allow dhcpc_t ping_exec_t:file { read { getattr execute } };
#line 72

#line 72
#
#line 72
# Allow the process to reap the new domain.
#line 72
#
#line 72
allow ping_t dhcpc_t:process sigchld;
#line 72

#line 72
#
#line 72
# Allow the new domain to inherit and use file 
#line 72
# descriptions from the creating process and vice versa.
#line 72
#
#line 72
allow ping_t dhcpc_t:fd use;
#line 72
allow dhcpc_t ping_t:fd use;
#line 72

#line 72
#
#line 72
# Allow the new domain to write back to the old domain via a pipe.
#line 72
#
#line 72
allow ping_t dhcpc_t:fifo_file { ioctl read getattr lock write append };
#line 72

#line 72
#
#line 72
# Allow the new domain to read and execute the program.
#line 72
#
#line 72
allow ping_t ping_exec_t:file { read getattr lock execute ioctl };
#line 72

#line 72
#
#line 72
# Allow the new domain to be entered via the program.
#line 72
#
#line 72
allow ping_t ping_exec_t:file entrypoint;
#line 72

#line 72
type_transition dhcpc_t ping_exec_t:process ping_t;
#line 72

#line 72

#line 72
allow ping_t hotplug_t:fd use;
#line 72
 
#line 72
allow ping_t cardmgr_t:fd use;
#line 72
  
#line 77

type dhcpc_state_t, file_type, sysadmfile;

allow dhcpc_t etc_t:lnk_file read;
allow dhcpc_t { etc_t etc_runtime_t }:file { getattr read };
allow dhcpc_t proc_net_t:dir search;
allow dhcpc_t { proc_t proc_net_t }:file { getattr read };
allow dhcpc_t self:file { getattr read };

#line 85
# Read system variables in /sys.
#line 85

#line 85
allow dhcpc_t sysctl_t:dir search;
#line 85
allow dhcpc_t sysctl_kernel_t:dir search;
#line 85
allow dhcpc_t sysctl_kernel_t:file { getattr read };
#line 85

#line 85

#line 85

allow dhcpc_t userdomain:fd use;
#line 89


# Use capabilities
allow dhcpc_t self:capability { dac_override fsetid net_admin net_raw net_bind_service sys_resource sys_tty_config };

# for access("/etc/bashrc", X_OK) on Red Hat
dontaudit dhcpc_t self:capability { dac_read_search sys_module };

# for udp port 68
allow dhcpc_t dhcpc_port_t:udp_socket name_bind;

# Allow read/write to /etc/resolv.conf and /etc/ntp.conf. Note that any files
# in /etc created by dhcpcd will be labelled net_conf_t.

#line 102

#line 102

#line 102

#line 102
#
#line 102
# Allow the process to modify the directory.
#line 102
#
#line 102
allow dhcpc_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 102

#line 102
#
#line 102
# Allow the process to create the file.
#line 102
#
#line 102

#line 102

#line 102

#line 102

#line 102

#line 102
allow dhcpc_t net_conf_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 102

#line 102

#line 102

#line 102

#line 102

#line 102

#line 102

#line 102

#line 102

#line 102
type_transition dhcpc_t etc_t:file net_conf_t;
#line 102

#line 102


# Allow access to the dhcpc file types

#line 105
allow dhcpc_t dhcp_etc_t:dir { read getattr lock search ioctl };
#line 105
allow dhcpc_t dhcp_etc_t:file { read getattr lock ioctl };
#line 105
allow dhcpc_t dhcp_etc_t:lnk_file { getattr read };
#line 105

allow dhcpc_t sbin_t:dir search;

#line 107
allow dhcpc_t { dhcpc_exec_t dhcp_etc_t sbin_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 107

#line 111

#line 111

#line 111
allow dhcpc_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 111

#line 111
allow initrc_t dhcp_etc_t:file { ioctl read getattr lock write append };
#line 111

#line 114

#line 114

#line 114

#line 114

#line 114
#
#line 114
# Allow the process to transition to the new domain.
#line 114
#
#line 114
allow dhcpc_t ifconfig_t:process transition;
#line 114

#line 114
#
#line 114
# Do not audit when glibc secure mode is enabled upon the transition.
#line 114
#
#line 114
dontaudit dhcpc_t ifconfig_t:process noatsecure;
#line 114

#line 114
#
#line 114
# Do not audit when signal-related state is cleared upon the transition.
#line 114
#
#line 114
dontaudit dhcpc_t ifconfig_t:process siginh;
#line 114

#line 114
#
#line 114
# Do not audit when resource limits are reset upon the transition.
#line 114
#
#line 114
dontaudit dhcpc_t ifconfig_t:process rlimitinh;
#line 114

#line 114
#
#line 114
# Allow the process to execute the program.
#line 114
# 
#line 114
allow dhcpc_t ifconfig_exec_t:file { read { getattr execute } };
#line 114

#line 114
#
#line 114
# Allow the process to reap the new domain.
#line 114
#
#line 114
allow ifconfig_t dhcpc_t:process sigchld;
#line 114

#line 114
#
#line 114
# Allow the new domain to inherit and use file 
#line 114
# descriptions from the creating process and vice versa.
#line 114
#
#line 114
allow ifconfig_t dhcpc_t:fd use;
#line 114
allow dhcpc_t ifconfig_t:fd use;
#line 114

#line 114
#
#line 114
# Allow the new domain to write back to the old domain via a pipe.
#line 114
#
#line 114
allow ifconfig_t dhcpc_t:fifo_file { ioctl read getattr lock write append };
#line 114

#line 114
#
#line 114
# Allow the new domain to read and execute the program.
#line 114
#
#line 114
allow ifconfig_t ifconfig_exec_t:file { read getattr lock execute ioctl };
#line 114

#line 114
#
#line 114
# Allow the new domain to be entered via the program.
#line 114
#
#line 114
allow ifconfig_t ifconfig_exec_t:file entrypoint;
#line 114

#line 114
type_transition dhcpc_t ifconfig_exec_t:process ifconfig_t;
#line 114




#line 117
type dhcpc_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 117

#line 117

#line 117

#line 117

#line 117
#
#line 117
# Allow the process to modify the directory.
#line 117
#
#line 117
allow dhcpc_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 117

#line 117
#
#line 117
# Allow the process to create the file.
#line 117
#
#line 117

#line 117

#line 117

#line 117

#line 117

#line 117
allow dhcpc_t dhcpc_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 117

#line 117

#line 117

#line 117

#line 117

#line 117

#line 117
allow dhcpc_t dhcpc_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 117

#line 117

#line 117

#line 117

#line 117

#line 117

#line 117

#line 117

#line 117

#line 117

#line 117

#line 117
type_transition dhcpc_t tmp_t:{ file dir } dhcpc_tmp_t;
#line 117

#line 117

#line 117


# Allow dhcpc_t to use packet sockets
allow dhcpc_t self:packet_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow dhcpc_t var_lib_t:dir search;

#line 122

#line 122

#line 122

#line 122
#
#line 122
# Allow the process to modify the directory.
#line 122
#
#line 122
allow dhcpc_t dhcp_state_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 122

#line 122
#
#line 122
# Allow the process to create the file.
#line 122
#
#line 122

#line 122

#line 122

#line 122

#line 122

#line 122
allow dhcpc_t dhcpc_state_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122
type_transition dhcpc_t dhcp_state_t:file dhcpc_state_t;
#line 122

#line 122


#line 123
allow dhcpc_t dhcpc_state_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 123
allow dhcpc_t dhcpc_state_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 123
allow dhcpc_t dhcpc_state_t:lnk_file { create read getattr setattr link unlink rename };
#line 123

allow dhcpc_t dhcp_state_t:file { getattr read };

allow dhcpc_t bin_t:dir { getattr search };
allow dhcpc_t bin_t:lnk_file read;

#line 128
allow dhcpc_t { bin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 128


#line 132

#line 132

#line 132

#line 132

#line 132
#
#line 132
# Allow the process to transition to the new domain.
#line 132
#
#line 132
allow dhcpc_t hostname_t:process transition;
#line 132

#line 132
#
#line 132
# Do not audit when glibc secure mode is enabled upon the transition.
#line 132
#
#line 132
dontaudit dhcpc_t hostname_t:process noatsecure;
#line 132

#line 132
#
#line 132
# Do not audit when signal-related state is cleared upon the transition.
#line 132
#
#line 132
dontaudit dhcpc_t hostname_t:process siginh;
#line 132

#line 132
#
#line 132
# Do not audit when resource limits are reset upon the transition.
#line 132
#
#line 132
dontaudit dhcpc_t hostname_t:process rlimitinh;
#line 132

#line 132
#
#line 132
# Allow the process to execute the program.
#line 132
# 
#line 132
allow dhcpc_t hostname_exec_t:file { read { getattr execute } };
#line 132

#line 132
#
#line 132
# Allow the process to reap the new domain.
#line 132
#
#line 132
allow hostname_t dhcpc_t:process sigchld;
#line 132

#line 132
#
#line 132
# Allow the new domain to inherit and use file 
#line 132
# descriptions from the creating process and vice versa.
#line 132
#
#line 132
allow hostname_t dhcpc_t:fd use;
#line 132
allow dhcpc_t hostname_t:fd use;
#line 132

#line 132
#
#line 132
# Allow the new domain to write back to the old domain via a pipe.
#line 132
#
#line 132
allow hostname_t dhcpc_t:fifo_file { ioctl read getattr lock write append };
#line 132

#line 132
#
#line 132
# Allow the new domain to read and execute the program.
#line 132
#
#line 132
allow hostname_t hostname_exec_t:file { read getattr lock execute ioctl };
#line 132

#line 132
#
#line 132
# Allow the new domain to be entered via the program.
#line 132
#
#line 132
allow hostname_t hostname_exec_t:file entrypoint;
#line 132

#line 132
type_transition dhcpc_t hostname_exec_t:process hostname_t;
#line 132

#line 132

dontaudit dhcpc_t { devpts_t ttyfile ptyfile tty_device_t }:chr_file { ioctl read getattr lock write append };
allow dhcpc_t { userdomain kernel_t }:fd use;

allow dhcpc_t home_root_t:dir search;
allow initrc_t dhcpc_state_t:file { getattr read };
dontaudit dhcpc_t var_lock_t:dir search;
allow dhcpc_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
dontaudit dhcpc_t domain:dir getattr;
allow dhcpc_t initrc_var_run_t:file { ioctl read getattr lock write append };
#
# dhclient sometimes starts ypbind and ntdp
#

#line 145
allow dhcpc_t initrc_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 145

#line 150

#line 150

#line 150

#line 150

#line 150
#
#line 150
# Allow the process to transition to the new domain.
#line 150
#
#line 150
allow dhcpc_t ypbind_t:process transition;
#line 150

#line 150
#
#line 150
# Do not audit when glibc secure mode is enabled upon the transition.
#line 150
#
#line 150
dontaudit dhcpc_t ypbind_t:process noatsecure;
#line 150

#line 150
#
#line 150
# Do not audit when signal-related state is cleared upon the transition.
#line 150
#
#line 150
dontaudit dhcpc_t ypbind_t:process siginh;
#line 150

#line 150
#
#line 150
# Do not audit when resource limits are reset upon the transition.
#line 150
#
#line 150
dontaudit dhcpc_t ypbind_t:process rlimitinh;
#line 150

#line 150
#
#line 150
# Allow the process to execute the program.
#line 150
# 
#line 150
allow dhcpc_t ypbind_exec_t:file { read { getattr execute } };
#line 150

#line 150
#
#line 150
# Allow the process to reap the new domain.
#line 150
#
#line 150
allow ypbind_t dhcpc_t:process sigchld;
#line 150

#line 150
#
#line 150
# Allow the new domain to inherit and use file 
#line 150
# descriptions from the creating process and vice versa.
#line 150
#
#line 150
allow ypbind_t dhcpc_t:fd use;
#line 150
allow dhcpc_t ypbind_t:fd use;
#line 150

#line 150
#
#line 150
# Allow the new domain to write back to the old domain via a pipe.
#line 150
#
#line 150
allow ypbind_t dhcpc_t:fifo_file { ioctl read getattr lock write append };
#line 150

#line 150
#
#line 150
# Allow the new domain to read and execute the program.
#line 150
#
#line 150
allow ypbind_t ypbind_exec_t:file { read getattr lock execute ioctl };
#line 150

#line 150
#
#line 150
# Allow the new domain to be entered via the program.
#line 150
#
#line 150
allow ypbind_t ypbind_exec_t:file entrypoint;
#line 150

#line 150
type_transition dhcpc_t ypbind_exec_t:process ypbind_t;
#line 150

#line 150
allow dhcpc_t ypbind_var_run_t:file { { read getattr lock ioctl } unlink };
#line 150
allow dhcpc_t ypbind_t:process signal;
#line 150

#line 153

#line 153

#line 153

#line 153

#line 153
#
#line 153
# Allow the process to transition to the new domain.
#line 153
#
#line 153
allow dhcpc_t ntpd_t:process transition;
#line 153

#line 153
#
#line 153
# Do not audit when glibc secure mode is enabled upon the transition.
#line 153
#
#line 153
dontaudit dhcpc_t ntpd_t:process noatsecure;
#line 153

#line 153
#
#line 153
# Do not audit when signal-related state is cleared upon the transition.
#line 153
#
#line 153
dontaudit dhcpc_t ntpd_t:process siginh;
#line 153

#line 153
#
#line 153
# Do not audit when resource limits are reset upon the transition.
#line 153
#
#line 153
dontaudit dhcpc_t ntpd_t:process rlimitinh;
#line 153

#line 153
#
#line 153
# Allow the process to execute the program.
#line 153
# 
#line 153
allow dhcpc_t ntpd_exec_t:file { read { getattr execute } };
#line 153

#line 153
#
#line 153
# Allow the process to reap the new domain.
#line 153
#
#line 153
allow ntpd_t dhcpc_t:process sigchld;
#line 153

#line 153
#
#line 153
# Allow the new domain to inherit and use file 
#line 153
# descriptions from the creating process and vice versa.
#line 153
#
#line 153
allow ntpd_t dhcpc_t:fd use;
#line 153
allow dhcpc_t ntpd_t:fd use;
#line 153

#line 153
#
#line 153
# Allow the new domain to write back to the old domain via a pipe.
#line 153
#
#line 153
allow ntpd_t dhcpc_t:fifo_file { ioctl read getattr lock write append };
#line 153

#line 153
#
#line 153
# Allow the new domain to read and execute the program.
#line 153
#
#line 153
allow ntpd_t ntpd_exec_t:file { read getattr lock execute ioctl };
#line 153

#line 153
#
#line 153
# Allow the new domain to be entered via the program.
#line 153
#
#line 153
allow ntpd_t ntpd_exec_t:file entrypoint;
#line 153

#line 153
type_transition dhcpc_t ntpd_exec_t:process ntpd_t;
#line 153

#line 153

role sysadm_r types dhcpc_t;

#line 155

#line 155

#line 155
#
#line 155
# Allow the process to transition to the new domain.
#line 155
#
#line 155
allow sysadm_t dhcpc_t:process transition;
#line 155

#line 155
#
#line 155
# Do not audit when glibc secure mode is enabled upon the transition.
#line 155
#
#line 155
dontaudit sysadm_t dhcpc_t:process noatsecure;
#line 155

#line 155
#
#line 155
# Do not audit when signal-related state is cleared upon the transition.
#line 155
#
#line 155
dontaudit sysadm_t dhcpc_t:process siginh;
#line 155

#line 155
#
#line 155
# Do not audit when resource limits are reset upon the transition.
#line 155
#
#line 155
dontaudit sysadm_t dhcpc_t:process rlimitinh;
#line 155

#line 155
#
#line 155
# Allow the process to execute the program.
#line 155
# 
#line 155
allow sysadm_t dhcpc_exec_t:file { read { getattr execute } };
#line 155

#line 155
#
#line 155
# Allow the process to reap the new domain.
#line 155
#
#line 155
allow dhcpc_t sysadm_t:process sigchld;
#line 155

#line 155
#
#line 155
# Allow the new domain to inherit and use file 
#line 155
# descriptions from the creating process and vice versa.
#line 155
#
#line 155
allow dhcpc_t sysadm_t:fd use;
#line 155
allow sysadm_t dhcpc_t:fd use;
#line 155

#line 155
#
#line 155
# Allow the new domain to write back to the old domain via a pipe.
#line 155
#
#line 155
allow dhcpc_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 155

#line 155
#
#line 155
# Allow the new domain to read and execute the program.
#line 155
#
#line 155
allow dhcpc_t dhcpc_exec_t:file { read getattr lock execute ioctl };
#line 155

#line 155
#
#line 155
# Allow the new domain to be entered via the program.
#line 155
#
#line 155
allow dhcpc_t dhcpc_exec_t:file entrypoint;
#line 155

#line 155
type_transition sysadm_t dhcpc_exec_t:process dhcpc_t;
#line 155

#line 167

#line 167

#line 167

#line 167

#line 167
# Derived type used for connection
#line 167
type dhcpc_dbusd_system_t;
#line 167
type_change dhcpc_t system_dbusd_t:dbus dhcpc_dbusd_system_t;
#line 167

#line 167
# SE-DBus specific permissions
#line 167
allow dhcpc_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 167

#line 167
# For connecting to the bus
#line 167
allow dhcpc_t system_dbusd_t:unix_stream_socket connectto;
#line 167

#line 167

#line 167
allow { dhcpc_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 167
allow { dhcpc_t } system_dbusd_var_run_t:sock_file write;
#line 167
  
#line 167

#line 167

#line 167

#line 167
#
#line 167
# Allow the process to transition to the new domain.
#line 167
#
#line 167
allow system_dbusd_t dhcpc_t:process transition;
#line 167

#line 167
#
#line 167
# Do not audit when glibc secure mode is enabled upon the transition.
#line 167
#
#line 167
dontaudit system_dbusd_t dhcpc_t:process noatsecure;
#line 167

#line 167
#
#line 167
# Do not audit when signal-related state is cleared upon the transition.
#line 167
#
#line 167
dontaudit system_dbusd_t dhcpc_t:process siginh;
#line 167

#line 167
#
#line 167
# Do not audit when resource limits are reset upon the transition.
#line 167
#
#line 167
dontaudit system_dbusd_t dhcpc_t:process rlimitinh;
#line 167

#line 167
#
#line 167
# Allow the process to execute the program.
#line 167
# 
#line 167
allow system_dbusd_t dhcpc_exec_t:file { read { getattr execute } };
#line 167

#line 167
#
#line 167
# Allow the process to reap the new domain.
#line 167
#
#line 167
allow dhcpc_t system_dbusd_t:process sigchld;
#line 167

#line 167
#
#line 167
# Allow the new domain to inherit and use file 
#line 167
# descriptions from the creating process and vice versa.
#line 167
#
#line 167
allow dhcpc_t system_dbusd_t:fd use;
#line 167
allow system_dbusd_t dhcpc_t:fd use;
#line 167

#line 167
#
#line 167
# Allow the new domain to write back to the old domain via a pipe.
#line 167
#
#line 167
allow dhcpc_t system_dbusd_t:fifo_file { ioctl read getattr lock write append };
#line 167

#line 167
#
#line 167
# Allow the new domain to read and execute the program.
#line 167
#
#line 167
allow dhcpc_t dhcpc_exec_t:file { read getattr lock execute ioctl };
#line 167

#line 167
#
#line 167
# Allow the new domain to be entered via the program.
#line 167
#
#line 167
allow dhcpc_t dhcpc_exec_t:file entrypoint;
#line 167

#line 167
type_transition system_dbusd_t dhcpc_exec_t:process dhcpc_t;
#line 167

#line 167
allow dhcpc_t system_dbusd_t:dbus { acquire_svc send_msg };
#line 167
allow dhcpc_t self:dbus send_msg;
#line 167
allow { NetworkManager_t initrc_t } dhcpc_t:dbus send_msg;
#line 167
allow dhcpc_t { NetworkManager_t initrc_t }:dbus send_msg;
#line 167


#line 168

#line 168

#line 168
#
#line 168
# Allow the process to transition to the new domain.
#line 168
#
#line 168
allow dhcpc_t netutils_t:process transition;
#line 168

#line 168
#
#line 168
# Do not audit when glibc secure mode is enabled upon the transition.
#line 168
#
#line 168
dontaudit dhcpc_t netutils_t:process noatsecure;
#line 168

#line 168
#
#line 168
# Do not audit when signal-related state is cleared upon the transition.
#line 168
#
#line 168
dontaudit dhcpc_t netutils_t:process siginh;
#line 168

#line 168
#
#line 168
# Do not audit when resource limits are reset upon the transition.
#line 168
#
#line 168
dontaudit dhcpc_t netutils_t:process rlimitinh;
#line 168

#line 168
#
#line 168
# Allow the process to execute the program.
#line 168
# 
#line 168
allow dhcpc_t netutils_exec_t:file { read { getattr execute } };
#line 168

#line 168
#
#line 168
# Allow the process to reap the new domain.
#line 168
#
#line 168
allow netutils_t dhcpc_t:process sigchld;
#line 168

#line 168
#
#line 168
# Allow the new domain to inherit and use file 
#line 168
# descriptions from the creating process and vice versa.
#line 168
#
#line 168
allow netutils_t dhcpc_t:fd use;
#line 168
allow dhcpc_t netutils_t:fd use;
#line 168

#line 168
#
#line 168
# Allow the new domain to write back to the old domain via a pipe.
#line 168
#
#line 168
allow netutils_t dhcpc_t:fifo_file { ioctl read getattr lock write append };
#line 168

#line 168
#
#line 168
# Allow the new domain to read and execute the program.
#line 168
#
#line 168
allow netutils_t netutils_exec_t:file { read getattr lock execute ioctl };
#line 168

#line 168
#
#line 168
# Allow the new domain to be entered via the program.
#line 168
#
#line 168
allow netutils_t netutils_exec_t:file entrypoint;
#line 168

#line 168
type_transition dhcpc_t netutils_exec_t:process netutils_t;
#line 168

allow dhcpc_t locale_t:file write;
#line 1 "domains/program/dhcpd.te"
#DESC DHCPD - DHCP server
#
# Author: Russell Coker <russell@coker.com.au> 
# based on the dhcpc_t policy from:
#          Wayne Salamon (NAI Labs) <wsalamon@tislabs.com>
# X-Debian-Packages: dhcp dhcp3-server 
#

#################################
#
# Rules for the dhcpd_t domain.
#
# dhcpd_t is the domain for the server side of DHCP. dhcpd, the DHCP 
# server daemon rc scripts, runs in this domain.
# dhcpd_exec_t is the type of the dhcpdd executable.
# The dhcpd_t can be used for other DHCPC related files as well.
#

#line 18

#line 18

#line 18

#line 18
type dhcpd_t, domain, privlog, daemon , nscd_client_domain, transitionbool;
#line 18
type dhcpd_exec_t, file_type, sysadmfile, exec_type;
#line 18
dontaudit dhcpd_t self:capability sys_tty_config;
#line 18

#line 18
role system_r types dhcpd_t;
#line 18

#line 18
# Inherit and use descriptors from init.
#line 18
allow dhcpd_t init_t:fd use;
#line 18
allow dhcpd_t init_t:process sigchld;
#line 18
allow dhcpd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 18

#line 18

#line 18
allow dhcpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 18
allow dhcpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 18
allow dhcpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 18
#allow dhcpd_t ld_so_t:file execute_no_trans;
#line 18
allow dhcpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 18
allow dhcpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 18
allow dhcpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 18
allow dhcpd_t texrel_shlib_t:file execmod;
#line 18
allow dhcpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 18
allow dhcpd_t device_t:dir search;
#line 18
allow dhcpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18

#line 18
allow dhcpd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 18
allow dhcpd_t { self proc_t }:lnk_file { getattr read };
#line 18

#line 18
allow dhcpd_t device_t:dir { read getattr lock search ioctl };
#line 18

#line 18
allow dhcpd_t udev_tdb_t:file { read getattr lock ioctl };
#line 18
allow dhcpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 18
dontaudit dhcpd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 18
dontaudit dhcpd_t unpriv_userdomain:fd use;
#line 18

#line 18

#line 18
allow dhcpd_t sysfs_t:dir { read getattr lock search ioctl };
#line 18
allow dhcpd_t sysfs_t:file { read getattr lock ioctl };
#line 18
allow dhcpd_t sysfs_t:lnk_file { getattr read };
#line 18
 
#line 18

#line 18
allow dhcpd_t autofs_t:dir { search getattr };
#line 18

#line 18
dontaudit dhcpd_t { tty_device_t devpts_t }:chr_file { read write };
#line 18
dontaudit dhcpd_t root_t:file { getattr read };
#line 18
 
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
# Read system variables in /sys.
#line 18

#line 18
allow dhcpd_t sysctl_t:dir search;
#line 18
allow dhcpd_t sysctl_kernel_t:dir search;
#line 18
allow dhcpd_t sysctl_kernel_t:file { getattr read };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allows user to define a tunable to disable domain transition
#line 18
#
#line 18

#line 18
bool dhcpd_disable_trans false;
#line 18
if (dhcpd_disable_trans) {
#line 18

#line 18
allow initrc_t dhcpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 18

#line 18

#line 18
allow sysadm_t dhcpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 18

#line 18
} else {
#line 18
 
#line 18

#line 18

#line 18
#
#line 18
# Allow the process to transition to the new domain.
#line 18
#
#line 18
allow initrc_t dhcpd_t:process transition;
#line 18

#line 18
#
#line 18
# Do not audit when glibc secure mode is enabled upon the transition.
#line 18
#
#line 18
dontaudit initrc_t dhcpd_t:process noatsecure;
#line 18

#line 18
#
#line 18
# Do not audit when signal-related state is cleared upon the transition.
#line 18
#
#line 18
dontaudit initrc_t dhcpd_t:process siginh;
#line 18

#line 18
#
#line 18
# Do not audit when resource limits are reset upon the transition.
#line 18
#
#line 18
dontaudit initrc_t dhcpd_t:process rlimitinh;
#line 18

#line 18
#
#line 18
# Allow the process to execute the program.
#line 18
# 
#line 18
allow initrc_t dhcpd_exec_t:file { read { getattr execute } };
#line 18

#line 18
#
#line 18
# Allow the process to reap the new domain.
#line 18
#
#line 18
allow dhcpd_t initrc_t:process sigchld;
#line 18

#line 18
#
#line 18
# Allow the new domain to inherit and use file 
#line 18
# descriptions from the creating process and vice versa.
#line 18
#
#line 18
allow dhcpd_t initrc_t:fd use;
#line 18
allow initrc_t dhcpd_t:fd use;
#line 18

#line 18
#
#line 18
# Allow the new domain to write back to the old domain via a pipe.
#line 18
#
#line 18
allow dhcpd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 18

#line 18
#
#line 18
# Allow the new domain to read and execute the program.
#line 18
#
#line 18
allow dhcpd_t dhcpd_exec_t:file { read getattr lock execute ioctl };
#line 18

#line 18
#
#line 18
# Allow the new domain to be entered via the program.
#line 18
#
#line 18
allow dhcpd_t dhcpd_exec_t:file entrypoint;
#line 18

#line 18
type_transition initrc_t dhcpd_exec_t:process dhcpd_t;
#line 18

#line 18

#line 18
allow initrc_t dhcpd_t:process { noatsecure siginh rlimitinh };
#line 18

#line 18
}
#line 18
 
#line 18
allow dhcpd_t privfd:fd use;
#line 18

#line 18
allow dhcpd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18

#line 18
# Create pid file.
#line 18
allow dhcpd_t var_t:dir { getattr search };
#line 18

#line 18
type dhcpd_var_run_t, file_type, sysadmfile, pidfile;
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the process to modify the directory.
#line 18
#
#line 18
allow dhcpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 18

#line 18
#
#line 18
# Allow the process to create the file.
#line 18
#
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
allow dhcpd_t dhcpd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
type_transition dhcpd_t var_run_t:file dhcpd_var_run_t;
#line 18

#line 18

#line 18

#line 18
allow dhcpd_t var_t:dir search;
#line 18
allow dhcpd_t dhcpd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 18

#line 18

#line 18
allow dhcpd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18
# for daemons that look at /root on startup
#line 18
dontaudit dhcpd_t sysadm_home_dir_t:dir search;
#line 18

#line 18
# for df
#line 18
allow dhcpd_t fs_type:filesystem getattr;
#line 18
allow dhcpd_t removable_t:filesystem getattr;
#line 18

#line 18

#line 18
allow dhcpd_t etc_t:lnk_file read;
#line 18
allow dhcpd_t lib_t:file { read getattr lock ioctl };
#line 18

#line 18
allow dhcpd_t locale_t:dir { read getattr lock search ioctl };
#line 18
allow dhcpd_t locale_t:file { read getattr lock ioctl };
#line 18
allow dhcpd_t locale_t:lnk_file { getattr read };
#line 18

#line 18

#line 18

#line 18
# for localization
#line 18
allow dhcpd_t lib_t:file { getattr read };
#line 18


# for UDP port 4011
allow dhcpd_t pxe_port_t:udp_socket name_bind;

type dhcp_etc_t, file_type, sysadmfile, usercanread;

# Use the network.

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
#
#line 26
# Allow the domain to create and use tcp sockets.
#line 26
# Other kinds of sockets must be separately authorized for use.
#line 26
allow dhcpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 26

#line 26
allow dhcpd_t unlabeled_t:association { sendto recvfrom };
#line 26

#line 26
#
#line 26
# Allow the domain to send or receive using any network interface.
#line 26
# netif_type is a type attribute for all network interface types.
#line 26
#
#line 26
allow dhcpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 26
#
#line 26
# Allow the domain to send to or receive from any node.
#line 26
# node_type is a type attribute for all node types.
#line 26
#
#line 26
allow dhcpd_t node_type:node { tcp_send rawip_send };
#line 26
allow dhcpd_t node_type:node { tcp_recv rawip_recv };
#line 26

#line 26
#
#line 26
# Allow the domain to send to or receive from any port.
#line 26
# port_type is a type attribute for all port types.
#line 26
#
#line 26

#line 26
allow dhcpd_t port_type:tcp_socket { send_msg recv_msg };
#line 26

#line 26

#line 26
# XXX Allow binding to any node type.  Remove once
#line 26
# individual rules have been added to all domains that 
#line 26
# bind sockets. 
#line 26
allow dhcpd_t node_type:tcp_socket node_bind;
#line 26
#
#line 26
# Allow access to network files including /etc/resolv.conf
#line 26
#
#line 26
allow dhcpd_t net_conf_t:file { read getattr lock ioctl };
#line 26

#line 26
allow dhcpd_t self:tcp_socket { listen accept };
#line 26

#line 26

#line 26

#line 26
#
#line 26
# Allow the domain to create and use tcp sockets.
#line 26
# Other kinds of sockets must be separately authorized for use.
#line 26
allow dhcpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 26

#line 26
allow dhcpd_t unlabeled_t:association { sendto recvfrom };
#line 26

#line 26
#
#line 26
# Allow the domain to send or receive using any network interface.
#line 26
# netif_type is a type attribute for all network interface types.
#line 26
#
#line 26
allow dhcpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 26
#
#line 26
# Allow the domain to send to or receive from any node.
#line 26
# node_type is a type attribute for all node types.
#line 26
#
#line 26
allow dhcpd_t node_type:node { tcp_send rawip_send };
#line 26
allow dhcpd_t node_type:node { tcp_recv rawip_recv };
#line 26

#line 26
#
#line 26
# Allow the domain to send to or receive from any port.
#line 26
# port_type is a type attribute for all port types.
#line 26
#
#line 26

#line 26
allow dhcpd_t port_type:tcp_socket { send_msg recv_msg };
#line 26

#line 26

#line 26
# XXX Allow binding to any node type.  Remove once
#line 26
# individual rules have been added to all domains that 
#line 26
# bind sockets. 
#line 26
allow dhcpd_t node_type:tcp_socket node_bind;
#line 26
#
#line 26
# Allow access to network files including /etc/resolv.conf
#line 26
#
#line 26
allow dhcpd_t net_conf_t:file { read getattr lock ioctl };
#line 26

#line 26
allow dhcpd_t self:tcp_socket { connect };
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
#
#line 26
# Allow the domain to create and use udp sockets.
#line 26
# Other kinds of sockets must be separately authorized for use.
#line 26
allow dhcpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 26

#line 26
allow dhcpd_t unlabeled_t:association { sendto recvfrom };
#line 26

#line 26
#
#line 26
# Allow the domain to send or receive using any network interface.
#line 26
# netif_type is a type attribute for all network interface types.
#line 26
#
#line 26
allow dhcpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 26
#
#line 26
# Allow the domain to send to or receive from any node.
#line 26
# node_type is a type attribute for all node types.
#line 26
#
#line 26
allow dhcpd_t node_type:node { udp_send rawip_send };
#line 26
allow dhcpd_t node_type:node { udp_recv rawip_recv };
#line 26

#line 26
#
#line 26
# Allow the domain to send to or receive from any port.
#line 26
# port_type is a type attribute for all port types.
#line 26
#
#line 26

#line 26
allow dhcpd_t port_type:udp_socket { send_msg recv_msg };
#line 26

#line 26

#line 26
# XXX Allow binding to any node type.  Remove once
#line 26
# individual rules have been added to all domains that 
#line 26
# bind sockets. 
#line 26
allow dhcpd_t node_type:udp_socket node_bind;
#line 26
#
#line 26
# Allow access to network files including /etc/resolv.conf
#line 26
#
#line 26
allow dhcpd_t net_conf_t:file { read getattr lock ioctl };
#line 26

#line 26
allow dhcpd_t self:udp_socket { connect };
#line 26

#line 26

#line 26

#line 26

#line 26

allow dhcpd_t port_type:tcp_socket name_connect;
allow dhcpd_t dhcpd_port_t:{ tcp_socket udp_socket } name_bind;

#line 29

#line 29
if (allow_ypbind) {
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
#
#line 29
# Allow the domain to create and use tcp sockets.
#line 29
# Other kinds of sockets must be separately authorized for use.
#line 29
allow dhcpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 29

#line 29
allow dhcpd_t unlabeled_t:association { sendto recvfrom };
#line 29

#line 29
#
#line 29
# Allow the domain to send or receive using any network interface.
#line 29
# netif_type is a type attribute for all network interface types.
#line 29
#
#line 29
allow dhcpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 29
#
#line 29
# Allow the domain to send to or receive from any node.
#line 29
# node_type is a type attribute for all node types.
#line 29
#
#line 29
allow dhcpd_t node_type:node { tcp_send rawip_send };
#line 29
allow dhcpd_t node_type:node { tcp_recv rawip_recv };
#line 29

#line 29
#
#line 29
# Allow the domain to send to or receive from any port.
#line 29
# port_type is a type attribute for all port types.
#line 29
#
#line 29

#line 29
allow dhcpd_t port_type:tcp_socket { send_msg recv_msg };
#line 29

#line 29

#line 29
# XXX Allow binding to any node type.  Remove once
#line 29
# individual rules have been added to all domains that 
#line 29
# bind sockets. 
#line 29
allow dhcpd_t node_type:tcp_socket node_bind;
#line 29
#
#line 29
# Allow access to network files including /etc/resolv.conf
#line 29
#
#line 29
allow dhcpd_t net_conf_t:file { read getattr lock ioctl };
#line 29

#line 29
allow dhcpd_t self:tcp_socket { listen accept };
#line 29

#line 29

#line 29

#line 29
#
#line 29
# Allow the domain to create and use tcp sockets.
#line 29
# Other kinds of sockets must be separately authorized for use.
#line 29
allow dhcpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 29

#line 29
allow dhcpd_t unlabeled_t:association { sendto recvfrom };
#line 29

#line 29
#
#line 29
# Allow the domain to send or receive using any network interface.
#line 29
# netif_type is a type attribute for all network interface types.
#line 29
#
#line 29
allow dhcpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 29
#
#line 29
# Allow the domain to send to or receive from any node.
#line 29
# node_type is a type attribute for all node types.
#line 29
#
#line 29
allow dhcpd_t node_type:node { tcp_send rawip_send };
#line 29
allow dhcpd_t node_type:node { tcp_recv rawip_recv };
#line 29

#line 29
#
#line 29
# Allow the domain to send to or receive from any port.
#line 29
# port_type is a type attribute for all port types.
#line 29
#
#line 29

#line 29
allow dhcpd_t port_type:tcp_socket { send_msg recv_msg };
#line 29

#line 29

#line 29
# XXX Allow binding to any node type.  Remove once
#line 29
# individual rules have been added to all domains that 
#line 29
# bind sockets. 
#line 29
allow dhcpd_t node_type:tcp_socket node_bind;
#line 29
#
#line 29
# Allow access to network files including /etc/resolv.conf
#line 29
#
#line 29
allow dhcpd_t net_conf_t:file { read getattr lock ioctl };
#line 29

#line 29
allow dhcpd_t self:tcp_socket { connect };
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
#
#line 29
# Allow the domain to create and use udp sockets.
#line 29
# Other kinds of sockets must be separately authorized for use.
#line 29
allow dhcpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 29

#line 29
allow dhcpd_t unlabeled_t:association { sendto recvfrom };
#line 29

#line 29
#
#line 29
# Allow the domain to send or receive using any network interface.
#line 29
# netif_type is a type attribute for all network interface types.
#line 29
#
#line 29
allow dhcpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 29
#
#line 29
# Allow the domain to send to or receive from any node.
#line 29
# node_type is a type attribute for all node types.
#line 29
#
#line 29
allow dhcpd_t node_type:node { udp_send rawip_send };
#line 29
allow dhcpd_t node_type:node { udp_recv rawip_recv };
#line 29

#line 29
#
#line 29
# Allow the domain to send to or receive from any port.
#line 29
# port_type is a type attribute for all port types.
#line 29
#
#line 29

#line 29
allow dhcpd_t port_type:udp_socket { send_msg recv_msg };
#line 29

#line 29

#line 29
# XXX Allow binding to any node type.  Remove once
#line 29
# individual rules have been added to all domains that 
#line 29
# bind sockets. 
#line 29
allow dhcpd_t node_type:udp_socket node_bind;
#line 29
#
#line 29
# Allow access to network files including /etc/resolv.conf
#line 29
#
#line 29
allow dhcpd_t net_conf_t:file { read getattr lock ioctl };
#line 29

#line 29
allow dhcpd_t self:udp_socket { connect };
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
allow dhcpd_t var_yp_t:dir { read getattr lock search ioctl };
#line 29
allow dhcpd_t var_yp_t:file { read getattr lock ioctl };
#line 29
allow dhcpd_t var_yp_t:lnk_file { getattr read };
#line 29

#line 29
allow dhcpd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 29
allow dhcpd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 29
dontaudit dhcpd_t self:capability net_bind_service;
#line 29
dontaudit dhcpd_t reserved_port_type:tcp_socket name_connect;
#line 29
dontaudit dhcpd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 29

#line 29
} else {
#line 29
dontaudit dhcpd_t var_yp_t:dir search;
#line 29
}
#line 29
 
allow dhcpd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow dhcpd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow dhcpd_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };

allow dhcpd_t var_lib_t:dir search;

allow dhcpd_t devtty_t:chr_file { read write };

# Use capabilities
allow dhcpd_t self:capability { net_raw net_bind_service };
dontaudit dhcpd_t self:capability  net_admin;

# Allow access to the dhcpd file types
type dhcp_state_t, file_type, sysadmfile;
type dhcpd_state_t, file_type, sysadmfile;
allow dhcpd_t dhcp_etc_t:file { read getattr };
allow dhcpd_t dhcp_etc_t:dir search;

#line 47

#line 47

#line 47

#line 47
#
#line 47
# Allow the process to modify the directory.
#line 47
#
#line 47
allow dhcpd_t dhcp_state_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 47

#line 47
#
#line 47
# Allow the process to create the file.
#line 47
#
#line 47

#line 47

#line 47

#line 47

#line 47

#line 47
allow dhcpd_t dhcpd_state_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 47

#line 47

#line 47

#line 47

#line 47

#line 47

#line 47

#line 47

#line 47

#line 47
type_transition dhcpd_t dhcp_state_t:file dhcpd_state_t;
#line 47

#line 47


#line 48
allow dhcpd_t dhcpd_state_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 48
allow dhcpd_t dhcpd_state_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 48
allow dhcpd_t dhcpd_state_t:lnk_file { create read getattr setattr link unlink rename };
#line 48


allow dhcpd_t etc_t:lnk_file read;
allow dhcpd_t { etc_t etc_runtime_t }:file { read getattr lock ioctl };

# Allow dhcpd_t programs to execute themselves and bin_t (uname etc)

#line 54
allow dhcpd_t { dhcpd_exec_t bin_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 54


# Allow dhcpd_t to use packet sockets
allow dhcpd_t self:packet_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow dhcpd_t self:rawip_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# allow to run utilities and scripts
allow dhcpd_t { bin_t sbin_t }:dir { read getattr lock search ioctl };
allow dhcpd_t { bin_t sbin_t }:{ file lnk_file } { read getattr lock execute ioctl };
allow dhcpd_t self:fifo_file { read write getattr };

# allow reading /proc
allow dhcpd_t proc_t:{ file lnk_file } { read getattr lock ioctl };

#line 67
type dhcpd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 67

#line 67

#line 67

#line 67

#line 67
#
#line 67
# Allow the process to modify the directory.
#line 67
#
#line 67
allow dhcpd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 67

#line 67
#
#line 67
# Allow the process to create the file.
#line 67
#
#line 67

#line 67

#line 67

#line 67

#line 67

#line 67
allow dhcpd_t dhcpd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67
allow dhcpd_t dhcpd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67
type_transition dhcpd_t tmp_t:{ file dir } dhcpd_tmp_t;
#line 67

#line 67

#line 67


#line 72


#line 73
allow dhcpd_t usr_t:dir { read getattr lock search ioctl };
#line 73
allow dhcpd_t usr_t:file { read getattr lock ioctl };
#line 73
allow dhcpd_t usr_t:lnk_file { getattr read };
#line 73

allow dhcpd_t { urandom_device_t random_device_t }:chr_file { read getattr lock ioctl };

#line 79

#line 79
allow dhcpd_t { named_conf_t named_zone_t }:dir search;
#line 79
allow dhcpd_t dnssec_t:file { getattr read };
#line 79

#line 1 "domains/program/dictd.te"
#DESC Dictd - Dictionary daemon
#
# Authors:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: dictd
#

#################################
#
# Rules for the dictd_t domain.
#
# dictd_exec_t is the type of the dictd executable.
#

#line 13

#line 13
type dictd_t, domain, privlog, daemon ;
#line 13
type dictd_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit dictd_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types dictd_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow dictd_t init_t:fd use;
#line 13
allow dictd_t init_t:process sigchld;
#line 13
allow dictd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow dictd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow dictd_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow dictd_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow dictd_t ld_so_t:file execute_no_trans;
#line 13
allow dictd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow dictd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow dictd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow dictd_t texrel_shlib_t:file execmod;
#line 13
allow dictd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow dictd_t device_t:dir search;
#line 13
allow dictd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow dictd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow dictd_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow dictd_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow dictd_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow dictd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit dictd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit dictd_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow dictd_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow dictd_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow dictd_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow dictd_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit dictd_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit dictd_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow dictd_t sysctl_t:dir search;
#line 13
allow dictd_t sysctl_kernel_t:dir search;
#line 13
allow dictd_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t dictd_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t dictd_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t dictd_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t dictd_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t dictd_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow dictd_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow dictd_t initrc_t:fd use;
#line 13
allow initrc_t dictd_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow dictd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow dictd_t dictd_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow dictd_t dictd_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t dictd_exec_t:process dictd_t;
#line 13

#line 13

#line 13
allow initrc_t dictd_t:process { noatsecure siginh rlimitinh };
#line 13
 
#line 13
allow dictd_t privfd:fd use;
#line 13

#line 13
allow dictd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

type dictd_var_lib_t, file_type, sysadmfile;
typealias dictd_var_lib_t alias var_lib_dictd_t;

#line 16
type dictd_etc_t, file_type, sysadmfile, usercanread;
#line 16
allow dictd_t dictd_etc_t:file { read getattr lock ioctl };
#line 16


# for checking for nscd
dontaudit dictd_t var_run_t:dir search;

# read config files
allow dictd_t { etc_t etc_runtime_t }:file { read getattr lock ioctl };


#line 24
allow dictd_t etc_t:lnk_file read;
#line 24
allow dictd_t lib_t:file { read getattr lock ioctl };
#line 24

#line 24
allow dictd_t locale_t:dir { read getattr lock search ioctl };
#line 24
allow dictd_t locale_t:file { read getattr lock ioctl };
#line 24
allow dictd_t locale_t:lnk_file { getattr read };
#line 24

#line 24


allow dictd_t { var_t var_lib_t }:dir search;
allow dictd_t dictd_var_lib_t:dir { read getattr lock search ioctl };
allow dictd_t dictd_var_lib_t:file { read getattr lock ioctl };

allow dictd_t self:capability { setuid setgid };

allow dictd_t usr_t:file { read getattr lock ioctl };

allow dictd_t self:process { setpgid fork sigchld };

allow dictd_t proc_t:file { read getattr lock ioctl };

allow dictd_t dict_port_t:tcp_socket name_bind;

allow dictd_t devtty_t:chr_file { ioctl read getattr lock write append };

allow dictd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };


#line 44

#line 44

#line 44

#line 44
#
#line 44
# Allow the domain to create and use tcp sockets.
#line 44
# Other kinds of sockets must be separately authorized for use.
#line 44
allow dictd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 44

#line 44
allow dictd_t unlabeled_t:association { sendto recvfrom };
#line 44

#line 44
#
#line 44
# Allow the domain to send or receive using any network interface.
#line 44
# netif_type is a type attribute for all network interface types.
#line 44
#
#line 44
allow dictd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 44
#
#line 44
# Allow the domain to send to or receive from any node.
#line 44
# node_type is a type attribute for all node types.
#line 44
#
#line 44
allow dictd_t node_type:node { tcp_send rawip_send };
#line 44
allow dictd_t node_type:node { tcp_recv rawip_recv };
#line 44

#line 44
#
#line 44
# Allow the domain to send to or receive from any port.
#line 44
# port_type is a type attribute for all port types.
#line 44
#
#line 44

#line 44
allow dictd_t port_type:tcp_socket { send_msg recv_msg };
#line 44

#line 44

#line 44
# XXX Allow binding to any node type.  Remove once
#line 44
# individual rules have been added to all domains that 
#line 44
# bind sockets. 
#line 44
allow dictd_t node_type:tcp_socket node_bind;
#line 44
#
#line 44
# Allow access to network files including /etc/resolv.conf
#line 44
#
#line 44
allow dictd_t net_conf_t:file { read getattr lock ioctl };
#line 44

#line 44
allow dictd_t self:tcp_socket { listen accept };
#line 44

#line 44

#line 44

#line 44
#
#line 44
# Allow the domain to create and use udp sockets.
#line 44
# Other kinds of sockets must be separately authorized for use.
#line 44
allow dictd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 44

#line 44
allow dictd_t unlabeled_t:association { sendto recvfrom };
#line 44

#line 44
#
#line 44
# Allow the domain to send or receive using any network interface.
#line 44
# netif_type is a type attribute for all network interface types.
#line 44
#
#line 44
allow dictd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 44
#
#line 44
# Allow the domain to send to or receive from any node.
#line 44
# node_type is a type attribute for all node types.
#line 44
#
#line 44
allow dictd_t node_type:node { udp_send rawip_send };
#line 44
allow dictd_t node_type:node { udp_recv rawip_recv };
#line 44

#line 44
#
#line 44
# Allow the domain to send to or receive from any port.
#line 44
# port_type is a type attribute for all port types.
#line 44
#
#line 44

#line 44
allow dictd_t port_type:udp_socket { send_msg recv_msg };
#line 44

#line 44

#line 44
# XXX Allow binding to any node type.  Remove once
#line 44
# individual rules have been added to all domains that 
#line 44
# bind sockets. 
#line 44
allow dictd_t node_type:udp_socket node_bind;
#line 44
#
#line 44
# Allow access to network files including /etc/resolv.conf
#line 44
#
#line 44
allow dictd_t net_conf_t:file { read getattr lock ioctl };
#line 44

#line 44
allow dictd_t self:udp_socket { connect };
#line 44

#line 44

#line 44


#line 45

#line 45
if (allow_ypbind) {
#line 45

#line 45

#line 45

#line 45

#line 45

#line 45

#line 45

#line 45
#
#line 45
# Allow the domain to create and use tcp sockets.
#line 45
# Other kinds of sockets must be separately authorized for use.
#line 45
allow dictd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 45

#line 45
allow dictd_t unlabeled_t:association { sendto recvfrom };
#line 45

#line 45
#
#line 45
# Allow the domain to send or receive using any network interface.
#line 45
# netif_type is a type attribute for all network interface types.
#line 45
#
#line 45
allow dictd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 45
#
#line 45
# Allow the domain to send to or receive from any node.
#line 45
# node_type is a type attribute for all node types.
#line 45
#
#line 45
allow dictd_t node_type:node { tcp_send rawip_send };
#line 45
allow dictd_t node_type:node { tcp_recv rawip_recv };
#line 45

#line 45
#
#line 45
# Allow the domain to send to or receive from any port.
#line 45
# port_type is a type attribute for all port types.
#line 45
#
#line 45

#line 45
allow dictd_t port_type:tcp_socket { send_msg recv_msg };
#line 45

#line 45

#line 45
# XXX Allow binding to any node type.  Remove once
#line 45
# individual rules have been added to all domains that 
#line 45
# bind sockets. 
#line 45
allow dictd_t node_type:tcp_socket node_bind;
#line 45
#
#line 45
# Allow access to network files including /etc/resolv.conf
#line 45
#
#line 45
allow dictd_t net_conf_t:file { read getattr lock ioctl };
#line 45

#line 45
allow dictd_t self:tcp_socket { listen accept };
#line 45

#line 45

#line 45

#line 45
#
#line 45
# Allow the domain to create and use tcp sockets.
#line 45
# Other kinds of sockets must be separately authorized for use.
#line 45
allow dictd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 45

#line 45
allow dictd_t unlabeled_t:association { sendto recvfrom };
#line 45

#line 45
#
#line 45
# Allow the domain to send or receive using any network interface.
#line 45
# netif_type is a type attribute for all network interface types.
#line 45
#
#line 45
allow dictd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 45
#
#line 45
# Allow the domain to send to or receive from any node.
#line 45
# node_type is a type attribute for all node types.
#line 45
#
#line 45
allow dictd_t node_type:node { tcp_send rawip_send };
#line 45
allow dictd_t node_type:node { tcp_recv rawip_recv };
#line 45

#line 45
#
#line 45
# Allow the domain to send to or receive from any port.
#line 45
# port_type is a type attribute for all port types.
#line 45
#
#line 45

#line 45
allow dictd_t port_type:tcp_socket { send_msg recv_msg };
#line 45

#line 45

#line 45
# XXX Allow binding to any node type.  Remove once
#line 45
# individual rules have been added to all domains that 
#line 45
# bind sockets. 
#line 45
allow dictd_t node_type:tcp_socket node_bind;
#line 45
#
#line 45
# Allow access to network files including /etc/resolv.conf
#line 45
#
#line 45
allow dictd_t net_conf_t:file { read getattr lock ioctl };
#line 45

#line 45
allow dictd_t self:tcp_socket { connect };
#line 45

#line 45

#line 45

#line 45

#line 45

#line 45
#
#line 45
# Allow the domain to create and use udp sockets.
#line 45
# Other kinds of sockets must be separately authorized for use.
#line 45
allow dictd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 45

#line 45
allow dictd_t unlabeled_t:association { sendto recvfrom };
#line 45

#line 45
#
#line 45
# Allow the domain to send or receive using any network interface.
#line 45
# netif_type is a type attribute for all network interface types.
#line 45
#
#line 45
allow dictd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 45
#
#line 45
# Allow the domain to send to or receive from any node.
#line 45
# node_type is a type attribute for all node types.
#line 45
#
#line 45
allow dictd_t node_type:node { udp_send rawip_send };
#line 45
allow dictd_t node_type:node { udp_recv rawip_recv };
#line 45

#line 45
#
#line 45
# Allow the domain to send to or receive from any port.
#line 45
# port_type is a type attribute for all port types.
#line 45
#
#line 45

#line 45
allow dictd_t port_type:udp_socket { send_msg recv_msg };
#line 45

#line 45

#line 45
# XXX Allow binding to any node type.  Remove once
#line 45
# individual rules have been added to all domains that 
#line 45
# bind sockets. 
#line 45
allow dictd_t node_type:udp_socket node_bind;
#line 45
#
#line 45
# Allow access to network files including /etc/resolv.conf
#line 45
#
#line 45
allow dictd_t net_conf_t:file { read getattr lock ioctl };
#line 45

#line 45
allow dictd_t self:udp_socket { connect };
#line 45

#line 45

#line 45

#line 45

#line 45

#line 45

#line 45
allow dictd_t var_yp_t:dir { read getattr lock search ioctl };
#line 45
allow dictd_t var_yp_t:file { read getattr lock ioctl };
#line 45
allow dictd_t var_yp_t:lnk_file { getattr read };
#line 45

#line 45
allow dictd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 45
allow dictd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 45
dontaudit dictd_t self:capability net_bind_service;
#line 45
dontaudit dictd_t reserved_port_type:tcp_socket name_connect;
#line 45
dontaudit dictd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 45

#line 45
} else {
#line 45
dontaudit dictd_t var_yp_t:dir search;
#line 45
}
#line 45
 

#line 46
#allow userdomain dictd_t:tcp_socket { connectto recvfrom };
#line 46
#allow dictd_t userdomain:tcp_socket { acceptfrom recvfrom };
#line 46
#allow dictd_t kernel_t:tcp_socket recvfrom;
#line 46
#allow userdomain kernel_t:tcp_socket recvfrom;
#line 46


allow dictd_t fs_t:filesystem getattr;
#line 1 "domains/program/dmidecode.te"
#DESC dmidecode - decodes DMI data for x86/ia64 bioses 
#
# Author: Ivan Gyurdiev <ivg2@cornell.edu>
#

type dmidecode_t, domain, privmem;
type dmidecode_exec_t, file_type, exec_type, sysadmfile;

# Allow execution by the sysadm
role sysadm_r types dmidecode_t;
role system_r types dmidecode_t;

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow sysadm_t dmidecode_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit sysadm_t dmidecode_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit sysadm_t dmidecode_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit sysadm_t dmidecode_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow sysadm_t dmidecode_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow dmidecode_t sysadm_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow dmidecode_t sysadm_t:fd use;
#line 12
allow sysadm_t dmidecode_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow dmidecode_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow dmidecode_t dmidecode_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow dmidecode_t dmidecode_exec_t:file entrypoint;
#line 12

#line 12
type_transition sysadm_t dmidecode_exec_t:process dmidecode_t;
#line 12



#line 14
allow dmidecode_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow dmidecode_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow dmidecode_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow dmidecode_t ld_so_t:file execute_no_trans;
#line 14
allow dmidecode_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow dmidecode_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow dmidecode_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow dmidecode_t texrel_shlib_t:file execmod;
#line 14
allow dmidecode_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow dmidecode_t device_t:dir search;
#line 14
allow dmidecode_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14


# Allow terminal access

#line 17
allow dmidecode_t sysadm_tty_device_t:chr_file { read write getattr ioctl };
#line 17
allow dmidecode_t devtty_t:chr_file { read write getattr ioctl };
#line 17

#line 17
allow dmidecode_t devpts_t:dir { read getattr lock search ioctl };
#line 17
allow dmidecode_t sysadm_devpts_t:chr_file { ioctl read getattr lock write append };
#line 17

#line 17


# Allow dmidecode to read /dev/mem
allow dmidecode_t memory_device_t:chr_file read;

allow dmidecode_t self:capability sys_rawio;
#line 1 "domains/program/dovecot.te"
#DESC Dovecot POP and IMAP servers
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: dovecot-imapd, dovecot-pop3d

#
# Main dovecot daemon
#

#line 9

#line 9

#line 9

#line 9
type dovecot_t, domain, privlog, daemon , privhome, transitionbool;
#line 9
type dovecot_exec_t, file_type, sysadmfile, exec_type;
#line 9
dontaudit dovecot_t self:capability sys_tty_config;
#line 9

#line 9
role system_r types dovecot_t;
#line 9

#line 9
# Inherit and use descriptors from init.
#line 9
allow dovecot_t init_t:fd use;
#line 9
allow dovecot_t init_t:process sigchld;
#line 9
allow dovecot_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 9

#line 9

#line 9
allow dovecot_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 9
allow dovecot_t lib_t:lnk_file { read getattr lock ioctl };
#line 9
allow dovecot_t ld_so_t:file { read getattr lock execute ioctl };
#line 9
#allow dovecot_t ld_so_t:file execute_no_trans;
#line 9
allow dovecot_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 9
allow dovecot_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 9
allow dovecot_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 9
allow dovecot_t texrel_shlib_t:file execmod;
#line 9
allow dovecot_t ld_so_cache_t:file { read getattr lock ioctl };
#line 9
allow dovecot_t device_t:dir search;
#line 9
allow dovecot_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 9

#line 9

#line 9
allow dovecot_t { self proc_t }:dir { read getattr lock search ioctl };
#line 9
allow dovecot_t { self proc_t }:lnk_file { getattr read };
#line 9

#line 9
allow dovecot_t device_t:dir { read getattr lock search ioctl };
#line 9

#line 9
allow dovecot_t udev_tdb_t:file { read getattr lock ioctl };
#line 9
allow dovecot_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 9
dontaudit dovecot_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 9
dontaudit dovecot_t unpriv_userdomain:fd use;
#line 9

#line 9

#line 9
allow dovecot_t sysfs_t:dir { read getattr lock search ioctl };
#line 9
allow dovecot_t sysfs_t:file { read getattr lock ioctl };
#line 9
allow dovecot_t sysfs_t:lnk_file { getattr read };
#line 9
 
#line 9

#line 9
allow dovecot_t autofs_t:dir { search getattr };
#line 9

#line 9
dontaudit dovecot_t { tty_device_t devpts_t }:chr_file { read write };
#line 9
dontaudit dovecot_t root_t:file { getattr read };
#line 9
 
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
# Read system variables in /sys.
#line 9

#line 9
allow dovecot_t sysctl_t:dir search;
#line 9
allow dovecot_t sysctl_kernel_t:dir search;
#line 9
allow dovecot_t sysctl_kernel_t:file { getattr read };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allows user to define a tunable to disable domain transition
#line 9
#
#line 9

#line 9
bool dovecot_disable_trans false;
#line 9
if (dovecot_disable_trans) {
#line 9

#line 9
allow initrc_t dovecot_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 9

#line 9

#line 9
allow sysadm_t dovecot_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 9

#line 9
} else {
#line 9
 
#line 9

#line 9

#line 9
#
#line 9
# Allow the process to transition to the new domain.
#line 9
#
#line 9
allow initrc_t dovecot_t:process transition;
#line 9

#line 9
#
#line 9
# Do not audit when glibc secure mode is enabled upon the transition.
#line 9
#
#line 9
dontaudit initrc_t dovecot_t:process noatsecure;
#line 9

#line 9
#
#line 9
# Do not audit when signal-related state is cleared upon the transition.
#line 9
#
#line 9
dontaudit initrc_t dovecot_t:process siginh;
#line 9

#line 9
#
#line 9
# Do not audit when resource limits are reset upon the transition.
#line 9
#
#line 9
dontaudit initrc_t dovecot_t:process rlimitinh;
#line 9

#line 9
#
#line 9
# Allow the process to execute the program.
#line 9
# 
#line 9
allow initrc_t dovecot_exec_t:file { read { getattr execute } };
#line 9

#line 9
#
#line 9
# Allow the process to reap the new domain.
#line 9
#
#line 9
allow dovecot_t initrc_t:process sigchld;
#line 9

#line 9
#
#line 9
# Allow the new domain to inherit and use file 
#line 9
# descriptions from the creating process and vice versa.
#line 9
#
#line 9
allow dovecot_t initrc_t:fd use;
#line 9
allow initrc_t dovecot_t:fd use;
#line 9

#line 9
#
#line 9
# Allow the new domain to write back to the old domain via a pipe.
#line 9
#
#line 9
allow dovecot_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 9

#line 9
#
#line 9
# Allow the new domain to read and execute the program.
#line 9
#
#line 9
allow dovecot_t dovecot_exec_t:file { read getattr lock execute ioctl };
#line 9

#line 9
#
#line 9
# Allow the new domain to be entered via the program.
#line 9
#
#line 9
allow dovecot_t dovecot_exec_t:file entrypoint;
#line 9

#line 9
type_transition initrc_t dovecot_exec_t:process dovecot_t;
#line 9

#line 9

#line 9
allow initrc_t dovecot_t:process { noatsecure siginh rlimitinh };
#line 9

#line 9
}
#line 9
 
#line 9
allow dovecot_t privfd:fd use;
#line 9

#line 9
allow dovecot_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 9

#line 9

#line 9
# Create pid file.
#line 9
allow dovecot_t var_t:dir { getattr search };
#line 9

#line 9
type dovecot_var_run_t, file_type, sysadmfile, pidfile;
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the process to modify the directory.
#line 9
#
#line 9
allow dovecot_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 9

#line 9
#
#line 9
# Allow the process to create the file.
#line 9
#
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
allow dovecot_t dovecot_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
type_transition dovecot_t var_run_t:file dovecot_var_run_t;
#line 9

#line 9

#line 9

#line 9
allow dovecot_t var_t:dir search;
#line 9
allow dovecot_t dovecot_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 9

#line 9

#line 9
allow dovecot_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 9

#line 9
# for daemons that look at /root on startup
#line 9
dontaudit dovecot_t sysadm_home_dir_t:dir search;
#line 9

#line 9
# for df
#line 9
allow dovecot_t fs_type:filesystem getattr;
#line 9
allow dovecot_t removable_t:filesystem getattr;
#line 9

#line 9

#line 9
allow dovecot_t etc_t:lnk_file read;
#line 9
allow dovecot_t lib_t:file { read getattr lock ioctl };
#line 9

#line 9
allow dovecot_t locale_t:dir { read getattr lock search ioctl };
#line 9
allow dovecot_t locale_t:file { read getattr lock ioctl };
#line 9
allow dovecot_t locale_t:lnk_file { getattr read };
#line 9

#line 9

#line 9

#line 9
# for localization
#line 9
allow dovecot_t lib_t:file { getattr read };
#line 9


#line 10
type dovecot_etc_t, file_type, sysadmfile, usercanread;
#line 10
allow dovecot_t dovecot_etc_t:file { read getattr lock ioctl };
#line 10
;

allow dovecot_t dovecot_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };


#line 14
allow dovecot_t dovecot_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14


type dovecot_cert_t, file_type, sysadmfile;
type dovecot_passwd_t, file_type, sysadmfile;
type dovecot_spool_t, file_type, sysadmfile;

allow dovecot_t self:capability { dac_override dac_read_search chown net_bind_service setgid setuid sys_chroot };
allow dovecot_t self:process setrlimit;

#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the domain to create and use tcp sockets.
#line 22
# Other kinds of sockets must be separately authorized for use.
#line 22
allow dovecot_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 22

#line 22
allow dovecot_t unlabeled_t:association { sendto recvfrom };
#line 22

#line 22
#
#line 22
# Allow the domain to send or receive using any network interface.
#line 22
# netif_type is a type attribute for all network interface types.
#line 22
#
#line 22
allow dovecot_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 22
#
#line 22
# Allow the domain to send to or receive from any node.
#line 22
# node_type is a type attribute for all node types.
#line 22
#
#line 22
allow dovecot_t node_type:node { tcp_send rawip_send };
#line 22
allow dovecot_t node_type:node { tcp_recv rawip_recv };
#line 22

#line 22
#
#line 22
# Allow the domain to send to or receive from any port.
#line 22
# port_type is a type attribute for all port types.
#line 22
#
#line 22

#line 22
allow dovecot_t port_type:tcp_socket { send_msg recv_msg };
#line 22

#line 22

#line 22
# XXX Allow binding to any node type.  Remove once
#line 22
# individual rules have been added to all domains that 
#line 22
# bind sockets. 
#line 22
allow dovecot_t node_type:tcp_socket node_bind;
#line 22
#
#line 22
# Allow access to network files including /etc/resolv.conf
#line 22
#
#line 22
allow dovecot_t net_conf_t:file { read getattr lock ioctl };
#line 22

#line 22
allow dovecot_t self:tcp_socket { listen accept };
#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the domain to create and use tcp sockets.
#line 22
# Other kinds of sockets must be separately authorized for use.
#line 22
allow dovecot_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 22

#line 22
allow dovecot_t unlabeled_t:association { sendto recvfrom };
#line 22

#line 22
#
#line 22
# Allow the domain to send or receive using any network interface.
#line 22
# netif_type is a type attribute for all network interface types.
#line 22
#
#line 22
allow dovecot_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 22
#
#line 22
# Allow the domain to send to or receive from any node.
#line 22
# node_type is a type attribute for all node types.
#line 22
#
#line 22
allow dovecot_t node_type:node { tcp_send rawip_send };
#line 22
allow dovecot_t node_type:node { tcp_recv rawip_recv };
#line 22

#line 22
#
#line 22
# Allow the domain to send to or receive from any port.
#line 22
# port_type is a type attribute for all port types.
#line 22
#
#line 22

#line 22
allow dovecot_t port_type:tcp_socket { send_msg recv_msg };
#line 22

#line 22

#line 22
# XXX Allow binding to any node type.  Remove once
#line 22
# individual rules have been added to all domains that 
#line 22
# bind sockets. 
#line 22
allow dovecot_t node_type:tcp_socket node_bind;
#line 22
#
#line 22
# Allow access to network files including /etc/resolv.conf
#line 22
#
#line 22
allow dovecot_t net_conf_t:file { read getattr lock ioctl };
#line 22

#line 22
allow dovecot_t self:tcp_socket { connect };
#line 22

#line 22

#line 22

allow dovecot_t port_type:tcp_socket name_connect;

#line 24

#line 24
if (allow_ypbind) {
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the domain to create and use tcp sockets.
#line 24
# Other kinds of sockets must be separately authorized for use.
#line 24
allow dovecot_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 24

#line 24
allow dovecot_t unlabeled_t:association { sendto recvfrom };
#line 24

#line 24
#
#line 24
# Allow the domain to send or receive using any network interface.
#line 24
# netif_type is a type attribute for all network interface types.
#line 24
#
#line 24
allow dovecot_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 24
#
#line 24
# Allow the domain to send to or receive from any node.
#line 24
# node_type is a type attribute for all node types.
#line 24
#
#line 24
allow dovecot_t node_type:node { tcp_send rawip_send };
#line 24
allow dovecot_t node_type:node { tcp_recv rawip_recv };
#line 24

#line 24
#
#line 24
# Allow the domain to send to or receive from any port.
#line 24
# port_type is a type attribute for all port types.
#line 24
#
#line 24

#line 24
allow dovecot_t port_type:tcp_socket { send_msg recv_msg };
#line 24

#line 24

#line 24
# XXX Allow binding to any node type.  Remove once
#line 24
# individual rules have been added to all domains that 
#line 24
# bind sockets. 
#line 24
allow dovecot_t node_type:tcp_socket node_bind;
#line 24
#
#line 24
# Allow access to network files including /etc/resolv.conf
#line 24
#
#line 24
allow dovecot_t net_conf_t:file { read getattr lock ioctl };
#line 24

#line 24
allow dovecot_t self:tcp_socket { listen accept };
#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the domain to create and use tcp sockets.
#line 24
# Other kinds of sockets must be separately authorized for use.
#line 24
allow dovecot_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 24

#line 24
allow dovecot_t unlabeled_t:association { sendto recvfrom };
#line 24

#line 24
#
#line 24
# Allow the domain to send or receive using any network interface.
#line 24
# netif_type is a type attribute for all network interface types.
#line 24
#
#line 24
allow dovecot_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 24
#
#line 24
# Allow the domain to send to or receive from any node.
#line 24
# node_type is a type attribute for all node types.
#line 24
#
#line 24
allow dovecot_t node_type:node { tcp_send rawip_send };
#line 24
allow dovecot_t node_type:node { tcp_recv rawip_recv };
#line 24

#line 24
#
#line 24
# Allow the domain to send to or receive from any port.
#line 24
# port_type is a type attribute for all port types.
#line 24
#
#line 24

#line 24
allow dovecot_t port_type:tcp_socket { send_msg recv_msg };
#line 24

#line 24

#line 24
# XXX Allow binding to any node type.  Remove once
#line 24
# individual rules have been added to all domains that 
#line 24
# bind sockets. 
#line 24
allow dovecot_t node_type:tcp_socket node_bind;
#line 24
#
#line 24
# Allow access to network files including /etc/resolv.conf
#line 24
#
#line 24
allow dovecot_t net_conf_t:file { read getattr lock ioctl };
#line 24

#line 24
allow dovecot_t self:tcp_socket { connect };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the domain to create and use udp sockets.
#line 24
# Other kinds of sockets must be separately authorized for use.
#line 24
allow dovecot_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 24

#line 24
allow dovecot_t unlabeled_t:association { sendto recvfrom };
#line 24

#line 24
#
#line 24
# Allow the domain to send or receive using any network interface.
#line 24
# netif_type is a type attribute for all network interface types.
#line 24
#
#line 24
allow dovecot_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 24
#
#line 24
# Allow the domain to send to or receive from any node.
#line 24
# node_type is a type attribute for all node types.
#line 24
#
#line 24
allow dovecot_t node_type:node { udp_send rawip_send };
#line 24
allow dovecot_t node_type:node { udp_recv rawip_recv };
#line 24

#line 24
#
#line 24
# Allow the domain to send to or receive from any port.
#line 24
# port_type is a type attribute for all port types.
#line 24
#
#line 24

#line 24
allow dovecot_t port_type:udp_socket { send_msg recv_msg };
#line 24

#line 24

#line 24
# XXX Allow binding to any node type.  Remove once
#line 24
# individual rules have been added to all domains that 
#line 24
# bind sockets. 
#line 24
allow dovecot_t node_type:udp_socket node_bind;
#line 24
#
#line 24
# Allow access to network files including /etc/resolv.conf
#line 24
#
#line 24
allow dovecot_t net_conf_t:file { read getattr lock ioctl };
#line 24

#line 24
allow dovecot_t self:udp_socket { connect };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
allow dovecot_t var_yp_t:dir { read getattr lock search ioctl };
#line 24
allow dovecot_t var_yp_t:file { read getattr lock ioctl };
#line 24
allow dovecot_t var_yp_t:lnk_file { getattr read };
#line 24

#line 24
allow dovecot_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 24
allow dovecot_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 24
dontaudit dovecot_t self:capability net_bind_service;
#line 24
dontaudit dovecot_t reserved_port_type:tcp_socket name_connect;
#line 24
dontaudit dovecot_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 24

#line 24
} else {
#line 24
dontaudit dovecot_t var_yp_t:dir search;
#line 24
}
#line 24
 
allow dovecot_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow dovecot_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

#line 27
allow dovecot_t self:unix_stream_socket connectto;
#line 27


allow dovecot_t etc_t:file { getattr read };
allow dovecot_t initrc_var_run_t:file getattr;
allow dovecot_t bin_t:dir { getattr search };

#line 32
allow dovecot_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 32


allow dovecot_t pop_port_t:tcp_socket name_bind;
allow dovecot_t urandom_device_t:chr_file { getattr read };
allow dovecot_t cert_t:dir search;

#line 37
allow dovecot_t dovecot_cert_t:dir { read getattr lock search ioctl };
#line 37
allow dovecot_t dovecot_cert_t:file { read getattr lock ioctl };
#line 37
allow dovecot_t dovecot_cert_t:lnk_file { getattr read };
#line 37


#line 38
allow dovecot_t cert_t:dir { read getattr lock search ioctl };
#line 38
allow dovecot_t cert_t:file { read getattr lock ioctl };
#line 38
allow dovecot_t cert_t:lnk_file { getattr read };
#line 38


allow dovecot_t { self proc_t }:file { getattr read };
allow dovecot_t self:fifo_file { ioctl read getattr lock write append };


#line 43

#line 43
if (allow_kerberos) {
#line 43

#line 43

#line 43

#line 43

#line 43
#
#line 43
# Allow the domain to create and use tcp sockets.
#line 43
# Other kinds of sockets must be separately authorized for use.
#line 43
allow dovecot_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 43

#line 43
allow dovecot_t unlabeled_t:association { sendto recvfrom };
#line 43

#line 43
#
#line 43
# Allow the domain to send or receive using any network interface.
#line 43
# netif_type is a type attribute for all network interface types.
#line 43
#
#line 43
allow dovecot_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 43
#
#line 43
# Allow the domain to send to or receive from any node.
#line 43
# node_type is a type attribute for all node types.
#line 43
#
#line 43
allow dovecot_t node_type:node { tcp_send rawip_send };
#line 43
allow dovecot_t node_type:node { tcp_recv rawip_recv };
#line 43

#line 43
#
#line 43
# Allow the domain to send to or receive from any port.
#line 43
# port_type is a type attribute for all port types.
#line 43
#
#line 43

#line 43
allow dovecot_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 43

#line 43

#line 43
# XXX Allow binding to any node type.  Remove once
#line 43
# individual rules have been added to all domains that 
#line 43
# bind sockets. 
#line 43
allow dovecot_t node_type:tcp_socket node_bind;
#line 43
#
#line 43
# Allow access to network files including /etc/resolv.conf
#line 43
#
#line 43
allow dovecot_t net_conf_t:file { read getattr lock ioctl };
#line 43

#line 43
allow dovecot_t self:tcp_socket { connect };
#line 43

#line 43

#line 43

#line 43
#
#line 43
# Allow the domain to create and use udp sockets.
#line 43
# Other kinds of sockets must be separately authorized for use.
#line 43
allow dovecot_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 43

#line 43
allow dovecot_t unlabeled_t:association { sendto recvfrom };
#line 43

#line 43
#
#line 43
# Allow the domain to send or receive using any network interface.
#line 43
# netif_type is a type attribute for all network interface types.
#line 43
#
#line 43
allow dovecot_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 43
#
#line 43
# Allow the domain to send to or receive from any node.
#line 43
# node_type is a type attribute for all node types.
#line 43
#
#line 43
allow dovecot_t node_type:node { udp_send rawip_send };
#line 43
allow dovecot_t node_type:node { udp_recv rawip_recv };
#line 43

#line 43
#
#line 43
# Allow the domain to send to or receive from any port.
#line 43
# port_type is a type attribute for all port types.
#line 43
#
#line 43

#line 43
allow dovecot_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 43

#line 43

#line 43
# XXX Allow binding to any node type.  Remove once
#line 43
# individual rules have been added to all domains that 
#line 43
# bind sockets. 
#line 43
allow dovecot_t node_type:udp_socket node_bind;
#line 43
#
#line 43
# Allow access to network files including /etc/resolv.conf
#line 43
#
#line 43
allow dovecot_t net_conf_t:file { read getattr lock ioctl };
#line 43

#line 43
allow dovecot_t self:udp_socket { connect };
#line 43

#line 43

#line 43

#line 43
allow dovecot_t kerberos_port_t:tcp_socket name_connect;
#line 43

#line 43

#line 43

#line 43

#line 43

#line 43
#
#line 43
# Allow the domain to create and use tcp sockets.
#line 43
# Other kinds of sockets must be separately authorized for use.
#line 43
allow dovecot_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 43

#line 43
allow dovecot_t unlabeled_t:association { sendto recvfrom };
#line 43

#line 43
#
#line 43
# Allow the domain to send or receive using any network interface.
#line 43
# netif_type is a type attribute for all network interface types.
#line 43
#
#line 43
allow dovecot_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 43
#
#line 43
# Allow the domain to send to or receive from any node.
#line 43
# node_type is a type attribute for all node types.
#line 43
#
#line 43
allow dovecot_t node_type:node { tcp_send rawip_send };
#line 43
allow dovecot_t node_type:node { tcp_recv rawip_recv };
#line 43

#line 43
#
#line 43
# Allow the domain to send to or receive from any port.
#line 43
# port_type is a type attribute for all port types.
#line 43
#
#line 43

#line 43
allow dovecot_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 43

#line 43

#line 43
# XXX Allow binding to any node type.  Remove once
#line 43
# individual rules have been added to all domains that 
#line 43
# bind sockets. 
#line 43
allow dovecot_t node_type:tcp_socket node_bind;
#line 43
#
#line 43
# Allow access to network files including /etc/resolv.conf
#line 43
#
#line 43
allow dovecot_t net_conf_t:file { read getattr lock ioctl };
#line 43

#line 43
allow dovecot_t self:tcp_socket { connect };
#line 43

#line 43

#line 43

#line 43
#
#line 43
# Allow the domain to create and use udp sockets.
#line 43
# Other kinds of sockets must be separately authorized for use.
#line 43
allow dovecot_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 43

#line 43
allow dovecot_t unlabeled_t:association { sendto recvfrom };
#line 43

#line 43
#
#line 43
# Allow the domain to send or receive using any network interface.
#line 43
# netif_type is a type attribute for all network interface types.
#line 43
#
#line 43
allow dovecot_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 43
#
#line 43
# Allow the domain to send to or receive from any node.
#line 43
# node_type is a type attribute for all node types.
#line 43
#
#line 43
allow dovecot_t node_type:node { udp_send rawip_send };
#line 43
allow dovecot_t node_type:node { udp_recv rawip_recv };
#line 43

#line 43
#
#line 43
# Allow the domain to send to or receive from any port.
#line 43
# port_type is a type attribute for all port types.
#line 43
#
#line 43

#line 43
allow dovecot_t dns_port_t:udp_socket { send_msg recv_msg };
#line 43

#line 43

#line 43
# XXX Allow binding to any node type.  Remove once
#line 43
# individual rules have been added to all domains that 
#line 43
# bind sockets. 
#line 43
allow dovecot_t node_type:udp_socket node_bind;
#line 43
#
#line 43
# Allow access to network files including /etc/resolv.conf
#line 43
#
#line 43
allow dovecot_t net_conf_t:file { read getattr lock ioctl };
#line 43

#line 43
allow dovecot_t self:udp_socket { connect };
#line 43

#line 43

#line 43

#line 43
allow dovecot_t dns_port_t:tcp_socket name_connect;
#line 43

#line 43
}
#line 43
 dontaudit dovecot_t krb5_conf_t:file write;
#line 43
allow dovecot_t krb5_conf_t:file { getattr read };
#line 43


allow dovecot_t tmp_t:dir search;

#line 46
allow dovecot_t mail_spool_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 46
allow dovecot_t mail_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 46
allow dovecot_t mail_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 46




#line 49
allow dovecot_t dovecot_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 49
allow dovecot_t dovecot_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 49
allow dovecot_t dovecot_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 49


#line 50
allow mta_delivery_agent dovecot_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 50
allow mta_delivery_agent dovecot_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 50
allow mta_delivery_agent dovecot_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 50

allow dovecot_t mail_spool_t:lnk_file read;
allow dovecot_t var_spool_t:dir { search };

#
# Dovecot auth daemon
#

#line 57
# dovecot_t is the parent domain (or domains), dovecot_auth_t is the child domain,
#line 57
# and , auth_chkpwd is any attributes to apply to the child
#line 57
type dovecot_auth_t, domain, privlog, daemon , auth_chkpwd;
#line 57
type dovecot_auth_exec_t, file_type, sysadmfile, exec_type;
#line 57

#line 57
role system_r types dovecot_auth_t;
#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57
#
#line 57
# Allow the process to transition to the new domain.
#line 57
#
#line 57
allow dovecot_t dovecot_auth_t:process transition;
#line 57

#line 57
#
#line 57
# Do not audit when glibc secure mode is enabled upon the transition.
#line 57
#
#line 57
dontaudit dovecot_t dovecot_auth_t:process noatsecure;
#line 57

#line 57
#
#line 57
# Do not audit when signal-related state is cleared upon the transition.
#line 57
#
#line 57
dontaudit dovecot_t dovecot_auth_t:process siginh;
#line 57

#line 57
#
#line 57
# Do not audit when resource limits are reset upon the transition.
#line 57
#
#line 57
dontaudit dovecot_t dovecot_auth_t:process rlimitinh;
#line 57

#line 57
#
#line 57
# Allow the process to execute the program.
#line 57
# 
#line 57
allow dovecot_t dovecot_auth_exec_t:file { read { getattr execute } };
#line 57

#line 57
#
#line 57
# Allow the process to reap the new domain.
#line 57
#
#line 57
allow dovecot_auth_t dovecot_t:process sigchld;
#line 57

#line 57
#
#line 57
# Allow the new domain to inherit and use file 
#line 57
# descriptions from the creating process and vice versa.
#line 57
#
#line 57
allow dovecot_auth_t dovecot_t:fd use;
#line 57
allow dovecot_t dovecot_auth_t:fd use;
#line 57

#line 57
#
#line 57
# Allow the new domain to write back to the old domain via a pipe.
#line 57
#
#line 57
allow dovecot_auth_t dovecot_t:fifo_file { ioctl read getattr lock write append };
#line 57

#line 57
#
#line 57
# Allow the new domain to read and execute the program.
#line 57
#
#line 57
allow dovecot_auth_t dovecot_auth_exec_t:file { read getattr lock execute ioctl };
#line 57

#line 57
#
#line 57
# Allow the new domain to be entered via the program.
#line 57
#
#line 57
allow dovecot_auth_t dovecot_auth_exec_t:file entrypoint;
#line 57

#line 57
type_transition dovecot_t dovecot_auth_exec_t:process dovecot_auth_t;
#line 57

#line 57

#line 57
;
#line 57
# Inherit and use descriptors from parent.
#line 57
allow dovecot_auth_t dovecot_t:fd use;
#line 57
allow dovecot_auth_t dovecot_t:process sigchld;
#line 57

#line 57
allow dovecot_auth_t self:process { sigchld sigkill sigstop signull signal };
#line 57

#line 57

#line 57
allow dovecot_auth_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 57
allow dovecot_auth_t lib_t:lnk_file { read getattr lock ioctl };
#line 57
allow dovecot_auth_t ld_so_t:file { read getattr lock execute ioctl };
#line 57
#allow dovecot_auth_t ld_so_t:file execute_no_trans;
#line 57
allow dovecot_auth_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 57
allow dovecot_auth_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 57
allow dovecot_auth_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 57
allow dovecot_auth_t texrel_shlib_t:file execmod;
#line 57
allow dovecot_auth_t ld_so_cache_t:file { read getattr lock ioctl };
#line 57
allow dovecot_auth_t device_t:dir search;
#line 57
allow dovecot_auth_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 57

#line 57

#line 57
allow dovecot_auth_t { self proc_t }:dir { read getattr lock search ioctl };
#line 57
allow dovecot_auth_t { self proc_t }:lnk_file read;
#line 57

#line 57
allow dovecot_auth_t device_t:dir getattr;
#line 57


#line 58

#line 58

#line 58
#
#line 58
# Allow the domain to create and use tcp sockets.
#line 58
# Other kinds of sockets must be separately authorized for use.
#line 58
allow dovecot_auth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 58

#line 58
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 58

#line 58
#
#line 58
# Allow the domain to send or receive using any network interface.
#line 58
# netif_type is a type attribute for all network interface types.
#line 58
#
#line 58
allow dovecot_auth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 58
#
#line 58
# Allow the domain to send to or receive from any node.
#line 58
# node_type is a type attribute for all node types.
#line 58
#
#line 58
allow dovecot_auth_t node_type:node { tcp_send rawip_send };
#line 58
allow dovecot_auth_t node_type:node { tcp_recv rawip_recv };
#line 58

#line 58
#
#line 58
# Allow the domain to send to or receive from any port.
#line 58
# port_type is a type attribute for all port types.
#line 58
#
#line 58

#line 58
allow dovecot_auth_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 58

#line 58

#line 58
# XXX Allow binding to any node type.  Remove once
#line 58
# individual rules have been added to all domains that 
#line 58
# bind sockets. 
#line 58
allow dovecot_auth_t node_type:tcp_socket node_bind;
#line 58
#
#line 58
# Allow access to network files including /etc/resolv.conf
#line 58
#
#line 58
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 58

#line 58
allow dovecot_auth_t self:tcp_socket { connect };
#line 58

#line 58
allow dovecot_auth_t ldap_port_t:tcp_socket name_connect;
#line 58


#line 59

#line 59
if (allow_ypbind) {
#line 59

#line 59

#line 59

#line 59

#line 59

#line 59

#line 59

#line 59
#
#line 59
# Allow the domain to create and use tcp sockets.
#line 59
# Other kinds of sockets must be separately authorized for use.
#line 59
allow dovecot_auth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 59

#line 59
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 59

#line 59
#
#line 59
# Allow the domain to send or receive using any network interface.
#line 59
# netif_type is a type attribute for all network interface types.
#line 59
#
#line 59
allow dovecot_auth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 59
#
#line 59
# Allow the domain to send to or receive from any node.
#line 59
# node_type is a type attribute for all node types.
#line 59
#
#line 59
allow dovecot_auth_t node_type:node { tcp_send rawip_send };
#line 59
allow dovecot_auth_t node_type:node { tcp_recv rawip_recv };
#line 59

#line 59
#
#line 59
# Allow the domain to send to or receive from any port.
#line 59
# port_type is a type attribute for all port types.
#line 59
#
#line 59

#line 59
allow dovecot_auth_t port_type:tcp_socket { send_msg recv_msg };
#line 59

#line 59

#line 59
# XXX Allow binding to any node type.  Remove once
#line 59
# individual rules have been added to all domains that 
#line 59
# bind sockets. 
#line 59
allow dovecot_auth_t node_type:tcp_socket node_bind;
#line 59
#
#line 59
# Allow access to network files including /etc/resolv.conf
#line 59
#
#line 59
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 59

#line 59
allow dovecot_auth_t self:tcp_socket { listen accept };
#line 59

#line 59

#line 59

#line 59
#
#line 59
# Allow the domain to create and use tcp sockets.
#line 59
# Other kinds of sockets must be separately authorized for use.
#line 59
allow dovecot_auth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 59

#line 59
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 59

#line 59
#
#line 59
# Allow the domain to send or receive using any network interface.
#line 59
# netif_type is a type attribute for all network interface types.
#line 59
#
#line 59
allow dovecot_auth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 59
#
#line 59
# Allow the domain to send to or receive from any node.
#line 59
# node_type is a type attribute for all node types.
#line 59
#
#line 59
allow dovecot_auth_t node_type:node { tcp_send rawip_send };
#line 59
allow dovecot_auth_t node_type:node { tcp_recv rawip_recv };
#line 59

#line 59
#
#line 59
# Allow the domain to send to or receive from any port.
#line 59
# port_type is a type attribute for all port types.
#line 59
#
#line 59

#line 59
allow dovecot_auth_t port_type:tcp_socket { send_msg recv_msg };
#line 59

#line 59

#line 59
# XXX Allow binding to any node type.  Remove once
#line 59
# individual rules have been added to all domains that 
#line 59
# bind sockets. 
#line 59
allow dovecot_auth_t node_type:tcp_socket node_bind;
#line 59
#
#line 59
# Allow access to network files including /etc/resolv.conf
#line 59
#
#line 59
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 59

#line 59
allow dovecot_auth_t self:tcp_socket { connect };
#line 59

#line 59

#line 59

#line 59

#line 59

#line 59
#
#line 59
# Allow the domain to create and use udp sockets.
#line 59
# Other kinds of sockets must be separately authorized for use.
#line 59
allow dovecot_auth_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 59

#line 59
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 59

#line 59
#
#line 59
# Allow the domain to send or receive using any network interface.
#line 59
# netif_type is a type attribute for all network interface types.
#line 59
#
#line 59
allow dovecot_auth_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 59
#
#line 59
# Allow the domain to send to or receive from any node.
#line 59
# node_type is a type attribute for all node types.
#line 59
#
#line 59
allow dovecot_auth_t node_type:node { udp_send rawip_send };
#line 59
allow dovecot_auth_t node_type:node { udp_recv rawip_recv };
#line 59

#line 59
#
#line 59
# Allow the domain to send to or receive from any port.
#line 59
# port_type is a type attribute for all port types.
#line 59
#
#line 59

#line 59
allow dovecot_auth_t port_type:udp_socket { send_msg recv_msg };
#line 59

#line 59

#line 59
# XXX Allow binding to any node type.  Remove once
#line 59
# individual rules have been added to all domains that 
#line 59
# bind sockets. 
#line 59
allow dovecot_auth_t node_type:udp_socket node_bind;
#line 59
#
#line 59
# Allow access to network files including /etc/resolv.conf
#line 59
#
#line 59
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 59

#line 59
allow dovecot_auth_t self:udp_socket { connect };
#line 59

#line 59

#line 59

#line 59

#line 59

#line 59

#line 59
allow dovecot_auth_t var_yp_t:dir { read getattr lock search ioctl };
#line 59
allow dovecot_auth_t var_yp_t:file { read getattr lock ioctl };
#line 59
allow dovecot_auth_t var_yp_t:lnk_file { getattr read };
#line 59

#line 59
allow dovecot_auth_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 59
allow dovecot_auth_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 59
dontaudit dovecot_auth_t self:capability net_bind_service;
#line 59
dontaudit dovecot_auth_t reserved_port_type:tcp_socket name_connect;
#line 59
dontaudit dovecot_auth_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 59

#line 59
} else {
#line 59
dontaudit dovecot_auth_t var_yp_t:dir search;
#line 59
}
#line 59
 

#line 60

#line 60
if (allow_kerberos) {
#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use tcp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow dovecot_auth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow dovecot_auth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow dovecot_auth_t node_type:node { tcp_send rawip_send };
#line 60
allow dovecot_auth_t node_type:node { tcp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow dovecot_auth_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow dovecot_auth_t node_type:tcp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow dovecot_auth_t self:tcp_socket { connect };
#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use udp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow dovecot_auth_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow dovecot_auth_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow dovecot_auth_t node_type:node { udp_send rawip_send };
#line 60
allow dovecot_auth_t node_type:node { udp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow dovecot_auth_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow dovecot_auth_t node_type:udp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow dovecot_auth_t self:udp_socket { connect };
#line 60

#line 60

#line 60

#line 60
allow dovecot_auth_t kerberos_port_t:tcp_socket name_connect;
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use tcp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow dovecot_auth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow dovecot_auth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow dovecot_auth_t node_type:node { tcp_send rawip_send };
#line 60
allow dovecot_auth_t node_type:node { tcp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow dovecot_auth_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow dovecot_auth_t node_type:tcp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow dovecot_auth_t self:tcp_socket { connect };
#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use udp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow dovecot_auth_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow dovecot_auth_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow dovecot_auth_t node_type:node { udp_send rawip_send };
#line 60
allow dovecot_auth_t node_type:node { udp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow dovecot_auth_t dns_port_t:udp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow dovecot_auth_t node_type:udp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow dovecot_auth_t self:udp_socket { connect };
#line 60

#line 60

#line 60

#line 60
allow dovecot_auth_t dns_port_t:tcp_socket name_connect;
#line 60

#line 60
}
#line 60
 dontaudit dovecot_auth_t krb5_conf_t:file write;
#line 60
allow dovecot_auth_t krb5_conf_t:file { getattr read };
#line 60


#line 61

#line 61

#line 61

#line 61

#line 61
#
#line 61
# Allow the domain to create and use tcp sockets.
#line 61
# Other kinds of sockets must be separately authorized for use.
#line 61
allow dovecot_auth_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 61

#line 61
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 61

#line 61
#
#line 61
# Allow the domain to send or receive using any network interface.
#line 61
# netif_type is a type attribute for all network interface types.
#line 61
#
#line 61
allow dovecot_auth_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 61
#
#line 61
# Allow the domain to send to or receive from any node.
#line 61
# node_type is a type attribute for all node types.
#line 61
#
#line 61
allow dovecot_auth_t node_type:node { tcp_send rawip_send };
#line 61
allow dovecot_auth_t node_type:node { tcp_recv rawip_recv };
#line 61

#line 61
#
#line 61
# Allow the domain to send to or receive from any port.
#line 61
# port_type is a type attribute for all port types.
#line 61
#
#line 61

#line 61
allow dovecot_auth_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 61

#line 61

#line 61
# XXX Allow binding to any node type.  Remove once
#line 61
# individual rules have been added to all domains that 
#line 61
# bind sockets. 
#line 61
allow dovecot_auth_t node_type:tcp_socket node_bind;
#line 61
#
#line 61
# Allow access to network files including /etc/resolv.conf
#line 61
#
#line 61
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 61

#line 61
allow dovecot_auth_t self:tcp_socket { connect };
#line 61

#line 61

#line 61

#line 61
#
#line 61
# Allow the domain to create and use udp sockets.
#line 61
# Other kinds of sockets must be separately authorized for use.
#line 61
allow dovecot_auth_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 61

#line 61
allow dovecot_auth_t unlabeled_t:association { sendto recvfrom };
#line 61

#line 61
#
#line 61
# Allow the domain to send or receive using any network interface.
#line 61
# netif_type is a type attribute for all network interface types.
#line 61
#
#line 61
allow dovecot_auth_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 61
#
#line 61
# Allow the domain to send to or receive from any node.
#line 61
# node_type is a type attribute for all node types.
#line 61
#
#line 61
allow dovecot_auth_t node_type:node { udp_send rawip_send };
#line 61
allow dovecot_auth_t node_type:node { udp_recv rawip_recv };
#line 61

#line 61
#
#line 61
# Allow the domain to send to or receive from any port.
#line 61
# port_type is a type attribute for all port types.
#line 61
#
#line 61

#line 61
allow dovecot_auth_t dns_port_t:udp_socket { send_msg recv_msg };
#line 61

#line 61

#line 61
# XXX Allow binding to any node type.  Remove once
#line 61
# individual rules have been added to all domains that 
#line 61
# bind sockets. 
#line 61
allow dovecot_auth_t node_type:udp_socket node_bind;
#line 61
#
#line 61
# Allow access to network files including /etc/resolv.conf
#line 61
#
#line 61
allow dovecot_auth_t net_conf_t:file { read getattr lock ioctl };
#line 61

#line 61
allow dovecot_auth_t self:udp_socket { connect };
#line 61

#line 61

#line 61

#line 61
allow dovecot_auth_t dns_port_t:tcp_socket name_connect;
#line 61

allow dovecot_auth_t self:process { fork { sigchld sigkill sigstop signull signal } };
allow dovecot_auth_t self:capability { setgid setuid };
allow dovecot_auth_t dovecot_t:unix_stream_socket { getattr accept read write ioctl };
allow dovecot_auth_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow dovecot_auth_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow dovecot_auth_t self:fifo_file { ioctl read getattr lock write append };
allow dovecot_auth_t urandom_device_t:chr_file { getattr read };
allow dovecot_auth_t etc_t:file { getattr read };
allow dovecot_auth_t { self proc_t }:file { getattr read };

#line 71
allow dovecot_auth_t etc_t:lnk_file read;
#line 71
allow dovecot_auth_t lib_t:file { read getattr lock ioctl };
#line 71

#line 71
allow dovecot_auth_t locale_t:dir { read getattr lock search ioctl };
#line 71
allow dovecot_auth_t locale_t:file { read getattr lock ioctl };
#line 71
allow dovecot_auth_t locale_t:lnk_file { getattr read };
#line 71

#line 71


#line 72
# Read system variables in /sys.
#line 72

#line 72
allow dovecot_auth_t sysctl_t:dir search;
#line 72
allow dovecot_auth_t sysctl_kernel_t:dir search;
#line 72
allow dovecot_auth_t sysctl_kernel_t:file { getattr read };
#line 72

#line 72

#line 72

allow dovecot_auth_t dovecot_passwd_t:file { getattr read };
dontaudit dovecot_auth_t selinux_config_t:dir search;
allow dovecot_auth_t etc_runtime_t:file { getattr read };
#line 1 "domains/program/fingerd.te"
#DESC Fingerd - Finger daemon
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: fingerd cfingerd efingerd ffingerd
#

#################################
#
# Rules for the fingerd_t domain.
#
# fingerd_exec_t is the type of the fingerd executable.
#

#line 13

#line 13

#line 13

#line 13
type fingerd_t, domain, privlog, daemon , transitionbool;
#line 13
type fingerd_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit fingerd_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types fingerd_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow fingerd_t init_t:fd use;
#line 13
allow fingerd_t init_t:process sigchld;
#line 13
allow fingerd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow fingerd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow fingerd_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow fingerd_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow fingerd_t ld_so_t:file execute_no_trans;
#line 13
allow fingerd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow fingerd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow fingerd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow fingerd_t texrel_shlib_t:file execmod;
#line 13
allow fingerd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow fingerd_t device_t:dir search;
#line 13
allow fingerd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow fingerd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow fingerd_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow fingerd_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow fingerd_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow fingerd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit fingerd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit fingerd_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow fingerd_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow fingerd_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow fingerd_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow fingerd_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit fingerd_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit fingerd_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow fingerd_t sysctl_t:dir search;
#line 13
allow fingerd_t sysctl_kernel_t:dir search;
#line 13
allow fingerd_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13

#line 13
bool fingerd_disable_trans false;
#line 13
if (fingerd_disable_trans) {
#line 13

#line 13
allow initrc_t fingerd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13

#line 13
allow sysadm_t fingerd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13
} else {
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t fingerd_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t fingerd_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t fingerd_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t fingerd_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t fingerd_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow fingerd_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow fingerd_t initrc_t:fd use;
#line 13
allow initrc_t fingerd_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow fingerd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow fingerd_t fingerd_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow fingerd_t fingerd_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t fingerd_exec_t:process fingerd_t;
#line 13

#line 13

#line 13
allow initrc_t fingerd_t:process { noatsecure siginh rlimitinh };
#line 13

#line 13
}
#line 13
 
#line 13
allow fingerd_t privfd:fd use;
#line 13

#line 13
allow fingerd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
# Create pid file.
#line 13
allow fingerd_t var_t:dir { getattr search };
#line 13

#line 13
type fingerd_var_run_t, file_type, sysadmfile, pidfile;
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow fingerd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow fingerd_t fingerd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition fingerd_t var_run_t:file fingerd_var_run_t;
#line 13

#line 13

#line 13

#line 13
allow fingerd_t var_t:dir search;
#line 13
allow fingerd_t fingerd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13

#line 13
allow fingerd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13
# for daemons that look at /root on startup
#line 13
dontaudit fingerd_t sysadm_home_dir_t:dir search;
#line 13

#line 13
# for df
#line 13
allow fingerd_t fs_type:filesystem getattr;
#line 13
allow fingerd_t removable_t:filesystem getattr;
#line 13

#line 13

#line 13
allow fingerd_t etc_t:lnk_file read;
#line 13
allow fingerd_t lib_t:file { read getattr lock ioctl };
#line 13

#line 13
allow fingerd_t locale_t:dir { read getattr lock search ioctl };
#line 13
allow fingerd_t locale_t:file { read getattr lock ioctl };
#line 13
allow fingerd_t locale_t:lnk_file { getattr read };
#line 13

#line 13

#line 13

#line 13
# for localization
#line 13
allow fingerd_t lib_t:file { getattr read };
#line 13



#line 15

#line 15
type fingerd_etc_t, file_type, sysadmfile, usercanread;
#line 15
allow fingerd_t fingerd_etc_t:file { read getattr lock ioctl };
#line 15

#line 15
allow fingerd_t fingerd_etc_t:dir { read getattr lock search ioctl };
#line 15
allow fingerd_t fingerd_etc_t:lnk_file { getattr read };
#line 15


allow fingerd_t etc_t:lnk_file read;
allow fingerd_t { etc_t etc_runtime_t }:file { read getattr };


#line 20
type fingerd_log_t, file_type, sysadmfile, logfile;
#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the process to modify the directory.
#line 20
#
#line 20
allow fingerd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 20

#line 20
#
#line 20
# Allow the process to create the file.
#line 20
#
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
allow fingerd_t fingerd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
type_transition fingerd_t var_log_t:file fingerd_log_t;
#line 20

#line 20

#line 20


#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the process to transition to the new domain.
#line 21
#
#line 21
allow system_crond_t fingerd_t:process transition;
#line 21

#line 21
#
#line 21
# Do not audit when glibc secure mode is enabled upon the transition.
#line 21
#
#line 21
dontaudit system_crond_t fingerd_t:process noatsecure;
#line 21

#line 21
#
#line 21
# Do not audit when signal-related state is cleared upon the transition.
#line 21
#
#line 21
dontaudit system_crond_t fingerd_t:process siginh;
#line 21

#line 21
#
#line 21
# Do not audit when resource limits are reset upon the transition.
#line 21
#
#line 21
dontaudit system_crond_t fingerd_t:process rlimitinh;
#line 21

#line 21
#
#line 21
# Allow the process to execute the program.
#line 21
# 
#line 21
allow system_crond_t fingerd_exec_t:file { read { getattr execute } };
#line 21

#line 21
#
#line 21
# Allow the process to reap the new domain.
#line 21
#
#line 21
allow fingerd_t system_crond_t:process sigchld;
#line 21

#line 21
#
#line 21
# Allow the new domain to inherit and use file 
#line 21
# descriptions from the creating process and vice versa.
#line 21
#
#line 21
allow fingerd_t system_crond_t:fd use;
#line 21
allow system_crond_t fingerd_t:fd use;
#line 21

#line 21
#
#line 21
# Allow the new domain to write back to the old domain via a pipe.
#line 21
#
#line 21
allow fingerd_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 21

#line 21
#
#line 21
# Allow the new domain to read and execute the program.
#line 21
#
#line 21
allow fingerd_t fingerd_exec_t:file { read getattr lock execute ioctl };
#line 21

#line 21
#
#line 21
# Allow the new domain to be entered via the program.
#line 21
#
#line 21
allow fingerd_t fingerd_exec_t:file entrypoint;
#line 21

#line 21
type_transition system_crond_t fingerd_exec_t:process fingerd_t;
#line 21

#line 21
allow fingerd_t crond_t:fifo_file { getattr read write ioctl };
#line 21
# a rule for privfd may make this obsolete
#line 21
allow fingerd_t crond_t:fd use;
#line 21
allow fingerd_t crond_t:process sigchld;
#line 21



allow fingerd_t fingerd_port_t:tcp_socket name_bind;
#line 30

#line 30
allow inetd_t fingerd_port_t:tcp_socket name_bind;
#line 30
# can be run from inetd
#line 30

#line 30

#line 30

#line 30
#
#line 30
# Allow the process to transition to the new domain.
#line 30
#
#line 30
allow inetd_t fingerd_t:process transition;
#line 30

#line 30
#
#line 30
# Do not audit when glibc secure mode is enabled upon the transition.
#line 30
#
#line 30
dontaudit inetd_t fingerd_t:process noatsecure;
#line 30

#line 30
#
#line 30
# Do not audit when signal-related state is cleared upon the transition.
#line 30
#
#line 30
dontaudit inetd_t fingerd_t:process siginh;
#line 30

#line 30
#
#line 30
# Do not audit when resource limits are reset upon the transition.
#line 30
#
#line 30
dontaudit inetd_t fingerd_t:process rlimitinh;
#line 30

#line 30
#
#line 30
# Allow the process to execute the program.
#line 30
# 
#line 30
allow inetd_t fingerd_exec_t:file { read { getattr execute } };
#line 30

#line 30
#
#line 30
# Allow the process to reap the new domain.
#line 30
#
#line 30
allow fingerd_t inetd_t:process sigchld;
#line 30

#line 30
#
#line 30
# Allow the new domain to inherit and use file 
#line 30
# descriptions from the creating process and vice versa.
#line 30
#
#line 30
allow fingerd_t inetd_t:fd use;
#line 30
allow inetd_t fingerd_t:fd use;
#line 30

#line 30
#
#line 30
# Allow the new domain to write back to the old domain via a pipe.
#line 30
#
#line 30
allow fingerd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 30

#line 30
#
#line 30
# Allow the new domain to read and execute the program.
#line 30
#
#line 30
allow fingerd_t fingerd_exec_t:file { read getattr lock execute ioctl };
#line 30

#line 30
#
#line 30
# Allow the new domain to be entered via the program.
#line 30
#
#line 30
allow fingerd_t fingerd_exec_t:file entrypoint;
#line 30

#line 30
type_transition inetd_t fingerd_exec_t:process fingerd_t;
#line 30

#line 30
allow fingerd_t inetd_t:tcp_socket { read write getattr ioctl };
#line 30

#line 33


allow fingerd_t self:capability { setgid setuid };
# for gzip from logrotate
dontaudit fingerd_t self:capability fsetid;

# cfingerd runs shell scripts
allow fingerd_t { bin_t sbin_t }:dir search;
allow fingerd_t bin_t:lnk_file read;

#line 42
allow fingerd_t { shell_exec_t bin_t sbin_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 42

allow fingerd_t devtty_t:chr_file { read write };

allow fingerd_t { ttyfile ptyfile }:chr_file getattr;

# Use the network.

#line 48

#line 48

#line 48

#line 48
#
#line 48
# Allow the domain to create and use tcp sockets.
#line 48
# Other kinds of sockets must be separately authorized for use.
#line 48
allow fingerd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 48

#line 48
allow fingerd_t unlabeled_t:association { sendto recvfrom };
#line 48

#line 48
#
#line 48
# Allow the domain to send or receive using any network interface.
#line 48
# netif_type is a type attribute for all network interface types.
#line 48
#
#line 48
allow fingerd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 48
#
#line 48
# Allow the domain to send to or receive from any node.
#line 48
# node_type is a type attribute for all node types.
#line 48
#
#line 48
allow fingerd_t node_type:node { tcp_send rawip_send };
#line 48
allow fingerd_t node_type:node { tcp_recv rawip_recv };
#line 48

#line 48
#
#line 48
# Allow the domain to send to or receive from any port.
#line 48
# port_type is a type attribute for all port types.
#line 48
#
#line 48

#line 48
allow fingerd_t port_type:tcp_socket { send_msg recv_msg };
#line 48

#line 48

#line 48
# XXX Allow binding to any node type.  Remove once
#line 48
# individual rules have been added to all domains that 
#line 48
# bind sockets. 
#line 48
allow fingerd_t node_type:tcp_socket node_bind;
#line 48
#
#line 48
# Allow access to network files including /etc/resolv.conf
#line 48
#
#line 48
allow fingerd_t net_conf_t:file { read getattr lock ioctl };
#line 48

#line 48
allow fingerd_t self:tcp_socket { listen accept };
#line 48

#line 48

#line 48

#line 48
#
#line 48
# Allow the domain to create and use udp sockets.
#line 48
# Other kinds of sockets must be separately authorized for use.
#line 48
allow fingerd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 48

#line 48
allow fingerd_t unlabeled_t:association { sendto recvfrom };
#line 48

#line 48
#
#line 48
# Allow the domain to send or receive using any network interface.
#line 48
# netif_type is a type attribute for all network interface types.
#line 48
#
#line 48
allow fingerd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 48
#
#line 48
# Allow the domain to send to or receive from any node.
#line 48
# node_type is a type attribute for all node types.
#line 48
#
#line 48
allow fingerd_t node_type:node { udp_send rawip_send };
#line 48
allow fingerd_t node_type:node { udp_recv rawip_recv };
#line 48

#line 48
#
#line 48
# Allow the domain to send to or receive from any port.
#line 48
# port_type is a type attribute for all port types.
#line 48
#
#line 48

#line 48
allow fingerd_t port_type:udp_socket { send_msg recv_msg };
#line 48

#line 48

#line 48
# XXX Allow binding to any node type.  Remove once
#line 48
# individual rules have been added to all domains that 
#line 48
# bind sockets. 
#line 48
allow fingerd_t node_type:udp_socket node_bind;
#line 48
#
#line 48
# Allow access to network files including /etc/resolv.conf
#line 48
#
#line 48
allow fingerd_t net_conf_t:file { read getattr lock ioctl };
#line 48

#line 48
allow fingerd_t self:udp_socket { connect };
#line 48

#line 48

#line 48


#line 49

#line 49
if (allow_ypbind) {
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use tcp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow fingerd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow fingerd_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow fingerd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow fingerd_t node_type:node { tcp_send rawip_send };
#line 49
allow fingerd_t node_type:node { tcp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow fingerd_t port_type:tcp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow fingerd_t node_type:tcp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow fingerd_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow fingerd_t self:tcp_socket { listen accept };
#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use tcp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow fingerd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow fingerd_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow fingerd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow fingerd_t node_type:node { tcp_send rawip_send };
#line 49
allow fingerd_t node_type:node { tcp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow fingerd_t port_type:tcp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow fingerd_t node_type:tcp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow fingerd_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow fingerd_t self:tcp_socket { connect };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use udp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow fingerd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow fingerd_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow fingerd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow fingerd_t node_type:node { udp_send rawip_send };
#line 49
allow fingerd_t node_type:node { udp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow fingerd_t port_type:udp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow fingerd_t node_type:udp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow fingerd_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow fingerd_t self:udp_socket { connect };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow fingerd_t var_yp_t:dir { read getattr lock search ioctl };
#line 49
allow fingerd_t var_yp_t:file { read getattr lock ioctl };
#line 49
allow fingerd_t var_yp_t:lnk_file { getattr read };
#line 49

#line 49
allow fingerd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 49
allow fingerd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 49
dontaudit fingerd_t self:capability net_bind_service;
#line 49
dontaudit fingerd_t reserved_port_type:tcp_socket name_connect;
#line 49
dontaudit fingerd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 49

#line 49
} else {
#line 49
dontaudit fingerd_t var_yp_t:dir search;
#line 49
}
#line 49
 

allow fingerd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow fingerd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow fingerd_t self:fifo_file { read write getattr };

# allow any user domain to connect to the finger server

#line 56
#allow userdomain fingerd_t:tcp_socket { connectto recvfrom };
#line 56
#allow fingerd_t userdomain:tcp_socket { acceptfrom recvfrom };
#line 56
#allow fingerd_t kernel_t:tcp_socket recvfrom;
#line 56
#allow userdomain kernel_t:tcp_socket recvfrom;
#line 56


# for .finger, .plan. etc
allow fingerd_t { home_root_t user_home_dir_type }:dir search;
# should really have a different type for .plan etc
allow fingerd_t user_home_type:file { getattr read };
# stop it accessing sub-directories, prevents checking a Maildir for new mail,
# have to change this when we create a type for Maildir
dontaudit fingerd_t user_home_t:dir search;

# for mail
allow fingerd_t { var_spool_t mail_spool_t }:dir search;
allow fingerd_t mail_spool_t:file getattr;
allow fingerd_t mail_spool_t:lnk_file read;

# see who is logged in and when users last logged in
allow fingerd_t { initrc_var_run_t lastlog_t }:file { read getattr };
dontaudit fingerd_t initrc_var_run_t:file lock;
allow fingerd_t devpts_t:dir search;
allow fingerd_t ptyfile:chr_file getattr;

allow fingerd_t proc_t:file { read getattr };

# for date command

#line 80
# Read system variables in /sys.
#line 80

#line 80
allow fingerd_t sysctl_t:dir search;
#line 80
allow fingerd_t sysctl_kernel_t:dir search;
#line 80
allow fingerd_t sysctl_kernel_t:file { getattr read };
#line 80

#line 80

#line 80

#line 1 "domains/program/firstboot.te"
#DESC firstboot
#
# Author:  Dan Walsh <dwalsh@redhat.com>
# X-Debian-Packages: firstboot
#

#################################
#
# Rules for the firstboot_t domain.
#
# firstboot_exec_t is the type of the firstboot executable.
#

#line 13
type firstboot_t, domain, privlog , admin, etc_writer, fs_domain, privmem, auth_write, privowner, privmodule, privuser, sysctl_kernel_writer;
#line 13
type firstboot_exec_t, file_type, sysadmfile, exec_type;
#line 13
role sysadm_r types firstboot_t;
#line 13

#line 13
role system_r types firstboot_t;
#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow sysadm_t firstboot_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit sysadm_t firstboot_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit sysadm_t firstboot_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit sysadm_t firstboot_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow sysadm_t firstboot_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow firstboot_t sysadm_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow firstboot_t sysadm_t:fd use;
#line 13
allow sysadm_t firstboot_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow firstboot_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow firstboot_t firstboot_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow firstboot_t firstboot_exec_t:file entrypoint;
#line 13

#line 13
type_transition sysadm_t firstboot_exec_t:process firstboot_t;
#line 13

#line 13

#line 13
allow firstboot_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow firstboot_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow firstboot_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow firstboot_t ld_so_t:file execute_no_trans;
#line 13
allow firstboot_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow firstboot_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow firstboot_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow firstboot_t texrel_shlib_t:file execmod;
#line 13
allow firstboot_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow firstboot_t device_t:dir search;
#line 13
allow firstboot_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

type firstboot_rw_t, file_type, sysadmfile;
role system_r types firstboot_t;

#line 19



#line 21
type firstboot_etc_t, file_type, sysadmfile, usercanread;
#line 21
allow firstboot_t firstboot_etc_t:file { read getattr lock ioctl };
#line 21


allow firstboot_t proc_t:file { read getattr lock ioctl };

allow firstboot_t urandom_device_t:chr_file { getattr read };
allow firstboot_t proc_t:file { getattr read write };


#line 28

#line 28

#line 28
#
#line 28
# Allow the process to transition to the new domain.
#line 28
#
#line 28
allow initrc_t firstboot_t:process transition;
#line 28

#line 28
#
#line 28
# Do not audit when glibc secure mode is enabled upon the transition.
#line 28
#
#line 28
dontaudit initrc_t firstboot_t:process noatsecure;
#line 28

#line 28
#
#line 28
# Do not audit when signal-related state is cleared upon the transition.
#line 28
#
#line 28
dontaudit initrc_t firstboot_t:process siginh;
#line 28

#line 28
#
#line 28
# Do not audit when resource limits are reset upon the transition.
#line 28
#
#line 28
dontaudit initrc_t firstboot_t:process rlimitinh;
#line 28

#line 28
#
#line 28
# Allow the process to execute the program.
#line 28
# 
#line 28
allow initrc_t firstboot_exec_t:file { read { getattr execute } };
#line 28

#line 28
#
#line 28
# Allow the process to reap the new domain.
#line 28
#
#line 28
allow firstboot_t initrc_t:process sigchld;
#line 28

#line 28
#
#line 28
# Allow the new domain to inherit and use file 
#line 28
# descriptions from the creating process and vice versa.
#line 28
#
#line 28
allow firstboot_t initrc_t:fd use;
#line 28
allow initrc_t firstboot_t:fd use;
#line 28

#line 28
#
#line 28
# Allow the new domain to write back to the old domain via a pipe.
#line 28
#
#line 28
allow firstboot_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 28

#line 28
#
#line 28
# Allow the new domain to read and execute the program.
#line 28
#
#line 28
allow firstboot_t firstboot_exec_t:file { read getattr lock execute ioctl };
#line 28

#line 28
#
#line 28
# Allow the new domain to be entered via the program.
#line 28
#
#line 28
allow firstboot_t firstboot_exec_t:file entrypoint;
#line 28

#line 28
type_transition initrc_t firstboot_exec_t:process firstboot_t;
#line 28


#line 29

#line 29

#line 29

#line 29
#
#line 29
# Allow the process to modify the directory.
#line 29
#
#line 29
allow firstboot_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 29

#line 29
#
#line 29
# Allow the process to create the file.
#line 29
#
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
allow firstboot_t firstboot_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
type_transition firstboot_t etc_t:file firstboot_rw_t;
#line 29

#line 29



#line 31
allow firstboot_t { bin_t sbin_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 31
allow firstboot_t { bin_t sbin_t etc_t }:lnk_file { getattr read };
#line 31

#line 31
allow firstboot_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 31
allow firstboot_t lib_t:lnk_file { read getattr lock ioctl };
#line 31
allow firstboot_t ld_so_t:file { read getattr lock execute ioctl };
#line 31
#allow firstboot_t ld_so_t:file execute_no_trans;
#line 31
allow firstboot_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 31
allow firstboot_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 31
allow firstboot_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 31
allow firstboot_t texrel_shlib_t:file execmod;
#line 31
allow firstboot_t ld_so_cache_t:file { read getattr lock ioctl };
#line 31
allow firstboot_t device_t:dir search;
#line 31
allow firstboot_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 31

#line 31

#line 31
allow firstboot_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 31

#line 31

#line 31
allow firstboot_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 31

#line 31

#line 31
allow firstboot_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 31

#line 31

#line 31
allow firstboot_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 31

#line 31

#line 31
allow firstboot_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 31

#line 31

#line 31
allow firstboot_t ld_so_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 31

#line 31

#line 35

allow firstboot_t etc_runtime_t:file { getattr read };


#line 38
allow firstboot_t etc_t:dir { read getattr lock search ioctl };
#line 38
allow firstboot_t etc_t:file { read getattr lock ioctl };
#line 38
allow firstboot_t etc_t:lnk_file { getattr read };
#line 38


allow firstboot_t firstboot_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
allow firstboot_t firstboot_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
allow firstboot_t self:fifo_file { getattr read write };
allow firstboot_t self:process { fork sigchld };
allow firstboot_t self:unix_stream_socket { connect create };
allow firstboot_t initrc_exec_t:file { getattr read };
allow firstboot_t initrc_var_run_t:file { read getattr lock ioctl };
allow firstboot_t lib_t:file { getattr read };
allow firstboot_t local_login_t:fd use;

#line 49
allow firstboot_t etc_t:lnk_file read;
#line 49
allow firstboot_t lib_t:file { read getattr lock ioctl };
#line 49

#line 49
allow firstboot_t locale_t:dir { read getattr lock search ioctl };
#line 49
allow firstboot_t locale_t:file { read getattr lock ioctl };
#line 49
allow firstboot_t locale_t:lnk_file { getattr read };
#line 49

#line 49


allow firstboot_t proc_t:dir search;
allow firstboot_t { devtty_t sysadm_tty_device_t }:chr_file { ioctl read getattr lock write append };
allow firstboot_t usr_t:file { read getattr lock ioctl };

allow firstboot_t etc_t:file write;

# Allow write to utmp file
allow firstboot_t initrc_var_run_t:file write;

#line 62

#line 62

#line 62
allow firstboot_t samba_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 62
allow firstboot_t samba_etc_t:file { ioctl read getattr lock write append };
#line 62
allow firstboot_t samba_etc_t:lnk_file { getattr read };
#line 62

#line 62


dontaudit firstboot_t shadow_t:file getattr;

role system_r types initrc_t;
#role_transition firstboot_r initrc_exec_t system_r;

#line 68

#line 68

#line 68
#
#line 68
# Allow the process to transition to the new domain.
#line 68
#
#line 68
allow firstboot_t initrc_t:process transition;
#line 68

#line 68
#
#line 68
# Do not audit when glibc secure mode is enabled upon the transition.
#line 68
#
#line 68
dontaudit firstboot_t initrc_t:process noatsecure;
#line 68

#line 68
#
#line 68
# Do not audit when signal-related state is cleared upon the transition.
#line 68
#
#line 68
dontaudit firstboot_t initrc_t:process siginh;
#line 68

#line 68
#
#line 68
# Do not audit when resource limits are reset upon the transition.
#line 68
#
#line 68
dontaudit firstboot_t initrc_t:process rlimitinh;
#line 68

#line 68
#
#line 68
# Allow the process to execute the program.
#line 68
# 
#line 68
allow firstboot_t initrc_exec_t:file { read { getattr execute } };
#line 68

#line 68
#
#line 68
# Allow the process to reap the new domain.
#line 68
#
#line 68
allow initrc_t firstboot_t:process sigchld;
#line 68

#line 68
#
#line 68
# Allow the new domain to inherit and use file 
#line 68
# descriptions from the creating process and vice versa.
#line 68
#
#line 68
allow initrc_t firstboot_t:fd use;
#line 68
allow firstboot_t initrc_t:fd use;
#line 68

#line 68
#
#line 68
# Allow the new domain to write back to the old domain via a pipe.
#line 68
#
#line 68
allow initrc_t firstboot_t:fifo_file { ioctl read getattr lock write append };
#line 68

#line 68
#
#line 68
# Allow the new domain to read and execute the program.
#line 68
#
#line 68
allow initrc_t initrc_exec_t:file { read getattr lock execute ioctl };
#line 68

#line 68
#
#line 68
# Allow the new domain to be entered via the program.
#line 68
#
#line 68
allow initrc_t initrc_exec_t:file entrypoint;
#line 68

#line 68
type_transition firstboot_t initrc_exec_t:process initrc_t;
#line 68


allow firstboot_t self:passwd rootok;

#line 75


#line 81

#line 81
allow consoletype_t devtty_t:chr_file { read write };
#line 81
allow consoletype_t etc_t:file { getattr read };
#line 81
allow consoletype_t firstboot_t:fd use;
#line 81


allow firstboot_t etc_t:{ file lnk_file } { create ioctl read getattr lock write setattr append link unlink rename };

allow firstboot_t self:capability { dac_override setgid };
allow firstboot_t self:dir search;
allow firstboot_t self:file { read write };
allow firstboot_t self:lnk_file read;

#line 89
allow firstboot_t self:process setfscreate;
#line 89
allow firstboot_t proc_t:dir search;
#line 89
allow firstboot_t proc_t:{ file lnk_file } read;
#line 89
allow firstboot_t self:dir search;
#line 89
allow firstboot_t self:file { getattr read write };
#line 89

allow firstboot_t krb5_conf_t:file { ioctl read getattr lock write append };

allow firstboot_t modules_conf_t:file { getattr read };
allow firstboot_t modules_dep_t:file { getattr read };
allow firstboot_t modules_object_t:dir search;
allow firstboot_t port_t:tcp_socket { recv_msg send_msg };
allow firstboot_t proc_t:lnk_file read;


#line 98
# Get the selinuxfs mount point via /proc/self/mounts.
#line 98
allow firstboot_t proc_t:dir search;
#line 98
allow firstboot_t proc_t:{ file lnk_file } { getattr read };
#line 98
allow firstboot_t self:dir search;
#line 98
allow firstboot_t self:file { getattr read };
#line 98
# Access selinuxfs.
#line 98
allow firstboot_t security_t:dir { read search getattr };
#line 98
allow firstboot_t security_t:file { getattr read write };
#line 98
allow firstboot_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 98


dontaudit firstboot_t sysadm_t:process { noatsecure rlimitinh siginh transition };

#line 101
# Read system variables in /sys.
#line 101

#line 101
allow firstboot_t sysctl_t:dir search;
#line 101
allow firstboot_t sysctl_kernel_t:dir search;
#line 101
allow firstboot_t sysctl_kernel_t:file { getattr read };
#line 101

#line 101

#line 101


allow firstboot_t var_run_t:dir getattr;
allow firstboot_t var_t:dir getattr;
#line 108

#line 108
allow hostname_t devtty_t:chr_file { read write };
#line 108
allow hostname_t firstboot_t:fd use;
#line 108

#line 113


#line 114

#line 114

#line 114

#line 114
#
#line 114
# Allow the domain to create and use tcp sockets.
#line 114
# Other kinds of sockets must be separately authorized for use.
#line 114
allow firstboot_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 114

#line 114
allow firstboot_t unlabeled_t:association { sendto recvfrom };
#line 114

#line 114
#
#line 114
# Allow the domain to send or receive using any network interface.
#line 114
# netif_type is a type attribute for all network interface types.
#line 114
#
#line 114
allow firstboot_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 114
#
#line 114
# Allow the domain to send to or receive from any node.
#line 114
# node_type is a type attribute for all node types.
#line 114
#
#line 114
allow firstboot_t node_type:node { tcp_send rawip_send };
#line 114
allow firstboot_t node_type:node { tcp_recv rawip_recv };
#line 114

#line 114
#
#line 114
# Allow the domain to send to or receive from any port.
#line 114
# port_type is a type attribute for all port types.
#line 114
#
#line 114

#line 114
allow firstboot_t port_type:tcp_socket { send_msg recv_msg };
#line 114

#line 114

#line 114
# XXX Allow binding to any node type.  Remove once
#line 114
# individual rules have been added to all domains that 
#line 114
# bind sockets. 
#line 114
allow firstboot_t node_type:tcp_socket node_bind;
#line 114
#
#line 114
# Allow access to network files including /etc/resolv.conf
#line 114
#
#line 114
allow firstboot_t net_conf_t:file { read getattr lock ioctl };
#line 114

#line 114
allow firstboot_t self:tcp_socket { listen accept };
#line 114

#line 114

#line 114

#line 114
#
#line 114
# Allow the domain to create and use udp sockets.
#line 114
# Other kinds of sockets must be separately authorized for use.
#line 114
allow firstboot_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 114

#line 114
allow firstboot_t unlabeled_t:association { sendto recvfrom };
#line 114

#line 114
#
#line 114
# Allow the domain to send or receive using any network interface.
#line 114
# netif_type is a type attribute for all network interface types.
#line 114
#
#line 114
allow firstboot_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 114
#
#line 114
# Allow the domain to send to or receive from any node.
#line 114
# node_type is a type attribute for all node types.
#line 114
#
#line 114
allow firstboot_t node_type:node { udp_send rawip_send };
#line 114
allow firstboot_t node_type:node { udp_recv rawip_recv };
#line 114

#line 114
#
#line 114
# Allow the domain to send to or receive from any port.
#line 114
# port_type is a type attribute for all port types.
#line 114
#
#line 114

#line 114
allow firstboot_t port_type:udp_socket { send_msg recv_msg };
#line 114

#line 114

#line 114
# XXX Allow binding to any node type.  Remove once
#line 114
# individual rules have been added to all domains that 
#line 114
# bind sockets. 
#line 114
allow firstboot_t node_type:udp_socket node_bind;
#line 114
#
#line 114
# Allow access to network files including /etc/resolv.conf
#line 114
#
#line 114
allow firstboot_t net_conf_t:file { read getattr lock ioctl };
#line 114

#line 114
allow firstboot_t self:udp_socket { connect };
#line 114

#line 114

#line 114


#line 115

#line 115
if (allow_ypbind) {
#line 115

#line 115

#line 115

#line 115

#line 115

#line 115

#line 115

#line 115
#
#line 115
# Allow the domain to create and use tcp sockets.
#line 115
# Other kinds of sockets must be separately authorized for use.
#line 115
allow firstboot_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 115

#line 115
allow firstboot_t unlabeled_t:association { sendto recvfrom };
#line 115

#line 115
#
#line 115
# Allow the domain to send or receive using any network interface.
#line 115
# netif_type is a type attribute for all network interface types.
#line 115
#
#line 115
allow firstboot_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 115
#
#line 115
# Allow the domain to send to or receive from any node.
#line 115
# node_type is a type attribute for all node types.
#line 115
#
#line 115
allow firstboot_t node_type:node { tcp_send rawip_send };
#line 115
allow firstboot_t node_type:node { tcp_recv rawip_recv };
#line 115

#line 115
#
#line 115
# Allow the domain to send to or receive from any port.
#line 115
# port_type is a type attribute for all port types.
#line 115
#
#line 115

#line 115
allow firstboot_t port_type:tcp_socket { send_msg recv_msg };
#line 115

#line 115

#line 115
# XXX Allow binding to any node type.  Remove once
#line 115
# individual rules have been added to all domains that 
#line 115
# bind sockets. 
#line 115
allow firstboot_t node_type:tcp_socket node_bind;
#line 115
#
#line 115
# Allow access to network files including /etc/resolv.conf
#line 115
#
#line 115
allow firstboot_t net_conf_t:file { read getattr lock ioctl };
#line 115

#line 115
allow firstboot_t self:tcp_socket { listen accept };
#line 115

#line 115

#line 115

#line 115
#
#line 115
# Allow the domain to create and use tcp sockets.
#line 115
# Other kinds of sockets must be separately authorized for use.
#line 115
allow firstboot_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 115

#line 115
allow firstboot_t unlabeled_t:association { sendto recvfrom };
#line 115

#line 115
#
#line 115
# Allow the domain to send or receive using any network interface.
#line 115
# netif_type is a type attribute for all network interface types.
#line 115
#
#line 115
allow firstboot_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 115
#
#line 115
# Allow the domain to send to or receive from any node.
#line 115
# node_type is a type attribute for all node types.
#line 115
#
#line 115
allow firstboot_t node_type:node { tcp_send rawip_send };
#line 115
allow firstboot_t node_type:node { tcp_recv rawip_recv };
#line 115

#line 115
#
#line 115
# Allow the domain to send to or receive from any port.
#line 115
# port_type is a type attribute for all port types.
#line 115
#
#line 115

#line 115
allow firstboot_t port_type:tcp_socket { send_msg recv_msg };
#line 115

#line 115

#line 115
# XXX Allow binding to any node type.  Remove once
#line 115
# individual rules have been added to all domains that 
#line 115
# bind sockets. 
#line 115
allow firstboot_t node_type:tcp_socket node_bind;
#line 115
#
#line 115
# Allow access to network files including /etc/resolv.conf
#line 115
#
#line 115
allow firstboot_t net_conf_t:file { read getattr lock ioctl };
#line 115

#line 115
allow firstboot_t self:tcp_socket { connect };
#line 115

#line 115

#line 115

#line 115

#line 115

#line 115
#
#line 115
# Allow the domain to create and use udp sockets.
#line 115
# Other kinds of sockets must be separately authorized for use.
#line 115
allow firstboot_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 115

#line 115
allow firstboot_t unlabeled_t:association { sendto recvfrom };
#line 115

#line 115
#
#line 115
# Allow the domain to send or receive using any network interface.
#line 115
# netif_type is a type attribute for all network interface types.
#line 115
#
#line 115
allow firstboot_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 115
#
#line 115
# Allow the domain to send to or receive from any node.
#line 115
# node_type is a type attribute for all node types.
#line 115
#
#line 115
allow firstboot_t node_type:node { udp_send rawip_send };
#line 115
allow firstboot_t node_type:node { udp_recv rawip_recv };
#line 115

#line 115
#
#line 115
# Allow the domain to send to or receive from any port.
#line 115
# port_type is a type attribute for all port types.
#line 115
#
#line 115

#line 115
allow firstboot_t port_type:udp_socket { send_msg recv_msg };
#line 115

#line 115

#line 115
# XXX Allow binding to any node type.  Remove once
#line 115
# individual rules have been added to all domains that 
#line 115
# bind sockets. 
#line 115
allow firstboot_t node_type:udp_socket node_bind;
#line 115
#
#line 115
# Allow access to network files including /etc/resolv.conf
#line 115
#
#line 115
allow firstboot_t net_conf_t:file { read getattr lock ioctl };
#line 115

#line 115
allow firstboot_t self:udp_socket { connect };
#line 115

#line 115

#line 115

#line 115

#line 115

#line 115

#line 115
allow firstboot_t var_yp_t:dir { read getattr lock search ioctl };
#line 115
allow firstboot_t var_yp_t:file { read getattr lock ioctl };
#line 115
allow firstboot_t var_yp_t:lnk_file { getattr read };
#line 115

#line 115
allow firstboot_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 115
allow firstboot_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 115
dontaudit firstboot_t self:capability net_bind_service;
#line 115
dontaudit firstboot_t reserved_port_type:tcp_socket name_connect;
#line 115
dontaudit firstboot_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 115

#line 115
} else {
#line 115
dontaudit firstboot_t var_yp_t:dir search;
#line 115
}
#line 115
 
#line 118


#line 119
allow firstboot_t var_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 119
allow firstboot_t var_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 119
allow firstboot_t var_t:lnk_file { create read getattr setattr link unlink rename };
#line 119

# Add/remove user home directories

#line 121

#line 121

#line 121

#line 121
#
#line 121
# Allow the process to modify the directory.
#line 121
#
#line 121
allow firstboot_t home_root_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 121

#line 121
#
#line 121
# Allow the process to create the file.
#line 121
#
#line 121

#line 121

#line 121

#line 121

#line 121

#line 121
allow firstboot_t user_home_dir_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 121

#line 121

#line 121

#line 121

#line 121

#line 121

#line 121

#line 121

#line 121

#line 121
type_transition firstboot_t home_root_t:dir user_home_dir_t;
#line 121

#line 121


#line 122

#line 122

#line 122

#line 122
#
#line 122
# Allow the process to modify the directory.
#line 122
#
#line 122
allow firstboot_t user_home_dir_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 122

#line 122
#
#line 122
# Allow the process to create the file.
#line 122
#
#line 122

#line 122

#line 122

#line 122

#line 122

#line 122
allow firstboot_t user_home_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122
allow firstboot_t user_home_t:lnk_file { create read getattr setattr link unlink rename };
#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122
allow firstboot_t user_home_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122
allow firstboot_t user_home_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122
allow firstboot_t user_home_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122

#line 122
type_transition firstboot_t user_home_dir_t:dir user_home_t;
#line 122
type_transition firstboot_t user_home_dir_t:{ file lnk_file sock_file fifo_file } user_home_t;
#line 122

#line 122


#
# The big hammer
#

#line 127

#line 127
typeattribute firstboot_t unrestricted;
#line 127
typeattribute firstboot_t privuser;
#line 127

#line 127
# Mount/unmount any filesystem. 
#line 127
allow firstboot_t fs_type:filesystem *;
#line 127

#line 127
# Mount/unmount any filesystem with the context= option. 
#line 127
allow firstboot_t file_type:filesystem *;
#line 127

#line 127
# Create/access any file in a labeled filesystem;
#line 127
allow firstboot_t file_type:{ file chr_file } ~execmod;
#line 127
allow firstboot_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 127
allow firstboot_t sysctl_t:{ dir file } *;
#line 127
allow firstboot_t device_type:{ chr_file blk_file } *;
#line 127
allow firstboot_t mtrr_device_t:file *;
#line 127

#line 127
# Create/access other files.  fs_type is to pick up various
#line 127
# pseudo filesystem types that are applied to both the filesystem
#line 127
# and its files.
#line 127
allow firstboot_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 127
allow firstboot_t unlabeled_t:association { sendto recvfrom };
#line 127

#line 127
allow firstboot_t proc_fs:{ dir file } *;
#line 127

#line 127
# For /proc/pid
#line 127

#line 127
allow firstboot_t domain:dir { read getattr lock search ioctl };
#line 127
allow firstboot_t domain:file { read getattr lock ioctl };
#line 127
allow firstboot_t domain:lnk_file { getattr read };
#line 127

#line 127
# Write access is for setting attributes under /proc/self/attr.
#line 127
allow firstboot_t self:file { ioctl read getattr lock write append };
#line 127

#line 127
# Read and write sysctls.
#line 127

#line 127
allow firstboot_t sysctl_type:dir { read getattr lock search ioctl };
#line 127
allow firstboot_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 127

#line 127

#line 127
# Access the network.
#line 127
allow firstboot_t node_type:node *;
#line 127
allow firstboot_t netif_type:netif *;
#line 127
allow firstboot_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 127
allow firstboot_t port_type:tcp_socket name_connect;
#line 127

#line 127
# Bind to any network address.
#line 127
allow firstboot_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 127
allow firstboot_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 127
allow firstboot_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 127

#line 127
# Use/sendto/connectto sockets created by any domain.
#line 127
allow firstboot_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 127

#line 127
# Use descriptors and pipes created by any domain.
#line 127
allow firstboot_t domain:fd use;
#line 127
allow firstboot_t domain:fifo_file { ioctl read getattr lock write append };
#line 127

#line 127
# Act upon any other process.
#line 127
allow firstboot_t domain:process ~{ transition dyntransition execmem };
#line 127
# Transition to myself, to make get_ordered_context_list happy.
#line 127
allow firstboot_t self:process transition;
#line 127

#line 127
if (allow_execmem) {
#line 127
# Allow making anonymous memory executable, e.g. 
#line 127
# for runtime-code generation or executable stack.
#line 127
allow firstboot_t self:process execmem;
#line 127
}
#line 127

#line 127
if (allow_execmem && allow_execstack) {
#line 127
# Allow making the stack executable via mprotect.
#line 127
allow firstboot_t self:process execstack;
#line 127
}
#line 127

#line 127
if (allow_execmod) {
#line 127
# Allow text relocations on system shared libraries, e.g. libGL.
#line 127

#line 127
allow firstboot_t file_type:file execmod;
#line 127

#line 127
}
#line 127

#line 127
# Create/access any System V IPC objects.
#line 127
allow firstboot_t domain:{ sem msgq shm } *;
#line 127
allow firstboot_t domain:msg  { send receive };
#line 127

#line 127
# Access the security API.
#line 127
if (!secure_mode_policyload) {
#line 127
allow firstboot_t security_t:security *;
#line 127
auditallow firstboot_t security_t:security { load_policy setenforce setbool };
#line 127
}
#line 127
# Perform certain system operations that lacked individual capabilities.
#line 127
allow firstboot_t kernel_t:system *;
#line 127

#line 127
# Use any Linux capability.
#line 127
allow firstboot_t self:capability *;
#line 127

#line 127
# Set user information and skip authentication.
#line 127
allow firstboot_t self:passwd *;
#line 127

#line 127
# Communicate via dbusd.
#line 127
allow firstboot_t self:dbus *;
#line 127

#line 127
allow firstboot_t system_dbusd_t:dbus *;
#line 127

#line 127

#line 127
# Get info via nscd.
#line 127
allow firstboot_t self:nscd *;
#line 127

#line 127
allow firstboot_t nscd_t:nscd *;
#line 127

#line 127

#line 127
 
#line 130

#line 130
allow firstboot_t unconfined_t:process transition;
#line 130


#line 1 "domains/program/fsadm.te"
#DESC Fsadm - Disk and file system administration
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: util-linux e2fsprogs xfsprogs reiserfsprogs parted raidtools2 mount
#

#################################
#
# Rules for the fsadm_t domain.
#
# fsadm_t is the domain for disk and file system
# administration.
# fsadm_exec_t is the type of the corresponding programs.
#
type fsadm_t, domain, privlog, fs_domain, mlsfileread, mlsfilewrite;
role system_r types fsadm_t;
role sysadm_r types fsadm_t;


#line 19
# Access other processes in the same domain.
#line 19
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 19
# These must be granted separately if desired.
#line 19
allow fsadm_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 19

#line 19
# Access /proc/PID files for processes in the same domain.
#line 19
allow fsadm_t self:dir { read getattr lock search ioctl };
#line 19
allow fsadm_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 19

#line 19
# Access file descriptions, pipes, and sockets
#line 19
# created by processes in the same domain.
#line 19
allow fsadm_t self:fd *;
#line 19
allow fsadm_t self:fifo_file { ioctl read getattr lock write append };
#line 19
allow fsadm_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 19
allow fsadm_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 19

#line 19
# Allow the domain to communicate with other processes in the same domain.
#line 19
allow fsadm_t self:unix_dgram_socket sendto;
#line 19
allow fsadm_t self:unix_stream_socket connectto;
#line 19

#line 19
# Access System V IPC objects created by processes in the same domain.
#line 19
allow fsadm_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 19
allow fsadm_t self:msg  { send receive };
#line 19
allow fsadm_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 19
allow fsadm_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 19
allow fsadm_t unpriv_userdomain:fd use;
#line 19
#
#line 19
# Every app is asking for ypbind so I am adding this here, 
#line 19
# eventually this should become can_nsswitch
#line 19
#
#line 19

#line 19

#line 19
if (allow_ypbind) {
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow fsadm_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow fsadm_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow fsadm_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow fsadm_t node_type:node { tcp_send rawip_send };
#line 19
allow fsadm_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow fsadm_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow fsadm_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow fsadm_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow fsadm_t self:tcp_socket { listen accept };
#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow fsadm_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow fsadm_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow fsadm_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow fsadm_t node_type:node { tcp_send rawip_send };
#line 19
allow fsadm_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow fsadm_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow fsadm_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow fsadm_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow fsadm_t self:tcp_socket { connect };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use udp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow fsadm_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow fsadm_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow fsadm_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow fsadm_t node_type:node { udp_send rawip_send };
#line 19
allow fsadm_t node_type:node { udp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow fsadm_t port_type:udp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow fsadm_t node_type:udp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow fsadm_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow fsadm_t self:udp_socket { connect };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow fsadm_t var_yp_t:dir { read getattr lock search ioctl };
#line 19
allow fsadm_t var_yp_t:file { read getattr lock ioctl };
#line 19
allow fsadm_t var_yp_t:lnk_file { getattr read };
#line 19

#line 19
allow fsadm_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 19
allow fsadm_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 19
dontaudit fsadm_t self:capability net_bind_service;
#line 19
dontaudit fsadm_t reserved_port_type:tcp_socket name_connect;
#line 19
dontaudit fsadm_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 19

#line 19
} else {
#line 19
dontaudit fsadm_t var_yp_t:dir search;
#line 19
}
#line 19
 
#line 19
allow fsadm_t autofs_t:dir { search getattr };
#line 19


# for swapon

#line 22
allow fsadm_t sysfs_t:dir { read getattr lock search ioctl };
#line 22
allow fsadm_t sysfs_t:file { read getattr lock ioctl };
#line 22
allow fsadm_t sysfs_t:lnk_file { getattr read };
#line 22


# Read system information files in /proc.

#line 25
allow fsadm_t proc_t:dir { read getattr lock search ioctl };
#line 25
allow fsadm_t proc_t:file { read getattr lock ioctl };
#line 25
allow fsadm_t proc_t:lnk_file { getattr read };
#line 25


# Read system variables in /proc/sys

#line 28
# Read system variables in /sys.
#line 28

#line 28
allow fsadm_t sysctl_t:dir search;
#line 28
allow fsadm_t sysctl_kernel_t:dir search;
#line 28
allow fsadm_t sysctl_kernel_t:file { getattr read };
#line 28

#line 28

#line 28


# for /dev/shm
allow fsadm_t tmpfs_t:dir { getattr search };
allow fsadm_t tmpfs_t:file { read write };


#line 34
# Read /.
#line 34
allow fsadm_t root_t:dir { read getattr lock search ioctl };
#line 34
allow fsadm_t root_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 34

#line 34
# Read /home.
#line 34
allow fsadm_t home_root_t:dir { read getattr lock search ioctl };
#line 34

#line 34
# Read /usr.
#line 34
allow fsadm_t usr_t:dir { read getattr lock search ioctl };
#line 34
allow fsadm_t usr_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 34

#line 34
# Read bin and sbin directories.
#line 34
allow fsadm_t bin_t:dir { read getattr lock search ioctl };
#line 34
allow fsadm_t bin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 34
allow fsadm_t sbin_t:dir { read getattr lock search ioctl };
#line 34
allow fsadm_t sbin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 34

#line 34
# Read system variables in /sys.
#line 34

#line 34
allow fsadm_t sysctl_t:dir search;
#line 34
allow fsadm_t sysctl_kernel_t:dir search;
#line 34
allow fsadm_t sysctl_kernel_t:file { getattr read };
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
allow fsadm_t selinux_config_t:dir { read getattr lock search ioctl };
#line 34
allow fsadm_t selinux_config_t:file { read getattr lock ioctl };
#line 34
allow fsadm_t selinux_config_t:lnk_file { getattr read };
#line 34

#line 34

#line 34
if (read_default_t) {
#line 34
#
#line 34
# Read default_t
#line 34
#.
#line 34
allow fsadm_t default_t:dir { read getattr lock search ioctl };
#line 34
allow fsadm_t default_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 34
}
#line 34

#line 34


# Read /etc.

#line 37
allow fsadm_t etc_t:dir { read getattr lock search ioctl };
#line 37
allow fsadm_t etc_t:file { read getattr lock ioctl };
#line 37
allow fsadm_t etc_t:lnk_file { getattr read };
#line 37


# Read module-related files.
allow fsadm_t modules_conf_t:{ file lnk_file } { read getattr lock ioctl };

# Read /dev directories and any symbolic links.
allow fsadm_t device_t:dir { read getattr lock search ioctl };
allow fsadm_t device_t:lnk_file { read getattr lock ioctl };


#line 46
allow fsadm_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 46
allow fsadm_t lib_t:lnk_file { read getattr lock ioctl };
#line 46
allow fsadm_t ld_so_t:file { read getattr lock execute ioctl };
#line 46
#allow fsadm_t ld_so_t:file execute_no_trans;
#line 46
allow fsadm_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 46
allow fsadm_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 46
allow fsadm_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 46
allow fsadm_t texrel_shlib_t:file execmod;
#line 46
allow fsadm_t ld_so_cache_t:file { read getattr lock ioctl };
#line 46
allow fsadm_t device_t:dir search;
#line 46
allow fsadm_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 46


type fsadm_exec_t, file_type, sysadmfile, exec_type;

#line 49

#line 49

#line 49
#
#line 49
# Allow the process to transition to the new domain.
#line 49
#
#line 49
allow initrc_t fsadm_t:process transition;
#line 49

#line 49
#
#line 49
# Do not audit when glibc secure mode is enabled upon the transition.
#line 49
#
#line 49
dontaudit initrc_t fsadm_t:process noatsecure;
#line 49

#line 49
#
#line 49
# Do not audit when signal-related state is cleared upon the transition.
#line 49
#
#line 49
dontaudit initrc_t fsadm_t:process siginh;
#line 49

#line 49
#
#line 49
# Do not audit when resource limits are reset upon the transition.
#line 49
#
#line 49
dontaudit initrc_t fsadm_t:process rlimitinh;
#line 49

#line 49
#
#line 49
# Allow the process to execute the program.
#line 49
# 
#line 49
allow initrc_t fsadm_exec_t:file { read { getattr execute } };
#line 49

#line 49
#
#line 49
# Allow the process to reap the new domain.
#line 49
#
#line 49
allow fsadm_t initrc_t:process sigchld;
#line 49

#line 49
#
#line 49
# Allow the new domain to inherit and use file 
#line 49
# descriptions from the creating process and vice versa.
#line 49
#
#line 49
allow fsadm_t initrc_t:fd use;
#line 49
allow initrc_t fsadm_t:fd use;
#line 49

#line 49
#
#line 49
# Allow the new domain to write back to the old domain via a pipe.
#line 49
#
#line 49
allow fsadm_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 49

#line 49
#
#line 49
# Allow the new domain to read and execute the program.
#line 49
#
#line 49
allow fsadm_t fsadm_exec_t:file { read getattr lock execute ioctl };
#line 49

#line 49
#
#line 49
# Allow the new domain to be entered via the program.
#line 49
#
#line 49
allow fsadm_t fsadm_exec_t:file entrypoint;
#line 49

#line 49
type_transition initrc_t fsadm_exec_t:process fsadm_t;
#line 49

#line 52


#line 53
type fsadm_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the process to modify the directory.
#line 53
#
#line 53
allow fsadm_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 53

#line 53
#
#line 53
# Allow the process to create the file.
#line 53
#
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
allow fsadm_t fsadm_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
allow fsadm_t fsadm_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
type_transition fsadm_t tmp_t:{ file dir } fsadm_tmp_t;
#line 53

#line 53

#line 53


# remount file system to apply changes
allow fsadm_t fs_t:filesystem remount;

allow fsadm_t fs_t:filesystem getattr;

# mkreiserfs needs this
allow fsadm_t proc_t:filesystem getattr;

# mkreiserfs and other programs need this for UUID
allow fsadm_t { urandom_device_t random_device_t }:chr_file { getattr read };

# Use capabilities.  ipc_lock is for losetup
allow fsadm_t self:capability { ipc_lock sys_rawio sys_admin sys_tty_config dac_override dac_read_search };

# Write to /etc/mtab.

#line 70

#line 70

#line 70

#line 70
#
#line 70
# Allow the process to modify the directory.
#line 70
#
#line 70
allow fsadm_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 70

#line 70
#
#line 70
# Allow the process to create the file.
#line 70
#
#line 70

#line 70

#line 70

#line 70

#line 70

#line 70
allow fsadm_t etc_runtime_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 70

#line 70

#line 70

#line 70

#line 70

#line 70

#line 70

#line 70

#line 70

#line 70
type_transition fsadm_t etc_t:file etc_runtime_t;
#line 70

#line 70


# Inherit and use descriptors from init.
allow fsadm_t init_t:fd use;

# Run other fs admin programs in the fsadm_t domain.

#line 76
allow fsadm_t fsadm_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 76


# Access disk devices.
allow fsadm_t fixed_disk_device_t:{ chr_file blk_file } { ioctl read getattr lock write append };
allow fsadm_t removable_device_t:{ chr_file blk_file } { ioctl read getattr lock write append };
allow fsadm_t scsi_generic_device_t:chr_file { read getattr lock ioctl };

# Access lost+found.
allow fsadm_t lost_found_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
allow fsadm_t lost_found_t:{ file sock_file fifo_file } { create ioctl read getattr lock write setattr append link unlink rename };
allow fsadm_t lost_found_t:lnk_file { create read getattr setattr link unlink rename };

allow fsadm_t file_t:dir { search read getattr rmdir create };

# Recreate /mnt/cdrom. 
allow fsadm_t mnt_t:dir { search read getattr rmdir create };

# Recreate /dev/cdrom.
allow fsadm_t device_t:dir { read getattr lock search ioctl add_name remove_name write };
allow fsadm_t device_t:lnk_file { unlink create };

# Enable swapping to devices and files
allow fsadm_t swapfile_t:file { getattr swapon };
allow fsadm_t fixed_disk_device_t:blk_file { getattr swapon };

# Allow console log change (updfstab)
allow fsadm_t kernel_t:system syslog_console;

# Access terminals.

#line 105
allow fsadm_t devpts_t:dir { read getattr lock search ioctl };
#line 105
allow fsadm_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 105

allow fsadm_t { admin_tty_type devtty_t console_device_t }:chr_file { ioctl read getattr lock write append };

allow fsadm_t privfd:fd use;


#line 110
allow fsadm_t etc_t:lnk_file read;
#line 110
allow fsadm_t lib_t:file { read getattr lock ioctl };
#line 110

#line 110
allow fsadm_t locale_t:dir { read getattr lock search ioctl };
#line 110
allow fsadm_t locale_t:file { read getattr lock ioctl };
#line 110
allow fsadm_t locale_t:lnk_file { getattr read };
#line 110

#line 110


# for smartctl cron jobs

#line 113

#line 113

#line 113

#line 113

#line 113
#
#line 113
# Allow the process to transition to the new domain.
#line 113
#
#line 113
allow system_crond_t fsadm_t:process transition;
#line 113

#line 113
#
#line 113
# Do not audit when glibc secure mode is enabled upon the transition.
#line 113
#
#line 113
dontaudit system_crond_t fsadm_t:process noatsecure;
#line 113

#line 113
#
#line 113
# Do not audit when signal-related state is cleared upon the transition.
#line 113
#
#line 113
dontaudit system_crond_t fsadm_t:process siginh;
#line 113

#line 113
#
#line 113
# Do not audit when resource limits are reset upon the transition.
#line 113
#
#line 113
dontaudit system_crond_t fsadm_t:process rlimitinh;
#line 113

#line 113
#
#line 113
# Allow the process to execute the program.
#line 113
# 
#line 113
allow system_crond_t fsadm_exec_t:file { read { getattr execute } };
#line 113

#line 113
#
#line 113
# Allow the process to reap the new domain.
#line 113
#
#line 113
allow fsadm_t system_crond_t:process sigchld;
#line 113

#line 113
#
#line 113
# Allow the new domain to inherit and use file 
#line 113
# descriptions from the creating process and vice versa.
#line 113
#
#line 113
allow fsadm_t system_crond_t:fd use;
#line 113
allow system_crond_t fsadm_t:fd use;
#line 113

#line 113
#
#line 113
# Allow the new domain to write back to the old domain via a pipe.
#line 113
#
#line 113
allow fsadm_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 113

#line 113
#
#line 113
# Allow the new domain to read and execute the program.
#line 113
#
#line 113
allow fsadm_t fsadm_exec_t:file { read getattr lock execute ioctl };
#line 113

#line 113
#
#line 113
# Allow the new domain to be entered via the program.
#line 113
#
#line 113
allow fsadm_t fsadm_exec_t:file entrypoint;
#line 113

#line 113
type_transition system_crond_t fsadm_exec_t:process fsadm_t;
#line 113

#line 113
allow fsadm_t crond_t:fifo_file { getattr read write ioctl };
#line 113
# a rule for privfd may make this obsolete
#line 113
allow fsadm_t crond_t:fd use;
#line 113
allow fsadm_t crond_t:process sigchld;
#line 113


# Access to /initrd devices
allow fsadm_t { file_t unlabeled_t }:dir { read getattr lock search ioctl add_name remove_name write };
allow fsadm_t { file_t unlabeled_t }:blk_file { ioctl read getattr lock write append };
allow fsadm_t usbfs_t:dir { getattr search };
allow fsadm_t ramfs_t:fifo_file { ioctl read getattr lock write append };
allow fsadm_t device_type:chr_file getattr;

# for tune2fs
allow fsadm_t file_type:dir { getattr search };
#line 1 "domains/program/ftpd.te"
#DESC Ftpd - Ftp daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#           Russell Coker <russell@coker.com.au>
# X-Debian-Packages: proftpd-common bsd-ftpd ftpd vsftpd
#

#################################
#
# Rules for the ftpd_t domain 
#

#line 12

#line 12

#line 12

#line 12
type ftpd_t, domain, privlog, daemon , auth_chkpwd, nscd_client_domain, transitionbool;
#line 12
type ftpd_exec_t, file_type, sysadmfile, exec_type;
#line 12
dontaudit ftpd_t self:capability sys_tty_config;
#line 12

#line 12
role system_r types ftpd_t;
#line 12

#line 12
# Inherit and use descriptors from init.
#line 12
allow ftpd_t init_t:fd use;
#line 12
allow ftpd_t init_t:process sigchld;
#line 12
allow ftpd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 12

#line 12

#line 12
allow ftpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 12
allow ftpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 12
allow ftpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 12
#allow ftpd_t ld_so_t:file execute_no_trans;
#line 12
allow ftpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 12
allow ftpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 12
allow ftpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 12
allow ftpd_t texrel_shlib_t:file execmod;
#line 12
allow ftpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 12
allow ftpd_t device_t:dir search;
#line 12
allow ftpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
allow ftpd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 12
allow ftpd_t { self proc_t }:lnk_file { getattr read };
#line 12

#line 12
allow ftpd_t device_t:dir { read getattr lock search ioctl };
#line 12

#line 12
allow ftpd_t udev_tdb_t:file { read getattr lock ioctl };
#line 12
allow ftpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit ftpd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit ftpd_t unpriv_userdomain:fd use;
#line 12

#line 12

#line 12
allow ftpd_t sysfs_t:dir { read getattr lock search ioctl };
#line 12
allow ftpd_t sysfs_t:file { read getattr lock ioctl };
#line 12
allow ftpd_t sysfs_t:lnk_file { getattr read };
#line 12
 
#line 12

#line 12
allow ftpd_t autofs_t:dir { search getattr };
#line 12

#line 12
dontaudit ftpd_t { tty_device_t devpts_t }:chr_file { read write };
#line 12
dontaudit ftpd_t root_t:file { getattr read };
#line 12
 
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
# Read system variables in /sys.
#line 12

#line 12
allow ftpd_t sysctl_t:dir search;
#line 12
allow ftpd_t sysctl_kernel_t:dir search;
#line 12
allow ftpd_t sysctl_kernel_t:file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allows user to define a tunable to disable domain transition
#line 12
#
#line 12

#line 12
bool ftpd_disable_trans false;
#line 12
if (ftpd_disable_trans) {
#line 12

#line 12
allow initrc_t ftpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12

#line 12
allow sysadm_t ftpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12
} else {
#line 12
 
#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow initrc_t ftpd_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit initrc_t ftpd_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit initrc_t ftpd_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit initrc_t ftpd_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow initrc_t ftpd_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow ftpd_t initrc_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow ftpd_t initrc_t:fd use;
#line 12
allow initrc_t ftpd_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow ftpd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow ftpd_t ftpd_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow ftpd_t ftpd_exec_t:file entrypoint;
#line 12

#line 12
type_transition initrc_t ftpd_exec_t:process ftpd_t;
#line 12

#line 12

#line 12
allow initrc_t ftpd_t:process { noatsecure siginh rlimitinh };
#line 12

#line 12
}
#line 12
 
#line 12
allow ftpd_t privfd:fd use;
#line 12

#line 12
allow ftpd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
# Create pid file.
#line 12
allow ftpd_t var_t:dir { getattr search };
#line 12

#line 12
type ftpd_var_run_t, file_type, sysadmfile, pidfile;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to modify the directory.
#line 12
#
#line 12
allow ftpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12
#
#line 12
# Allow the process to create the file.
#line 12
#
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow ftpd_t ftpd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
type_transition ftpd_t var_run_t:file ftpd_var_run_t;
#line 12

#line 12

#line 12

#line 12
allow ftpd_t var_t:dir search;
#line 12
allow ftpd_t ftpd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12

#line 12
allow ftpd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12
# for daemons that look at /root on startup
#line 12
dontaudit ftpd_t sysadm_home_dir_t:dir search;
#line 12

#line 12
# for df
#line 12
allow ftpd_t fs_type:filesystem getattr;
#line 12
allow ftpd_t removable_t:filesystem getattr;
#line 12

#line 12

#line 12
allow ftpd_t etc_t:lnk_file read;
#line 12
allow ftpd_t lib_t:file { read getattr lock ioctl };
#line 12

#line 12
allow ftpd_t locale_t:dir { read getattr lock search ioctl };
#line 12
allow ftpd_t locale_t:file { read getattr lock ioctl };
#line 12
allow ftpd_t locale_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12
# for localization
#line 12
allow ftpd_t lib_t:file { getattr read };
#line 12


#line 13
type ftpd_etc_t, file_type, sysadmfile, usercanread;
#line 13
allow ftpd_t ftpd_etc_t:file { read getattr lock ioctl };
#line 13



#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the domain to create and use tcp sockets.
#line 15
# Other kinds of sockets must be separately authorized for use.
#line 15
allow ftpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 15

#line 15
allow ftpd_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
#
#line 15
# Allow the domain to send or receive using any network interface.
#line 15
# netif_type is a type attribute for all network interface types.
#line 15
#
#line 15
allow ftpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 15
#
#line 15
# Allow the domain to send to or receive from any node.
#line 15
# node_type is a type attribute for all node types.
#line 15
#
#line 15
allow ftpd_t node_type:node { tcp_send rawip_send };
#line 15
allow ftpd_t node_type:node { tcp_recv rawip_recv };
#line 15

#line 15
#
#line 15
# Allow the domain to send to or receive from any port.
#line 15
# port_type is a type attribute for all port types.
#line 15
#
#line 15

#line 15
allow ftpd_t port_type:tcp_socket { send_msg recv_msg };
#line 15

#line 15

#line 15
# XXX Allow binding to any node type.  Remove once
#line 15
# individual rules have been added to all domains that 
#line 15
# bind sockets. 
#line 15
allow ftpd_t node_type:tcp_socket node_bind;
#line 15
#
#line 15
# Allow access to network files including /etc/resolv.conf
#line 15
#
#line 15
allow ftpd_t net_conf_t:file { read getattr lock ioctl };
#line 15

#line 15
allow ftpd_t self:tcp_socket { listen accept };
#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the domain to create and use tcp sockets.
#line 15
# Other kinds of sockets must be separately authorized for use.
#line 15
allow ftpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 15

#line 15
allow ftpd_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
#
#line 15
# Allow the domain to send or receive using any network interface.
#line 15
# netif_type is a type attribute for all network interface types.
#line 15
#
#line 15
allow ftpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 15
#
#line 15
# Allow the domain to send to or receive from any node.
#line 15
# node_type is a type attribute for all node types.
#line 15
#
#line 15
allow ftpd_t node_type:node { tcp_send rawip_send };
#line 15
allow ftpd_t node_type:node { tcp_recv rawip_recv };
#line 15

#line 15
#
#line 15
# Allow the domain to send to or receive from any port.
#line 15
# port_type is a type attribute for all port types.
#line 15
#
#line 15

#line 15
allow ftpd_t port_type:tcp_socket { send_msg recv_msg };
#line 15

#line 15

#line 15
# XXX Allow binding to any node type.  Remove once
#line 15
# individual rules have been added to all domains that 
#line 15
# bind sockets. 
#line 15
allow ftpd_t node_type:tcp_socket node_bind;
#line 15
#
#line 15
# Allow access to network files including /etc/resolv.conf
#line 15
#
#line 15
allow ftpd_t net_conf_t:file { read getattr lock ioctl };
#line 15

#line 15
allow ftpd_t self:tcp_socket { connect };
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the domain to create and use udp sockets.
#line 15
# Other kinds of sockets must be separately authorized for use.
#line 15
allow ftpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 15

#line 15
allow ftpd_t unlabeled_t:association { sendto recvfrom };
#line 15

#line 15
#
#line 15
# Allow the domain to send or receive using any network interface.
#line 15
# netif_type is a type attribute for all network interface types.
#line 15
#
#line 15
allow ftpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 15
#
#line 15
# Allow the domain to send to or receive from any node.
#line 15
# node_type is a type attribute for all node types.
#line 15
#
#line 15
allow ftpd_t node_type:node { udp_send rawip_send };
#line 15
allow ftpd_t node_type:node { udp_recv rawip_recv };
#line 15

#line 15
#
#line 15
# Allow the domain to send to or receive from any port.
#line 15
# port_type is a type attribute for all port types.
#line 15
#
#line 15

#line 15
allow ftpd_t port_type:udp_socket { send_msg recv_msg };
#line 15

#line 15

#line 15
# XXX Allow binding to any node type.  Remove once
#line 15
# individual rules have been added to all domains that 
#line 15
# bind sockets. 
#line 15
allow ftpd_t node_type:udp_socket node_bind;
#line 15
#
#line 15
# Allow access to network files including /etc/resolv.conf
#line 15
#
#line 15
allow ftpd_t net_conf_t:file { read getattr lock ioctl };
#line 15

#line 15
allow ftpd_t self:udp_socket { connect };
#line 15

#line 15

#line 15

#line 15

#line 15

allow ftpd_t port_type:tcp_socket name_connect;
allow ftpd_t self:unix_dgram_socket { sendto { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } };
allow ftpd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow ftpd_t self:process { getcap setcap setsched setrlimit };
allow ftpd_t self:fifo_file { ioctl read getattr lock write append };

allow ftpd_t bin_t:dir search;

#line 23
allow ftpd_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23

allow ftpd_t bin_t:lnk_file read;

#line 25
# Read system variables in /sys.
#line 25

#line 25
allow ftpd_t sysctl_t:dir search;
#line 25
allow ftpd_t sysctl_kernel_t:dir search;
#line 25
allow ftpd_t sysctl_kernel_t:file { getattr read };
#line 25

#line 25

#line 25


allow ftpd_t urandom_device_t:chr_file { getattr read };

#line 37

#line 37

#line 37

#line 37

#line 37

#line 37

#line 37
#
#line 37
# Allow the process to transition to the new domain.
#line 37
#
#line 37
allow system_crond_t ftpd_t:process transition;
#line 37

#line 37
#
#line 37
# Do not audit when glibc secure mode is enabled upon the transition.
#line 37
#
#line 37
dontaudit system_crond_t ftpd_t:process noatsecure;
#line 37

#line 37
#
#line 37
# Do not audit when signal-related state is cleared upon the transition.
#line 37
#
#line 37
dontaudit system_crond_t ftpd_t:process siginh;
#line 37

#line 37
#
#line 37
# Do not audit when resource limits are reset upon the transition.
#line 37
#
#line 37
dontaudit system_crond_t ftpd_t:process rlimitinh;
#line 37

#line 37
#
#line 37
# Allow the process to execute the program.
#line 37
# 
#line 37
allow system_crond_t ftpd_exec_t:file { read { getattr execute } };
#line 37

#line 37
#
#line 37
# Allow the process to reap the new domain.
#line 37
#
#line 37
allow ftpd_t system_crond_t:process sigchld;
#line 37

#line 37
#
#line 37
# Allow the new domain to inherit and use file 
#line 37
# descriptions from the creating process and vice versa.
#line 37
#
#line 37
allow ftpd_t system_crond_t:fd use;
#line 37
allow system_crond_t ftpd_t:fd use;
#line 37

#line 37
#
#line 37
# Allow the new domain to write back to the old domain via a pipe.
#line 37
#
#line 37
allow ftpd_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 37

#line 37
#
#line 37
# Allow the new domain to read and execute the program.
#line 37
#
#line 37
allow ftpd_t ftpd_exec_t:file { read getattr lock execute ioctl };
#line 37

#line 37
#
#line 37
# Allow the new domain to be entered via the program.
#line 37
#
#line 37
allow ftpd_t ftpd_exec_t:file entrypoint;
#line 37

#line 37
type_transition system_crond_t ftpd_exec_t:process ftpd_t;
#line 37

#line 37
allow ftpd_t crond_t:fifo_file { getattr read write ioctl };
#line 37
# a rule for privfd may make this obsolete
#line 37
allow ftpd_t crond_t:fd use;
#line 37
allow ftpd_t crond_t:process sigchld;
#line 37

#line 37
allow system_crond_t xferlog_t:file { read getattr lock ioctl };
#line 37

#line 37
allow ftpd_t { sbin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 37

#line 37
allow ftpd_t usr_t:file { getattr read };

allow ftpd_t ftp_data_port_t:tcp_socket name_bind;
allow ftpd_t port_t:tcp_socket name_bind;

# ftpd_lock_t is only needed when ftpd_is_daemon is true, but we cannot define types conditionally
type ftpd_lock_t, file_type, sysadmfile, lockfile;

# Allow ftpd to run directly without inetd.
bool ftpd_is_daemon false;
if (ftpd_is_daemon) {

#line 48

#line 48

#line 48

#line 48
#
#line 48
# Allow the process to modify the directory.
#line 48
#
#line 48
allow ftpd_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 48

#line 48
#
#line 48
# Allow the process to create the file.
#line 48
#
#line 48

#line 48

#line 48

#line 48

#line 48

#line 48
allow ftpd_t ftpd_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 48

#line 48

#line 48

#line 48

#line 48

#line 48

#line 48

#line 48

#line 48

#line 48
type_transition ftpd_t var_lock_t:file ftpd_lock_t;
#line 48

#line 48

allow ftpd_t ftp_port_t:tcp_socket name_bind;

#line 50
#allow userdomain ftpd_t:tcp_socket { connectto recvfrom };
#line 50
#allow ftpd_t userdomain:tcp_socket { acceptfrom recvfrom };
#line 50
#allow ftpd_t kernel_t:tcp_socket recvfrom;
#line 50
#allow userdomain kernel_t:tcp_socket recvfrom;
#line 50

# Allows it to check exec privs on daemon
allow inetd_t ftpd_exec_t:file { getattr execute };
}
#line 66

#line 66
if (!ftpd_is_daemon) {
#line 66

#line 66

#line 66

#line 66

#line 66
#
#line 66
# Allow the process to transition to the new domain.
#line 66
#
#line 66
allow inetd_t ftpd_t:process transition;
#line 66

#line 66
#
#line 66
# Do not audit when glibc secure mode is enabled upon the transition.
#line 66
#
#line 66
dontaudit inetd_t ftpd_t:process noatsecure;
#line 66

#line 66
#
#line 66
# Do not audit when signal-related state is cleared upon the transition.
#line 66
#
#line 66
dontaudit inetd_t ftpd_t:process siginh;
#line 66

#line 66
#
#line 66
# Do not audit when resource limits are reset upon the transition.
#line 66
#
#line 66
dontaudit inetd_t ftpd_t:process rlimitinh;
#line 66

#line 66
#
#line 66
# Allow the process to execute the program.
#line 66
# 
#line 66
allow inetd_t ftpd_exec_t:file { read { getattr execute } };
#line 66

#line 66
#
#line 66
# Allow the process to reap the new domain.
#line 66
#
#line 66
allow ftpd_t inetd_t:process sigchld;
#line 66

#line 66
#
#line 66
# Allow the new domain to inherit and use file 
#line 66
# descriptions from the creating process and vice versa.
#line 66
#
#line 66
allow ftpd_t inetd_t:fd use;
#line 66
allow inetd_t ftpd_t:fd use;
#line 66

#line 66
#
#line 66
# Allow the new domain to write back to the old domain via a pipe.
#line 66
#
#line 66
allow ftpd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 66

#line 66
#
#line 66
# Allow the new domain to read and execute the program.
#line 66
#
#line 66
allow ftpd_t ftpd_exec_t:file { read getattr lock execute ioctl };
#line 66

#line 66
#
#line 66
# Allow the new domain to be entered via the program.
#line 66
#
#line 66
allow ftpd_t ftpd_exec_t:file entrypoint;
#line 66

#line 66
type_transition inetd_t ftpd_exec_t:process ftpd_t;
#line 66

#line 66

#line 66
# Use sockets inherited from inetd.
#line 66
allow ftpd_t inetd_t:fd use;
#line 66
allow ftpd_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 66

#line 66
# Send SIGCHLD to inetd on death.
#line 66
allow ftpd_t inetd_t:process sigchld;
#line 66
}
#line 66
 
#line 68
# Access shared memory tmpfs instance.

#line 69

#line 69

#line 69
type ftpd_tmpfs_t, file_type, sysadmfile, tmpfsfile;
#line 69
# Use this type when creating tmpfs/shm objects.
#line 69

#line 69

#line 69

#line 69

#line 69
#
#line 69
# Allow the process to modify the directory.
#line 69
#
#line 69
allow ftpd_t tmpfs_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 69

#line 69
#
#line 69
# Allow the process to create the file.
#line 69
#
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
allow ftpd_t ftpd_tmpfs_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
allow ftpd_t ftpd_tmpfs_t:lnk_file { create read getattr setattr link unlink rename };
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
allow ftpd_t ftpd_tmpfs_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
allow ftpd_t ftpd_tmpfs_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
allow ftpd_t ftpd_tmpfs_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
type_transition ftpd_t tmpfs_t:dir ftpd_tmpfs_t;
#line 69
type_transition ftpd_t tmpfs_t:{ file lnk_file sock_file fifo_file } ftpd_tmpfs_t;
#line 69

#line 69

#line 69
allow ftpd_tmpfs_t tmpfs_t:filesystem associate;
#line 69

#line 69


# Use capabilities.
allow ftpd_t self:capability { chown fowner fsetid setgid setuid net_bind_service sys_chroot sys_nice sys_resource };

# Append to /var/log/wtmp.
allow ftpd_t wtmp_t:file { getattr append };
#kerberized ftp requires the following
allow ftpd_t wtmp_t:file { write lock };

# Create and modify /var/log/xferlog.
type xferlog_t, file_type, sysadmfile, logfile;

#line 81

#line 81

#line 81

#line 81
#
#line 81
# Allow the process to modify the directory.
#line 81
#
#line 81
allow ftpd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 81

#line 81
#
#line 81
# Allow the process to create the file.
#line 81
#
#line 81

#line 81

#line 81

#line 81

#line 81

#line 81
allow ftpd_t xferlog_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81
type_transition ftpd_t var_log_t:file xferlog_t;
#line 81

#line 81


# Execute /bin/ls (can comment this out for proftpd)
# also may need rules to allow tar etc...

#line 85
allow ftpd_t ls_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 85


allow initrc_t ftpd_etc_t:file { getattr read };
allow ftpd_t { etc_t etc_runtime_t }:file { getattr read };
allow ftpd_t proc_t:file { getattr read };

dontaudit ftpd_t sysadm_home_dir_t:dir getattr;
dontaudit ftpd_t selinux_config_t:dir search;
allow ftpd_t autofs_t:dir search;
allow ftpd_t self:file { getattr read };

#line 95
type ftpd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 95

#line 95

#line 95

#line 95

#line 95
#
#line 95
# Allow the process to modify the directory.
#line 95
#
#line 95
allow ftpd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 95

#line 95
#
#line 95
# Allow the process to create the file.
#line 95
#
#line 95

#line 95

#line 95

#line 95

#line 95

#line 95
allow ftpd_t ftpd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 95

#line 95

#line 95

#line 95

#line 95

#line 95

#line 95
allow ftpd_t ftpd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 95

#line 95

#line 95

#line 95

#line 95

#line 95

#line 95

#line 95

#line 95

#line 95

#line 95

#line 95
type_transition ftpd_t tmp_t:{ file dir } ftpd_tmp_t;
#line 95

#line 95

#line 95


# Allow ftp to read/write files in the user home directories.
bool ftp_home_dir false;

if (ftp_home_dir) {
# allow access to /home
allow ftpd_t home_root_t:dir { read getattr lock search ioctl };

#line 103
allow ftpd_t home_type:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 103
allow ftpd_t home_type:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 103
allow ftpd_t home_type:lnk_file { create read getattr setattr link unlink rename };
#line 103

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106
#
#line 106
# Allow the process to modify the directory.
#line 106
#
#line 106
allow ftpd_t user_home_dir_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 106

#line 106
#
#line 106
# Allow the process to create the file.
#line 106
#
#line 106

#line 106

#line 106

#line 106

#line 106

#line 106
allow ftpd_t user_home_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106
allow ftpd_t user_home_t:lnk_file { create read getattr setattr link unlink rename };
#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106
allow ftpd_t user_home_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106
allow ftpd_t user_home_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106
allow ftpd_t user_home_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106

#line 106
type_transition ftpd_t user_home_dir_t:dir user_home_t;
#line 106
type_transition ftpd_t user_home_dir_t:{ file lnk_file sock_file fifo_file } user_home_t;
#line 106

#line 106

#line 106

}
if (use_nfs_home_dirs && ftp_home_dir) {
	
#line 109
allow ftpd_t nfs_t:dir { read getattr lock search ioctl };
#line 109
allow ftpd_t nfs_t:file { read getattr lock ioctl };
#line 109
allow ftpd_t nfs_t:lnk_file { getattr read };
#line 109

}
if (use_samba_home_dirs && ftp_home_dir) {
	
#line 112
allow ftpd_t cifs_t:dir { read getattr lock search ioctl };
#line 112
allow ftpd_t cifs_t:file { read getattr lock ioctl };
#line 112
allow ftpd_t cifs_t:lnk_file { getattr read };
#line 112

}
dontaudit ftpd_t selinux_config_t:dir search;

#line 115

#line 115
allow ftpd_t { public_content_t public_content_rw_t } :dir { read getattr lock search ioctl };
#line 115
allow ftpd_t { public_content_t public_content_rw_t } :file { read getattr lock ioctl };
#line 115
allow ftpd_t { public_content_t public_content_rw_t } :lnk_file { getattr read };
#line 115

#line 115
bool allow_ftpd_anon_write false;
#line 115
if (allow_ftpd_anon_write) {
#line 115

#line 115
allow ftpd_t public_content_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 115
allow ftpd_t public_content_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 115
allow ftpd_t public_content_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 115

#line 115
}
#line 115


#line 1 "domains/program/getty.te"
#DESC Getty - Manage ttys
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: util-linux fbgetty mingetty mgetty rungetty
#

#################################
#
# Rules for the getty_t domain.
#

#line 11

#line 11
type getty_t, domain, privlog, daemon , privfd, privmail, mlsfileread, mlsfilewrite;
#line 11
type getty_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit getty_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types getty_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow getty_t init_t:fd use;
#line 11
allow getty_t init_t:process sigchld;
#line 11
allow getty_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow getty_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow getty_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow getty_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow getty_t ld_so_t:file execute_no_trans;
#line 11
allow getty_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow getty_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow getty_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow getty_t texrel_shlib_t:file execmod;
#line 11
allow getty_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow getty_t device_t:dir search;
#line 11
allow getty_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow getty_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow getty_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow getty_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow getty_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow getty_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit getty_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit getty_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow getty_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow getty_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow getty_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow getty_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit getty_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit getty_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11
bool getty_disable_trans false;
#line 11
if (getty_disable_trans) {
#line 11

#line 11
allow init_t getty_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow init_t getty_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit init_t getty_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit init_t getty_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit init_t getty_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow init_t getty_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow getty_t init_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow getty_t init_t:fd use;
#line 11
allow init_t getty_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow getty_t init_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow getty_t getty_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow getty_t getty_exec_t:file entrypoint;
#line 11

#line 11
type_transition init_t getty_exec_t:process getty_t;
#line 11

#line 11
}
#line 11



#line 13

#line 13
type getty_etc_t, file_type, sysadmfile, usercanread;
#line 13
allow getty_t getty_etc_t:file { read getattr lock ioctl };
#line 13

#line 13
allow getty_t getty_etc_t:dir { read getattr lock search ioctl };
#line 13
allow getty_t getty_etc_t:lnk_file { getattr read };
#line 13


allow getty_t console_device_t:chr_file setattr;


#line 17
type getty_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the process to modify the directory.
#line 17
#
#line 17
allow getty_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17

#line 17
#
#line 17
# Allow the process to create the file.
#line 17
#
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow getty_t getty_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow getty_t getty_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
type_transition getty_t tmp_t:{ file dir } getty_tmp_t;
#line 17

#line 17

#line 17


#line 18
type getty_log_t, file_type, sysadmfile, logfile;
#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the process to modify the directory.
#line 18
#
#line 18
allow getty_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 18

#line 18
#
#line 18
# Allow the process to create the file.
#line 18
#
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
allow getty_t getty_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
type_transition getty_t var_log_t:file getty_log_t;
#line 18

#line 18

#line 18


allow getty_t { etc_t etc_runtime_t }:file { getattr read };
allow getty_t etc_t:lnk_file read;
allow getty_t self:process { getpgid getsession };
allow getty_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow getty_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# Use capabilities.
allow getty_t self:capability { dac_override chown sys_resource sys_tty_config };


#line 29
allow getty_t etc_t:lnk_file read;
#line 29
allow getty_t lib_t:file { read getattr lock ioctl };
#line 29

#line 29
allow getty_t locale_t:dir { read getattr lock search ioctl };
#line 29
allow getty_t locale_t:file { read getattr lock ioctl };
#line 29
allow getty_t locale_t:lnk_file { getattr read };
#line 29

#line 29


# Run login in local_login_t domain.
allow getty_t { sbin_t bin_t }:dir search;

#line 33

#line 33

#line 33
#
#line 33
# Allow the process to transition to the new domain.
#line 33
#
#line 33
allow getty_t local_login_t:process transition;
#line 33

#line 33
#
#line 33
# Do not audit when glibc secure mode is enabled upon the transition.
#line 33
#
#line 33
dontaudit getty_t local_login_t:process noatsecure;
#line 33

#line 33
#
#line 33
# Do not audit when signal-related state is cleared upon the transition.
#line 33
#
#line 33
dontaudit getty_t local_login_t:process siginh;
#line 33

#line 33
#
#line 33
# Do not audit when resource limits are reset upon the transition.
#line 33
#
#line 33
dontaudit getty_t local_login_t:process rlimitinh;
#line 33

#line 33
#
#line 33
# Allow the process to execute the program.
#line 33
# 
#line 33
allow getty_t login_exec_t:file { read { getattr execute } };
#line 33

#line 33
#
#line 33
# Allow the process to reap the new domain.
#line 33
#
#line 33
allow local_login_t getty_t:process sigchld;
#line 33

#line 33
#
#line 33
# Allow the new domain to inherit and use file 
#line 33
# descriptions from the creating process and vice versa.
#line 33
#
#line 33
allow local_login_t getty_t:fd use;
#line 33
allow getty_t local_login_t:fd use;
#line 33

#line 33
#
#line 33
# Allow the new domain to write back to the old domain via a pipe.
#line 33
#
#line 33
allow local_login_t getty_t:fifo_file { ioctl read getattr lock write append };
#line 33

#line 33
#
#line 33
# Allow the new domain to read and execute the program.
#line 33
#
#line 33
allow local_login_t login_exec_t:file { read getattr lock execute ioctl };
#line 33

#line 33
#
#line 33
# Allow the new domain to be entered via the program.
#line 33
#
#line 33
allow local_login_t login_exec_t:file entrypoint;
#line 33

#line 33
type_transition getty_t login_exec_t:process local_login_t;
#line 33


# Write to /var/run/utmp.
allow getty_t { var_t var_run_t }:dir search;
allow getty_t initrc_var_run_t:file { ioctl read getattr lock write append };

# Write to /var/log/wtmp.
allow getty_t wtmp_t:file { ioctl read getattr lock write append };

# Chown, chmod, read and write ttys.
allow getty_t tty_device_t:chr_file { setattr { ioctl read getattr lock write append } };
allow getty_t ttyfile:chr_file { setattr { ioctl read getattr lock write append } };
dontaudit getty_t initrc_devpts_t:chr_file { ioctl read getattr lock write append }; 

# for error condition handling
allow getty_t fs_t:filesystem getattr;


#line 50
type getty_lock_t, file_type, sysadmfile, lockfile;
#line 50

#line 50

#line 50

#line 50

#line 50
#
#line 50
# Allow the process to modify the directory.
#line 50
#
#line 50
allow getty_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 50

#line 50
#
#line 50
# Allow the process to create the file.
#line 50
#
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow getty_t getty_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
type_transition getty_t var_lock_t:file getty_lock_t;
#line 50

#line 50

#line 50


#line 51
allow getty_t sysfs_t:dir { read getattr lock search ioctl };
#line 51
allow getty_t sysfs_t:file { read getattr lock ioctl };
#line 51
allow getty_t sysfs_t:lnk_file { getattr read };
#line 51

# for mgetty

#line 53
type getty_var_run_t, file_type, sysadmfile, pidfile;
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the process to modify the directory.
#line 53
#
#line 53
allow getty_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 53

#line 53
#
#line 53
# Allow the process to create the file.
#line 53
#
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
allow getty_t getty_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
type_transition getty_t var_run_t:file getty_var_run_t;
#line 53

#line 53

#line 53

#line 53
allow getty_t var_t:dir search;
#line 53
allow getty_t getty_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 53

allow getty_t self:capability { fowner fsetid };

#
# getty needs to be able to run pppd
#
#line 61

#line 61

#line 61

#line 61

#line 61
#
#line 61
# Allow the process to transition to the new domain.
#line 61
#
#line 61
allow getty_t pppd_t:process transition;
#line 61

#line 61
#
#line 61
# Do not audit when glibc secure mode is enabled upon the transition.
#line 61
#
#line 61
dontaudit getty_t pppd_t:process noatsecure;
#line 61

#line 61
#
#line 61
# Do not audit when signal-related state is cleared upon the transition.
#line 61
#
#line 61
dontaudit getty_t pppd_t:process siginh;
#line 61

#line 61
#
#line 61
# Do not audit when resource limits are reset upon the transition.
#line 61
#
#line 61
dontaudit getty_t pppd_t:process rlimitinh;
#line 61

#line 61
#
#line 61
# Allow the process to execute the program.
#line 61
# 
#line 61
allow getty_t pppd_exec_t:file { read { getattr execute } };
#line 61

#line 61
#
#line 61
# Allow the process to reap the new domain.
#line 61
#
#line 61
allow pppd_t getty_t:process sigchld;
#line 61

#line 61
#
#line 61
# Allow the new domain to inherit and use file 
#line 61
# descriptions from the creating process and vice versa.
#line 61
#
#line 61
allow pppd_t getty_t:fd use;
#line 61
allow getty_t pppd_t:fd use;
#line 61

#line 61
#
#line 61
# Allow the new domain to write back to the old domain via a pipe.
#line 61
#
#line 61
allow pppd_t getty_t:fifo_file { ioctl read getattr lock write append };
#line 61

#line 61
#
#line 61
# Allow the new domain to read and execute the program.
#line 61
#
#line 61
allow pppd_t pppd_exec_t:file { read getattr lock execute ioctl };
#line 61

#line 61
#
#line 61
# Allow the new domain to be entered via the program.
#line 61
#
#line 61
allow pppd_t pppd_exec_t:file entrypoint;
#line 61

#line 61
type_transition getty_t pppd_exec_t:process pppd_t;
#line 61

#line 61

#line 1 "domains/program/hald.te"
#DESC hald - server for device info
#
# Author:  Russell Coker <rcoker@redhat.com>
# X-Debian-Packages: 
#

#################################
#
# Rules for the hald_t domain.
#
# hald_exec_t is the type of the hald executable.
#

#line 13

#line 13

#line 13

#line 13
type hald_t, domain, privlog, daemon , fs_domain, nscd_client_domain, transitionbool;
#line 13
type hald_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit hald_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types hald_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow hald_t init_t:fd use;
#line 13
allow hald_t init_t:process sigchld;
#line 13
allow hald_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow hald_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow hald_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow hald_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow hald_t ld_so_t:file execute_no_trans;
#line 13
allow hald_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow hald_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow hald_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow hald_t texrel_shlib_t:file execmod;
#line 13
allow hald_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow hald_t device_t:dir search;
#line 13
allow hald_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow hald_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow hald_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow hald_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow hald_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow hald_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit hald_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit hald_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow hald_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow hald_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow hald_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow hald_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit hald_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit hald_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow hald_t sysctl_t:dir search;
#line 13
allow hald_t sysctl_kernel_t:dir search;
#line 13
allow hald_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13

#line 13
bool hald_disable_trans false;
#line 13
if (hald_disable_trans) {
#line 13

#line 13
allow initrc_t hald_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13

#line 13
allow sysadm_t hald_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13
} else {
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t hald_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t hald_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t hald_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t hald_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t hald_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow hald_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow hald_t initrc_t:fd use;
#line 13
allow initrc_t hald_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow hald_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow hald_t hald_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow hald_t hald_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t hald_exec_t:process hald_t;
#line 13

#line 13

#line 13
allow initrc_t hald_t:process { noatsecure siginh rlimitinh };
#line 13

#line 13
}
#line 13
 
#line 13
allow hald_t privfd:fd use;
#line 13

#line 13
allow hald_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
# Create pid file.
#line 13
allow hald_t var_t:dir { getattr search };
#line 13

#line 13
type hald_var_run_t, file_type, sysadmfile, pidfile;
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow hald_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow hald_t hald_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition hald_t var_run_t:file hald_var_run_t;
#line 13

#line 13

#line 13

#line 13
allow hald_t var_t:dir search;
#line 13
allow hald_t hald_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13

#line 13
allow hald_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13
# for daemons that look at /root on startup
#line 13
dontaudit hald_t sysadm_home_dir_t:dir search;
#line 13

#line 13
# for df
#line 13
allow hald_t fs_type:filesystem getattr;
#line 13
allow hald_t removable_t:filesystem getattr;
#line 13

#line 13

#line 13
allow hald_t etc_t:lnk_file read;
#line 13
allow hald_t lib_t:file { read getattr lock ioctl };
#line 13

#line 13
allow hald_t locale_t:dir { read getattr lock search ioctl };
#line 13
allow hald_t locale_t:file { read getattr lock ioctl };
#line 13
allow hald_t locale_t:lnk_file { getattr read };
#line 13

#line 13

#line 13

#line 13
# for localization
#line 13
allow hald_t lib_t:file { getattr read };
#line 13



#line 15
allow hald_t { bin_t sbin_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 15
allow hald_t { bin_t sbin_t etc_t }:lnk_file { getattr read };
#line 15

#line 15
allow hald_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 15
allow hald_t lib_t:lnk_file { read getattr lock ioctl };
#line 15
allow hald_t ld_so_t:file { read getattr lock execute ioctl };
#line 15
#allow hald_t ld_so_t:file execute_no_trans;
#line 15
allow hald_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 15
allow hald_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 15
allow hald_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 15
allow hald_t texrel_shlib_t:file execmod;
#line 15
allow hald_t ld_so_cache_t:file { read getattr lock ioctl };
#line 15
allow hald_t device_t:dir search;
#line 15
allow hald_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 15

#line 15

#line 15
allow hald_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 15

#line 15

#line 15
allow hald_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 15

#line 15

#line 15
allow hald_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 15

#line 15

#line 15
allow hald_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 15

#line 15

#line 15
allow hald_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 15

#line 15

#line 15
allow hald_t ld_so_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 15

#line 15


allow hald_t { etc_t etc_runtime_t }:file { getattr read };
allow hald_t self:unix_stream_socket { connectto { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept } };
allow hald_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

#line 25

#line 25
allow hald_t system_dbusd_t:dbus { acquire_svc send_msg };
#line 25

#line 25

#line 25

#line 25
# Derived type used for connection
#line 25
type hald_dbusd_system_t;
#line 25
type_change hald_t system_dbusd_t:dbus hald_dbusd_system_t;
#line 25

#line 25
# SE-DBus specific permissions
#line 25
allow hald_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 25

#line 25
# For connecting to the bus
#line 25
allow hald_t system_dbusd_t:unix_stream_socket connectto;
#line 25

#line 25

#line 25
allow { hald_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 25
allow { hald_t } system_dbusd_var_run_t:sock_file write;
#line 25
  
#line 25
allow hald_t self:dbus send_msg;
#line 25


allow hald_t self:file { getattr read };
allow hald_t proc_t:file { ioctl read getattr lock write append };

allow hald_t { bin_t sbin_t }:dir search;
allow hald_t self:fifo_file { ioctl read getattr lock write append };
allow hald_t usr_t:file { getattr read };
allow hald_t bin_t:file getattr;

# For backwards compatibility with older kernels
allow hald_t self:netlink_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

allow hald_t self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow hald_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
allow hald_t self:capability { net_admin sys_admin dac_override dac_read_search mknod sys_rawio };

#line 41

#line 41

#line 41

#line 41
#
#line 41
# Allow the domain to create and use tcp sockets.
#line 41
# Other kinds of sockets must be separately authorized for use.
#line 41
allow hald_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 41

#line 41
allow hald_t unlabeled_t:association { sendto recvfrom };
#line 41

#line 41
#
#line 41
# Allow the domain to send or receive using any network interface.
#line 41
# netif_type is a type attribute for all network interface types.
#line 41
#
#line 41
allow hald_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 41
#
#line 41
# Allow the domain to send to or receive from any node.
#line 41
# node_type is a type attribute for all node types.
#line 41
#
#line 41
allow hald_t node_type:node { tcp_send rawip_send };
#line 41
allow hald_t node_type:node { tcp_recv rawip_recv };
#line 41

#line 41
#
#line 41
# Allow the domain to send to or receive from any port.
#line 41
# port_type is a type attribute for all port types.
#line 41
#
#line 41

#line 41
allow hald_t port_type:tcp_socket { send_msg recv_msg };
#line 41

#line 41

#line 41
# XXX Allow binding to any node type.  Remove once
#line 41
# individual rules have been added to all domains that 
#line 41
# bind sockets. 
#line 41
allow hald_t node_type:tcp_socket node_bind;
#line 41
#
#line 41
# Allow access to network files including /etc/resolv.conf
#line 41
#
#line 41
allow hald_t net_conf_t:file { read getattr lock ioctl };
#line 41

#line 41
allow hald_t self:tcp_socket { listen accept };
#line 41

#line 41

#line 41

#line 41
#
#line 41
# Allow the domain to create and use udp sockets.
#line 41
# Other kinds of sockets must be separately authorized for use.
#line 41
allow hald_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 41

#line 41
allow hald_t unlabeled_t:association { sendto recvfrom };
#line 41

#line 41
#
#line 41
# Allow the domain to send or receive using any network interface.
#line 41
# netif_type is a type attribute for all network interface types.
#line 41
#
#line 41
allow hald_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 41
#
#line 41
# Allow the domain to send to or receive from any node.
#line 41
# node_type is a type attribute for all node types.
#line 41
#
#line 41
allow hald_t node_type:node { udp_send rawip_send };
#line 41
allow hald_t node_type:node { udp_recv rawip_recv };
#line 41

#line 41
#
#line 41
# Allow the domain to send to or receive from any port.
#line 41
# port_type is a type attribute for all port types.
#line 41
#
#line 41

#line 41
allow hald_t port_type:udp_socket { send_msg recv_msg };
#line 41

#line 41

#line 41
# XXX Allow binding to any node type.  Remove once
#line 41
# individual rules have been added to all domains that 
#line 41
# bind sockets. 
#line 41
allow hald_t node_type:udp_socket node_bind;
#line 41
#
#line 41
# Allow access to network files including /etc/resolv.conf
#line 41
#
#line 41
allow hald_t net_conf_t:file { read getattr lock ioctl };
#line 41

#line 41
allow hald_t self:udp_socket { connect };
#line 41

#line 41

#line 41


#line 42

#line 42
if (allow_ypbind) {
#line 42

#line 42

#line 42

#line 42

#line 42

#line 42

#line 42

#line 42
#
#line 42
# Allow the domain to create and use tcp sockets.
#line 42
# Other kinds of sockets must be separately authorized for use.
#line 42
allow hald_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 42

#line 42
allow hald_t unlabeled_t:association { sendto recvfrom };
#line 42

#line 42
#
#line 42
# Allow the domain to send or receive using any network interface.
#line 42
# netif_type is a type attribute for all network interface types.
#line 42
#
#line 42
allow hald_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 42
#
#line 42
# Allow the domain to send to or receive from any node.
#line 42
# node_type is a type attribute for all node types.
#line 42
#
#line 42
allow hald_t node_type:node { tcp_send rawip_send };
#line 42
allow hald_t node_type:node { tcp_recv rawip_recv };
#line 42

#line 42
#
#line 42
# Allow the domain to send to or receive from any port.
#line 42
# port_type is a type attribute for all port types.
#line 42
#
#line 42

#line 42
allow hald_t port_type:tcp_socket { send_msg recv_msg };
#line 42

#line 42

#line 42
# XXX Allow binding to any node type.  Remove once
#line 42
# individual rules have been added to all domains that 
#line 42
# bind sockets. 
#line 42
allow hald_t node_type:tcp_socket node_bind;
#line 42
#
#line 42
# Allow access to network files including /etc/resolv.conf
#line 42
#
#line 42
allow hald_t net_conf_t:file { read getattr lock ioctl };
#line 42

#line 42
allow hald_t self:tcp_socket { listen accept };
#line 42

#line 42

#line 42

#line 42
#
#line 42
# Allow the domain to create and use tcp sockets.
#line 42
# Other kinds of sockets must be separately authorized for use.
#line 42
allow hald_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 42

#line 42
allow hald_t unlabeled_t:association { sendto recvfrom };
#line 42

#line 42
#
#line 42
# Allow the domain to send or receive using any network interface.
#line 42
# netif_type is a type attribute for all network interface types.
#line 42
#
#line 42
allow hald_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 42
#
#line 42
# Allow the domain to send to or receive from any node.
#line 42
# node_type is a type attribute for all node types.
#line 42
#
#line 42
allow hald_t node_type:node { tcp_send rawip_send };
#line 42
allow hald_t node_type:node { tcp_recv rawip_recv };
#line 42

#line 42
#
#line 42
# Allow the domain to send to or receive from any port.
#line 42
# port_type is a type attribute for all port types.
#line 42
#
#line 42

#line 42
allow hald_t port_type:tcp_socket { send_msg recv_msg };
#line 42

#line 42

#line 42
# XXX Allow binding to any node type.  Remove once
#line 42
# individual rules have been added to all domains that 
#line 42
# bind sockets. 
#line 42
allow hald_t node_type:tcp_socket node_bind;
#line 42
#
#line 42
# Allow access to network files including /etc/resolv.conf
#line 42
#
#line 42
allow hald_t net_conf_t:file { read getattr lock ioctl };
#line 42

#line 42
allow hald_t self:tcp_socket { connect };
#line 42

#line 42

#line 42

#line 42

#line 42

#line 42
#
#line 42
# Allow the domain to create and use udp sockets.
#line 42
# Other kinds of sockets must be separately authorized for use.
#line 42
allow hald_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 42

#line 42
allow hald_t unlabeled_t:association { sendto recvfrom };
#line 42

#line 42
#
#line 42
# Allow the domain to send or receive using any network interface.
#line 42
# netif_type is a type attribute for all network interface types.
#line 42
#
#line 42
allow hald_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 42
#
#line 42
# Allow the domain to send to or receive from any node.
#line 42
# node_type is a type attribute for all node types.
#line 42
#
#line 42
allow hald_t node_type:node { udp_send rawip_send };
#line 42
allow hald_t node_type:node { udp_recv rawip_recv };
#line 42

#line 42
#
#line 42
# Allow the domain to send to or receive from any port.
#line 42
# port_type is a type attribute for all port types.
#line 42
#
#line 42

#line 42
allow hald_t port_type:udp_socket { send_msg recv_msg };
#line 42

#line 42

#line 42
# XXX Allow binding to any node type.  Remove once
#line 42
# individual rules have been added to all domains that 
#line 42
# bind sockets. 
#line 42
allow hald_t node_type:udp_socket node_bind;
#line 42
#
#line 42
# Allow access to network files including /etc/resolv.conf
#line 42
#
#line 42
allow hald_t net_conf_t:file { read getattr lock ioctl };
#line 42

#line 42
allow hald_t self:udp_socket { connect };
#line 42

#line 42

#line 42

#line 42

#line 42

#line 42

#line 42
allow hald_t var_yp_t:dir { read getattr lock search ioctl };
#line 42
allow hald_t var_yp_t:file { read getattr lock ioctl };
#line 42
allow hald_t var_yp_t:lnk_file { getattr read };
#line 42

#line 42
allow hald_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 42
allow hald_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 42
dontaudit hald_t self:capability net_bind_service;
#line 42
dontaudit hald_t reserved_port_type:tcp_socket name_connect;
#line 42
dontaudit hald_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 42

#line 42
} else {
#line 42
dontaudit hald_t var_yp_t:dir search;
#line 42
}
#line 42
 

allow hald_t device_t:lnk_file read;
allow hald_t { fixed_disk_device_t removable_device_t }:blk_file { getattr read ioctl };
allow hald_t removable_device_t:blk_file write;
allow hald_t event_device_t:chr_file { getattr read ioctl };
allow hald_t printer_device_t:chr_file { ioctl read getattr lock write append };
allow hald_t urandom_device_t:chr_file read;
allow hald_t mouse_device_t:chr_file { read getattr lock ioctl };
allow hald_t device_type:chr_file getattr;


#line 53
# Get the selinuxfs mount point via /proc/self/mounts.
#line 53
allow hald_t proc_t:dir search;
#line 53
allow hald_t proc_t:{ file lnk_file } { getattr read };
#line 53
allow hald_t self:dir search;
#line 53
allow hald_t self:file { getattr read };
#line 53
# Access selinuxfs.
#line 53
allow hald_t security_t:dir { read search getattr };
#line 53
allow hald_t security_t:file { getattr read write };
#line 53
allow hald_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 53


#line 59

#line 59

#line 59

#line 59

#line 59
#
#line 59
# Allow the process to transition to the new domain.
#line 59
#
#line 59
allow hald_t updfstab_t:process transition;
#line 59

#line 59
#
#line 59
# Do not audit when glibc secure mode is enabled upon the transition.
#line 59
#
#line 59
dontaudit hald_t updfstab_t:process noatsecure;
#line 59

#line 59
#
#line 59
# Do not audit when signal-related state is cleared upon the transition.
#line 59
#
#line 59
dontaudit hald_t updfstab_t:process siginh;
#line 59

#line 59
#
#line 59
# Do not audit when resource limits are reset upon the transition.
#line 59
#
#line 59
dontaudit hald_t updfstab_t:process rlimitinh;
#line 59

#line 59
#
#line 59
# Allow the process to execute the program.
#line 59
# 
#line 59
allow hald_t updfstab_exec_t:file { read { getattr execute } };
#line 59

#line 59
#
#line 59
# Allow the process to reap the new domain.
#line 59
#
#line 59
allow updfstab_t hald_t:process sigchld;
#line 59

#line 59
#
#line 59
# Allow the new domain to inherit and use file 
#line 59
# descriptions from the creating process and vice versa.
#line 59
#
#line 59
allow updfstab_t hald_t:fd use;
#line 59
allow hald_t updfstab_t:fd use;
#line 59

#line 59
#
#line 59
# Allow the new domain to write back to the old domain via a pipe.
#line 59
#
#line 59
allow updfstab_t hald_t:fifo_file { ioctl read getattr lock write append };
#line 59

#line 59
#
#line 59
# Allow the new domain to read and execute the program.
#line 59
#
#line 59
allow updfstab_t updfstab_exec_t:file { read getattr lock execute ioctl };
#line 59

#line 59
#
#line 59
# Allow the new domain to be entered via the program.
#line 59
#
#line 59
allow updfstab_t updfstab_exec_t:file entrypoint;
#line 59

#line 59
type_transition hald_t updfstab_exec_t:process updfstab_t;
#line 59

#line 59
allow updfstab_t hald_t:dbus send_msg;
#line 59
allow hald_t updfstab_t:dbus send_msg;
#line 59

#line 64

#line 64

#line 64

#line 64

#line 64
#
#line 64
# Allow the process to transition to the new domain.
#line 64
#
#line 64
allow hald_t udev_t:process transition;
#line 64

#line 64
#
#line 64
# Do not audit when glibc secure mode is enabled upon the transition.
#line 64
#
#line 64
dontaudit hald_t udev_t:process noatsecure;
#line 64

#line 64
#
#line 64
# Do not audit when signal-related state is cleared upon the transition.
#line 64
#
#line 64
dontaudit hald_t udev_t:process siginh;
#line 64

#line 64
#
#line 64
# Do not audit when resource limits are reset upon the transition.
#line 64
#
#line 64
dontaudit hald_t udev_t:process rlimitinh;
#line 64

#line 64
#
#line 64
# Allow the process to execute the program.
#line 64
# 
#line 64
allow hald_t udev_exec_t:file { read { getattr execute } };
#line 64

#line 64
#
#line 64
# Allow the process to reap the new domain.
#line 64
#
#line 64
allow udev_t hald_t:process sigchld;
#line 64

#line 64
#
#line 64
# Allow the new domain to inherit and use file 
#line 64
# descriptions from the creating process and vice versa.
#line 64
#
#line 64
allow udev_t hald_t:fd use;
#line 64
allow hald_t udev_t:fd use;
#line 64

#line 64
#
#line 64
# Allow the new domain to write back to the old domain via a pipe.
#line 64
#
#line 64
allow udev_t hald_t:fifo_file { ioctl read getattr lock write append };
#line 64

#line 64
#
#line 64
# Allow the new domain to read and execute the program.
#line 64
#
#line 64
allow udev_t udev_exec_t:file { read getattr lock execute ioctl };
#line 64

#line 64
#
#line 64
# Allow the new domain to be entered via the program.
#line 64
#
#line 64
allow udev_t udev_exec_t:file entrypoint;
#line 64

#line 64
type_transition hald_t udev_exec_t:process udev_t;
#line 64

#line 64
allow udev_t hald_t:unix_dgram_socket sendto;
#line 64
allow hald_t udev_tbl_t:file { getattr read };
#line 64


#line 68

#line 68

#line 68
allow hald_t hotplug_etc_t:dir { read getattr lock search ioctl };
#line 68
allow hald_t hotplug_etc_t:file { read getattr lock ioctl };
#line 68
allow hald_t hotplug_etc_t:lnk_file { getattr read };
#line 68

#line 68

allow hald_t fs_type:dir { search getattr };
allow hald_t usbfs_t:dir { read getattr lock search ioctl };
allow hald_t { usbdevfs_t usbfs_t }:file { ioctl read getattr lock write append };
allow hald_t bin_t:lnk_file read;

#line 73
allow hald_t { selinux_config_t default_context_t } :dir { read getattr lock search ioctl };
#line 73
allow hald_t { selinux_config_t default_context_t } :file { read getattr lock ioctl };
#line 73
allow hald_t { selinux_config_t default_context_t } :lnk_file { getattr read };
#line 73

allow hald_t initrc_t:dbus send_msg;
allow initrc_t hald_t:dbus send_msg;
allow hald_t etc_runtime_t:file { ioctl read getattr lock write append };
allow hald_t var_lib_t:dir search;
allow hald_t device_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
allow hald_t device_t:chr_file { create ioctl read getattr lock write setattr append link unlink rename };

#line 80
type hald_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 80

#line 80

#line 80

#line 80

#line 80
#
#line 80
# Allow the process to modify the directory.
#line 80
#
#line 80
allow hald_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 80

#line 80
#
#line 80
# Allow the process to create the file.
#line 80
#
#line 80

#line 80

#line 80

#line 80

#line 80

#line 80
allow hald_t hald_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80
allow hald_t hald_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80
type_transition hald_t tmp_t:{ file dir } hald_tmp_t;
#line 80

#line 80

#line 80

allow hald_t mnt_t:dir search;

#line 82
allow hald_t proc_net_t:dir { read getattr lock search ioctl };
#line 82
allow hald_t proc_net_t:file { read getattr lock ioctl };
#line 82
allow hald_t proc_net_t:lnk_file { getattr read };
#line 82


# For /usr/libexec/hald-addon-acpi - writes to /var/run/acpid.socket
#line 88

#line 88
allow hald_t apmd_var_run_t:sock_file write;
#line 88
allow hald_t apmd_t:unix_stream_socket connectto;
#line 88


# For /usr/libexec/hald-probe-smbios

#line 91

#line 91

#line 91
#
#line 91
# Allow the process to transition to the new domain.
#line 91
#
#line 91
allow hald_t dmidecode_t:process transition;
#line 91

#line 91
#
#line 91
# Do not audit when glibc secure mode is enabled upon the transition.
#line 91
#
#line 91
dontaudit hald_t dmidecode_t:process noatsecure;
#line 91

#line 91
#
#line 91
# Do not audit when signal-related state is cleared upon the transition.
#line 91
#
#line 91
dontaudit hald_t dmidecode_t:process siginh;
#line 91

#line 91
#
#line 91
# Do not audit when resource limits are reset upon the transition.
#line 91
#
#line 91
dontaudit hald_t dmidecode_t:process rlimitinh;
#line 91

#line 91
#
#line 91
# Allow the process to execute the program.
#line 91
# 
#line 91
allow hald_t dmidecode_exec_t:file { read { getattr execute } };
#line 91

#line 91
#
#line 91
# Allow the process to reap the new domain.
#line 91
#
#line 91
allow dmidecode_t hald_t:process sigchld;
#line 91

#line 91
#
#line 91
# Allow the new domain to inherit and use file 
#line 91
# descriptions from the creating process and vice versa.
#line 91
#
#line 91
allow dmidecode_t hald_t:fd use;
#line 91
allow hald_t dmidecode_t:fd use;
#line 91

#line 91
#
#line 91
# Allow the new domain to write back to the old domain via a pipe.
#line 91
#
#line 91
allow dmidecode_t hald_t:fifo_file { ioctl read getattr lock write append };
#line 91

#line 91
#
#line 91
# Allow the new domain to read and execute the program.
#line 91
#
#line 91
allow dmidecode_t dmidecode_exec_t:file { read getattr lock execute ioctl };
#line 91

#line 91
#
#line 91
# Allow the new domain to be entered via the program.
#line 91
#
#line 91
allow dmidecode_t dmidecode_exec_t:file entrypoint;
#line 91

#line 91
type_transition hald_t dmidecode_exec_t:process dmidecode_t;
#line 91


# ??
#line 96

#line 100

#line 100
allow unconfined_t hald_t:dbus send_msg;
#line 100
allow hald_t unconfined_t:dbus send_msg;
#line 100

#line 103


#line 104
allow hald_t hwdata_t:dir { read getattr lock search ioctl };
#line 104
allow hald_t hwdata_t:file { read getattr lock ioctl };
#line 104
allow hald_t hwdata_t:lnk_file { getattr read };
#line 104

#line 1 "domains/program/hostname.te"
#DESC hostname - show or set the system host name
#
# Author: Russell Coker <russell@coker.com.au>
# X-Debian-Packages: hostname

# for setting the hostname

#line 7
type hostname_t, domain, privlog, daemon ;
#line 7
type hostname_exec_t, file_type, sysadmfile, exec_type;
#line 7
dontaudit hostname_t self:capability sys_tty_config;
#line 7

#line 7
role system_r types hostname_t;
#line 7

#line 7
# Inherit and use descriptors from init.
#line 7
allow hostname_t init_t:fd use;
#line 7
allow hostname_t init_t:process sigchld;
#line 7
allow hostname_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 7

#line 7

#line 7
allow hostname_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 7
allow hostname_t lib_t:lnk_file { read getattr lock ioctl };
#line 7
allow hostname_t ld_so_t:file { read getattr lock execute ioctl };
#line 7
#allow hostname_t ld_so_t:file execute_no_trans;
#line 7
allow hostname_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 7
allow hostname_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 7
allow hostname_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 7
allow hostname_t texrel_shlib_t:file execmod;
#line 7
allow hostname_t ld_so_cache_t:file { read getattr lock ioctl };
#line 7
allow hostname_t device_t:dir search;
#line 7
allow hostname_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 7

#line 7

#line 7
allow hostname_t { self proc_t }:dir { read getattr lock search ioctl };
#line 7
allow hostname_t { self proc_t }:lnk_file { getattr read };
#line 7

#line 7
allow hostname_t device_t:dir { read getattr lock search ioctl };
#line 7

#line 7
allow hostname_t udev_tdb_t:file { read getattr lock ioctl };
#line 7
allow hostname_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 7
dontaudit hostname_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 7
dontaudit hostname_t unpriv_userdomain:fd use;
#line 7

#line 7

#line 7
allow hostname_t sysfs_t:dir { read getattr lock search ioctl };
#line 7
allow hostname_t sysfs_t:file { read getattr lock ioctl };
#line 7
allow hostname_t sysfs_t:lnk_file { getattr read };
#line 7
 
#line 7

#line 7
allow hostname_t autofs_t:dir { search getattr };
#line 7

#line 7
dontaudit hostname_t { tty_device_t devpts_t }:chr_file { read write };
#line 7
dontaudit hostname_t root_t:file { getattr read };
#line 7
 
#line 7

allow hostname_t self:capability sys_admin;
allow hostname_t etc_t:file { getattr read };

allow hostname_t { user_tty_type admin_tty_type }:chr_file { ioctl read getattr lock write append };

#line 12
allow hostname_t etc_t:lnk_file read;
#line 12
allow hostname_t lib_t:file { read getattr lock ioctl };
#line 12

#line 12
allow hostname_t locale_t:dir { read getattr lock search ioctl };
#line 12
allow hostname_t locale_t:file { read getattr lock ioctl };
#line 12
allow hostname_t locale_t:lnk_file { getattr read };
#line 12

#line 12


#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the domain to create and use tcp sockets.
#line 13
# Other kinds of sockets must be separately authorized for use.
#line 13
allow hostname_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 13

#line 13
allow hostname_t unlabeled_t:association { sendto recvfrom };
#line 13

#line 13
#
#line 13
# Allow the domain to send or receive using any network interface.
#line 13
# netif_type is a type attribute for all network interface types.
#line 13
#
#line 13
allow hostname_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 13
#
#line 13
# Allow the domain to send to or receive from any node.
#line 13
# node_type is a type attribute for all node types.
#line 13
#
#line 13
allow hostname_t node_type:node { tcp_send rawip_send };
#line 13
allow hostname_t node_type:node { tcp_recv rawip_recv };
#line 13

#line 13
#
#line 13
# Allow the domain to send to or receive from any port.
#line 13
# port_type is a type attribute for all port types.
#line 13
#
#line 13

#line 13
allow hostname_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 13

#line 13

#line 13
# XXX Allow binding to any node type.  Remove once
#line 13
# individual rules have been added to all domains that 
#line 13
# bind sockets. 
#line 13
allow hostname_t node_type:tcp_socket node_bind;
#line 13
#
#line 13
# Allow access to network files including /etc/resolv.conf
#line 13
#
#line 13
allow hostname_t net_conf_t:file { read getattr lock ioctl };
#line 13

#line 13
allow hostname_t self:tcp_socket { connect };
#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the domain to create and use udp sockets.
#line 13
# Other kinds of sockets must be separately authorized for use.
#line 13
allow hostname_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 13

#line 13
allow hostname_t unlabeled_t:association { sendto recvfrom };
#line 13

#line 13
#
#line 13
# Allow the domain to send or receive using any network interface.
#line 13
# netif_type is a type attribute for all network interface types.
#line 13
#
#line 13
allow hostname_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 13
#
#line 13
# Allow the domain to send to or receive from any node.
#line 13
# node_type is a type attribute for all node types.
#line 13
#
#line 13
allow hostname_t node_type:node { udp_send rawip_send };
#line 13
allow hostname_t node_type:node { udp_recv rawip_recv };
#line 13

#line 13
#
#line 13
# Allow the domain to send to or receive from any port.
#line 13
# port_type is a type attribute for all port types.
#line 13
#
#line 13

#line 13
allow hostname_t dns_port_t:udp_socket { send_msg recv_msg };
#line 13

#line 13

#line 13
# XXX Allow binding to any node type.  Remove once
#line 13
# individual rules have been added to all domains that 
#line 13
# bind sockets. 
#line 13
allow hostname_t node_type:udp_socket node_bind;
#line 13
#
#line 13
# Allow access to network files including /etc/resolv.conf
#line 13
#
#line 13
allow hostname_t net_conf_t:file { read getattr lock ioctl };
#line 13

#line 13
allow hostname_t self:udp_socket { connect };
#line 13

#line 13

#line 13

#line 13
allow hostname_t dns_port_t:tcp_socket name_connect;
#line 13

allow hostname_t userdomain:fd use;
dontaudit hostname_t kernel_t:fd use;
allow hostname_t net_conf_t:file { getattr read };
allow hostname_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
dontaudit hostname_t var_t:dir search;
allow hostname_t fs_t:filesystem getattr;

# for when /usr is not mounted
dontaudit hostname_t file_t:dir search;

#line 26

#line 26
allow hostname_t tmpfs_t:chr_file { ioctl read getattr lock write append };
#line 26


#line 27
allow hostname_t devpts_t:dir { read getattr lock search ioctl };
#line 27
allow hostname_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 27

allow hostname_t initrc_t:fd use;
#line 1 "domains/program/hotplug.te"
#DESC Hotplug - Hardware event manager
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: hotplug
#

#################################
#
# Rules for the hotplug_t domain.
#
# hotplug_exec_t is the type of the hotplug executable.
#
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
type hotplug_t, domain, privlog, daemon , admin, etc_writer, fs_domain, privmem, privmail, auth_write, privowner, privmodule, domain, privlog, sysctl_kernel_writer, nscd_client_domain, transitionbool;
#line 17
type hotplug_exec_t, file_type, sysadmfile, exec_type;
#line 17
dontaudit hotplug_t self:capability sys_tty_config;
#line 17

#line 17
role system_r types hotplug_t;
#line 17

#line 17
# Inherit and use descriptors from init.
#line 17
allow hotplug_t init_t:fd use;
#line 17
allow hotplug_t init_t:process sigchld;
#line 17
allow hotplug_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 17

#line 17

#line 17
allow hotplug_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 17
allow hotplug_t lib_t:lnk_file { read getattr lock ioctl };
#line 17
allow hotplug_t ld_so_t:file { read getattr lock execute ioctl };
#line 17
#allow hotplug_t ld_so_t:file execute_no_trans;
#line 17
allow hotplug_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 17
allow hotplug_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 17
allow hotplug_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 17
allow hotplug_t texrel_shlib_t:file execmod;
#line 17
allow hotplug_t ld_so_cache_t:file { read getattr lock ioctl };
#line 17
allow hotplug_t device_t:dir search;
#line 17
allow hotplug_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 17

#line 17

#line 17
allow hotplug_t { self proc_t }:dir { read getattr lock search ioctl };
#line 17
allow hotplug_t { self proc_t }:lnk_file { getattr read };
#line 17

#line 17
allow hotplug_t device_t:dir { read getattr lock search ioctl };
#line 17

#line 17
allow hotplug_t udev_tdb_t:file { read getattr lock ioctl };
#line 17
allow hotplug_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 17
dontaudit hotplug_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 17
dontaudit hotplug_t unpriv_userdomain:fd use;
#line 17

#line 17

#line 17
allow hotplug_t sysfs_t:dir { read getattr lock search ioctl };
#line 17
allow hotplug_t sysfs_t:file { read getattr lock ioctl };
#line 17
allow hotplug_t sysfs_t:lnk_file { getattr read };
#line 17
 
#line 17

#line 17
allow hotplug_t autofs_t:dir { search getattr };
#line 17

#line 17
dontaudit hotplug_t { tty_device_t devpts_t }:chr_file { read write };
#line 17
dontaudit hotplug_t root_t:file { getattr read };
#line 17
 
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
# Read system variables in /sys.
#line 17

#line 17
allow hotplug_t sysctl_t:dir search;
#line 17
allow hotplug_t sysctl_kernel_t:dir search;
#line 17
allow hotplug_t sysctl_kernel_t:file { getattr read };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allows user to define a tunable to disable domain transition
#line 17
#
#line 17

#line 17
bool hotplug_disable_trans false;
#line 17
if (hotplug_disable_trans) {
#line 17

#line 17
allow initrc_t hotplug_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 17

#line 17

#line 17
allow sysadm_t hotplug_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 17

#line 17
} else {
#line 17
 
#line 17

#line 17

#line 17
#
#line 17
# Allow the process to transition to the new domain.
#line 17
#
#line 17
allow initrc_t hotplug_t:process transition;
#line 17

#line 17
#
#line 17
# Do not audit when glibc secure mode is enabled upon the transition.
#line 17
#
#line 17
dontaudit initrc_t hotplug_t:process noatsecure;
#line 17

#line 17
#
#line 17
# Do not audit when signal-related state is cleared upon the transition.
#line 17
#
#line 17
dontaudit initrc_t hotplug_t:process siginh;
#line 17

#line 17
#
#line 17
# Do not audit when resource limits are reset upon the transition.
#line 17
#
#line 17
dontaudit initrc_t hotplug_t:process rlimitinh;
#line 17

#line 17
#
#line 17
# Allow the process to execute the program.
#line 17
# 
#line 17
allow initrc_t hotplug_exec_t:file { read { getattr execute } };
#line 17

#line 17
#
#line 17
# Allow the process to reap the new domain.
#line 17
#
#line 17
allow hotplug_t initrc_t:process sigchld;
#line 17

#line 17
#
#line 17
# Allow the new domain to inherit and use file 
#line 17
# descriptions from the creating process and vice versa.
#line 17
#
#line 17
allow hotplug_t initrc_t:fd use;
#line 17
allow initrc_t hotplug_t:fd use;
#line 17

#line 17
#
#line 17
# Allow the new domain to write back to the old domain via a pipe.
#line 17
#
#line 17
allow hotplug_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 17

#line 17
#
#line 17
# Allow the new domain to read and execute the program.
#line 17
#
#line 17
allow hotplug_t hotplug_exec_t:file { read getattr lock execute ioctl };
#line 17

#line 17
#
#line 17
# Allow the new domain to be entered via the program.
#line 17
#
#line 17
allow hotplug_t hotplug_exec_t:file entrypoint;
#line 17

#line 17
type_transition initrc_t hotplug_exec_t:process hotplug_t;
#line 17

#line 17

#line 17
allow initrc_t hotplug_t:process { noatsecure siginh rlimitinh };
#line 17

#line 17
}
#line 17
 
#line 17
allow hotplug_t privfd:fd use;
#line 17

#line 17
allow hotplug_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 17

#line 17

#line 17
# Create pid file.
#line 17
allow hotplug_t var_t:dir { getattr search };
#line 17

#line 17
type hotplug_var_run_t, file_type, sysadmfile, pidfile;
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the process to modify the directory.
#line 17
#
#line 17
allow hotplug_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17

#line 17
#
#line 17
# Allow the process to create the file.
#line 17
#
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow hotplug_t hotplug_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
type_transition hotplug_t var_run_t:file hotplug_var_run_t;
#line 17

#line 17

#line 17

#line 17
allow hotplug_t var_t:dir search;
#line 17
allow hotplug_t hotplug_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17

#line 17

#line 17
allow hotplug_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 17

#line 17
# for daemons that look at /root on startup
#line 17
dontaudit hotplug_t sysadm_home_dir_t:dir search;
#line 17

#line 17
# for df
#line 17
allow hotplug_t fs_type:filesystem getattr;
#line 17
allow hotplug_t removable_t:filesystem getattr;
#line 17

#line 17

#line 17
allow hotplug_t etc_t:lnk_file read;
#line 17
allow hotplug_t lib_t:file { read getattr lock ioctl };
#line 17

#line 17
allow hotplug_t locale_t:dir { read getattr lock search ioctl };
#line 17
allow hotplug_t locale_t:file { read getattr lock ioctl };
#line 17
allow hotplug_t locale_t:lnk_file { getattr read };
#line 17

#line 17

#line 17

#line 17
# for localization
#line 17
allow hotplug_t lib_t:file { getattr read };
#line 17

#line 17



#line 19

#line 19
type hotplug_etc_t, file_type, sysadmfile, usercanread;
#line 19
allow hotplug_t hotplug_etc_t:file { read getattr lock ioctl };
#line 19

#line 19
allow hotplug_t hotplug_etc_t:dir { read getattr lock search ioctl };
#line 19
allow hotplug_t hotplug_etc_t:lnk_file { getattr read };
#line 19


allow hotplug_t self:fifo_file { read write getattr ioctl };
allow hotplug_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow hotplug_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow hotplug_t self:udp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };


#line 26
# Read system variables in /sys.
#line 26

#line 26
allow hotplug_t sysctl_t:dir search;
#line 26
allow hotplug_t sysctl_kernel_t:dir search;
#line 26
allow hotplug_t sysctl_kernel_t:file { getattr read };
#line 26

#line 26

#line 26

allow hotplug_t sysctl_net_t:dir { read getattr lock search ioctl };
allow hotplug_t sysctl_net_t:file { getattr read };

# get info from /proc

#line 31
allow hotplug_t proc_t:dir { read getattr lock search ioctl };
#line 31
allow hotplug_t proc_t:file { read getattr lock ioctl };
#line 31
allow hotplug_t proc_t:lnk_file { getattr read };
#line 31

allow hotplug_t self:file { getattr read ioctl };

allow hotplug_t devtty_t:chr_file { ioctl read getattr lock write append };

allow hotplug_t device_t:dir { read getattr lock search ioctl };

# for SSP
allow hotplug_t urandom_device_t:chr_file read;

allow hotplug_t { bin_t sbin_t }:dir search;
allow hotplug_t { bin_t sbin_t }:lnk_file read;

#line 43
allow hotplug_t { hotplug_exec_t bin_t sbin_t ls_exec_t shell_exec_t hotplug_etc_t etc_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 43

#line 47

#line 47

#line 47
allow hotplug_t hostname_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 47

#line 47
dontaudit hostname_t hotplug_t:fd use;
#line 47

#line 56

#line 56

#line 56
# for arping used for static IP addresses on PCMCIA ethernet
#line 56

#line 56

#line 56

#line 56
#
#line 56
# Allow the process to transition to the new domain.
#line 56
#
#line 56
allow hotplug_t netutils_t:process transition;
#line 56

#line 56
#
#line 56
# Do not audit when glibc secure mode is enabled upon the transition.
#line 56
#
#line 56
dontaudit hotplug_t netutils_t:process noatsecure;
#line 56

#line 56
#
#line 56
# Do not audit when signal-related state is cleared upon the transition.
#line 56
#
#line 56
dontaudit hotplug_t netutils_t:process siginh;
#line 56

#line 56
#
#line 56
# Do not audit when resource limits are reset upon the transition.
#line 56
#
#line 56
dontaudit hotplug_t netutils_t:process rlimitinh;
#line 56

#line 56
#
#line 56
# Allow the process to execute the program.
#line 56
# 
#line 56
allow hotplug_t netutils_exec_t:file { read { getattr execute } };
#line 56

#line 56
#
#line 56
# Allow the process to reap the new domain.
#line 56
#
#line 56
allow netutils_t hotplug_t:process sigchld;
#line 56

#line 56
#
#line 56
# Allow the new domain to inherit and use file 
#line 56
# descriptions from the creating process and vice versa.
#line 56
#
#line 56
allow netutils_t hotplug_t:fd use;
#line 56
allow hotplug_t netutils_t:fd use;
#line 56

#line 56
#
#line 56
# Allow the new domain to write back to the old domain via a pipe.
#line 56
#
#line 56
allow netutils_t hotplug_t:fifo_file { ioctl read getattr lock write append };
#line 56

#line 56
#
#line 56
# Allow the new domain to read and execute the program.
#line 56
#
#line 56
allow netutils_t netutils_exec_t:file { read getattr lock execute ioctl };
#line 56

#line 56
#
#line 56
# Allow the new domain to be entered via the program.
#line 56
#
#line 56
allow netutils_t netutils_exec_t:file entrypoint;
#line 56

#line 56
type_transition hotplug_t netutils_exec_t:process netutils_t;
#line 56

#line 56

#line 56
allow hotplug_t tmpfs_t:dir search;
#line 56
allow hotplug_t tmpfs_t:chr_file { ioctl read getattr lock write append };

allow initrc_t usbdevfs_t:file { getattr read ioctl };
allow initrc_t modules_dep_t:file { getattr read ioctl };

#line 60
allow hotplug_t usbdevfs_t:dir { read getattr lock search ioctl };
#line 60
allow hotplug_t usbdevfs_t:file { read getattr lock ioctl };
#line 60
allow hotplug_t usbdevfs_t:lnk_file { getattr read };
#line 60

allow hotplug_t usbfs_t:dir { read getattr lock search ioctl };
allow hotplug_t usbfs_t:file { getattr read };

# read config files
allow hotplug_t etc_t:dir { read getattr lock search ioctl };
allow hotplug_t etc_t:{ file lnk_file } { read getattr lock ioctl };

allow hotplug_t kernel_t:process { sigchld setpgid };

#line 73

#line 73
allow hotplug_t var_lock_t:dir search;
#line 73
allow hotplug_t var_lock_t:file getattr;
#line 73


#line 79

#line 79
allow hotplug_t hald_t:unix_dgram_socket sendto;
#line 79
allow hald_t hotplug_etc_t:dir search;
#line 79
allow hald_t hotplug_etc_t:file { getattr read };
#line 79


# for killall
allow hotplug_t self:process { getsession getattr };
allow hotplug_t self:file getattr;


#line 85

#line 85

#line 85
#
#line 85
# Allow the process to transition to the new domain.
#line 85
#
#line 85
allow kernel_t hotplug_t:process transition;
#line 85

#line 85
#
#line 85
# Do not audit when glibc secure mode is enabled upon the transition.
#line 85
#
#line 85
dontaudit kernel_t hotplug_t:process noatsecure;
#line 85

#line 85
#
#line 85
# Do not audit when signal-related state is cleared upon the transition.
#line 85
#
#line 85
dontaudit kernel_t hotplug_t:process siginh;
#line 85

#line 85
#
#line 85
# Do not audit when resource limits are reset upon the transition.
#line 85
#
#line 85
dontaudit kernel_t hotplug_t:process rlimitinh;
#line 85

#line 85
#
#line 85
# Allow the process to execute the program.
#line 85
# 
#line 85
allow kernel_t hotplug_exec_t:file { read { getattr execute } };
#line 85

#line 85
#
#line 85
# Allow the process to reap the new domain.
#line 85
#
#line 85
allow hotplug_t kernel_t:process sigchld;
#line 85

#line 85
#
#line 85
# Allow the new domain to inherit and use file 
#line 85
# descriptions from the creating process and vice versa.
#line 85
#
#line 85
allow hotplug_t kernel_t:fd use;
#line 85
allow kernel_t hotplug_t:fd use;
#line 85

#line 85
#
#line 85
# Allow the new domain to write back to the old domain via a pipe.
#line 85
#
#line 85
allow hotplug_t kernel_t:fifo_file { ioctl read getattr lock write append };
#line 85

#line 85
#
#line 85
# Allow the new domain to read and execute the program.
#line 85
#
#line 85
allow hotplug_t hotplug_exec_t:file { read getattr lock execute ioctl };
#line 85

#line 85
#
#line 85
# Allow the new domain to be entered via the program.
#line 85
#
#line 85
allow hotplug_t hotplug_exec_t:file entrypoint;
#line 85

#line 85
type_transition kernel_t hotplug_exec_t:process hotplug_t;
#line 85

#line 88


#line 89

#line 89

#line 89
#
#line 89
# Allow the process to transition to the new domain.
#line 89
#
#line 89
allow hotplug_t ifconfig_t:process transition;
#line 89

#line 89
#
#line 89
# Do not audit when glibc secure mode is enabled upon the transition.
#line 89
#
#line 89
dontaudit hotplug_t ifconfig_t:process noatsecure;
#line 89

#line 89
#
#line 89
# Do not audit when signal-related state is cleared upon the transition.
#line 89
#
#line 89
dontaudit hotplug_t ifconfig_t:process siginh;
#line 89

#line 89
#
#line 89
# Do not audit when resource limits are reset upon the transition.
#line 89
#
#line 89
dontaudit hotplug_t ifconfig_t:process rlimitinh;
#line 89

#line 89
#
#line 89
# Allow the process to execute the program.
#line 89
# 
#line 89
allow hotplug_t ifconfig_exec_t:file { read { getattr execute } };
#line 89

#line 89
#
#line 89
# Allow the process to reap the new domain.
#line 89
#
#line 89
allow ifconfig_t hotplug_t:process sigchld;
#line 89

#line 89
#
#line 89
# Allow the new domain to inherit and use file 
#line 89
# descriptions from the creating process and vice versa.
#line 89
#
#line 89
allow ifconfig_t hotplug_t:fd use;
#line 89
allow hotplug_t ifconfig_t:fd use;
#line 89

#line 89
#
#line 89
# Allow the new domain to write back to the old domain via a pipe.
#line 89
#
#line 89
allow ifconfig_t hotplug_t:fifo_file { ioctl read getattr lock write append };
#line 89

#line 89
#
#line 89
# Allow the new domain to read and execute the program.
#line 89
#
#line 89
allow ifconfig_t ifconfig_exec_t:file { read getattr lock execute ioctl };
#line 89

#line 89
#
#line 89
# Allow the new domain to be entered via the program.
#line 89
#
#line 89
allow ifconfig_t ifconfig_exec_t:file entrypoint;
#line 89

#line 89
type_transition hotplug_t ifconfig_exec_t:process ifconfig_t;
#line 89

#line 92

#line 92

#line 92

#line 92

#line 92
#
#line 92
# Allow the process to transition to the new domain.
#line 92
#
#line 92
allow hotplug_t updfstab_t:process transition;
#line 92

#line 92
#
#line 92
# Do not audit when glibc secure mode is enabled upon the transition.
#line 92
#
#line 92
dontaudit hotplug_t updfstab_t:process noatsecure;
#line 92

#line 92
#
#line 92
# Do not audit when signal-related state is cleared upon the transition.
#line 92
#
#line 92
dontaudit hotplug_t updfstab_t:process siginh;
#line 92

#line 92
#
#line 92
# Do not audit when resource limits are reset upon the transition.
#line 92
#
#line 92
dontaudit hotplug_t updfstab_t:process rlimitinh;
#line 92

#line 92
#
#line 92
# Allow the process to execute the program.
#line 92
# 
#line 92
allow hotplug_t updfstab_exec_t:file { read { getattr execute } };
#line 92

#line 92
#
#line 92
# Allow the process to reap the new domain.
#line 92
#
#line 92
allow updfstab_t hotplug_t:process sigchld;
#line 92

#line 92
#
#line 92
# Allow the new domain to inherit and use file 
#line 92
# descriptions from the creating process and vice versa.
#line 92
#
#line 92
allow updfstab_t hotplug_t:fd use;
#line 92
allow hotplug_t updfstab_t:fd use;
#line 92

#line 92
#
#line 92
# Allow the new domain to write back to the old domain via a pipe.
#line 92
#
#line 92
allow updfstab_t hotplug_t:fifo_file { ioctl read getattr lock write append };
#line 92

#line 92
#
#line 92
# Allow the new domain to read and execute the program.
#line 92
#
#line 92
allow updfstab_t updfstab_exec_t:file { read getattr lock execute ioctl };
#line 92

#line 92
#
#line 92
# Allow the new domain to be entered via the program.
#line 92
#
#line 92
allow updfstab_t updfstab_exec_t:file entrypoint;
#line 92

#line 92
type_transition hotplug_t updfstab_exec_t:process updfstab_t;
#line 92

#line 92


# init scripts run /etc/hotplug/usb.rc

#line 95

#line 95

#line 95
#
#line 95
# Allow the process to transition to the new domain.
#line 95
#
#line 95
allow initrc_t hotplug_t:process transition;
#line 95

#line 95
#
#line 95
# Do not audit when glibc secure mode is enabled upon the transition.
#line 95
#
#line 95
dontaudit initrc_t hotplug_t:process noatsecure;
#line 95

#line 95
#
#line 95
# Do not audit when signal-related state is cleared upon the transition.
#line 95
#
#line 95
dontaudit initrc_t hotplug_t:process siginh;
#line 95

#line 95
#
#line 95
# Do not audit when resource limits are reset upon the transition.
#line 95
#
#line 95
dontaudit initrc_t hotplug_t:process rlimitinh;
#line 95

#line 95
#
#line 95
# Allow the process to execute the program.
#line 95
# 
#line 95
allow initrc_t hotplug_etc_t:file { read { getattr execute } };
#line 95

#line 95
#
#line 95
# Allow the process to reap the new domain.
#line 95
#
#line 95
allow hotplug_t initrc_t:process sigchld;
#line 95

#line 95
#
#line 95
# Allow the new domain to inherit and use file 
#line 95
# descriptions from the creating process and vice versa.
#line 95
#
#line 95
allow hotplug_t initrc_t:fd use;
#line 95
allow initrc_t hotplug_t:fd use;
#line 95

#line 95
#
#line 95
# Allow the new domain to write back to the old domain via a pipe.
#line 95
#
#line 95
allow hotplug_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 95

#line 95
#
#line 95
# Allow the new domain to read and execute the program.
#line 95
#
#line 95
allow hotplug_t hotplug_etc_t:file { read getattr lock execute ioctl };
#line 95

#line 95
#
#line 95
# Allow the new domain to be entered via the program.
#line 95
#
#line 95
allow hotplug_t hotplug_etc_t:file entrypoint;
#line 95

#line 95
type_transition initrc_t hotplug_etc_t:process hotplug_t;
#line 95

allow initrc_t hotplug_etc_t:dir { read getattr lock search ioctl };




#line 100
allow hotplug_t modules_object_t:dir { read getattr lock search ioctl };
#line 100
allow hotplug_t modules_object_t:file { read getattr lock ioctl };
#line 100
allow hotplug_t modules_object_t:lnk_file { getattr read };
#line 100

allow hotplug_t modules_dep_t:file { getattr read ioctl };

# for lsmod
dontaudit hotplug_t self:capability { sys_module sys_admin };

# for access("/etc/bashrc", X_OK) on Red Hat
dontaudit hotplug_t self:capability { dac_override dac_read_search };

#line 111

#line 111

#line 111

#line 111

#line 111
#
#line 111
# Allow the process to transition to the new domain.
#line 111
#
#line 111
allow hotplug_t fsadm_t:process transition;
#line 111

#line 111
#
#line 111
# Do not audit when glibc secure mode is enabled upon the transition.
#line 111
#
#line 111
dontaudit hotplug_t fsadm_t:process noatsecure;
#line 111

#line 111
#
#line 111
# Do not audit when signal-related state is cleared upon the transition.
#line 111
#
#line 111
dontaudit hotplug_t fsadm_t:process siginh;
#line 111

#line 111
#
#line 111
# Do not audit when resource limits are reset upon the transition.
#line 111
#
#line 111
dontaudit hotplug_t fsadm_t:process rlimitinh;
#line 111

#line 111
#
#line 111
# Allow the process to execute the program.
#line 111
# 
#line 111
allow hotplug_t fsadm_exec_t:file { read { getattr execute } };
#line 111

#line 111
#
#line 111
# Allow the process to reap the new domain.
#line 111
#
#line 111
allow fsadm_t hotplug_t:process sigchld;
#line 111

#line 111
#
#line 111
# Allow the new domain to inherit and use file 
#line 111
# descriptions from the creating process and vice versa.
#line 111
#
#line 111
allow fsadm_t hotplug_t:fd use;
#line 111
allow hotplug_t fsadm_t:fd use;
#line 111

#line 111
#
#line 111
# Allow the new domain to write back to the old domain via a pipe.
#line 111
#
#line 111
allow fsadm_t hotplug_t:fifo_file { ioctl read getattr lock write append };
#line 111

#line 111
#
#line 111
# Allow the new domain to read and execute the program.
#line 111
#
#line 111
allow fsadm_t fsadm_exec_t:file { read getattr lock execute ioctl };
#line 111

#line 111
#
#line 111
# Allow the new domain to be entered via the program.
#line 111
#
#line 111
allow fsadm_t fsadm_exec_t:file entrypoint;
#line 111

#line 111
type_transition hotplug_t fsadm_exec_t:process fsadm_t;
#line 111

#line 111


allow hotplug_t var_log_t:dir search;

# for ps
dontaudit hotplug_t domain:dir { getattr search };
dontaudit hotplug_t { init_t kernel_t }:file read;
#line 120

#line 120

#line 120
allow hotplug_t initrc_t:dir { search getattr read };
#line 120
allow hotplug_t initrc_t:{ file lnk_file } { read getattr };
#line 120
allow hotplug_t initrc_t:process getattr;
#line 120
# We need to suppress this denial because procps tries to access
#line 120
# /proc/pid/environ and this now triggers a ptrace check in recent kernels
#line 120
# (2.4 and 2.6).  Might want to change procps to not do this, or only if
#line 120
# running in a privileged domain.
#line 120
dontaudit hotplug_t initrc_t:process ptrace;
#line 120

#line 120


# for when filesystems are not mounted early in the boot
dontaudit hotplug_t file_t:dir { search getattr };

# kernel threads inherit from shared descriptor table used by init
dontaudit hotplug_t initctl_t:fifo_file { read write };

# Read /usr/lib/gconv/.*
allow hotplug_t lib_t:file { getattr read };

allow hotplug_t self:capability { net_admin sys_tty_config mknod sys_rawio };
allow hotplug_t sysfs_t:dir { getattr read search write };
allow hotplug_t sysfs_t:file { ioctl read getattr lock write append };
allow hotplug_t sysfs_t:lnk_file { getattr read };

#line 135
allow hotplug_t hwdata_t:dir { read getattr lock search ioctl };
#line 135
allow hotplug_t hwdata_t:file { read getattr lock ioctl };
#line 135
allow hotplug_t hwdata_t:lnk_file { getattr read };
#line 135

allow hotplug_t udev_runtime_t:file { ioctl read getattr lock write append };
#line 139

#line 139
allow hotplug_t printer_device_t:chr_file setattr;
#line 139

allow hotplug_t fixed_disk_device_t:blk_file setattr;
allow hotplug_t removable_device_t:blk_file setattr;
allow hotplug_t sound_device_t:chr_file setattr;

#line 146

#line 146

#line 146

#line 146

#line 146
#
#line 146
# Allow the process to transition to the new domain.
#line 146
#
#line 146
allow hotplug_t udev_t:process transition;
#line 146

#line 146
#
#line 146
# Do not audit when glibc secure mode is enabled upon the transition.
#line 146
#
#line 146
dontaudit hotplug_t udev_t:process noatsecure;
#line 146

#line 146
#
#line 146
# Do not audit when signal-related state is cleared upon the transition.
#line 146
#
#line 146
dontaudit hotplug_t udev_t:process siginh;
#line 146

#line 146
#
#line 146
# Do not audit when resource limits are reset upon the transition.
#line 146
#
#line 146
dontaudit hotplug_t udev_t:process rlimitinh;
#line 146

#line 146
#
#line 146
# Allow the process to execute the program.
#line 146
# 
#line 146
allow hotplug_t { udev_exec_t udev_helper_exec_t }:file { read { getattr execute } };
#line 146

#line 146
#
#line 146
# Allow the process to reap the new domain.
#line 146
#
#line 146
allow udev_t hotplug_t:process sigchld;
#line 146

#line 146
#
#line 146
# Allow the new domain to inherit and use file 
#line 146
# descriptions from the creating process and vice versa.
#line 146
#
#line 146
allow udev_t hotplug_t:fd use;
#line 146
allow hotplug_t udev_t:fd use;
#line 146

#line 146
#
#line 146
# Allow the new domain to write back to the old domain via a pipe.
#line 146
#
#line 146
allow udev_t hotplug_t:fifo_file { ioctl read getattr lock write append };
#line 146

#line 146
#
#line 146
# Allow the new domain to read and execute the program.
#line 146
#
#line 146
allow udev_t { udev_exec_t udev_helper_exec_t }:file { read getattr lock execute ioctl };
#line 146

#line 146
#
#line 146
# Allow the new domain to be entered via the program.
#line 146
#
#line 146
allow udev_t { udev_exec_t udev_helper_exec_t }:file entrypoint;
#line 146

#line 146
type_transition hotplug_t { udev_exec_t udev_helper_exec_t }:process udev_t;
#line 146

#line 146



#line 148

#line 148

#line 148

#line 148
#
#line 148
# Allow the process to modify the directory.
#line 148
#
#line 148
allow hotplug_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 148

#line 148
#
#line 148
# Allow the process to create the file.
#line 148
#
#line 148

#line 148

#line 148

#line 148

#line 148

#line 148
allow hotplug_t etc_runtime_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148

#line 148
type_transition hotplug_t etc_t:file etc_runtime_t;
#line 148

#line 148



#line 150

#line 150

#line 150

#line 150
#
#line 150
# Allow the domain to create and use tcp sockets.
#line 150
# Other kinds of sockets must be separately authorized for use.
#line 150
allow hotplug_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 150

#line 150
allow hotplug_t unlabeled_t:association { sendto recvfrom };
#line 150

#line 150
#
#line 150
# Allow the domain to send or receive using any network interface.
#line 150
# netif_type is a type attribute for all network interface types.
#line 150
#
#line 150
allow hotplug_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 150
#
#line 150
# Allow the domain to send to or receive from any node.
#line 150
# node_type is a type attribute for all node types.
#line 150
#
#line 150
allow hotplug_t node_type:node { tcp_send rawip_send };
#line 150
allow hotplug_t node_type:node { tcp_recv rawip_recv };
#line 150

#line 150
#
#line 150
# Allow the domain to send to or receive from any port.
#line 150
# port_type is a type attribute for all port types.
#line 150
#
#line 150

#line 150
allow hotplug_t port_type:tcp_socket { send_msg recv_msg };
#line 150

#line 150

#line 150
# XXX Allow binding to any node type.  Remove once
#line 150
# individual rules have been added to all domains that 
#line 150
# bind sockets. 
#line 150
allow hotplug_t node_type:tcp_socket node_bind;
#line 150
#
#line 150
# Allow access to network files including /etc/resolv.conf
#line 150
#
#line 150
allow hotplug_t net_conf_t:file { read getattr lock ioctl };
#line 150

#line 150
allow hotplug_t self:tcp_socket { listen accept };
#line 150

#line 150

#line 150

#line 150
#
#line 150
# Allow the domain to create and use udp sockets.
#line 150
# Other kinds of sockets must be separately authorized for use.
#line 150
allow hotplug_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 150

#line 150
allow hotplug_t unlabeled_t:association { sendto recvfrom };
#line 150

#line 150
#
#line 150
# Allow the domain to send or receive using any network interface.
#line 150
# netif_type is a type attribute for all network interface types.
#line 150
#
#line 150
allow hotplug_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 150
#
#line 150
# Allow the domain to send to or receive from any node.
#line 150
# node_type is a type attribute for all node types.
#line 150
#
#line 150
allow hotplug_t node_type:node { udp_send rawip_send };
#line 150
allow hotplug_t node_type:node { udp_recv rawip_recv };
#line 150

#line 150
#
#line 150
# Allow the domain to send to or receive from any port.
#line 150
# port_type is a type attribute for all port types.
#line 150
#
#line 150

#line 150
allow hotplug_t port_type:udp_socket { send_msg recv_msg };
#line 150

#line 150

#line 150
# XXX Allow binding to any node type.  Remove once
#line 150
# individual rules have been added to all domains that 
#line 150
# bind sockets. 
#line 150
allow hotplug_t node_type:udp_socket node_bind;
#line 150
#
#line 150
# Allow access to network files including /etc/resolv.conf
#line 150
#
#line 150
allow hotplug_t net_conf_t:file { read getattr lock ioctl };
#line 150

#line 150
allow hotplug_t self:udp_socket { connect };
#line 150

#line 150

#line 150


#line 151

#line 151
if (allow_ypbind) {
#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151
#
#line 151
# Allow the domain to create and use tcp sockets.
#line 151
# Other kinds of sockets must be separately authorized for use.
#line 151
allow hotplug_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 151

#line 151
allow hotplug_t unlabeled_t:association { sendto recvfrom };
#line 151

#line 151
#
#line 151
# Allow the domain to send or receive using any network interface.
#line 151
# netif_type is a type attribute for all network interface types.
#line 151
#
#line 151
allow hotplug_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 151
#
#line 151
# Allow the domain to send to or receive from any node.
#line 151
# node_type is a type attribute for all node types.
#line 151
#
#line 151
allow hotplug_t node_type:node { tcp_send rawip_send };
#line 151
allow hotplug_t node_type:node { tcp_recv rawip_recv };
#line 151

#line 151
#
#line 151
# Allow the domain to send to or receive from any port.
#line 151
# port_type is a type attribute for all port types.
#line 151
#
#line 151

#line 151
allow hotplug_t port_type:tcp_socket { send_msg recv_msg };
#line 151

#line 151

#line 151
# XXX Allow binding to any node type.  Remove once
#line 151
# individual rules have been added to all domains that 
#line 151
# bind sockets. 
#line 151
allow hotplug_t node_type:tcp_socket node_bind;
#line 151
#
#line 151
# Allow access to network files including /etc/resolv.conf
#line 151
#
#line 151
allow hotplug_t net_conf_t:file { read getattr lock ioctl };
#line 151

#line 151
allow hotplug_t self:tcp_socket { listen accept };
#line 151

#line 151

#line 151

#line 151
#
#line 151
# Allow the domain to create and use tcp sockets.
#line 151
# Other kinds of sockets must be separately authorized for use.
#line 151
allow hotplug_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 151

#line 151
allow hotplug_t unlabeled_t:association { sendto recvfrom };
#line 151

#line 151
#
#line 151
# Allow the domain to send or receive using any network interface.
#line 151
# netif_type is a type attribute for all network interface types.
#line 151
#
#line 151
allow hotplug_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 151
#
#line 151
# Allow the domain to send to or receive from any node.
#line 151
# node_type is a type attribute for all node types.
#line 151
#
#line 151
allow hotplug_t node_type:node { tcp_send rawip_send };
#line 151
allow hotplug_t node_type:node { tcp_recv rawip_recv };
#line 151

#line 151
#
#line 151
# Allow the domain to send to or receive from any port.
#line 151
# port_type is a type attribute for all port types.
#line 151
#
#line 151

#line 151
allow hotplug_t port_type:tcp_socket { send_msg recv_msg };
#line 151

#line 151

#line 151
# XXX Allow binding to any node type.  Remove once
#line 151
# individual rules have been added to all domains that 
#line 151
# bind sockets. 
#line 151
allow hotplug_t node_type:tcp_socket node_bind;
#line 151
#
#line 151
# Allow access to network files including /etc/resolv.conf
#line 151
#
#line 151
allow hotplug_t net_conf_t:file { read getattr lock ioctl };
#line 151

#line 151
allow hotplug_t self:tcp_socket { connect };
#line 151

#line 151

#line 151

#line 151

#line 151

#line 151
#
#line 151
# Allow the domain to create and use udp sockets.
#line 151
# Other kinds of sockets must be separately authorized for use.
#line 151
allow hotplug_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 151

#line 151
allow hotplug_t unlabeled_t:association { sendto recvfrom };
#line 151

#line 151
#
#line 151
# Allow the domain to send or receive using any network interface.
#line 151
# netif_type is a type attribute for all network interface types.
#line 151
#
#line 151
allow hotplug_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 151
#
#line 151
# Allow the domain to send to or receive from any node.
#line 151
# node_type is a type attribute for all node types.
#line 151
#
#line 151
allow hotplug_t node_type:node { udp_send rawip_send };
#line 151
allow hotplug_t node_type:node { udp_recv rawip_recv };
#line 151

#line 151
#
#line 151
# Allow the domain to send to or receive from any port.
#line 151
# port_type is a type attribute for all port types.
#line 151
#
#line 151

#line 151
allow hotplug_t port_type:udp_socket { send_msg recv_msg };
#line 151

#line 151

#line 151
# XXX Allow binding to any node type.  Remove once
#line 151
# individual rules have been added to all domains that 
#line 151
# bind sockets. 
#line 151
allow hotplug_t node_type:udp_socket node_bind;
#line 151
#
#line 151
# Allow access to network files including /etc/resolv.conf
#line 151
#
#line 151
allow hotplug_t net_conf_t:file { read getattr lock ioctl };
#line 151

#line 151
allow hotplug_t self:udp_socket { connect };
#line 151

#line 151

#line 151

#line 151

#line 151

#line 151

#line 151
allow hotplug_t var_yp_t:dir { read getattr lock search ioctl };
#line 151
allow hotplug_t var_yp_t:file { read getattr lock ioctl };
#line 151
allow hotplug_t var_yp_t:lnk_file { getattr read };
#line 151

#line 151
allow hotplug_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 151
allow hotplug_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 151
dontaudit hotplug_t self:capability net_bind_service;
#line 151
dontaudit hotplug_t reserved_port_type:tcp_socket name_connect;
#line 151
dontaudit hotplug_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 151

#line 151
} else {
#line 151
dontaudit hotplug_t var_yp_t:dir search;
#line 151
}
#line 151
 

#line 152

#line 152

#line 152
# Derived type used for connection
#line 152
type hotplug_dbusd_system_t;
#line 152
type_change hotplug_t system_dbusd_t:dbus hotplug_dbusd_system_t;
#line 152

#line 152
# SE-DBus specific permissions
#line 152
allow hotplug_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 152

#line 152
# For connecting to the bus
#line 152
allow hotplug_t system_dbusd_t:unix_stream_socket connectto;
#line 152

#line 152

#line 152
allow { hotplug_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 152
allow { hotplug_t } system_dbusd_var_run_t:sock_file write;
#line 152
  

# Allow hotplug (including /sbin/ifup-local) to start/stop services

#line 155

#line 155

#line 155
#
#line 155
# Allow the process to transition to the new domain.
#line 155
#
#line 155
allow hotplug_t initrc_t:process transition;
#line 155

#line 155
#
#line 155
# Do not audit when glibc secure mode is enabled upon the transition.
#line 155
#
#line 155
dontaudit hotplug_t initrc_t:process noatsecure;
#line 155

#line 155
#
#line 155
# Do not audit when signal-related state is cleared upon the transition.
#line 155
#
#line 155
dontaudit hotplug_t initrc_t:process siginh;
#line 155

#line 155
#
#line 155
# Do not audit when resource limits are reset upon the transition.
#line 155
#
#line 155
dontaudit hotplug_t initrc_t:process rlimitinh;
#line 155

#line 155
#
#line 155
# Allow the process to execute the program.
#line 155
# 
#line 155
allow hotplug_t initrc_exec_t:file { read { getattr execute } };
#line 155

#line 155
#
#line 155
# Allow the process to reap the new domain.
#line 155
#
#line 155
allow initrc_t hotplug_t:process sigchld;
#line 155

#line 155
#
#line 155
# Allow the new domain to inherit and use file 
#line 155
# descriptions from the creating process and vice versa.
#line 155
#
#line 155
allow initrc_t hotplug_t:fd use;
#line 155
allow hotplug_t initrc_t:fd use;
#line 155

#line 155
#
#line 155
# Allow the new domain to write back to the old domain via a pipe.
#line 155
#
#line 155
allow initrc_t hotplug_t:fifo_file { ioctl read getattr lock write append };
#line 155

#line 155
#
#line 155
# Allow the new domain to read and execute the program.
#line 155
#
#line 155
allow initrc_t initrc_exec_t:file { read getattr lock execute ioctl };
#line 155

#line 155
#
#line 155
# Allow the new domain to be entered via the program.
#line 155
#
#line 155
allow initrc_t initrc_exec_t:file entrypoint;
#line 155

#line 155
type_transition hotplug_t initrc_exec_t:process initrc_t;
#line 155


allow { insmod_t kernel_t } hotplug_etc_t:dir { search getattr };
allow hotplug_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };

dontaudit hotplug_t selinux_config_t:dir search;
#line 1 "domains/program/howl.te"
#DESC howl - port of Apple Rendezvous multicast DNS
#
# Author:  Russell Coker <rcoker@redhat.com>
#


#line 6

#line 6

#line 6

#line 6
type howl_t, domain, privlog, daemon , privsysmod, transitionbool;
#line 6
type howl_exec_t, file_type, sysadmfile, exec_type;
#line 6
dontaudit howl_t self:capability sys_tty_config;
#line 6

#line 6
role system_r types howl_t;
#line 6

#line 6
# Inherit and use descriptors from init.
#line 6
allow howl_t init_t:fd use;
#line 6
allow howl_t init_t:process sigchld;
#line 6
allow howl_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 6

#line 6

#line 6
allow howl_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 6
allow howl_t lib_t:lnk_file { read getattr lock ioctl };
#line 6
allow howl_t ld_so_t:file { read getattr lock execute ioctl };
#line 6
#allow howl_t ld_so_t:file execute_no_trans;
#line 6
allow howl_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 6
allow howl_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 6
allow howl_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 6
allow howl_t texrel_shlib_t:file execmod;
#line 6
allow howl_t ld_so_cache_t:file { read getattr lock ioctl };
#line 6
allow howl_t device_t:dir search;
#line 6
allow howl_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 6

#line 6

#line 6
allow howl_t { self proc_t }:dir { read getattr lock search ioctl };
#line 6
allow howl_t { self proc_t }:lnk_file { getattr read };
#line 6

#line 6
allow howl_t device_t:dir { read getattr lock search ioctl };
#line 6

#line 6
allow howl_t udev_tdb_t:file { read getattr lock ioctl };
#line 6
allow howl_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 6
dontaudit howl_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 6
dontaudit howl_t unpriv_userdomain:fd use;
#line 6

#line 6

#line 6
allow howl_t sysfs_t:dir { read getattr lock search ioctl };
#line 6
allow howl_t sysfs_t:file { read getattr lock ioctl };
#line 6
allow howl_t sysfs_t:lnk_file { getattr read };
#line 6
 
#line 6

#line 6
allow howl_t autofs_t:dir { search getattr };
#line 6

#line 6
dontaudit howl_t { tty_device_t devpts_t }:chr_file { read write };
#line 6
dontaudit howl_t root_t:file { getattr read };
#line 6
 
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
# Read system variables in /sys.
#line 6

#line 6
allow howl_t sysctl_t:dir search;
#line 6
allow howl_t sysctl_kernel_t:dir search;
#line 6
allow howl_t sysctl_kernel_t:file { getattr read };
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
#
#line 6
# Allows user to define a tunable to disable domain transition
#line 6
#
#line 6

#line 6
bool howl_disable_trans false;
#line 6
if (howl_disable_trans) {
#line 6

#line 6
allow initrc_t howl_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 6

#line 6

#line 6
allow sysadm_t howl_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 6

#line 6
} else {
#line 6
 
#line 6

#line 6

#line 6
#
#line 6
# Allow the process to transition to the new domain.
#line 6
#
#line 6
allow initrc_t howl_t:process transition;
#line 6

#line 6
#
#line 6
# Do not audit when glibc secure mode is enabled upon the transition.
#line 6
#
#line 6
dontaudit initrc_t howl_t:process noatsecure;
#line 6

#line 6
#
#line 6
# Do not audit when signal-related state is cleared upon the transition.
#line 6
#
#line 6
dontaudit initrc_t howl_t:process siginh;
#line 6

#line 6
#
#line 6
# Do not audit when resource limits are reset upon the transition.
#line 6
#
#line 6
dontaudit initrc_t howl_t:process rlimitinh;
#line 6

#line 6
#
#line 6
# Allow the process to execute the program.
#line 6
# 
#line 6
allow initrc_t howl_exec_t:file { read { getattr execute } };
#line 6

#line 6
#
#line 6
# Allow the process to reap the new domain.
#line 6
#
#line 6
allow howl_t initrc_t:process sigchld;
#line 6

#line 6
#
#line 6
# Allow the new domain to inherit and use file 
#line 6
# descriptions from the creating process and vice versa.
#line 6
#
#line 6
allow howl_t initrc_t:fd use;
#line 6
allow initrc_t howl_t:fd use;
#line 6

#line 6
#
#line 6
# Allow the new domain to write back to the old domain via a pipe.
#line 6
#
#line 6
allow howl_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 6

#line 6
#
#line 6
# Allow the new domain to read and execute the program.
#line 6
#
#line 6
allow howl_t howl_exec_t:file { read getattr lock execute ioctl };
#line 6

#line 6
#
#line 6
# Allow the new domain to be entered via the program.
#line 6
#
#line 6
allow howl_t howl_exec_t:file entrypoint;
#line 6

#line 6
type_transition initrc_t howl_exec_t:process howl_t;
#line 6

#line 6

#line 6
allow initrc_t howl_t:process { noatsecure siginh rlimitinh };
#line 6

#line 6
}
#line 6
 
#line 6
allow howl_t privfd:fd use;
#line 6

#line 6
allow howl_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 6

#line 6

#line 6
# Create pid file.
#line 6
allow howl_t var_t:dir { getattr search };
#line 6

#line 6
type howl_var_run_t, file_type, sysadmfile, pidfile;
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
#
#line 6
# Allow the process to modify the directory.
#line 6
#
#line 6
allow howl_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 6

#line 6
#
#line 6
# Allow the process to create the file.
#line 6
#
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
allow howl_t howl_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
type_transition howl_t var_run_t:file howl_var_run_t;
#line 6

#line 6

#line 6

#line 6
allow howl_t var_t:dir search;
#line 6
allow howl_t howl_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 6

#line 6

#line 6
allow howl_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 6

#line 6
# for daemons that look at /root on startup
#line 6
dontaudit howl_t sysadm_home_dir_t:dir search;
#line 6

#line 6
# for df
#line 6
allow howl_t fs_type:filesystem getattr;
#line 6
allow howl_t removable_t:filesystem getattr;
#line 6

#line 6

#line 6
allow howl_t etc_t:lnk_file read;
#line 6
allow howl_t lib_t:file { read getattr lock ioctl };
#line 6

#line 6
allow howl_t locale_t:dir { read getattr lock search ioctl };
#line 6
allow howl_t locale_t:file { read getattr lock ioctl };
#line 6
allow howl_t locale_t:lnk_file { getattr read };
#line 6

#line 6

#line 6

#line 6
# for localization
#line 6
allow howl_t lib_t:file { getattr read };
#line 6


#line 7
allow howl_t proc_net_t:dir { read getattr lock search ioctl };
#line 7
allow howl_t proc_net_t:file { read getattr lock ioctl };
#line 7
allow howl_t proc_net_t:lnk_file { getattr read };
#line 7


#line 8

#line 8

#line 8

#line 8
#
#line 8
# Allow the domain to create and use tcp sockets.
#line 8
# Other kinds of sockets must be separately authorized for use.
#line 8
allow howl_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 8

#line 8
allow howl_t unlabeled_t:association { sendto recvfrom };
#line 8

#line 8
#
#line 8
# Allow the domain to send or receive using any network interface.
#line 8
# netif_type is a type attribute for all network interface types.
#line 8
#
#line 8
allow howl_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 8
#
#line 8
# Allow the domain to send to or receive from any node.
#line 8
# node_type is a type attribute for all node types.
#line 8
#
#line 8
allow howl_t node_type:node { tcp_send rawip_send };
#line 8
allow howl_t node_type:node { tcp_recv rawip_recv };
#line 8

#line 8
#
#line 8
# Allow the domain to send to or receive from any port.
#line 8
# port_type is a type attribute for all port types.
#line 8
#
#line 8

#line 8
allow howl_t port_type:tcp_socket { send_msg recv_msg };
#line 8

#line 8

#line 8
# XXX Allow binding to any node type.  Remove once
#line 8
# individual rules have been added to all domains that 
#line 8
# bind sockets. 
#line 8
allow howl_t node_type:tcp_socket node_bind;
#line 8
#
#line 8
# Allow access to network files including /etc/resolv.conf
#line 8
#
#line 8
allow howl_t net_conf_t:file { read getattr lock ioctl };
#line 8

#line 8
allow howl_t self:tcp_socket { listen accept };
#line 8

#line 8

#line 8

#line 8
#
#line 8
# Allow the domain to create and use udp sockets.
#line 8
# Other kinds of sockets must be separately authorized for use.
#line 8
allow howl_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 8

#line 8
allow howl_t unlabeled_t:association { sendto recvfrom };
#line 8

#line 8
#
#line 8
# Allow the domain to send or receive using any network interface.
#line 8
# netif_type is a type attribute for all network interface types.
#line 8
#
#line 8
allow howl_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 8
#
#line 8
# Allow the domain to send to or receive from any node.
#line 8
# node_type is a type attribute for all node types.
#line 8
#
#line 8
allow howl_t node_type:node { udp_send rawip_send };
#line 8
allow howl_t node_type:node { udp_recv rawip_recv };
#line 8

#line 8
#
#line 8
# Allow the domain to send to or receive from any port.
#line 8
# port_type is a type attribute for all port types.
#line 8
#
#line 8

#line 8
allow howl_t port_type:udp_socket { send_msg recv_msg };
#line 8

#line 8

#line 8
# XXX Allow binding to any node type.  Remove once
#line 8
# individual rules have been added to all domains that 
#line 8
# bind sockets. 
#line 8
allow howl_t node_type:udp_socket node_bind;
#line 8
#
#line 8
# Allow access to network files including /etc/resolv.conf
#line 8
#
#line 8
allow howl_t net_conf_t:file { read getattr lock ioctl };
#line 8

#line 8
allow howl_t self:udp_socket { connect };
#line 8

#line 8

#line 8


#line 9

#line 9
if (allow_ypbind) {
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use tcp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow howl_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow howl_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow howl_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow howl_t node_type:node { tcp_send rawip_send };
#line 9
allow howl_t node_type:node { tcp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow howl_t port_type:tcp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow howl_t node_type:tcp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow howl_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow howl_t self:tcp_socket { listen accept };
#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use tcp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow howl_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow howl_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow howl_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow howl_t node_type:node { tcp_send rawip_send };
#line 9
allow howl_t node_type:node { tcp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow howl_t port_type:tcp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow howl_t node_type:tcp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow howl_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow howl_t self:tcp_socket { connect };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use udp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow howl_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow howl_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow howl_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow howl_t node_type:node { udp_send rawip_send };
#line 9
allow howl_t node_type:node { udp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow howl_t port_type:udp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow howl_t node_type:udp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow howl_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow howl_t self:udp_socket { connect };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
allow howl_t var_yp_t:dir { read getattr lock search ioctl };
#line 9
allow howl_t var_yp_t:file { read getattr lock ioctl };
#line 9
allow howl_t var_yp_t:lnk_file { getattr read };
#line 9

#line 9
allow howl_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 9
allow howl_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 9
dontaudit howl_t self:capability net_bind_service;
#line 9
dontaudit howl_t reserved_port_type:tcp_socket name_connect;
#line 9
dontaudit howl_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 9

#line 9
} else {
#line 9
dontaudit howl_t var_yp_t:dir search;
#line 9
}
#line 9
 
allow howl_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow howl_t self:capability { kill net_admin sys_module };

allow howl_t self:fifo_file { ioctl read getattr lock write append };

allow howl_t howl_port_t:{ udp_socket tcp_socket } name_bind;

allow howl_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

allow howl_t etc_t:file { getattr read };
allow howl_t initrc_var_run_t:file { ioctl read getattr lock write append };

#line 1 "domains/program/hwclock.te"
#DESC Hwclock - Hardware clock manager
#
# Author:  David A. Wheeler <dwheeler@ida.org>
#          Russell Coker <russell@coker.com.au>
# X-Debian-Packages: util-linux
#

#################################
#
# Rules for the hwclock_t domain.
# This domain moves time information between the "hardware clock"
# (which runs when the system is off) and the "system clock",
# and it stores adjustment values in /etc/adjtime so that errors in the
# hardware clock are corrected.
# Note that any errors from this domain are NOT recorded by the system logger,
# because the system logger isnt running when this domain is active.
#

#line 18

#line 18
type hwclock_t, domain, privlog, daemon ;
#line 18
type hwclock_exec_t, file_type, sysadmfile, exec_type;
#line 18
dontaudit hwclock_t self:capability sys_tty_config;
#line 18

#line 18
role system_r types hwclock_t;
#line 18

#line 18
# Inherit and use descriptors from init.
#line 18
allow hwclock_t init_t:fd use;
#line 18
allow hwclock_t init_t:process sigchld;
#line 18
allow hwclock_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 18

#line 18

#line 18
allow hwclock_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 18
allow hwclock_t lib_t:lnk_file { read getattr lock ioctl };
#line 18
allow hwclock_t ld_so_t:file { read getattr lock execute ioctl };
#line 18
#allow hwclock_t ld_so_t:file execute_no_trans;
#line 18
allow hwclock_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 18
allow hwclock_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 18
allow hwclock_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 18
allow hwclock_t texrel_shlib_t:file execmod;
#line 18
allow hwclock_t ld_so_cache_t:file { read getattr lock ioctl };
#line 18
allow hwclock_t device_t:dir search;
#line 18
allow hwclock_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18

#line 18
allow hwclock_t { self proc_t }:dir { read getattr lock search ioctl };
#line 18
allow hwclock_t { self proc_t }:lnk_file { getattr read };
#line 18

#line 18
allow hwclock_t device_t:dir { read getattr lock search ioctl };
#line 18

#line 18
allow hwclock_t udev_tdb_t:file { read getattr lock ioctl };
#line 18
allow hwclock_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 18
dontaudit hwclock_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 18
dontaudit hwclock_t unpriv_userdomain:fd use;
#line 18

#line 18

#line 18
allow hwclock_t sysfs_t:dir { read getattr lock search ioctl };
#line 18
allow hwclock_t sysfs_t:file { read getattr lock ioctl };
#line 18
allow hwclock_t sysfs_t:lnk_file { getattr read };
#line 18
 
#line 18

#line 18
allow hwclock_t autofs_t:dir { search getattr };
#line 18

#line 18
dontaudit hwclock_t { tty_device_t devpts_t }:chr_file { read write };
#line 18
dontaudit hwclock_t root_t:file { getattr read };
#line 18
 
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
# Read system variables in /sys.
#line 18

#line 18
allow hwclock_t sysctl_t:dir search;
#line 18
allow hwclock_t sysctl_kernel_t:dir search;
#line 18
allow hwclock_t sysctl_kernel_t:file { getattr read };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allows user to define a tunable to disable domain transition
#line 18
#
#line 18
 
#line 18

#line 18

#line 18
#
#line 18
# Allow the process to transition to the new domain.
#line 18
#
#line 18
allow initrc_t hwclock_t:process transition;
#line 18

#line 18
#
#line 18
# Do not audit when glibc secure mode is enabled upon the transition.
#line 18
#
#line 18
dontaudit initrc_t hwclock_t:process noatsecure;
#line 18

#line 18
#
#line 18
# Do not audit when signal-related state is cleared upon the transition.
#line 18
#
#line 18
dontaudit initrc_t hwclock_t:process siginh;
#line 18

#line 18
#
#line 18
# Do not audit when resource limits are reset upon the transition.
#line 18
#
#line 18
dontaudit initrc_t hwclock_t:process rlimitinh;
#line 18

#line 18
#
#line 18
# Allow the process to execute the program.
#line 18
# 
#line 18
allow initrc_t hwclock_exec_t:file { read { getattr execute } };
#line 18

#line 18
#
#line 18
# Allow the process to reap the new domain.
#line 18
#
#line 18
allow hwclock_t initrc_t:process sigchld;
#line 18

#line 18
#
#line 18
# Allow the new domain to inherit and use file 
#line 18
# descriptions from the creating process and vice versa.
#line 18
#
#line 18
allow hwclock_t initrc_t:fd use;
#line 18
allow initrc_t hwclock_t:fd use;
#line 18

#line 18
#
#line 18
# Allow the new domain to write back to the old domain via a pipe.
#line 18
#
#line 18
allow hwclock_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 18

#line 18
#
#line 18
# Allow the new domain to read and execute the program.
#line 18
#
#line 18
allow hwclock_t hwclock_exec_t:file { read getattr lock execute ioctl };
#line 18

#line 18
#
#line 18
# Allow the new domain to be entered via the program.
#line 18
#
#line 18
allow hwclock_t hwclock_exec_t:file entrypoint;
#line 18

#line 18
type_transition initrc_t hwclock_exec_t:process hwclock_t;
#line 18

#line 18

#line 18
allow initrc_t hwclock_t:process { noatsecure siginh rlimitinh };
#line 18
 
#line 18
allow hwclock_t privfd:fd use;
#line 18

#line 18
allow hwclock_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 18

role sysadm_r types hwclock_t;
#line 22

type adjtime_t, file_type, sysadmfile;

allow hwclock_t fs_t:filesystem getattr;


#line 27
allow hwclock_t etc_t:lnk_file read;
#line 27
allow hwclock_t lib_t:file { read getattr lock ioctl };
#line 27

#line 27
allow hwclock_t locale_t:dir { read getattr lock search ioctl };
#line 27
allow hwclock_t locale_t:file { read getattr lock ioctl };
#line 27
allow hwclock_t locale_t:lnk_file { getattr read };
#line 27

#line 27


# Give hwclock the capabilities it requires.  dac_override is a surprise,
# but hwclock does require it.
allow hwclock_t self:capability { dac_override sys_rawio sys_time sys_tty_config };

# Allow hwclock to set the hardware clock.
allow hwclock_t clock_device_t:{ chr_file blk_file } { setattr { ioctl read getattr lock write append } };

# Allow hwclock to store & retrieve correction factors.
allow hwclock_t adjtime_t:file { setattr { ioctl read getattr lock write append } };

# Read and write console and ttys.
allow hwclock_t tty_device_t:chr_file { ioctl read getattr lock write append };
allow hwclock_t ttyfile:chr_file { ioctl read getattr lock write append };
allow hwclock_t ptyfile:chr_file { ioctl read getattr lock write append };



#line 45
allow hwclock_t etc_t:lnk_file read;
#line 45
allow hwclock_t lib_t:file { read getattr lock ioctl };
#line 45

#line 45
allow hwclock_t locale_t:dir { read getattr lock search ioctl };
#line 45
allow hwclock_t locale_t:file { read getattr lock ioctl };
#line 45
allow hwclock_t locale_t:lnk_file { getattr read };
#line 45

#line 45


# for when /usr is not mounted
dontaudit hwclock_t file_t:dir search;
allow hwclock_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };

#line 50
allow hwclock_t etc_t:dir { read getattr lock search ioctl };
#line 50
allow hwclock_t etc_t:file { read getattr lock ioctl };
#line 50
allow hwclock_t etc_t:lnk_file { getattr read };
#line 50

#line 1 "domains/program/ifconfig.te"
#DESC Ifconfig - Configure network interfaces
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: net-tools
#

#################################
#
# Rules for the ifconfig_t domain.
#
# ifconfig_t is the domain for the ifconfig program.
# ifconfig_exec_t is the type of the corresponding program.
#
type ifconfig_t, domain, privlog, privmodule;
type ifconfig_exec_t, file_type, sysadmfile, exec_type;

role system_r types ifconfig_t;
role sysadm_r types ifconfig_t;


#line 20
allow ifconfig_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 20
allow ifconfig_t lib_t:lnk_file { read getattr lock ioctl };
#line 20
allow ifconfig_t ld_so_t:file { read getattr lock execute ioctl };
#line 20
#allow ifconfig_t ld_so_t:file execute_no_trans;
#line 20
allow ifconfig_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 20
allow ifconfig_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 20
allow ifconfig_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 20
allow ifconfig_t texrel_shlib_t:file execmod;
#line 20
allow ifconfig_t ld_so_cache_t:file { read getattr lock ioctl };
#line 20
allow ifconfig_t device_t:dir search;
#line 20
allow ifconfig_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 20


#line 21
# Access other processes in the same domain.
#line 21
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 21
# These must be granted separately if desired.
#line 21
allow ifconfig_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 21

#line 21
# Access /proc/PID files for processes in the same domain.
#line 21
allow ifconfig_t self:dir { read getattr lock search ioctl };
#line 21
allow ifconfig_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 21

#line 21
# Access file descriptions, pipes, and sockets
#line 21
# created by processes in the same domain.
#line 21
allow ifconfig_t self:fd *;
#line 21
allow ifconfig_t self:fifo_file { ioctl read getattr lock write append };
#line 21
allow ifconfig_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 21
allow ifconfig_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 21

#line 21
# Allow the domain to communicate with other processes in the same domain.
#line 21
allow ifconfig_t self:unix_dgram_socket sendto;
#line 21
allow ifconfig_t self:unix_stream_socket connectto;
#line 21

#line 21
# Access System V IPC objects created by processes in the same domain.
#line 21
allow ifconfig_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 21
allow ifconfig_t self:msg  { send receive };
#line 21
allow ifconfig_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 21
allow ifconfig_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 21
allow ifconfig_t unpriv_userdomain:fd use;
#line 21
#
#line 21
# Every app is asking for ypbind so I am adding this here, 
#line 21
# eventually this should become can_nsswitch
#line 21
#
#line 21

#line 21

#line 21
if (allow_ypbind) {
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use tcp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow ifconfig_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow ifconfig_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow ifconfig_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow ifconfig_t node_type:node { tcp_send rawip_send };
#line 21
allow ifconfig_t node_type:node { tcp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow ifconfig_t port_type:tcp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow ifconfig_t node_type:tcp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow ifconfig_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow ifconfig_t self:tcp_socket { listen accept };
#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use tcp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow ifconfig_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow ifconfig_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow ifconfig_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow ifconfig_t node_type:node { tcp_send rawip_send };
#line 21
allow ifconfig_t node_type:node { tcp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow ifconfig_t port_type:tcp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow ifconfig_t node_type:tcp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow ifconfig_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow ifconfig_t self:tcp_socket { connect };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use udp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow ifconfig_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow ifconfig_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow ifconfig_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow ifconfig_t node_type:node { udp_send rawip_send };
#line 21
allow ifconfig_t node_type:node { udp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow ifconfig_t port_type:udp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow ifconfig_t node_type:udp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow ifconfig_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow ifconfig_t self:udp_socket { connect };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
allow ifconfig_t var_yp_t:dir { read getattr lock search ioctl };
#line 21
allow ifconfig_t var_yp_t:file { read getattr lock ioctl };
#line 21
allow ifconfig_t var_yp_t:lnk_file { getattr read };
#line 21

#line 21
allow ifconfig_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 21
allow ifconfig_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 21
dontaudit ifconfig_t self:capability net_bind_service;
#line 21
dontaudit ifconfig_t reserved_port_type:tcp_socket name_connect;
#line 21
dontaudit ifconfig_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 21

#line 21
} else {
#line 21
dontaudit ifconfig_t var_yp_t:dir search;
#line 21
}
#line 21
 
#line 21
allow ifconfig_t autofs_t:dir { search getattr };
#line 21



#line 23

#line 23

#line 23
#
#line 23
# Allow the process to transition to the new domain.
#line 23
#
#line 23
allow initrc_t ifconfig_t:process transition;
#line 23

#line 23
#
#line 23
# Do not audit when glibc secure mode is enabled upon the transition.
#line 23
#
#line 23
dontaudit initrc_t ifconfig_t:process noatsecure;
#line 23

#line 23
#
#line 23
# Do not audit when signal-related state is cleared upon the transition.
#line 23
#
#line 23
dontaudit initrc_t ifconfig_t:process siginh;
#line 23

#line 23
#
#line 23
# Do not audit when resource limits are reset upon the transition.
#line 23
#
#line 23
dontaudit initrc_t ifconfig_t:process rlimitinh;
#line 23

#line 23
#
#line 23
# Allow the process to execute the program.
#line 23
# 
#line 23
allow initrc_t ifconfig_exec_t:file { read { getattr execute } };
#line 23

#line 23
#
#line 23
# Allow the process to reap the new domain.
#line 23
#
#line 23
allow ifconfig_t initrc_t:process sigchld;
#line 23

#line 23
#
#line 23
# Allow the new domain to inherit and use file 
#line 23
# descriptions from the creating process and vice versa.
#line 23
#
#line 23
allow ifconfig_t initrc_t:fd use;
#line 23
allow initrc_t ifconfig_t:fd use;
#line 23

#line 23
#
#line 23
# Allow the new domain to write back to the old domain via a pipe.
#line 23
#
#line 23
allow ifconfig_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 23

#line 23
#
#line 23
# Allow the new domain to read and execute the program.
#line 23
#
#line 23
allow ifconfig_t ifconfig_exec_t:file { read getattr lock execute ioctl };
#line 23

#line 23
#
#line 23
# Allow the new domain to be entered via the program.
#line 23
#
#line 23
allow ifconfig_t ifconfig_exec_t:file entrypoint;
#line 23

#line 23
type_transition initrc_t ifconfig_exec_t:process ifconfig_t;
#line 23

#line 26


# for /sbin/ip
allow ifconfig_t self:packet_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow ifconfig_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write };
allow ifconfig_t self:tcp_socket { create ioctl };
allow ifconfig_t etc_t:file { getattr read };

allow ifconfig_t self:socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# Use capabilities.
allow ifconfig_t self:capability { net_raw net_admin };
bool allow_ifconfig_sys_module false;
if (allow_ifconfig_sys_module) {
allow ifconfig_t self:capability sys_module;
} else {
dontaudit ifconfig_t self:capability sys_module;
}
allow ifconfig_t self:capability sys_tty_config;

# Inherit and use descriptors from init.
allow ifconfig_t { kernel_t init_t }:fd use;

# Access /proc

#line 50
allow ifconfig_t proc_t:dir { read getattr lock search ioctl };
#line 50
allow ifconfig_t proc_t:file { read getattr lock ioctl };
#line 50
allow ifconfig_t proc_t:lnk_file { getattr read };
#line 50


#line 51
allow ifconfig_t proc_net_t:dir { read getattr lock search ioctl };
#line 51
allow ifconfig_t proc_net_t:file { read getattr lock ioctl };
#line 51
allow ifconfig_t proc_net_t:lnk_file { getattr read };
#line 51


allow ifconfig_t privfd:fd use;
allow ifconfig_t run_init_t:fd use;

# Create UDP sockets, necessary when called from dhcpc
allow ifconfig_t self:udp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# Access terminals.

#line 60
allow ifconfig_t devpts_t:dir { read getattr lock search ioctl };
#line 60
allow ifconfig_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 60

allow ifconfig_t { user_tty_type admin_tty_type }:chr_file { ioctl read getattr lock write append };


allow ifconfig_t tun_tap_device_t:chr_file { read write };

# ifconfig attempts to search some sysctl entries.
# Do not audit those attempts; comment out these rules if it is desired to
# see the denials.
allow ifconfig_t { sysctl_t sysctl_net_t }:dir search;

allow ifconfig_t fs_t:filesystem getattr;


#line 73
allow ifconfig_t etc_t:lnk_file read;
#line 73
allow ifconfig_t lib_t:file { read getattr lock ioctl };
#line 73

#line 73
allow ifconfig_t locale_t:dir { read getattr lock search ioctl };
#line 73
allow ifconfig_t locale_t:file { read getattr lock ioctl };
#line 73
allow ifconfig_t locale_t:lnk_file { getattr read };
#line 73

#line 73

allow ifconfig_t lib_t:file { getattr read };


#line 76

allow ifconfig_t userdomain:fd use;
dontaudit ifconfig_t root_t:file read;

#line 79
allow ifconfig_t sysfs_t:dir { read getattr lock search ioctl };
#line 79
allow ifconfig_t sysfs_t:file { read getattr lock ioctl };
#line 79
allow ifconfig_t sysfs_t:lnk_file { getattr read };
#line 79

#line 1 "domains/program/inetd.te"
#DESC Inetd - Internet services daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# re-written with daemon_domain by Russell Coker <russell@coker.com.au>
# X-Debian-Packages: netkit-inetd openbsd-inetd xinetd
#

#################################
#
# Rules for the inetd_t domain and
# the inetd_child_t domain.
#


#line 14

#line 14

#line 14

#line 14
type inetd_t, domain, privlog, daemon ,admin, etc_writer, fs_domain, auth_write, privmem , transitionbool;
#line 14
type inetd_exec_t, file_type, sysadmfile, exec_type;
#line 14
dontaudit inetd_t self:capability sys_tty_config;
#line 14

#line 14
role system_r types inetd_t;
#line 14

#line 14
# Inherit and use descriptors from init.
#line 14
allow inetd_t init_t:fd use;
#line 14
allow inetd_t init_t:process sigchld;
#line 14
allow inetd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 14

#line 14

#line 14
allow inetd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow inetd_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow inetd_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow inetd_t ld_so_t:file execute_no_trans;
#line 14
allow inetd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow inetd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow inetd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow inetd_t texrel_shlib_t:file execmod;
#line 14
allow inetd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow inetd_t device_t:dir search;
#line 14
allow inetd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
allow inetd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 14
allow inetd_t { self proc_t }:lnk_file { getattr read };
#line 14

#line 14
allow inetd_t device_t:dir { read getattr lock search ioctl };
#line 14

#line 14
allow inetd_t udev_tdb_t:file { read getattr lock ioctl };
#line 14
allow inetd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit inetd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit inetd_t unpriv_userdomain:fd use;
#line 14

#line 14

#line 14
allow inetd_t sysfs_t:dir { read getattr lock search ioctl };
#line 14
allow inetd_t sysfs_t:file { read getattr lock ioctl };
#line 14
allow inetd_t sysfs_t:lnk_file { getattr read };
#line 14
 
#line 14

#line 14
allow inetd_t autofs_t:dir { search getattr };
#line 14

#line 14
dontaudit inetd_t { tty_device_t devpts_t }:chr_file { read write };
#line 14
dontaudit inetd_t root_t:file { getattr read };
#line 14
 
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow inetd_t sysctl_t:dir search;
#line 14
allow inetd_t sysctl_kernel_t:dir search;
#line 14
allow inetd_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14

#line 14
bool inetd_disable_trans false;
#line 14
if (inetd_disable_trans) {
#line 14

#line 14
allow initrc_t inetd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t inetd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14
 
#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow initrc_t inetd_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit initrc_t inetd_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit initrc_t inetd_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit initrc_t inetd_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow initrc_t inetd_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow inetd_t initrc_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow inetd_t initrc_t:fd use;
#line 14
allow initrc_t inetd_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow inetd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow inetd_t inetd_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow inetd_t inetd_exec_t:file entrypoint;
#line 14

#line 14
type_transition initrc_t inetd_exec_t:process inetd_t;
#line 14

#line 14

#line 14
allow initrc_t inetd_t:process { noatsecure siginh rlimitinh };
#line 14

#line 14
}
#line 14
 
#line 14
allow inetd_t privfd:fd use;
#line 14

#line 14
allow inetd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
# Create pid file.
#line 14
allow inetd_t var_t:dir { getattr search };
#line 14

#line 14
type inetd_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow inetd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow inetd_t inetd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition inetd_t var_run_t:file inetd_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow inetd_t var_t:dir search;
#line 14
allow inetd_t inetd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
allow inetd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
# for daemons that look at /root on startup
#line 14
dontaudit inetd_t sysadm_home_dir_t:dir search;
#line 14

#line 14
# for df
#line 14
allow inetd_t fs_type:filesystem getattr;
#line 14
allow inetd_t removable_t:filesystem getattr;
#line 14

#line 14

#line 14
allow inetd_t etc_t:lnk_file read;
#line 14
allow inetd_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow inetd_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow inetd_t locale_t:file { read getattr lock ioctl };
#line 14
allow inetd_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14

#line 14
# for localization
#line 14
allow inetd_t lib_t:file { getattr read };
#line 14



#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow inetd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow inetd_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow inetd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow inetd_t node_type:node { tcp_send rawip_send };
#line 16
allow inetd_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow inetd_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow inetd_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow inetd_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow inetd_t self:tcp_socket { listen accept };
#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow inetd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow inetd_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow inetd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow inetd_t node_type:node { tcp_send rawip_send };
#line 16
allow inetd_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow inetd_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow inetd_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow inetd_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow inetd_t self:tcp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use udp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow inetd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow inetd_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow inetd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow inetd_t node_type:node { udp_send rawip_send };
#line 16
allow inetd_t node_type:node { udp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow inetd_t port_type:udp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow inetd_t node_type:udp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow inetd_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow inetd_t self:udp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

allow inetd_t port_type:tcp_socket name_connect;
allow inetd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow inetd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow inetd_t self:fifo_file { ioctl read getattr lock write append };
allow inetd_t etc_t:file { getattr read ioctl };
allow inetd_t self:process setsched;


#line 24
type inetd_log_t, file_type, sysadmfile, logfile;
#line 24

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the process to modify the directory.
#line 24
#
#line 24
allow inetd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 24

#line 24
#
#line 24
# Allow the process to create the file.
#line 24
#
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
allow inetd_t inetd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
type_transition inetd_t var_log_t:file inetd_log_t;
#line 24

#line 24

#line 24


#line 25
type inetd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 25

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the process to modify the directory.
#line 25
#
#line 25
allow inetd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 25

#line 25
#
#line 25
# Allow the process to create the file.
#line 25
#
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow inetd_t inetd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow inetd_t inetd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
type_transition inetd_t tmp_t:{ file dir } inetd_tmp_t;
#line 25

#line 25

#line 25


# Use capabilities.
allow inetd_t self:capability { setuid setgid net_bind_service };

# allow any domain to connect to inetd

#line 31
#allow userdomain inetd_t:tcp_socket { connectto recvfrom };
#line 31
#allow inetd_t userdomain:tcp_socket { acceptfrom recvfrom };
#line 31
#allow inetd_t kernel_t:tcp_socket recvfrom;
#line 31
#allow userdomain kernel_t:tcp_socket recvfrom;
#line 31


# Run each daemon with a defined domain in its own domain.
# These rules have been moved to the individual target domain .te files.

# Run other daemons in the inetd_child_t domain.
allow inetd_t { bin_t sbin_t }:dir search;
allow inetd_t sbin_t:lnk_file read;

# Bind to the telnet, ftp, rlogin and rsh ports.
allow inetd_t ftp_port_t:tcp_socket name_bind;
allow inetd_t rsh_port_t:tcp_socket name_bind;
#line 46


allow inetd_t auth_port_t:tcp_socket name_bind;
# Communicate with the portmapper.

#line 50
#allow inetd_t portmap_t:udp_socket sendto;
#line 50
#allow portmap_t inetd_t:udp_socket recvfrom;
#line 50




#line 53
type inetd_child_t, domain, privlog, nscd_client_domain;
#line 53
role system_r types inetd_child_t;
#line 53

#line 53
#
#line 53
# Allows user to define a tunable to disable domain transition
#line 53
#
#line 53
bool inetd_child_disable_trans false;
#line 53
if (inetd_child_disable_trans) {
#line 53

#line 53
allow initrc_t inetd_child_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 53

#line 53

#line 53
allow sysadm_t inetd_child_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 53

#line 53
} else {
#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the process to transition to the new domain.
#line 53
#
#line 53
allow inetd_t inetd_child_t:process transition;
#line 53

#line 53
#
#line 53
# Do not audit when glibc secure mode is enabled upon the transition.
#line 53
#
#line 53
dontaudit inetd_t inetd_child_t:process noatsecure;
#line 53

#line 53
#
#line 53
# Do not audit when signal-related state is cleared upon the transition.
#line 53
#
#line 53
dontaudit inetd_t inetd_child_t:process siginh;
#line 53

#line 53
#
#line 53
# Do not audit when resource limits are reset upon the transition.
#line 53
#
#line 53
dontaudit inetd_t inetd_child_t:process rlimitinh;
#line 53

#line 53
#
#line 53
# Allow the process to execute the program.
#line 53
# 
#line 53
allow inetd_t inetd_child_exec_t:file { read { getattr execute } };
#line 53

#line 53
#
#line 53
# Allow the process to reap the new domain.
#line 53
#
#line 53
allow inetd_child_t inetd_t:process sigchld;
#line 53

#line 53
#
#line 53
# Allow the new domain to inherit and use file 
#line 53
# descriptions from the creating process and vice versa.
#line 53
#
#line 53
allow inetd_child_t inetd_t:fd use;
#line 53
allow inetd_t inetd_child_t:fd use;
#line 53

#line 53
#
#line 53
# Allow the new domain to write back to the old domain via a pipe.
#line 53
#
#line 53
allow inetd_child_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 53

#line 53
#
#line 53
# Allow the new domain to read and execute the program.
#line 53
#
#line 53
allow inetd_child_t inetd_child_exec_t:file { read getattr lock execute ioctl };
#line 53

#line 53
#
#line 53
# Allow the new domain to be entered via the program.
#line 53
#
#line 53
allow inetd_child_t inetd_child_exec_t:file entrypoint;
#line 53

#line 53
type_transition inetd_t inetd_child_exec_t:process inetd_child_t;
#line 53

#line 53
allow inetd_t inetd_child_t:process sigkill;
#line 53
}
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow inetd_child_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow inetd_child_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow inetd_child_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow inetd_child_t node_type:node { tcp_send rawip_send };
#line 53
allow inetd_child_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow inetd_child_t port_type:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow inetd_child_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow inetd_child_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t self:tcp_socket { listen accept };
#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use udp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow inetd_child_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow inetd_child_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow inetd_child_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow inetd_child_t node_type:node { udp_send rawip_send };
#line 53
allow inetd_child_t node_type:node { udp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow inetd_child_t port_type:udp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow inetd_child_t node_type:udp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow inetd_child_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t self:udp_socket { connect };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
if (allow_ypbind) {
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow inetd_child_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow inetd_child_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow inetd_child_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow inetd_child_t node_type:node { tcp_send rawip_send };
#line 53
allow inetd_child_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow inetd_child_t port_type:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow inetd_child_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow inetd_child_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t self:tcp_socket { listen accept };
#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow inetd_child_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow inetd_child_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow inetd_child_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow inetd_child_t node_type:node { tcp_send rawip_send };
#line 53
allow inetd_child_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow inetd_child_t port_type:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow inetd_child_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow inetd_child_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t self:tcp_socket { connect };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use udp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow inetd_child_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow inetd_child_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow inetd_child_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow inetd_child_t node_type:node { udp_send rawip_send };
#line 53
allow inetd_child_t node_type:node { udp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow inetd_child_t port_type:udp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow inetd_child_t node_type:udp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow inetd_child_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t self:udp_socket { connect };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
allow inetd_child_t var_yp_t:dir { read getattr lock search ioctl };
#line 53
allow inetd_child_t var_yp_t:file { read getattr lock ioctl };
#line 53
allow inetd_child_t var_yp_t:lnk_file { getattr read };
#line 53

#line 53
allow inetd_child_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 53
allow inetd_child_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 53
dontaudit inetd_child_t self:capability net_bind_service;
#line 53
dontaudit inetd_child_t reserved_port_type:tcp_socket name_connect;
#line 53
dontaudit inetd_child_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 53

#line 53
} else {
#line 53
dontaudit inetd_child_t var_yp_t:dir search;
#line 53
}
#line 53
 
#line 53

#line 53
allow inetd_child_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 53
allow inetd_child_t lib_t:lnk_file { read getattr lock ioctl };
#line 53
allow inetd_child_t ld_so_t:file { read getattr lock execute ioctl };
#line 53
#allow inetd_child_t ld_so_t:file execute_no_trans;
#line 53
allow inetd_child_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 53
allow inetd_child_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 53
allow inetd_child_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 53
allow inetd_child_t texrel_shlib_t:file execmod;
#line 53
allow inetd_child_t ld_so_cache_t:file { read getattr lock ioctl };
#line 53
allow inetd_child_t device_t:dir search;
#line 53
allow inetd_child_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 53

#line 53
allow inetd_child_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 53
allow inetd_child_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 53
allow inetd_child_t self:fifo_file { ioctl read getattr lock write append };
#line 53
type inetd_child_exec_t, file_type, sysadmfile, exec_type;
#line 53

#line 53
allow inetd_child_t etc_t:lnk_file read;
#line 53
allow inetd_child_t lib_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t locale_t:dir { read getattr lock search ioctl };
#line 53
allow inetd_child_t locale_t:file { read getattr lock ioctl };
#line 53
allow inetd_child_t locale_t:lnk_file { getattr read };
#line 53

#line 53

#line 53
allow inetd_child_t device_t:dir search;
#line 53
allow inetd_child_t proc_t:dir search;
#line 53
allow inetd_child_t proc_t:{ file lnk_file } { getattr read };
#line 53
allow inetd_child_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 53
allow inetd_child_t fs_t:filesystem getattr;
#line 53

#line 53

#line 53
# Read system variables in /sys.
#line 53

#line 53
allow inetd_child_t sysctl_t:dir search;
#line 53
allow inetd_child_t sysctl_kernel_t:dir search;
#line 53
allow inetd_child_t sysctl_kernel_t:file { getattr read };
#line 53

#line 53

#line 53

#line 53

#line 53
allow inetd_child_t etc_t:file { getattr read };
#line 53

#line 53

#line 53
type inetd_child_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the process to modify the directory.
#line 53
#
#line 53
allow inetd_child_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 53

#line 53
#
#line 53
# Allow the process to create the file.
#line 53
#
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
allow inetd_child_t inetd_child_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
allow inetd_child_t inetd_child_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
type_transition inetd_child_t tmp_t:{ file dir } inetd_child_tmp_t;
#line 53

#line 53

#line 53

#line 53
allow inetd_child_t var_t:dir search;
#line 53

#line 53
type inetd_child_var_run_t, file_type, sysadmfile, pidfile;
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the process to modify the directory.
#line 53
#
#line 53
allow inetd_child_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 53

#line 53
#
#line 53
# Allow the process to create the file.
#line 53
#
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
allow inetd_child_t inetd_child_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
type_transition inetd_child_t var_run_t:file inetd_child_var_run_t;
#line 53

#line 53

#line 53

#line 53
allow inetd_child_t var_t:dir search;
#line 53
allow inetd_child_t inetd_child_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 53

#line 53

#line 53
# Inherit and use descriptors from inetd.
#line 53
allow inetd_child_t inetd_t:fd use;
#line 53

#line 53
# for identd
#line 53
allow inetd_child_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 53
allow inetd_child_t self:capability { setuid setgid };
#line 53
allow inetd_child_t home_root_t:dir search;
#line 53
allow inetd_child_t self:dir search;
#line 53
allow inetd_child_t self:{ lnk_file file } { getattr read };
#line 53

#line 53

#line 53
if (allow_kerberos) {
#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow inetd_child_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow inetd_child_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow inetd_child_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow inetd_child_t node_type:node { tcp_send rawip_send };
#line 53
allow inetd_child_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow inetd_child_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow inetd_child_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow inetd_child_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t self:tcp_socket { connect };
#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use udp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow inetd_child_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow inetd_child_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow inetd_child_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow inetd_child_t node_type:node { udp_send rawip_send };
#line 53
allow inetd_child_t node_type:node { udp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow inetd_child_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow inetd_child_t node_type:udp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow inetd_child_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t self:udp_socket { connect };
#line 53

#line 53

#line 53

#line 53
allow inetd_child_t kerberos_port_t:tcp_socket name_connect;
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow inetd_child_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow inetd_child_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow inetd_child_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow inetd_child_t node_type:node { tcp_send rawip_send };
#line 53
allow inetd_child_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow inetd_child_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow inetd_child_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow inetd_child_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t self:tcp_socket { connect };
#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use udp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow inetd_child_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow inetd_child_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow inetd_child_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow inetd_child_t node_type:node { udp_send rawip_send };
#line 53
allow inetd_child_t node_type:node { udp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow inetd_child_t dns_port_t:udp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow inetd_child_t node_type:udp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow inetd_child_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow inetd_child_t self:udp_socket { connect };
#line 53

#line 53

#line 53

#line 53
allow inetd_child_t dns_port_t:tcp_socket name_connect;
#line 53

#line 53
}
#line 53
 dontaudit inetd_child_t krb5_conf_t:file write;
#line 53
allow inetd_child_t krb5_conf_t:file { getattr read };
#line 53

#line 53
allow inetd_child_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 53
# Use sockets inherited from inetd.
#line 53

#line 53
allow inetd_t inetd_child_port_t:udp_socket name_bind;
#line 53
allow inetd_child_t inetd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
#line 53
allow inetd_t inetd_child_port_t:tcp_socket name_bind;
#line 53
allow inetd_child_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 53

#line 53

#line 53

#line 53

#line 53
allow inetd_child_t proc_net_t:dir { read getattr lock search ioctl };
#line 53
allow inetd_child_t proc_net_t:file { read getattr lock ioctl };
#line 53
allow inetd_child_t proc_net_t:lnk_file { getattr read };
#line 53

#line 53

allow inetd_child_t proc_net_t:dir search;
allow inetd_child_t proc_net_t:file { getattr read };

#line 59


#line 63

#line 63

#line 63

#line 63
typeattribute inetd_t unrestricted;
#line 63
typeattribute inetd_t privuser;
#line 63

#line 63
# Mount/unmount any filesystem. 
#line 63
allow inetd_t fs_type:filesystem *;
#line 63

#line 63
# Mount/unmount any filesystem with the context= option. 
#line 63
allow inetd_t file_type:filesystem *;
#line 63

#line 63
# Create/access any file in a labeled filesystem;
#line 63
allow inetd_t file_type:{ file chr_file } ~execmod;
#line 63
allow inetd_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 63
allow inetd_t sysctl_t:{ dir file } *;
#line 63
allow inetd_t device_type:{ chr_file blk_file } *;
#line 63
allow inetd_t mtrr_device_t:file *;
#line 63

#line 63
# Create/access other files.  fs_type is to pick up various
#line 63
# pseudo filesystem types that are applied to both the filesystem
#line 63
# and its files.
#line 63
allow inetd_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 63
allow inetd_t unlabeled_t:association { sendto recvfrom };
#line 63

#line 63
allow inetd_t proc_fs:{ dir file } *;
#line 63

#line 63
# For /proc/pid
#line 63

#line 63
allow inetd_t domain:dir { read getattr lock search ioctl };
#line 63
allow inetd_t domain:file { read getattr lock ioctl };
#line 63
allow inetd_t domain:lnk_file { getattr read };
#line 63

#line 63
# Write access is for setting attributes under /proc/self/attr.
#line 63
allow inetd_t self:file { ioctl read getattr lock write append };
#line 63

#line 63
# Read and write sysctls.
#line 63

#line 63
allow inetd_t sysctl_type:dir { read getattr lock search ioctl };
#line 63
allow inetd_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 63

#line 63

#line 63
# Access the network.
#line 63
allow inetd_t node_type:node *;
#line 63
allow inetd_t netif_type:netif *;
#line 63
allow inetd_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 63
allow inetd_t port_type:tcp_socket name_connect;
#line 63

#line 63
# Bind to any network address.
#line 63
allow inetd_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 63
allow inetd_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 63
allow inetd_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 63

#line 63
# Use/sendto/connectto sockets created by any domain.
#line 63
allow inetd_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 63

#line 63
# Use descriptors and pipes created by any domain.
#line 63
allow inetd_t domain:fd use;
#line 63
allow inetd_t domain:fifo_file { ioctl read getattr lock write append };
#line 63

#line 63
# Act upon any other process.
#line 63
allow inetd_t domain:process ~{ transition dyntransition execmem };
#line 63
# Transition to myself, to make get_ordered_context_list happy.
#line 63
allow inetd_t self:process transition;
#line 63

#line 63
if (allow_execmem) {
#line 63
# Allow making anonymous memory executable, e.g. 
#line 63
# for runtime-code generation or executable stack.
#line 63
allow inetd_t self:process execmem;
#line 63
}
#line 63

#line 63
if (allow_execmem && allow_execstack) {
#line 63
# Allow making the stack executable via mprotect.
#line 63
allow inetd_t self:process execstack;
#line 63
}
#line 63

#line 63
if (allow_execmod) {
#line 63
# Allow text relocations on system shared libraries, e.g. libGL.
#line 63

#line 63
allow inetd_t file_type:file execmod;
#line 63

#line 63
}
#line 63

#line 63
# Create/access any System V IPC objects.
#line 63
allow inetd_t domain:{ sem msgq shm } *;
#line 63
allow inetd_t domain:msg  { send receive };
#line 63

#line 63
# Access the security API.
#line 63
if (!secure_mode_policyload) {
#line 63
allow inetd_t security_t:security *;
#line 63
auditallow inetd_t security_t:security { load_policy setenforce setbool };
#line 63
}
#line 63
# Perform certain system operations that lacked individual capabilities.
#line 63
allow inetd_t kernel_t:system *;
#line 63

#line 63
# Use any Linux capability.
#line 63
allow inetd_t self:capability *;
#line 63

#line 63
# Set user information and skip authentication.
#line 63
allow inetd_t self:passwd *;
#line 63

#line 63
# Communicate via dbusd.
#line 63
allow inetd_t self:dbus *;
#line 63

#line 63
allow inetd_t system_dbusd_t:dbus *;
#line 63

#line 63

#line 63
# Get info via nscd.
#line 63
allow inetd_t self:nscd *;
#line 63

#line 63
allow inetd_t nscd_t:nscd *;
#line 63

#line 63

#line 63
 
#line 63


#line 1 "domains/program/initrc.te"
#DESC Initrc - System initialization scripts
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: sysvinit policycoreutils
#

#################################
#
# Rules for the initrc_t domain.
#
# initrc_t is the domain of the init rc scripts.
# initrc_exec_t is the type of the init program.
#
# do not use privmail for sendmail as it creates a type transition conflict
type initrc_t, fs_domain, admin, etc_writer, privmem, auth_write,  domain, privlog, privowner, privmodule,   sysctl_kernel_writer, nscd_client_domain, mlsfileread, mlsfilewrite, mlsprocread, mlsprocwrite, privrangetrans;

role system_r types initrc_t;

#line 18
allow initrc_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 18
allow initrc_t lib_t:lnk_file { read getattr lock ioctl };
#line 18
allow initrc_t ld_so_t:file { read getattr lock execute ioctl };
#line 18
#allow initrc_t ld_so_t:file execute_no_trans;
#line 18
allow initrc_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 18
allow initrc_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 18
allow initrc_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 18
allow initrc_t texrel_shlib_t:file execmod;
#line 18
allow initrc_t ld_so_cache_t:file { read getattr lock ioctl };
#line 18
allow initrc_t device_t:dir search;
#line 18
allow initrc_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 18
;

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow initrc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow initrc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow initrc_t node_type:node { tcp_send rawip_send };
#line 19
allow initrc_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow initrc_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow initrc_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow initrc_t self:tcp_socket { listen accept };
#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow initrc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow initrc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow initrc_t node_type:node { tcp_send rawip_send };
#line 19
allow initrc_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow initrc_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow initrc_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow initrc_t self:tcp_socket { connect };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use udp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow initrc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow initrc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow initrc_t node_type:node { udp_send rawip_send };
#line 19
allow initrc_t node_type:node { udp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow initrc_t port_type:udp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow initrc_t node_type:udp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow initrc_t self:udp_socket { connect };
#line 19

#line 19

#line 19

#line 19

#line 19

allow initrc_t port_type:tcp_socket name_connect;

#line 21

#line 21
if (allow_ypbind) {
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use tcp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow initrc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow initrc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow initrc_t node_type:node { tcp_send rawip_send };
#line 21
allow initrc_t node_type:node { tcp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow initrc_t port_type:tcp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow initrc_t node_type:tcp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow initrc_t self:tcp_socket { listen accept };
#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use tcp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow initrc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow initrc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow initrc_t node_type:node { tcp_send rawip_send };
#line 21
allow initrc_t node_type:node { tcp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow initrc_t port_type:tcp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow initrc_t node_type:tcp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow initrc_t self:tcp_socket { connect };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use udp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow initrc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow initrc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow initrc_t node_type:node { udp_send rawip_send };
#line 21
allow initrc_t node_type:node { udp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow initrc_t port_type:udp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow initrc_t node_type:udp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow initrc_t self:udp_socket { connect };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
allow initrc_t var_yp_t:dir { read getattr lock search ioctl };
#line 21
allow initrc_t var_yp_t:file { read getattr lock ioctl };
#line 21
allow initrc_t var_yp_t:lnk_file { getattr read };
#line 21

#line 21
allow initrc_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 21
allow initrc_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 21
dontaudit initrc_t self:capability net_bind_service;
#line 21
dontaudit initrc_t reserved_port_type:tcp_socket name_connect;
#line 21
dontaudit initrc_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 21

#line 21
} else {
#line 21
dontaudit initrc_t var_yp_t:dir search;
#line 21
}
#line 21
 
type initrc_exec_t, file_type, sysadmfile, exec_type;

# for halt to down interfaces
allow initrc_t self:udp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# read files in /etc/init.d
allow initrc_t etc_t:lnk_file { read getattr lock ioctl };


#line 30
allow initrc_t etc_t:lnk_file read;
#line 30
allow initrc_t lib_t:file { read getattr lock ioctl };
#line 30

#line 30
allow initrc_t locale_t:dir { read getattr lock search ioctl };
#line 30
allow initrc_t locale_t:file { read getattr lock ioctl };
#line 30
allow initrc_t locale_t:lnk_file { getattr read };
#line 30

#line 30



#line 32
allow initrc_t usr_t:dir { read getattr lock search ioctl };
#line 32
allow initrc_t usr_t:file { read getattr lock ioctl };
#line 32
allow initrc_t usr_t:lnk_file { getattr read };
#line 32


# Read system information files in /proc.

#line 35
allow initrc_t { proc_t proc_net_t }:dir { read getattr lock search ioctl };
#line 35
allow initrc_t { proc_t proc_net_t }:file { read getattr lock ioctl };
#line 35
allow initrc_t { proc_t proc_net_t }:lnk_file { getattr read };
#line 35

allow initrc_t proc_mdstat_t:file { getattr read };

# Allow IPC with self
allow initrc_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow initrc_t self:unix_stream_socket { connectto { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept } };
allow initrc_t self:fifo_file { ioctl read getattr lock write append };

# Read the root directory of a usbdevfs filesystem, and
# the devices and drivers files.  Permit stating of the
# device nodes, but nothing else.
allow initrc_t usbdevfs_t:dir { read getattr lock search ioctl };
allow initrc_t usbdevfs_t:lnk_file { read getattr lock ioctl };
allow initrc_t usbdevfs_t:file getattr;
allow initrc_t usbfs_t:dir { read getattr lock search ioctl };
allow initrc_t usbfs_t:file getattr;

# allow initrc to fork and renice itself
allow initrc_t self:process { fork sigchld getpgid setsched setpgid setrlimit getsched };

# Can create ptys for open_init_pty

#line 56

#line 56
# Access the pty master multiplexer.
#line 56
allow initrc_t ptmx_t:chr_file { ioctl read getattr lock write append };
#line 56

#line 56
allow initrc_t devpts_t:filesystem getattr;
#line 56

#line 56
# allow searching /dev/pts
#line 56
allow initrc_t devpts_t:dir { getattr read search };
#line 56

#line 56
# ignore old BSD pty devices
#line 56
dontaudit initrc_t bsdpty_device_t:chr_file { getattr read write };
#line 56

#line 56

#line 56
type initrc_devpts_t, file_type, sysadmfile, ptyfile ;
#line 56

#line 56
# Allow the pty to be associated with the file system.
#line 56
allow initrc_devpts_t devpts_t:filesystem associate;
#line 56

#line 56
# Label pty files with a derived type.
#line 56
type_transition initrc_t devpts_t:chr_file initrc_devpts_t;
#line 56

#line 56
# allow searching /dev/pts
#line 56
allow initrc_t devpts_t:dir { getattr read search };
#line 56

#line 56
# Read and write my pty files.
#line 56
allow initrc_t initrc_devpts_t:chr_file { setattr { ioctl read getattr lock write append } };
#line 56

#line 56



#line 58
type initrc_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 58

#line 58

#line 58

#line 58

#line 58
#
#line 58
# Allow the process to modify the directory.
#line 58
#
#line 58
allow initrc_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 58

#line 58
#
#line 58
# Allow the process to create the file.
#line 58
#
#line 58

#line 58

#line 58

#line 58

#line 58

#line 58
allow initrc_t initrc_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58
allow initrc_t initrc_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58
type_transition initrc_t tmp_t:{ file dir } initrc_tmp_t;
#line 58

#line 58

#line 58

#
# Some initscripts generate scripts that they need to execute (ldap)
#

#line 62
allow initrc_t initrc_tmp_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 62



#line 64
type initrc_var_run_t, file_type, sysadmfile, pidfile;
#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64
#
#line 64
# Allow the process to modify the directory.
#line 64
#
#line 64
allow initrc_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 64

#line 64
#
#line 64
# Allow the process to create the file.
#line 64
#
#line 64

#line 64

#line 64

#line 64

#line 64

#line 64
allow initrc_t initrc_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64
type_transition initrc_t var_run_t:file initrc_var_run_t;
#line 64

#line 64

#line 64

#line 64
allow initrc_t var_t:dir search;
#line 64
allow initrc_t initrc_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 64

allow initrc_t var_run_t:{ file sock_file lnk_file } unlink;
allow initrc_t var_run_t:dir { create rmdir };

#line 76


allow initrc_t framebuf_device_t:chr_file { read getattr lock ioctl };

# Use capabilities.
allow initrc_t self:capability ~{ sys_admin sys_module };

# Use system operations.
allow initrc_t kernel_t:system *;

# Set values in /proc/sys.

#line 87
allow initrc_t sysctl_type:dir { read getattr lock search ioctl };
#line 87
allow initrc_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 87


# Run helper programs in the initrc_t domain.
allow initrc_t {bin_t sbin_t }:dir { read getattr lock search ioctl };
allow initrc_t {bin_t sbin_t }:lnk_file read;

#line 92
allow initrc_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 92


#line 93
allow initrc_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 93


#line 94
allow initrc_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 94


#line 95
allow initrc_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 95


#line 96
allow initrc_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 96

#
#  These rules are here to allow init scripts to su
#
#line 103

allow initrc_t self:passwd rootok;

# read /lib/modules
allow initrc_t modules_object_t:dir { search read };

# Read conf.modules.
allow initrc_t modules_conf_t:file { read getattr lock ioctl };

# Run other rc scripts in the initrc_t domain.

#line 113
allow initrc_t initrc_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 113


# Run init (telinit) in the initrc_t domain.

#line 116
allow initrc_t init_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 116


# Communicate with the init process.
allow initrc_t initctl_t:fifo_file { ioctl read getattr lock write append };

# Read /proc/PID directories for all domains.

#line 122
allow initrc_t domain:dir { read getattr lock search ioctl };
#line 122
allow initrc_t domain:file { read getattr lock ioctl };
#line 122
allow initrc_t domain:lnk_file { getattr read };
#line 122

allow initrc_t domain:process { getattr getsession };

# Mount and unmount file systems.
allow initrc_t fs_type:filesystem { mount remount unmount getattr };
allow initrc_t file_t:dir { read search getattr mounton };

# during boot up initrc needs to do the following
allow initrc_t default_t:dir { write read search getattr mounton };

# rhgb-console writes to ramfs
allow initrc_t ramfs_t:fifo_file write;

# Create runtime files in /etc, e.g. /etc/mtab, /etc/HOSTNAME.

#line 136

#line 136

#line 136

#line 136
#
#line 136
# Allow the process to modify the directory.
#line 136
#
#line 136
allow initrc_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 136

#line 136
#
#line 136
# Allow the process to create the file.
#line 136
#
#line 136

#line 136

#line 136

#line 136

#line 136

#line 136
allow initrc_t etc_runtime_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 136

#line 136

#line 136

#line 136

#line 136

#line 136

#line 136

#line 136

#line 136

#line 136
type_transition initrc_t etc_t:file etc_runtime_t;
#line 136

#line 136


# Update /etc/ld.so.cache.
allow initrc_t ld_so_cache_t:file { ioctl read getattr lock write append };

# Update /var/log/wtmp and /var/log/dmesg.
allow initrc_t wtmp_t:file { setattr { ioctl read getattr lock write append } };
allow initrc_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
allow initrc_t var_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
allow initrc_t lastlog_t:file { setattr { ioctl read getattr lock write append } };
allow initrc_t logfile:file { read append };

# remove old locks
allow initrc_t lockfile:dir { read getattr lock search ioctl add_name remove_name write };
allow initrc_t lockfile:file { getattr unlink };

# Access /var/lib/random-seed.
allow initrc_t var_lib_t:file { ioctl read getattr lock write append };
allow initrc_t var_lib_t:file unlink;

# Create lock file.
allow initrc_t var_lock_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
allow initrc_t var_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };

# Set the clock.
allow initrc_t clock_device_t:{ chr_file blk_file } { ioctl read getattr lock write append };

# Kill all processes.
allow initrc_t domain:process { sigchld sigkill sigstop signull signal };

# Write to /dev/urandom.
allow initrc_t { random_device_t urandom_device_t }:chr_file { ioctl read getattr lock write append };

# for cryptsetup
allow initrc_t fixed_disk_device_t:blk_file getattr;

# Set device ownerships/modes.
allow initrc_t framebuf_device_t:chr_file setattr;
allow initrc_t misc_device_t:{ chr_file blk_file } setattr;
allow initrc_t device_t:{ chr_file blk_file } setattr;
allow initrc_t fixed_disk_device_t:{ chr_file blk_file } setattr;
allow initrc_t removable_device_t:{ chr_file blk_file } setattr;
allow initrc_t device_t:lnk_file read;
allow initrc_t xconsole_device_t:fifo_file setattr;

# Stat any file.
allow initrc_t file_type:{ file lnk_file sock_file fifo_file } getattr;
allow initrc_t file_type:dir { search getattr };

# Read and write console and ttys.
allow initrc_t devtty_t:chr_file { ioctl read getattr lock write append };
allow initrc_t console_device_t:chr_file { ioctl read getattr lock write append };
allow initrc_t tty_device_t:chr_file { ioctl read getattr lock write append };
allow initrc_t ttyfile:chr_file { ioctl read getattr lock write append };
allow initrc_t ptyfile:chr_file { ioctl read getattr lock write append };

# Reset tty labels.
allow initrc_t ttyfile:chr_file relabelfrom;
allow initrc_t tty_device_t:chr_file relabelto;

#line 230

#line 230
# Create and read /boot/kernel.h and /boot/System.map.
#line 230
# Redhat systems typically create this file at boot time.
#line 230
allow initrc_t boot_t:lnk_file { ioctl read getattr lock write append };
#line 230

#line 230

#line 230

#line 230

#line 230
#
#line 230
# Allow the process to modify the directory.
#line 230
#
#line 230
allow initrc_t boot_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 230

#line 230
#
#line 230
# Allow the process to create the file.
#line 230
#
#line 230

#line 230

#line 230

#line 230

#line 230

#line 230
allow initrc_t boot_runtime_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230
type_transition initrc_t boot_t:file boot_runtime_t;
#line 230

#line 230

#line 230

#line 230
allow initrc_t tmpfs_t:chr_file { ioctl read getattr lock write append };
#line 230
allow initrc_t tmpfs_t:dir { read getattr lock search ioctl };
#line 230

#line 230
# Allow initrc domain to set the enforcing flag.
#line 230

#line 230
# Get the selinuxfs mount point via /proc/self/mounts.
#line 230
allow initrc_t proc_t:dir search;
#line 230
allow initrc_t proc_t:lnk_file read;
#line 230
allow initrc_t self:dir search;
#line 230
allow initrc_t self:file { getattr read };
#line 230
# Access selinuxfs.
#line 230
allow initrc_t security_t:dir { read search getattr };
#line 230
allow initrc_t security_t:file { getattr read write };
#line 230
if (!secure_mode_policyload) {
#line 230
allow initrc_t security_t:security setenforce;
#line 230
auditallow initrc_t security_t:security setenforce;
#line 230
}
#line 230

#line 230
#
#line 230
# readahead asks for these
#line 230
#
#line 230
allow initrc_t etc_aliases_t:file { getattr read };
#line 230
allow initrc_t var_lib_nfs_t:file { getattr read };
#line 230

#line 230
# for /halt /.autofsck and other flag files
#line 230

#line 230

#line 230

#line 230

#line 230
#
#line 230
# Allow the process to modify the directory.
#line 230
#
#line 230
allow { initrc_t sysadm_t } root_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 230

#line 230
#
#line 230
# Allow the process to create the file.
#line 230
#
#line 230

#line 230

#line 230

#line 230

#line 230

#line 230
allow { initrc_t sysadm_t } etc_runtime_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230
type_transition { initrc_t sysadm_t } root_t:file etc_runtime_t;
#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230
#
#line 230
# Allow the process to modify the directory.
#line 230
#
#line 230
allow initrc_t device_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 230

#line 230
#
#line 230
# Allow the process to create the file.
#line 230
#
#line 230

#line 230

#line 230

#line 230

#line 230

#line 230
allow initrc_t fixed_disk_device_t:blk_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230

#line 230
type_transition initrc_t device_t:blk_file fixed_disk_device_t;
#line 230

#line 230

#line 230
allow initrc_t file_type:{ { dir file lnk_file sock_file fifo_file chr_file blk_file } { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } } getattr;
#line 230
allow initrc_t self:capability sys_admin;
#line 230
allow initrc_t device_t:dir create;
#line 230
# wants to delete /poweroff and other files 
#line 230
allow initrc_t root_t:file unlink;
#line 230
# wants to read /.fonts directory
#line 230
allow initrc_t default_t:file { getattr read };
#line 230


allow initrc_t system_map_t:{ file lnk_file } { read getattr lock ioctl };
allow initrc_t var_spool_t:file { ioctl read getattr lock write append };

# Allow access to the sysadm TTYs. Note that this will give access to the 
# TTYs to any process in the initrc_t domain. Therefore, daemons and such
# started from init should be placed in their own domain.
allow initrc_t admin_tty_type:chr_file { ioctl read getattr lock write append };

# Access sound device and files.
allow initrc_t sound_device_t:chr_file { setattr ioctl read write };

# Read user home directories.
allow initrc_t { home_root_t home_type }:dir { read getattr lock search ioctl };
allow initrc_t home_type:file { read getattr lock ioctl };

# Read and unlink /var/run/*.pid files.
allow initrc_t pidfile:file { getattr read unlink };

# for system start scripts
allow initrc_t pidfile:dir { rmdir { read getattr lock search ioctl add_name remove_name write } };
allow initrc_t pidfile:sock_file unlink;


#line 254
allow initrc_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 254
allow initrc_t var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 254
allow initrc_t var_lib_t:lnk_file { create read getattr setattr link unlink rename };
#line 254


# allow start scripts to clean /tmp
allow initrc_t { unlabeled_t tmpfile }:dir { { read getattr lock search ioctl add_name remove_name write } rmdir };
allow initrc_t { unlabeled_t tmpfile }:{ file lnk_file sock_file fifo_file } { getattr unlink };

# for lsof which is used by alsa shutdown
dontaudit initrc_t domain:{ udp_socket tcp_socket fifo_file unix_dgram_socket } getattr;
dontaudit initrc_t proc_kmsg_t:file getattr;

#################################
#
# Rules for the run_init_t domain.
#
#line 279

#line 279
type run_init_exec_t, file_type, sysadmfile, exec_type;
#line 279
type run_init_t, domain;
#line 279

#line 279

#line 279

#line 279
#
#line 279
# Allow the process to transition to the new domain.
#line 279
#
#line 279
allow unconfined_t initrc_t:process transition;
#line 279

#line 279
#
#line 279
# Do not audit when glibc secure mode is enabled upon the transition.
#line 279
#
#line 279
dontaudit unconfined_t initrc_t:process noatsecure;
#line 279

#line 279
#
#line 279
# Do not audit when signal-related state is cleared upon the transition.
#line 279
#
#line 279
dontaudit unconfined_t initrc_t:process siginh;
#line 279

#line 279
#
#line 279
# Do not audit when resource limits are reset upon the transition.
#line 279
#
#line 279
dontaudit unconfined_t initrc_t:process rlimitinh;
#line 279

#line 279
#
#line 279
# Allow the process to execute the program.
#line 279
# 
#line 279
allow unconfined_t initrc_exec_t:file { read { getattr execute } };
#line 279

#line 279
#
#line 279
# Allow the process to reap the new domain.
#line 279
#
#line 279
allow initrc_t unconfined_t:process sigchld;
#line 279

#line 279
#
#line 279
# Allow the new domain to inherit and use file 
#line 279
# descriptions from the creating process and vice versa.
#line 279
#
#line 279
allow initrc_t unconfined_t:fd use;
#line 279
allow unconfined_t initrc_t:fd use;
#line 279

#line 279
#
#line 279
# Allow the new domain to write back to the old domain via a pipe.
#line 279
#
#line 279
allow initrc_t unconfined_t:fifo_file { ioctl read getattr lock write append };
#line 279

#line 279
#
#line 279
# Allow the new domain to read and execute the program.
#line 279
#
#line 279
allow initrc_t initrc_exec_t:file { read getattr lock execute ioctl };
#line 279

#line 279
#
#line 279
# Allow the new domain to be entered via the program.
#line 279
#
#line 279
allow initrc_t initrc_exec_t:file entrypoint;
#line 279

#line 279
type_transition unconfined_t initrc_exec_t:process initrc_t;
#line 279

#line 279
allow unconfined_t initrc_t:dbus { acquire_svc send_msg };
#line 279
allow initrc_t unconfined_t:dbus { acquire_svc send_msg };
#line 279
typeattribute initrc_t privuser;
#line 279

#line 279

#line 279
#
#line 279
# Allow the process to transition to the new domain.
#line 279
#
#line 279
allow initrc_t unconfined_t:process transition;
#line 279

#line 279
#
#line 279
# Do not audit when glibc secure mode is enabled upon the transition.
#line 279
#
#line 279
dontaudit initrc_t unconfined_t:process noatsecure;
#line 279

#line 279
#
#line 279
# Do not audit when signal-related state is cleared upon the transition.
#line 279
#
#line 279
dontaudit initrc_t unconfined_t:process siginh;
#line 279

#line 279
#
#line 279
# Do not audit when resource limits are reset upon the transition.
#line 279
#
#line 279
dontaudit initrc_t unconfined_t:process rlimitinh;
#line 279

#line 279
#
#line 279
# Allow the process to execute the program.
#line 279
# 
#line 279
allow initrc_t shell_exec_t:file { read { getattr execute } };
#line 279

#line 279
#
#line 279
# Allow the process to reap the new domain.
#line 279
#
#line 279
allow unconfined_t initrc_t:process sigchld;
#line 279

#line 279
#
#line 279
# Allow the new domain to inherit and use file 
#line 279
# descriptions from the creating process and vice versa.
#line 279
#
#line 279
allow unconfined_t initrc_t:fd use;
#line 279
allow initrc_t unconfined_t:fd use;
#line 279

#line 279
#
#line 279
# Allow the new domain to write back to the old domain via a pipe.
#line 279
#
#line 279
allow unconfined_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 279

#line 279
#
#line 279
# Allow the new domain to read and execute the program.
#line 279
#
#line 279
allow unconfined_t shell_exec_t:file { read getattr lock execute ioctl };
#line 279

#line 279
#
#line 279
# Allow the new domain to be entered via the program.
#line 279
#
#line 279
allow unconfined_t shell_exec_t:file entrypoint;
#line 279

#line 279
allow initrc_t unconfined_t:system syslog_mod;
#line 279

allow initrc_t privfd:fd use;

# Transition to system_r:initrc_t upon executing init scripts.
#line 290


#
# Shutting down xinet causes these
#
# Fam
dontaudit initrc_t device_t:dir { read write };
# Rsync
dontaudit initrc_t mail_spool_t:lnk_file read;

allow initrc_t sysfs_t:dir { getattr read search };
allow initrc_t sysfs_t:file { getattr read write };
allow initrc_t sysfs_t:lnk_file { getattr read };
allow initrc_t udev_runtime_t:file { ioctl read getattr lock write append };
allow initrc_t device_type:chr_file setattr;
allow initrc_t binfmt_misc_fs_t:dir { getattr search };
allow initrc_t binfmt_misc_fs_t:file { getattr ioctl write };

# for lsof in shutdown scripts

#line 309

#line 309
if (allow_kerberos) {
#line 309

#line 309

#line 309

#line 309

#line 309
#
#line 309
# Allow the domain to create and use tcp sockets.
#line 309
# Other kinds of sockets must be separately authorized for use.
#line 309
allow initrc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 309

#line 309
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 309

#line 309
#
#line 309
# Allow the domain to send or receive using any network interface.
#line 309
# netif_type is a type attribute for all network interface types.
#line 309
#
#line 309
allow initrc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 309
#
#line 309
# Allow the domain to send to or receive from any node.
#line 309
# node_type is a type attribute for all node types.
#line 309
#
#line 309
allow initrc_t node_type:node { tcp_send rawip_send };
#line 309
allow initrc_t node_type:node { tcp_recv rawip_recv };
#line 309

#line 309
#
#line 309
# Allow the domain to send to or receive from any port.
#line 309
# port_type is a type attribute for all port types.
#line 309
#
#line 309

#line 309
allow initrc_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 309

#line 309

#line 309
# XXX Allow binding to any node type.  Remove once
#line 309
# individual rules have been added to all domains that 
#line 309
# bind sockets. 
#line 309
allow initrc_t node_type:tcp_socket node_bind;
#line 309
#
#line 309
# Allow access to network files including /etc/resolv.conf
#line 309
#
#line 309
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 309

#line 309
allow initrc_t self:tcp_socket { connect };
#line 309

#line 309

#line 309

#line 309
#
#line 309
# Allow the domain to create and use udp sockets.
#line 309
# Other kinds of sockets must be separately authorized for use.
#line 309
allow initrc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 309

#line 309
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 309

#line 309
#
#line 309
# Allow the domain to send or receive using any network interface.
#line 309
# netif_type is a type attribute for all network interface types.
#line 309
#
#line 309
allow initrc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 309
#
#line 309
# Allow the domain to send to or receive from any node.
#line 309
# node_type is a type attribute for all node types.
#line 309
#
#line 309
allow initrc_t node_type:node { udp_send rawip_send };
#line 309
allow initrc_t node_type:node { udp_recv rawip_recv };
#line 309

#line 309
#
#line 309
# Allow the domain to send to or receive from any port.
#line 309
# port_type is a type attribute for all port types.
#line 309
#
#line 309

#line 309
allow initrc_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 309

#line 309

#line 309
# XXX Allow binding to any node type.  Remove once
#line 309
# individual rules have been added to all domains that 
#line 309
# bind sockets. 
#line 309
allow initrc_t node_type:udp_socket node_bind;
#line 309
#
#line 309
# Allow access to network files including /etc/resolv.conf
#line 309
#
#line 309
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 309

#line 309
allow initrc_t self:udp_socket { connect };
#line 309

#line 309

#line 309

#line 309
allow initrc_t kerberos_port_t:tcp_socket name_connect;
#line 309

#line 309

#line 309

#line 309

#line 309

#line 309
#
#line 309
# Allow the domain to create and use tcp sockets.
#line 309
# Other kinds of sockets must be separately authorized for use.
#line 309
allow initrc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 309

#line 309
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 309

#line 309
#
#line 309
# Allow the domain to send or receive using any network interface.
#line 309
# netif_type is a type attribute for all network interface types.
#line 309
#
#line 309
allow initrc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 309
#
#line 309
# Allow the domain to send to or receive from any node.
#line 309
# node_type is a type attribute for all node types.
#line 309
#
#line 309
allow initrc_t node_type:node { tcp_send rawip_send };
#line 309
allow initrc_t node_type:node { tcp_recv rawip_recv };
#line 309

#line 309
#
#line 309
# Allow the domain to send to or receive from any port.
#line 309
# port_type is a type attribute for all port types.
#line 309
#
#line 309

#line 309
allow initrc_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 309

#line 309

#line 309
# XXX Allow binding to any node type.  Remove once
#line 309
# individual rules have been added to all domains that 
#line 309
# bind sockets. 
#line 309
allow initrc_t node_type:tcp_socket node_bind;
#line 309
#
#line 309
# Allow access to network files including /etc/resolv.conf
#line 309
#
#line 309
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 309

#line 309
allow initrc_t self:tcp_socket { connect };
#line 309

#line 309

#line 309

#line 309
#
#line 309
# Allow the domain to create and use udp sockets.
#line 309
# Other kinds of sockets must be separately authorized for use.
#line 309
allow initrc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 309

#line 309
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 309

#line 309
#
#line 309
# Allow the domain to send or receive using any network interface.
#line 309
# netif_type is a type attribute for all network interface types.
#line 309
#
#line 309
allow initrc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 309
#
#line 309
# Allow the domain to send to or receive from any node.
#line 309
# node_type is a type attribute for all node types.
#line 309
#
#line 309
allow initrc_t node_type:node { udp_send rawip_send };
#line 309
allow initrc_t node_type:node { udp_recv rawip_recv };
#line 309

#line 309
#
#line 309
# Allow the domain to send to or receive from any port.
#line 309
# port_type is a type attribute for all port types.
#line 309
#
#line 309

#line 309
allow initrc_t dns_port_t:udp_socket { send_msg recv_msg };
#line 309

#line 309

#line 309
# XXX Allow binding to any node type.  Remove once
#line 309
# individual rules have been added to all domains that 
#line 309
# bind sockets. 
#line 309
allow initrc_t node_type:udp_socket node_bind;
#line 309
#
#line 309
# Allow access to network files including /etc/resolv.conf
#line 309
#
#line 309
allow initrc_t net_conf_t:file { read getattr lock ioctl };
#line 309

#line 309
allow initrc_t self:udp_socket { connect };
#line 309

#line 309

#line 309

#line 309
allow initrc_t dns_port_t:tcp_socket name_connect;
#line 309

#line 309
}
#line 309
 dontaudit initrc_t krb5_conf_t:file write;
#line 309
allow initrc_t krb5_conf_t:file { getattr read };
#line 309


#
# Wants to remove udev.tbl
#
allow initrc_t device_t:dir { read getattr lock search ioctl add_name remove_name write };
allow initrc_t device_t:lnk_file unlink;


#line 317
allow initrc_t selinux_config_t:dir { read getattr lock search ioctl };
#line 317
allow initrc_t selinux_config_t:file { read getattr lock ioctl };
#line 317
allow initrc_t selinux_config_t:lnk_file { getattr read };
#line 317


#line 321

#line 321

#line 321

#line 321
typeattribute initrc_t unrestricted;
#line 321
typeattribute initrc_t privuser;
#line 321

#line 321
# Mount/unmount any filesystem. 
#line 321
allow initrc_t fs_type:filesystem *;
#line 321

#line 321
# Mount/unmount any filesystem with the context= option. 
#line 321
allow initrc_t file_type:filesystem *;
#line 321

#line 321
# Create/access any file in a labeled filesystem;
#line 321
allow initrc_t file_type:{ file chr_file } ~execmod;
#line 321
allow initrc_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 321
allow initrc_t sysctl_t:{ dir file } *;
#line 321
allow initrc_t device_type:{ chr_file blk_file } *;
#line 321
allow initrc_t mtrr_device_t:file *;
#line 321

#line 321
# Create/access other files.  fs_type is to pick up various
#line 321
# pseudo filesystem types that are applied to both the filesystem
#line 321
# and its files.
#line 321
allow initrc_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 321
allow initrc_t unlabeled_t:association { sendto recvfrom };
#line 321

#line 321
allow initrc_t proc_fs:{ dir file } *;
#line 321

#line 321
# For /proc/pid
#line 321

#line 321
allow initrc_t domain:dir { read getattr lock search ioctl };
#line 321
allow initrc_t domain:file { read getattr lock ioctl };
#line 321
allow initrc_t domain:lnk_file { getattr read };
#line 321

#line 321
# Write access is for setting attributes under /proc/self/attr.
#line 321
allow initrc_t self:file { ioctl read getattr lock write append };
#line 321

#line 321
# Read and write sysctls.
#line 321

#line 321
allow initrc_t sysctl_type:dir { read getattr lock search ioctl };
#line 321
allow initrc_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 321

#line 321

#line 321
# Access the network.
#line 321
allow initrc_t node_type:node *;
#line 321
allow initrc_t netif_type:netif *;
#line 321
allow initrc_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 321
allow initrc_t port_type:tcp_socket name_connect;
#line 321

#line 321
# Bind to any network address.
#line 321
allow initrc_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 321
allow initrc_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 321
allow initrc_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 321

#line 321
# Use/sendto/connectto sockets created by any domain.
#line 321
allow initrc_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 321

#line 321
# Use descriptors and pipes created by any domain.
#line 321
allow initrc_t domain:fd use;
#line 321
allow initrc_t domain:fifo_file { ioctl read getattr lock write append };
#line 321

#line 321
# Act upon any other process.
#line 321
allow initrc_t domain:process ~{ transition dyntransition execmem };
#line 321
# Transition to myself, to make get_ordered_context_list happy.
#line 321
allow initrc_t self:process transition;
#line 321

#line 321
if (allow_execmem) {
#line 321
# Allow making anonymous memory executable, e.g. 
#line 321
# for runtime-code generation or executable stack.
#line 321
allow initrc_t self:process execmem;
#line 321
}
#line 321

#line 321
if (allow_execmem && allow_execstack) {
#line 321
# Allow making the stack executable via mprotect.
#line 321
allow initrc_t self:process execstack;
#line 321
}
#line 321

#line 321
if (allow_execmod) {
#line 321
# Allow text relocations on system shared libraries, e.g. libGL.
#line 321

#line 321
allow initrc_t file_type:file execmod;
#line 321

#line 321
}
#line 321

#line 321
# Create/access any System V IPC objects.
#line 321
allow initrc_t domain:{ sem msgq shm } *;
#line 321
allow initrc_t domain:msg  { send receive };
#line 321

#line 321
# Access the security API.
#line 321
if (!secure_mode_policyload) {
#line 321
allow initrc_t security_t:security *;
#line 321
auditallow initrc_t security_t:security { load_policy setenforce setbool };
#line 321
}
#line 321
# Perform certain system operations that lacked individual capabilities.
#line 321
allow initrc_t kernel_t:system *;
#line 321

#line 321
# Use any Linux capability.
#line 321
allow initrc_t self:capability *;
#line 321

#line 321
# Set user information and skip authentication.
#line 321
allow initrc_t self:passwd *;
#line 321

#line 321
# Communicate via dbusd.
#line 321
allow initrc_t self:dbus *;
#line 321

#line 321
allow initrc_t system_dbusd_t:dbus *;
#line 321

#line 321

#line 321
# Get info via nscd.
#line 321
allow initrc_t self:nscd *;
#line 321

#line 321
allow initrc_t nscd_t:nscd *;
#line 321

#line 321

#line 321
 
#line 321

#
# initrc script does a cat /selinux/enforce
#
allow initrc_t security_t:dir { getattr search };
allow initrc_t security_t:file { getattr read };

# init script state
type initrc_state_t, file_type, sysadmfile;

#line 330
allow initrc_t initrc_state_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 330
allow initrc_t initrc_state_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 330
allow initrc_t initrc_state_t:lnk_file { create read getattr setattr link unlink rename };
#line 330


#line 335

allow initrc_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
allow initrc_t device_t:lnk_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 340

#line 340
allow initrc_t system_dbusd_var_run_t:sock_file write;
#line 340


# Slapd needs to read cert files from its initscript

#line 343
allow initrc_t cert_t:dir { read getattr lock search ioctl };
#line 343
allow initrc_t cert_t:file { read getattr lock ioctl };
#line 343
allow initrc_t cert_t:lnk_file { getattr read };
#line 343

#line 346

#line 1 "domains/program/init.te"
#DESC Init - Process initialization
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: sysvinit
#

#################################
#
# Rules for the init_t domain.
#
# init_t is the domain of the init process.
# init_exec_t is the type of the init program.
# initctl_t is the type of the named pipe created 
# by init during initialization.  This pipe is used
# to communicate with init.
#
type init_t, domain, privlog, sysctl_kernel_writer, nscd_client_domain, mlsrangetrans, mlsfileread, mlsfilewrite, mlsprocwrite;
role system_r types init_t;

#line 19
allow init_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 19
allow init_t lib_t:lnk_file { read getattr lock ioctl };
#line 19
allow init_t ld_so_t:file { read getattr lock execute ioctl };
#line 19
#allow init_t ld_so_t:file execute_no_trans;
#line 19
allow init_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 19
allow init_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 19
allow init_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 19
allow init_t texrel_shlib_t:file execmod;
#line 19
allow init_t ld_so_cache_t:file { read getattr lock ioctl };
#line 19
allow init_t device_t:dir search;
#line 19
allow init_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 19
;
type init_exec_t, file_type, sysadmfile, exec_type;
type initctl_t, file_type, sysadmfile, dev_fs, mlstrustedobject;

# for init to determine whether SE Linux is active so it can know whether to
# activate it
allow init_t security_t:dir search;
allow init_t security_t:file { getattr read };

# for mount points
allow init_t file_t:dir search;

# Use capabilities.
allow init_t self:capability ~sys_module;

# Run /etc/rc.sysinit, /etc/rc, /etc/rc.local in the initrc_t domain.

#line 35

#line 35

#line 35
#
#line 35
# Allow the process to transition to the new domain.
#line 35
#
#line 35
allow init_t initrc_t:process transition;
#line 35

#line 35
#
#line 35
# Do not audit when glibc secure mode is enabled upon the transition.
#line 35
#
#line 35
dontaudit init_t initrc_t:process noatsecure;
#line 35

#line 35
#
#line 35
# Do not audit when signal-related state is cleared upon the transition.
#line 35
#
#line 35
dontaudit init_t initrc_t:process siginh;
#line 35

#line 35
#
#line 35
# Do not audit when resource limits are reset upon the transition.
#line 35
#
#line 35
dontaudit init_t initrc_t:process rlimitinh;
#line 35

#line 35
#
#line 35
# Allow the process to execute the program.
#line 35
# 
#line 35
allow init_t initrc_exec_t:file { read { getattr execute } };
#line 35

#line 35
#
#line 35
# Allow the process to reap the new domain.
#line 35
#
#line 35
allow initrc_t init_t:process sigchld;
#line 35

#line 35
#
#line 35
# Allow the new domain to inherit and use file 
#line 35
# descriptions from the creating process and vice versa.
#line 35
#
#line 35
allow initrc_t init_t:fd use;
#line 35
allow init_t initrc_t:fd use;
#line 35

#line 35
#
#line 35
# Allow the new domain to write back to the old domain via a pipe.
#line 35
#
#line 35
allow initrc_t init_t:fifo_file { ioctl read getattr lock write append };
#line 35

#line 35
#
#line 35
# Allow the new domain to read and execute the program.
#line 35
#
#line 35
allow initrc_t initrc_exec_t:file { read getattr lock execute ioctl };
#line 35

#line 35
#
#line 35
# Allow the new domain to be entered via the program.
#line 35
#
#line 35
allow initrc_t initrc_exec_t:file entrypoint;
#line 35

#line 35
type_transition init_t initrc_exec_t:process initrc_t;
#line 35


# Run the shell in the sysadm_t domain for single-user mode.

#line 38

#line 38

#line 38
#
#line 38
# Allow the process to transition to the new domain.
#line 38
#
#line 38
allow init_t sysadm_t:process transition;
#line 38

#line 38
#
#line 38
# Do not audit when glibc secure mode is enabled upon the transition.
#line 38
#
#line 38
dontaudit init_t sysadm_t:process noatsecure;
#line 38

#line 38
#
#line 38
# Do not audit when signal-related state is cleared upon the transition.
#line 38
#
#line 38
dontaudit init_t sysadm_t:process siginh;
#line 38

#line 38
#
#line 38
# Do not audit when resource limits are reset upon the transition.
#line 38
#
#line 38
dontaudit init_t sysadm_t:process rlimitinh;
#line 38

#line 38
#
#line 38
# Allow the process to execute the program.
#line 38
# 
#line 38
allow init_t shell_exec_t:file { read { getattr execute } };
#line 38

#line 38
#
#line 38
# Allow the process to reap the new domain.
#line 38
#
#line 38
allow sysadm_t init_t:process sigchld;
#line 38

#line 38
#
#line 38
# Allow the new domain to inherit and use file 
#line 38
# descriptions from the creating process and vice versa.
#line 38
#
#line 38
allow sysadm_t init_t:fd use;
#line 38
allow init_t sysadm_t:fd use;
#line 38

#line 38
#
#line 38
# Allow the new domain to write back to the old domain via a pipe.
#line 38
#
#line 38
allow sysadm_t init_t:fifo_file { ioctl read getattr lock write append };
#line 38

#line 38
#
#line 38
# Allow the new domain to read and execute the program.
#line 38
#
#line 38
allow sysadm_t shell_exec_t:file { read getattr lock execute ioctl };
#line 38

#line 38
#
#line 38
# Allow the new domain to be entered via the program.
#line 38
#
#line 38
allow sysadm_t shell_exec_t:file entrypoint;
#line 38

#line 38
type_transition init_t shell_exec_t:process sysadm_t;
#line 38


# Run /sbin/update in the init_t domain.

#line 41
allow init_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 41


# Run init.

#line 44
allow init_t init_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 44


# Run chroot from initrd scripts.
#line 49


# Create /dev/initctl.

#line 52

#line 52

#line 52

#line 52
#
#line 52
# Allow the process to modify the directory.
#line 52
#
#line 52
allow init_t device_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 52

#line 52
#
#line 52
# Allow the process to create the file.
#line 52
#
#line 52

#line 52

#line 52

#line 52

#line 52

#line 52
allow init_t initctl_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 52

#line 52

#line 52

#line 52

#line 52

#line 52

#line 52

#line 52

#line 52

#line 52
type_transition init_t device_t:fifo_file initctl_t;
#line 52

#line 52

#line 55

#line 55

#line 55

#line 55

#line 55

#line 55
#
#line 55
# Allow the process to modify the directory.
#line 55
#
#line 55
allow init_t tmpfs_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 55

#line 55
#
#line 55
# Allow the process to create the file.
#line 55
#
#line 55

#line 55

#line 55

#line 55

#line 55

#line 55
allow init_t initctl_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 55

#line 55

#line 55

#line 55

#line 55

#line 55

#line 55

#line 55

#line 55

#line 55
type_transition init_t tmpfs_t:fifo_file initctl_t;
#line 55

#line 55

#line 55


# Create ioctl.save.

#line 58

#line 58

#line 58

#line 58
#
#line 58
# Allow the process to modify the directory.
#line 58
#
#line 58
allow init_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 58

#line 58
#
#line 58
# Allow the process to create the file.
#line 58
#
#line 58

#line 58

#line 58

#line 58

#line 58

#line 58
allow init_t etc_runtime_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58
type_transition init_t etc_t:file etc_runtime_t;
#line 58

#line 58


# Update /etc/ld.so.cache
allow init_t ld_so_cache_t:file { ioctl read getattr lock write append };

# Allow access to log files
allow init_t var_t:dir search;
allow init_t var_log_t:dir search;
allow init_t var_log_t:file { ioctl read getattr lock write append };


#line 68
allow init_t etc_t:lnk_file read;
#line 68
allow init_t lib_t:file { read getattr lock ioctl };
#line 68

#line 68
allow init_t locale_t:dir { read getattr lock search ioctl };
#line 68
allow init_t locale_t:file { read getattr lock ioctl };
#line 68
allow init_t locale_t:lnk_file { getattr read };
#line 68

#line 68


# Create unix sockets
allow init_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow init_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow init_t self:fifo_file { ioctl read getattr lock write append };

# Permissions required for system startup
allow init_t { bin_t sbin_t }:dir { read getattr lock search ioctl };
allow init_t { bin_t sbin_t }:{ file lnk_file } { read getattr lock ioctl };

# allow init to fork
allow init_t self:process { fork sigchld };

# Modify utmp.
allow init_t var_run_t:file { ioctl read getattr lock write append };
allow init_t initrc_var_run_t:file { setattr { ioctl read getattr lock write append } };

#line 85
allow init_t initrc_t:unix_stream_socket connectto;
#line 85


# For /var/run/shutdown.pid.

#line 88
type init_var_run_t, file_type, sysadmfile, pidfile;
#line 88

#line 88

#line 88

#line 88

#line 88

#line 88

#line 88
#
#line 88
# Allow the process to modify the directory.
#line 88
#
#line 88
allow init_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 88

#line 88
#
#line 88
# Allow the process to create the file.
#line 88
#
#line 88

#line 88

#line 88

#line 88

#line 88

#line 88
allow init_t init_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 88

#line 88

#line 88

#line 88

#line 88

#line 88

#line 88

#line 88

#line 88

#line 88
type_transition init_t var_run_t:file init_var_run_t;
#line 88

#line 88

#line 88

#line 88
allow init_t var_t:dir search;
#line 88
allow init_t init_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 88


# Shutdown permissions

#line 91
allow init_t proc_t:dir { read getattr lock search ioctl };
#line 91
allow init_t proc_t:file { read getattr lock ioctl };
#line 91
allow init_t proc_t:lnk_file { getattr read };
#line 91


#line 92
allow init_t self:dir { read getattr lock search ioctl };
#line 92
allow init_t self:file { read getattr lock ioctl };
#line 92
allow init_t self:lnk_file { getattr read };
#line 92

allow init_t devpts_t:dir { read getattr lock search ioctl };

# Modify wtmp.
allow init_t wtmp_t:file { ioctl read getattr lock write append };

# Kill all processes.
allow init_t domain:process { sigchld sigkill sigstop signull signal };

# Allow all processes to send SIGCHLD to init.
allow domain init_t:process { sigchld signull };

# If you load a new policy that removes active domains, processes can
# get stuck if you do not allow unlabeled processes to signal init
# If you load an incompatible policy, you should probably reboot,
# since you may have compromised system security.
allow unlabeled_t init_t:process sigchld;

# for loading policy
allow init_t policy_config_t:file { read getattr lock ioctl };

# Set booleans.

#line 114
# Get the selinuxfs mount point via /proc/self/mounts.
#line 114
allow init_t proc_t:dir search;
#line 114
allow init_t proc_t:lnk_file read;
#line 114
allow init_t self:dir search;
#line 114
allow init_t self:file { getattr read };
#line 114
# Access selinuxfs.
#line 114
allow init_t security_t:dir { read search getattr };
#line 114
allow init_t security_t:file { getattr read write };
#line 114
if (!secure_mode_policyload) {
#line 114
allow init_t security_t:security setbool;
#line 114
auditallow init_t security_t:security setbool;
#line 114
}

# Read and write the console and ttys.
allow init_t { tty_device_t console_device_t } :chr_file { ioctl read getattr lock write append };
#line 120

#line 120
allow init_t tmpfs_t:chr_file { ioctl read getattr lock write append };
#line 120

allow init_t ttyfile:chr_file { ioctl read getattr lock write append };
allow init_t ptyfile:chr_file { ioctl read getattr lock write append };

# Run system executables.

#line 125
allow init_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 125

#line 128

#line 128

#line 128
allow init_t consoletype_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 128

#line 128


# Run /etc/X11/prefdm.

#line 131
allow init_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 131


allow init_t lib_t:file { getattr read };

allow init_t devtty_t:chr_file { read write };
allow init_t ramfs_t:dir search;
allow init_t ramfs_t:sock_file write;

#line 138
allow init_t sysfs_t:dir { read getattr lock search ioctl };
#line 138
allow init_t sysfs_t:file { read getattr lock ioctl };
#line 138
allow init_t sysfs_t:lnk_file { getattr read };
#line 138



#line 140
allow init_t selinux_config_t:dir { read getattr lock search ioctl };
#line 140
allow init_t selinux_config_t:file { read getattr lock ioctl };
#line 140
allow init_t selinux_config_t:lnk_file { getattr read };
#line 140


# file descriptors inherited from the rootfs.
dontaudit init_t root_t:{ file chr_file } { read write }; 
#line 146

#line 146

#line 146

#line 146
typeattribute init_t unrestricted;
#line 146
typeattribute init_t privuser;
#line 146

#line 146
# Mount/unmount any filesystem. 
#line 146
allow init_t fs_type:filesystem *;
#line 146

#line 146
# Mount/unmount any filesystem with the context= option. 
#line 146
allow init_t file_type:filesystem *;
#line 146

#line 146
# Create/access any file in a labeled filesystem;
#line 146
allow init_t file_type:{ file chr_file } ~execmod;
#line 146
allow init_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 146
allow init_t sysctl_t:{ dir file } *;
#line 146
allow init_t device_type:{ chr_file blk_file } *;
#line 146
allow init_t mtrr_device_t:file *;
#line 146

#line 146
# Create/access other files.  fs_type is to pick up various
#line 146
# pseudo filesystem types that are applied to both the filesystem
#line 146
# and its files.
#line 146
allow init_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 146
allow init_t unlabeled_t:association { sendto recvfrom };
#line 146

#line 146
allow init_t proc_fs:{ dir file } *;
#line 146

#line 146
# For /proc/pid
#line 146

#line 146
allow init_t domain:dir { read getattr lock search ioctl };
#line 146
allow init_t domain:file { read getattr lock ioctl };
#line 146
allow init_t domain:lnk_file { getattr read };
#line 146

#line 146
# Write access is for setting attributes under /proc/self/attr.
#line 146
allow init_t self:file { ioctl read getattr lock write append };
#line 146

#line 146
# Read and write sysctls.
#line 146

#line 146
allow init_t sysctl_type:dir { read getattr lock search ioctl };
#line 146
allow init_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 146

#line 146

#line 146
# Access the network.
#line 146
allow init_t node_type:node *;
#line 146
allow init_t netif_type:netif *;
#line 146
allow init_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 146
allow init_t port_type:tcp_socket name_connect;
#line 146

#line 146
# Bind to any network address.
#line 146
allow init_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 146
allow init_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 146
allow init_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 146

#line 146
# Use/sendto/connectto sockets created by any domain.
#line 146
allow init_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 146

#line 146
# Use descriptors and pipes created by any domain.
#line 146
allow init_t domain:fd use;
#line 146
allow init_t domain:fifo_file { ioctl read getattr lock write append };
#line 146

#line 146
# Act upon any other process.
#line 146
allow init_t domain:process ~{ transition dyntransition execmem };
#line 146
# Transition to myself, to make get_ordered_context_list happy.
#line 146
allow init_t self:process transition;
#line 146

#line 146
if (allow_execmem) {
#line 146
# Allow making anonymous memory executable, e.g. 
#line 146
# for runtime-code generation or executable stack.
#line 146
allow init_t self:process execmem;
#line 146
}
#line 146

#line 146
if (allow_execmem && allow_execstack) {
#line 146
# Allow making the stack executable via mprotect.
#line 146
allow init_t self:process execstack;
#line 146
}
#line 146

#line 146
if (allow_execmod) {
#line 146
# Allow text relocations on system shared libraries, e.g. libGL.
#line 146

#line 146
allow init_t file_type:file execmod;
#line 146

#line 146
}
#line 146

#line 146
# Create/access any System V IPC objects.
#line 146
allow init_t domain:{ sem msgq shm } *;
#line 146
allow init_t domain:msg  { send receive };
#line 146

#line 146
# Access the security API.
#line 146
if (!secure_mode_policyload) {
#line 146
allow init_t security_t:security *;
#line 146
auditallow init_t security_t:security { load_policy setenforce setbool };
#line 146
}
#line 146
# Perform certain system operations that lacked individual capabilities.
#line 146
allow init_t kernel_t:system *;
#line 146

#line 146
# Use any Linux capability.
#line 146
allow init_t self:capability *;
#line 146

#line 146
# Set user information and skip authentication.
#line 146
allow init_t self:passwd *;
#line 146

#line 146
# Communicate via dbusd.
#line 146
allow init_t self:dbus *;
#line 146

#line 146
allow init_t system_dbusd_t:dbus *;
#line 146

#line 146

#line 146
# Get info via nscd.
#line 146
allow init_t self:nscd *;
#line 146

#line 146
allow init_t nscd_t:nscd *;
#line 146

#line 146

#line 146

#line 146


#line 1 "domains/program/innd.te"
#DESC INN - InterNetNews server
#
# Author:  Faye Coker <faye@lurking-grue.org>
# X-Debian-Packages: inn
#
################################

# Types for the server port and news spool.
#
type news_spool_t, file_type, sysadmfile;


# need privmail attribute so innd can access system_mail_t

#line 14

#line 14

#line 14

#line 14
type innd_t, domain, privlog, daemon , privmail, transitionbool;
#line 14
type innd_exec_t, file_type, sysadmfile, exec_type;
#line 14
dontaudit innd_t self:capability sys_tty_config;
#line 14

#line 14
role system_r types innd_t;
#line 14

#line 14
# Inherit and use descriptors from init.
#line 14
allow innd_t init_t:fd use;
#line 14
allow innd_t init_t:process sigchld;
#line 14
allow innd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 14

#line 14

#line 14
allow innd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow innd_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow innd_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow innd_t ld_so_t:file execute_no_trans;
#line 14
allow innd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow innd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow innd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow innd_t texrel_shlib_t:file execmod;
#line 14
allow innd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow innd_t device_t:dir search;
#line 14
allow innd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
allow innd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 14
allow innd_t { self proc_t }:lnk_file { getattr read };
#line 14

#line 14
allow innd_t device_t:dir { read getattr lock search ioctl };
#line 14

#line 14
allow innd_t udev_tdb_t:file { read getattr lock ioctl };
#line 14
allow innd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit innd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit innd_t unpriv_userdomain:fd use;
#line 14

#line 14

#line 14
allow innd_t sysfs_t:dir { read getattr lock search ioctl };
#line 14
allow innd_t sysfs_t:file { read getattr lock ioctl };
#line 14
allow innd_t sysfs_t:lnk_file { getattr read };
#line 14
 
#line 14

#line 14
allow innd_t autofs_t:dir { search getattr };
#line 14

#line 14
dontaudit innd_t { tty_device_t devpts_t }:chr_file { read write };
#line 14
dontaudit innd_t root_t:file { getattr read };
#line 14
 
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow innd_t sysctl_t:dir search;
#line 14
allow innd_t sysctl_kernel_t:dir search;
#line 14
allow innd_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14

#line 14
bool innd_disable_trans false;
#line 14
if (innd_disable_trans) {
#line 14

#line 14
allow initrc_t innd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t innd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14
 
#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow initrc_t innd_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit initrc_t innd_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit initrc_t innd_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit initrc_t innd_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow initrc_t innd_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow innd_t initrc_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow innd_t initrc_t:fd use;
#line 14
allow initrc_t innd_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow innd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow innd_t innd_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow innd_t innd_exec_t:file entrypoint;
#line 14

#line 14
type_transition initrc_t innd_exec_t:process innd_t;
#line 14

#line 14

#line 14
allow initrc_t innd_t:process { noatsecure siginh rlimitinh };
#line 14

#line 14
}
#line 14
 
#line 14
allow innd_t privfd:fd use;
#line 14

#line 14
allow innd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
# Create pid file.
#line 14
allow innd_t var_t:dir { getattr search };
#line 14

#line 14
type innd_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow innd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow innd_t innd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition innd_t var_run_t:file innd_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow innd_t var_t:dir search;
#line 14
allow innd_t innd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
allow innd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
# for daemons that look at /root on startup
#line 14
dontaudit innd_t sysadm_home_dir_t:dir search;
#line 14

#line 14
# for df
#line 14
allow innd_t fs_type:filesystem getattr;
#line 14
allow innd_t removable_t:filesystem getattr;
#line 14

#line 14

#line 14
allow innd_t etc_t:lnk_file read;
#line 14
allow innd_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow innd_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow innd_t locale_t:file { read getattr lock ioctl };
#line 14
allow innd_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14

#line 14
# for localization
#line 14
allow innd_t lib_t:file { getattr read };
#line 14


# allow innd to create files and directories of type news_spool_t

#line 17
allow innd_t news_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 17
allow innd_t news_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 17
allow innd_t news_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 17


# allow user domains to read files and directories these types

#line 20
allow userdomain { news_spool_t innd_var_lib_t innd_etc_t }:dir { read getattr lock search ioctl };
#line 20
allow userdomain { news_spool_t innd_var_lib_t innd_etc_t }:file { read getattr lock ioctl };
#line 20
allow userdomain { news_spool_t innd_var_lib_t innd_etc_t }:lnk_file { getattr read };
#line 20



#line 22
allow initrc_t innd_etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 22


#line 23
allow innd_t { innd_exec_t bin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23

#line 26

#line 26

#line 26
allow innd_t hostname_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 26

#line 26


allow innd_t var_spool_t:dir { getattr search };


#line 30

#line 30

#line 30

#line 30

#line 30

#line 30
#
#line 30
# Allow the domain to create and use tcp sockets.
#line 30
# Other kinds of sockets must be separately authorized for use.
#line 30
allow innd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 30

#line 30
allow innd_t unlabeled_t:association { sendto recvfrom };
#line 30

#line 30
#
#line 30
# Allow the domain to send or receive using any network interface.
#line 30
# netif_type is a type attribute for all network interface types.
#line 30
#
#line 30
allow innd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 30
#
#line 30
# Allow the domain to send to or receive from any node.
#line 30
# node_type is a type attribute for all node types.
#line 30
#
#line 30
allow innd_t node_type:node { tcp_send rawip_send };
#line 30
allow innd_t node_type:node { tcp_recv rawip_recv };
#line 30

#line 30
#
#line 30
# Allow the domain to send to or receive from any port.
#line 30
# port_type is a type attribute for all port types.
#line 30
#
#line 30

#line 30
allow innd_t port_type:tcp_socket { send_msg recv_msg };
#line 30

#line 30

#line 30
# XXX Allow binding to any node type.  Remove once
#line 30
# individual rules have been added to all domains that 
#line 30
# bind sockets. 
#line 30
allow innd_t node_type:tcp_socket node_bind;
#line 30
#
#line 30
# Allow access to network files including /etc/resolv.conf
#line 30
#
#line 30
allow innd_t net_conf_t:file { read getattr lock ioctl };
#line 30

#line 30
allow innd_t self:tcp_socket { listen accept };
#line 30

#line 30

#line 30

#line 30
#
#line 30
# Allow the domain to create and use tcp sockets.
#line 30
# Other kinds of sockets must be separately authorized for use.
#line 30
allow innd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 30

#line 30
allow innd_t unlabeled_t:association { sendto recvfrom };
#line 30

#line 30
#
#line 30
# Allow the domain to send or receive using any network interface.
#line 30
# netif_type is a type attribute for all network interface types.
#line 30
#
#line 30
allow innd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 30
#
#line 30
# Allow the domain to send to or receive from any node.
#line 30
# node_type is a type attribute for all node types.
#line 30
#
#line 30
allow innd_t node_type:node { tcp_send rawip_send };
#line 30
allow innd_t node_type:node { tcp_recv rawip_recv };
#line 30

#line 30
#
#line 30
# Allow the domain to send to or receive from any port.
#line 30
# port_type is a type attribute for all port types.
#line 30
#
#line 30

#line 30
allow innd_t port_type:tcp_socket { send_msg recv_msg };
#line 30

#line 30

#line 30
# XXX Allow binding to any node type.  Remove once
#line 30
# individual rules have been added to all domains that 
#line 30
# bind sockets. 
#line 30
allow innd_t node_type:tcp_socket node_bind;
#line 30
#
#line 30
# Allow access to network files including /etc/resolv.conf
#line 30
#
#line 30
allow innd_t net_conf_t:file { read getattr lock ioctl };
#line 30

#line 30
allow innd_t self:tcp_socket { connect };
#line 30

#line 30

#line 30

#line 30

#line 30

#line 30
#
#line 30
# Allow the domain to create and use udp sockets.
#line 30
# Other kinds of sockets must be separately authorized for use.
#line 30
allow innd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 30

#line 30
allow innd_t unlabeled_t:association { sendto recvfrom };
#line 30

#line 30
#
#line 30
# Allow the domain to send or receive using any network interface.
#line 30
# netif_type is a type attribute for all network interface types.
#line 30
#
#line 30
allow innd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 30
#
#line 30
# Allow the domain to send to or receive from any node.
#line 30
# node_type is a type attribute for all node types.
#line 30
#
#line 30
allow innd_t node_type:node { udp_send rawip_send };
#line 30
allow innd_t node_type:node { udp_recv rawip_recv };
#line 30

#line 30
#
#line 30
# Allow the domain to send to or receive from any port.
#line 30
# port_type is a type attribute for all port types.
#line 30
#
#line 30

#line 30
allow innd_t port_type:udp_socket { send_msg recv_msg };
#line 30

#line 30

#line 30
# XXX Allow binding to any node type.  Remove once
#line 30
# individual rules have been added to all domains that 
#line 30
# bind sockets. 
#line 30
allow innd_t node_type:udp_socket node_bind;
#line 30
#
#line 30
# Allow access to network files including /etc/resolv.conf
#line 30
#
#line 30
allow innd_t net_conf_t:file { read getattr lock ioctl };
#line 30

#line 30
allow innd_t self:udp_socket { connect };
#line 30

#line 30

#line 30

#line 30

#line 30

allow innd_t port_type:tcp_socket name_connect;

#line 32

#line 32
if (allow_ypbind) {
#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32
#
#line 32
# Allow the domain to create and use tcp sockets.
#line 32
# Other kinds of sockets must be separately authorized for use.
#line 32
allow innd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 32

#line 32
allow innd_t unlabeled_t:association { sendto recvfrom };
#line 32

#line 32
#
#line 32
# Allow the domain to send or receive using any network interface.
#line 32
# netif_type is a type attribute for all network interface types.
#line 32
#
#line 32
allow innd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 32
#
#line 32
# Allow the domain to send to or receive from any node.
#line 32
# node_type is a type attribute for all node types.
#line 32
#
#line 32
allow innd_t node_type:node { tcp_send rawip_send };
#line 32
allow innd_t node_type:node { tcp_recv rawip_recv };
#line 32

#line 32
#
#line 32
# Allow the domain to send to or receive from any port.
#line 32
# port_type is a type attribute for all port types.
#line 32
#
#line 32

#line 32
allow innd_t port_type:tcp_socket { send_msg recv_msg };
#line 32

#line 32

#line 32
# XXX Allow binding to any node type.  Remove once
#line 32
# individual rules have been added to all domains that 
#line 32
# bind sockets. 
#line 32
allow innd_t node_type:tcp_socket node_bind;
#line 32
#
#line 32
# Allow access to network files including /etc/resolv.conf
#line 32
#
#line 32
allow innd_t net_conf_t:file { read getattr lock ioctl };
#line 32

#line 32
allow innd_t self:tcp_socket { listen accept };
#line 32

#line 32

#line 32

#line 32
#
#line 32
# Allow the domain to create and use tcp sockets.
#line 32
# Other kinds of sockets must be separately authorized for use.
#line 32
allow innd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 32

#line 32
allow innd_t unlabeled_t:association { sendto recvfrom };
#line 32

#line 32
#
#line 32
# Allow the domain to send or receive using any network interface.
#line 32
# netif_type is a type attribute for all network interface types.
#line 32
#
#line 32
allow innd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 32
#
#line 32
# Allow the domain to send to or receive from any node.
#line 32
# node_type is a type attribute for all node types.
#line 32
#
#line 32
allow innd_t node_type:node { tcp_send rawip_send };
#line 32
allow innd_t node_type:node { tcp_recv rawip_recv };
#line 32

#line 32
#
#line 32
# Allow the domain to send to or receive from any port.
#line 32
# port_type is a type attribute for all port types.
#line 32
#
#line 32

#line 32
allow innd_t port_type:tcp_socket { send_msg recv_msg };
#line 32

#line 32

#line 32
# XXX Allow binding to any node type.  Remove once
#line 32
# individual rules have been added to all domains that 
#line 32
# bind sockets. 
#line 32
allow innd_t node_type:tcp_socket node_bind;
#line 32
#
#line 32
# Allow access to network files including /etc/resolv.conf
#line 32
#
#line 32
allow innd_t net_conf_t:file { read getattr lock ioctl };
#line 32

#line 32
allow innd_t self:tcp_socket { connect };
#line 32

#line 32

#line 32

#line 32

#line 32

#line 32
#
#line 32
# Allow the domain to create and use udp sockets.
#line 32
# Other kinds of sockets must be separately authorized for use.
#line 32
allow innd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 32

#line 32
allow innd_t unlabeled_t:association { sendto recvfrom };
#line 32

#line 32
#
#line 32
# Allow the domain to send or receive using any network interface.
#line 32
# netif_type is a type attribute for all network interface types.
#line 32
#
#line 32
allow innd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 32
#
#line 32
# Allow the domain to send to or receive from any node.
#line 32
# node_type is a type attribute for all node types.
#line 32
#
#line 32
allow innd_t node_type:node { udp_send rawip_send };
#line 32
allow innd_t node_type:node { udp_recv rawip_recv };
#line 32

#line 32
#
#line 32
# Allow the domain to send to or receive from any port.
#line 32
# port_type is a type attribute for all port types.
#line 32
#
#line 32

#line 32
allow innd_t port_type:udp_socket { send_msg recv_msg };
#line 32

#line 32

#line 32
# XXX Allow binding to any node type.  Remove once
#line 32
# individual rules have been added to all domains that 
#line 32
# bind sockets. 
#line 32
allow innd_t node_type:udp_socket node_bind;
#line 32
#
#line 32
# Allow access to network files including /etc/resolv.conf
#line 32
#
#line 32
allow innd_t net_conf_t:file { read getattr lock ioctl };
#line 32

#line 32
allow innd_t self:udp_socket { connect };
#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32
allow innd_t var_yp_t:dir { read getattr lock search ioctl };
#line 32
allow innd_t var_yp_t:file { read getattr lock ioctl };
#line 32
allow innd_t var_yp_t:lnk_file { getattr read };
#line 32

#line 32
allow innd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 32
allow innd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 32
dontaudit innd_t self:capability net_bind_service;
#line 32
dontaudit innd_t reserved_port_type:tcp_socket name_connect;
#line 32
dontaudit innd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 32

#line 32
} else {
#line 32
dontaudit innd_t var_yp_t:dir search;
#line 32
}
#line 32
 


#line 34
allow { innd_t sysadm_t } { innd_t sysadm_t } :unix_dgram_socket sendto;
#line 34

allow innd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow innd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

#line 37
allow innd_t self:unix_stream_socket connectto;
#line 37


allow innd_t self:fifo_file { ioctl read getattr lock write append };
allow innd_t innd_port_t:tcp_socket name_bind;

allow innd_t self:capability { dac_override kill setgid setuid net_bind_service };
allow innd_t self:process setsched;

allow innd_t { bin_t sbin_t }:dir search;
allow innd_t usr_t:lnk_file read;
allow innd_t usr_t:file { getattr read ioctl };
allow innd_t lib_t:file ioctl;
allow innd_t etc_t:file { getattr read };
allow innd_t { proc_t etc_runtime_t }:file { getattr read };
allow innd_t urandom_device_t:chr_file read;

allow innd_t innd_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };

# allow innd to read directories of type innd_etc_t (/etc/news/(/.*)? and symbolic links with that type

#line 56

#line 56
type innd_etc_t, file_type, sysadmfile, usercanread;
#line 56
allow innd_t innd_etc_t:file { read getattr lock ioctl };
#line 56

#line 56
allow innd_t innd_etc_t:dir { read getattr lock search ioctl };
#line 56
allow innd_t innd_etc_t:lnk_file { getattr read };
#line 56


# allow innd to create files under /var/log of type innd_log_t and have a directory for its own files that
# it can write to

#line 60

#line 60
type innd_log_t, file_type, sysadmfile, logfile;
#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the process to modify the directory.
#line 60
#
#line 60
allow innd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 60

#line 60
#
#line 60
# Allow the process to create the file.
#line 60
#
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
allow innd_t innd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
type_transition innd_t var_log_t:file innd_log_t;
#line 60

#line 60

#line 60

#line 60
allow innd_t innd_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 60


# allow innd read-write directory permissions to /var/lib/news.

#line 63
type innd_var_lib_t, file_type, sysadmfile;
#line 63

#line 63

#line 63

#line 63

#line 63
#
#line 63
# Allow the process to modify the directory.
#line 63
#
#line 63
allow innd_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 63

#line 63
#
#line 63
# Allow the process to create the file.
#line 63
#
#line 63

#line 63

#line 63

#line 63

#line 63

#line 63
allow innd_t innd_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 63

#line 63

#line 63

#line 63

#line 63

#line 63

#line 63

#line 63

#line 63

#line 63
type_transition innd_t var_lib_t:file innd_var_lib_t;
#line 63

#line 63

#line 63
allow innd_t innd_var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 63


#line 70

#line 70

#line 70

#line 70

#line 70

#line 70

#line 70
#
#line 70
# Allow the process to transition to the new domain.
#line 70
#
#line 70
allow system_crond_t innd_t:process transition;
#line 70

#line 70
#
#line 70
# Do not audit when glibc secure mode is enabled upon the transition.
#line 70
#
#line 70
dontaudit system_crond_t innd_t:process noatsecure;
#line 70

#line 70
#
#line 70
# Do not audit when signal-related state is cleared upon the transition.
#line 70
#
#line 70
dontaudit system_crond_t innd_t:process siginh;
#line 70

#line 70
#
#line 70
# Do not audit when resource limits are reset upon the transition.
#line 70
#
#line 70
dontaudit system_crond_t innd_t:process rlimitinh;
#line 70

#line 70
#
#line 70
# Allow the process to execute the program.
#line 70
# 
#line 70
allow system_crond_t innd_exec_t:file { read { getattr execute } };
#line 70

#line 70
#
#line 70
# Allow the process to reap the new domain.
#line 70
#
#line 70
allow innd_t system_crond_t:process sigchld;
#line 70

#line 70
#
#line 70
# Allow the new domain to inherit and use file 
#line 70
# descriptions from the creating process and vice versa.
#line 70
#
#line 70
allow innd_t system_crond_t:fd use;
#line 70
allow system_crond_t innd_t:fd use;
#line 70

#line 70
#
#line 70
# Allow the new domain to write back to the old domain via a pipe.
#line 70
#
#line 70
allow innd_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 70

#line 70
#
#line 70
# Allow the new domain to read and execute the program.
#line 70
#
#line 70
allow innd_t innd_exec_t:file { read getattr lock execute ioctl };
#line 70

#line 70
#
#line 70
# Allow the new domain to be entered via the program.
#line 70
#
#line 70
allow innd_t innd_exec_t:file entrypoint;
#line 70

#line 70
type_transition system_crond_t innd_exec_t:process innd_t;
#line 70

#line 70
allow innd_t crond_t:fifo_file { getattr read write ioctl };
#line 70
# a rule for privfd may make this obsolete
#line 70
allow innd_t crond_t:fd use;
#line 70
allow innd_t crond_t:process sigchld;
#line 70

#line 70
allow system_crond_t innd_etc_t:file { getattr read };
#line 70

#line 70
allow system_crond_t innd_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 70
allow system_crond_t innd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 70
allow system_crond_t innd_log_t:lnk_file { create read getattr setattr link unlink rename };
#line 70

#line 70

#line 70
allow system_crond_t innd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 70
allow system_crond_t innd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 70
allow system_crond_t innd_var_run_t:lnk_file { create read getattr setattr link unlink rename };
#line 70

#line 70


#line 75

#line 75
allow syslogd_t innd_log_t:dir search;
#line 75
allow syslogd_t innd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 75


allow innd_t self:file { getattr read };
dontaudit innd_t selinux_config_t:dir { search };
allow system_crond_t innd_etc_t:file { getattr read };
allow innd_t bin_t:lnk_file { read };
allow innd_t sbin_t:lnk_file { read };
#line 1 "domains/program/kerberos.te"
#DESC Kerberos5 - MIT Kerberos5
# supports krb5kdc and kadmind daemons
# kinit, kdestroy, klist clients
# ksu support not complete
#
# includes rules for OpenSSH daemon compiled with both
# kerberos5 and SELinux support
#
# Not supported : telnetd, ftpd, kprop/kpropd daemons
#
# Author:   Kerry Thompson <kerry@crypt.gen.nz>
# Modified by Colin Walters <walters@redhat.com>
# 

#################################
#
# Rules for the krb5kdc_t,kadmind_t domains.
#

#line 19

#line 19

#line 19

#line 19
type krb5kdc_t, domain, privlog, daemon , transitionbool;
#line 19
type krb5kdc_exec_t, file_type, sysadmfile, exec_type;
#line 19
dontaudit krb5kdc_t self:capability sys_tty_config;
#line 19

#line 19
role system_r types krb5kdc_t;
#line 19

#line 19
# Inherit and use descriptors from init.
#line 19
allow krb5kdc_t init_t:fd use;
#line 19
allow krb5kdc_t init_t:process sigchld;
#line 19
allow krb5kdc_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 19

#line 19

#line 19
allow krb5kdc_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 19
allow krb5kdc_t lib_t:lnk_file { read getattr lock ioctl };
#line 19
allow krb5kdc_t ld_so_t:file { read getattr lock execute ioctl };
#line 19
#allow krb5kdc_t ld_so_t:file execute_no_trans;
#line 19
allow krb5kdc_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 19
allow krb5kdc_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 19
allow krb5kdc_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 19
allow krb5kdc_t texrel_shlib_t:file execmod;
#line 19
allow krb5kdc_t ld_so_cache_t:file { read getattr lock ioctl };
#line 19
allow krb5kdc_t device_t:dir search;
#line 19
allow krb5kdc_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 19

#line 19

#line 19
allow krb5kdc_t { self proc_t }:dir { read getattr lock search ioctl };
#line 19
allow krb5kdc_t { self proc_t }:lnk_file { getattr read };
#line 19

#line 19
allow krb5kdc_t device_t:dir { read getattr lock search ioctl };
#line 19

#line 19
allow krb5kdc_t udev_tdb_t:file { read getattr lock ioctl };
#line 19
allow krb5kdc_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 19
dontaudit krb5kdc_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 19
dontaudit krb5kdc_t unpriv_userdomain:fd use;
#line 19

#line 19

#line 19
allow krb5kdc_t sysfs_t:dir { read getattr lock search ioctl };
#line 19
allow krb5kdc_t sysfs_t:file { read getattr lock ioctl };
#line 19
allow krb5kdc_t sysfs_t:lnk_file { getattr read };
#line 19
 
#line 19

#line 19
allow krb5kdc_t autofs_t:dir { search getattr };
#line 19

#line 19
dontaudit krb5kdc_t { tty_device_t devpts_t }:chr_file { read write };
#line 19
dontaudit krb5kdc_t root_t:file { getattr read };
#line 19
 
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
# Read system variables in /sys.
#line 19

#line 19
allow krb5kdc_t sysctl_t:dir search;
#line 19
allow krb5kdc_t sysctl_kernel_t:dir search;
#line 19
allow krb5kdc_t sysctl_kernel_t:file { getattr read };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allows user to define a tunable to disable domain transition
#line 19
#
#line 19

#line 19
bool krb5kdc_disable_trans false;
#line 19
if (krb5kdc_disable_trans) {
#line 19

#line 19
allow initrc_t krb5kdc_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 19

#line 19

#line 19
allow sysadm_t krb5kdc_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 19

#line 19
} else {
#line 19
 
#line 19

#line 19

#line 19
#
#line 19
# Allow the process to transition to the new domain.
#line 19
#
#line 19
allow initrc_t krb5kdc_t:process transition;
#line 19

#line 19
#
#line 19
# Do not audit when glibc secure mode is enabled upon the transition.
#line 19
#
#line 19
dontaudit initrc_t krb5kdc_t:process noatsecure;
#line 19

#line 19
#
#line 19
# Do not audit when signal-related state is cleared upon the transition.
#line 19
#
#line 19
dontaudit initrc_t krb5kdc_t:process siginh;
#line 19

#line 19
#
#line 19
# Do not audit when resource limits are reset upon the transition.
#line 19
#
#line 19
dontaudit initrc_t krb5kdc_t:process rlimitinh;
#line 19

#line 19
#
#line 19
# Allow the process to execute the program.
#line 19
# 
#line 19
allow initrc_t krb5kdc_exec_t:file { read { getattr execute } };
#line 19

#line 19
#
#line 19
# Allow the process to reap the new domain.
#line 19
#
#line 19
allow krb5kdc_t initrc_t:process sigchld;
#line 19

#line 19
#
#line 19
# Allow the new domain to inherit and use file 
#line 19
# descriptions from the creating process and vice versa.
#line 19
#
#line 19
allow krb5kdc_t initrc_t:fd use;
#line 19
allow initrc_t krb5kdc_t:fd use;
#line 19

#line 19
#
#line 19
# Allow the new domain to write back to the old domain via a pipe.
#line 19
#
#line 19
allow krb5kdc_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 19

#line 19
#
#line 19
# Allow the new domain to read and execute the program.
#line 19
#
#line 19
allow krb5kdc_t krb5kdc_exec_t:file { read getattr lock execute ioctl };
#line 19

#line 19
#
#line 19
# Allow the new domain to be entered via the program.
#line 19
#
#line 19
allow krb5kdc_t krb5kdc_exec_t:file entrypoint;
#line 19

#line 19
type_transition initrc_t krb5kdc_exec_t:process krb5kdc_t;
#line 19

#line 19

#line 19
allow initrc_t krb5kdc_t:process { noatsecure siginh rlimitinh };
#line 19

#line 19
}
#line 19
 
#line 19
allow krb5kdc_t privfd:fd use;
#line 19

#line 19
allow krb5kdc_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 19

#line 19

#line 19
# Create pid file.
#line 19
allow krb5kdc_t var_t:dir { getattr search };
#line 19

#line 19
type krb5kdc_var_run_t, file_type, sysadmfile, pidfile;
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the process to modify the directory.
#line 19
#
#line 19
allow krb5kdc_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 19

#line 19
#
#line 19
# Allow the process to create the file.
#line 19
#
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow krb5kdc_t krb5kdc_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
type_transition krb5kdc_t var_run_t:file krb5kdc_var_run_t;
#line 19

#line 19

#line 19

#line 19
allow krb5kdc_t var_t:dir search;
#line 19
allow krb5kdc_t krb5kdc_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 19

#line 19

#line 19
allow krb5kdc_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 19

#line 19
# for daemons that look at /root on startup
#line 19
dontaudit krb5kdc_t sysadm_home_dir_t:dir search;
#line 19

#line 19
# for df
#line 19
allow krb5kdc_t fs_type:filesystem getattr;
#line 19
allow krb5kdc_t removable_t:filesystem getattr;
#line 19

#line 19

#line 19
allow krb5kdc_t etc_t:lnk_file read;
#line 19
allow krb5kdc_t lib_t:file { read getattr lock ioctl };
#line 19

#line 19
allow krb5kdc_t locale_t:dir { read getattr lock search ioctl };
#line 19
allow krb5kdc_t locale_t:file { read getattr lock ioctl };
#line 19
allow krb5kdc_t locale_t:lnk_file { getattr read };
#line 19

#line 19

#line 19

#line 19
# for localization
#line 19
allow krb5kdc_t lib_t:file { getattr read };
#line 19


#line 20

#line 20

#line 20

#line 20
type kadmind_t, domain, privlog, daemon , transitionbool;
#line 20
type kadmind_exec_t, file_type, sysadmfile, exec_type;
#line 20
dontaudit kadmind_t self:capability sys_tty_config;
#line 20

#line 20
role system_r types kadmind_t;
#line 20

#line 20
# Inherit and use descriptors from init.
#line 20
allow kadmind_t init_t:fd use;
#line 20
allow kadmind_t init_t:process sigchld;
#line 20
allow kadmind_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 20

#line 20

#line 20
allow kadmind_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 20
allow kadmind_t lib_t:lnk_file { read getattr lock ioctl };
#line 20
allow kadmind_t ld_so_t:file { read getattr lock execute ioctl };
#line 20
#allow kadmind_t ld_so_t:file execute_no_trans;
#line 20
allow kadmind_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 20
allow kadmind_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 20
allow kadmind_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 20
allow kadmind_t texrel_shlib_t:file execmod;
#line 20
allow kadmind_t ld_so_cache_t:file { read getattr lock ioctl };
#line 20
allow kadmind_t device_t:dir search;
#line 20
allow kadmind_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 20

#line 20

#line 20
allow kadmind_t { self proc_t }:dir { read getattr lock search ioctl };
#line 20
allow kadmind_t { self proc_t }:lnk_file { getattr read };
#line 20

#line 20
allow kadmind_t device_t:dir { read getattr lock search ioctl };
#line 20

#line 20
allow kadmind_t udev_tdb_t:file { read getattr lock ioctl };
#line 20
allow kadmind_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 20
dontaudit kadmind_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 20
dontaudit kadmind_t unpriv_userdomain:fd use;
#line 20

#line 20

#line 20
allow kadmind_t sysfs_t:dir { read getattr lock search ioctl };
#line 20
allow kadmind_t sysfs_t:file { read getattr lock ioctl };
#line 20
allow kadmind_t sysfs_t:lnk_file { getattr read };
#line 20
 
#line 20

#line 20
allow kadmind_t autofs_t:dir { search getattr };
#line 20

#line 20
dontaudit kadmind_t { tty_device_t devpts_t }:chr_file { read write };
#line 20
dontaudit kadmind_t root_t:file { getattr read };
#line 20
 
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
# Read system variables in /sys.
#line 20

#line 20
allow kadmind_t sysctl_t:dir search;
#line 20
allow kadmind_t sysctl_kernel_t:dir search;
#line 20
allow kadmind_t sysctl_kernel_t:file { getattr read };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allows user to define a tunable to disable domain transition
#line 20
#
#line 20

#line 20
bool kadmind_disable_trans false;
#line 20
if (kadmind_disable_trans) {
#line 20

#line 20
allow initrc_t kadmind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 20

#line 20

#line 20
allow sysadm_t kadmind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 20

#line 20
} else {
#line 20
 
#line 20

#line 20

#line 20
#
#line 20
# Allow the process to transition to the new domain.
#line 20
#
#line 20
allow initrc_t kadmind_t:process transition;
#line 20

#line 20
#
#line 20
# Do not audit when glibc secure mode is enabled upon the transition.
#line 20
#
#line 20
dontaudit initrc_t kadmind_t:process noatsecure;
#line 20

#line 20
#
#line 20
# Do not audit when signal-related state is cleared upon the transition.
#line 20
#
#line 20
dontaudit initrc_t kadmind_t:process siginh;
#line 20

#line 20
#
#line 20
# Do not audit when resource limits are reset upon the transition.
#line 20
#
#line 20
dontaudit initrc_t kadmind_t:process rlimitinh;
#line 20

#line 20
#
#line 20
# Allow the process to execute the program.
#line 20
# 
#line 20
allow initrc_t kadmind_exec_t:file { read { getattr execute } };
#line 20

#line 20
#
#line 20
# Allow the process to reap the new domain.
#line 20
#
#line 20
allow kadmind_t initrc_t:process sigchld;
#line 20

#line 20
#
#line 20
# Allow the new domain to inherit and use file 
#line 20
# descriptions from the creating process and vice versa.
#line 20
#
#line 20
allow kadmind_t initrc_t:fd use;
#line 20
allow initrc_t kadmind_t:fd use;
#line 20

#line 20
#
#line 20
# Allow the new domain to write back to the old domain via a pipe.
#line 20
#
#line 20
allow kadmind_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 20

#line 20
#
#line 20
# Allow the new domain to read and execute the program.
#line 20
#
#line 20
allow kadmind_t kadmind_exec_t:file { read getattr lock execute ioctl };
#line 20

#line 20
#
#line 20
# Allow the new domain to be entered via the program.
#line 20
#
#line 20
allow kadmind_t kadmind_exec_t:file entrypoint;
#line 20

#line 20
type_transition initrc_t kadmind_exec_t:process kadmind_t;
#line 20

#line 20

#line 20
allow initrc_t kadmind_t:process { noatsecure siginh rlimitinh };
#line 20

#line 20
}
#line 20
 
#line 20
allow kadmind_t privfd:fd use;
#line 20

#line 20
allow kadmind_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 20

#line 20

#line 20
# Create pid file.
#line 20
allow kadmind_t var_t:dir { getattr search };
#line 20

#line 20
type kadmind_var_run_t, file_type, sysadmfile, pidfile;
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the process to modify the directory.
#line 20
#
#line 20
allow kadmind_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 20

#line 20
#
#line 20
# Allow the process to create the file.
#line 20
#
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
allow kadmind_t kadmind_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
type_transition kadmind_t var_run_t:file kadmind_var_run_t;
#line 20

#line 20

#line 20

#line 20
allow kadmind_t var_t:dir search;
#line 20
allow kadmind_t kadmind_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 20

#line 20

#line 20
allow kadmind_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 20

#line 20
# for daemons that look at /root on startup
#line 20
dontaudit kadmind_t sysadm_home_dir_t:dir search;
#line 20

#line 20
# for df
#line 20
allow kadmind_t fs_type:filesystem getattr;
#line 20
allow kadmind_t removable_t:filesystem getattr;
#line 20

#line 20

#line 20
allow kadmind_t etc_t:lnk_file read;
#line 20
allow kadmind_t lib_t:file { read getattr lock ioctl };
#line 20

#line 20
allow kadmind_t locale_t:dir { read getattr lock search ioctl };
#line 20
allow kadmind_t locale_t:file { read getattr lock ioctl };
#line 20
allow kadmind_t locale_t:lnk_file { getattr read };
#line 20

#line 20

#line 20

#line 20
# for localization
#line 20
allow kadmind_t lib_t:file { getattr read };
#line 20



#line 22
allow krb5kdc_t krb5kdc_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 22


#line 23
allow kadmind_t kadmind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23


# types for general configuration files in /etc
type krb5_keytab_t, file_type, sysadmfile, secure_file_type;

# types for KDC configs and principal file(s)
type krb5kdc_conf_t, file_type, sysadmfile;
type krb5kdc_principal_t, file_type, sysadmfile;

# Use capabilities. Surplus capabilities may be allowed.
allow krb5kdc_t self:capability { setuid setgid net_admin net_bind_service chown fowner dac_override sys_nice };
allow kadmind_t self:capability { setuid setgid net_bind_service chown fowner dac_override sys_nice };

# krb5kdc and kadmind can use network

#line 37

#line 37

#line 37

#line 37
#
#line 37
# Allow the domain to create and use tcp sockets.
#line 37
# Other kinds of sockets must be separately authorized for use.
#line 37
allow { krb5kdc_t kadmind_t }  self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 37

#line 37
allow { krb5kdc_t kadmind_t }  unlabeled_t:association { sendto recvfrom };
#line 37

#line 37
#
#line 37
# Allow the domain to send or receive using any network interface.
#line 37
# netif_type is a type attribute for all network interface types.
#line 37
#
#line 37
allow { krb5kdc_t kadmind_t }  netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 37
#
#line 37
# Allow the domain to send to or receive from any node.
#line 37
# node_type is a type attribute for all node types.
#line 37
#
#line 37
allow { krb5kdc_t kadmind_t }  node_type:node { tcp_send rawip_send };
#line 37
allow { krb5kdc_t kadmind_t }  node_type:node { tcp_recv rawip_recv };
#line 37

#line 37
#
#line 37
# Allow the domain to send to or receive from any port.
#line 37
# port_type is a type attribute for all port types.
#line 37
#
#line 37

#line 37
allow { krb5kdc_t kadmind_t }  port_type:tcp_socket { send_msg recv_msg };
#line 37

#line 37

#line 37
# XXX Allow binding to any node type.  Remove once
#line 37
# individual rules have been added to all domains that 
#line 37
# bind sockets. 
#line 37
allow { krb5kdc_t kadmind_t }  node_type:tcp_socket node_bind;
#line 37
#
#line 37
# Allow access to network files including /etc/resolv.conf
#line 37
#
#line 37
allow { krb5kdc_t kadmind_t }  net_conf_t:file { read getattr lock ioctl };
#line 37

#line 37
allow { krb5kdc_t kadmind_t }  self:tcp_socket { listen accept };
#line 37

#line 37

#line 37

#line 37
#
#line 37
# Allow the domain to create and use udp sockets.
#line 37
# Other kinds of sockets must be separately authorized for use.
#line 37
allow { krb5kdc_t kadmind_t }  self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 37

#line 37
allow { krb5kdc_t kadmind_t }  unlabeled_t:association { sendto recvfrom };
#line 37

#line 37
#
#line 37
# Allow the domain to send or receive using any network interface.
#line 37
# netif_type is a type attribute for all network interface types.
#line 37
#
#line 37
allow { krb5kdc_t kadmind_t }  netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 37
#
#line 37
# Allow the domain to send to or receive from any node.
#line 37
# node_type is a type attribute for all node types.
#line 37
#
#line 37
allow { krb5kdc_t kadmind_t }  node_type:node { udp_send rawip_send };
#line 37
allow { krb5kdc_t kadmind_t }  node_type:node { udp_recv rawip_recv };
#line 37

#line 37
#
#line 37
# Allow the domain to send to or receive from any port.
#line 37
# port_type is a type attribute for all port types.
#line 37
#
#line 37

#line 37
allow { krb5kdc_t kadmind_t }  port_type:udp_socket { send_msg recv_msg };
#line 37

#line 37

#line 37
# XXX Allow binding to any node type.  Remove once
#line 37
# individual rules have been added to all domains that 
#line 37
# bind sockets. 
#line 37
allow { krb5kdc_t kadmind_t }  node_type:udp_socket node_bind;
#line 37
#
#line 37
# Allow access to network files including /etc/resolv.conf
#line 37
#
#line 37
allow { krb5kdc_t kadmind_t }  net_conf_t:file { read getattr lock ioctl };
#line 37

#line 37
allow { krb5kdc_t kadmind_t }  self:udp_socket { connect };
#line 37

#line 37

#line 37


#line 38

#line 38
if (allow_ypbind) {
#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38
#
#line 38
# Allow the domain to create and use tcp sockets.
#line 38
# Other kinds of sockets must be separately authorized for use.
#line 38
allow { krb5kdc_t kadmind_t }  self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  unlabeled_t:association { sendto recvfrom };
#line 38

#line 38
#
#line 38
# Allow the domain to send or receive using any network interface.
#line 38
# netif_type is a type attribute for all network interface types.
#line 38
#
#line 38
allow { krb5kdc_t kadmind_t }  netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 38
#
#line 38
# Allow the domain to send to or receive from any node.
#line 38
# node_type is a type attribute for all node types.
#line 38
#
#line 38
allow { krb5kdc_t kadmind_t }  node_type:node { tcp_send rawip_send };
#line 38
allow { krb5kdc_t kadmind_t }  node_type:node { tcp_recv rawip_recv };
#line 38

#line 38
#
#line 38
# Allow the domain to send to or receive from any port.
#line 38
# port_type is a type attribute for all port types.
#line 38
#
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  port_type:tcp_socket { send_msg recv_msg };
#line 38

#line 38

#line 38
# XXX Allow binding to any node type.  Remove once
#line 38
# individual rules have been added to all domains that 
#line 38
# bind sockets. 
#line 38
allow { krb5kdc_t kadmind_t }  node_type:tcp_socket node_bind;
#line 38
#
#line 38
# Allow access to network files including /etc/resolv.conf
#line 38
#
#line 38
allow { krb5kdc_t kadmind_t }  net_conf_t:file { read getattr lock ioctl };
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  self:tcp_socket { listen accept };
#line 38

#line 38

#line 38

#line 38
#
#line 38
# Allow the domain to create and use tcp sockets.
#line 38
# Other kinds of sockets must be separately authorized for use.
#line 38
allow { krb5kdc_t kadmind_t }  self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  unlabeled_t:association { sendto recvfrom };
#line 38

#line 38
#
#line 38
# Allow the domain to send or receive using any network interface.
#line 38
# netif_type is a type attribute for all network interface types.
#line 38
#
#line 38
allow { krb5kdc_t kadmind_t }  netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 38
#
#line 38
# Allow the domain to send to or receive from any node.
#line 38
# node_type is a type attribute for all node types.
#line 38
#
#line 38
allow { krb5kdc_t kadmind_t }  node_type:node { tcp_send rawip_send };
#line 38
allow { krb5kdc_t kadmind_t }  node_type:node { tcp_recv rawip_recv };
#line 38

#line 38
#
#line 38
# Allow the domain to send to or receive from any port.
#line 38
# port_type is a type attribute for all port types.
#line 38
#
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  port_type:tcp_socket { send_msg recv_msg };
#line 38

#line 38

#line 38
# XXX Allow binding to any node type.  Remove once
#line 38
# individual rules have been added to all domains that 
#line 38
# bind sockets. 
#line 38
allow { krb5kdc_t kadmind_t }  node_type:tcp_socket node_bind;
#line 38
#
#line 38
# Allow access to network files including /etc/resolv.conf
#line 38
#
#line 38
allow { krb5kdc_t kadmind_t }  net_conf_t:file { read getattr lock ioctl };
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  self:tcp_socket { connect };
#line 38

#line 38

#line 38

#line 38

#line 38

#line 38
#
#line 38
# Allow the domain to create and use udp sockets.
#line 38
# Other kinds of sockets must be separately authorized for use.
#line 38
allow { krb5kdc_t kadmind_t }  self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  unlabeled_t:association { sendto recvfrom };
#line 38

#line 38
#
#line 38
# Allow the domain to send or receive using any network interface.
#line 38
# netif_type is a type attribute for all network interface types.
#line 38
#
#line 38
allow { krb5kdc_t kadmind_t }  netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 38
#
#line 38
# Allow the domain to send to or receive from any node.
#line 38
# node_type is a type attribute for all node types.
#line 38
#
#line 38
allow { krb5kdc_t kadmind_t }  node_type:node { udp_send rawip_send };
#line 38
allow { krb5kdc_t kadmind_t }  node_type:node { udp_recv rawip_recv };
#line 38

#line 38
#
#line 38
# Allow the domain to send to or receive from any port.
#line 38
# port_type is a type attribute for all port types.
#line 38
#
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  port_type:udp_socket { send_msg recv_msg };
#line 38

#line 38

#line 38
# XXX Allow binding to any node type.  Remove once
#line 38
# individual rules have been added to all domains that 
#line 38
# bind sockets. 
#line 38
allow { krb5kdc_t kadmind_t }  node_type:udp_socket node_bind;
#line 38
#
#line 38
# Allow access to network files including /etc/resolv.conf
#line 38
#
#line 38
allow { krb5kdc_t kadmind_t }  net_conf_t:file { read getattr lock ioctl };
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  self:udp_socket { connect };
#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38
allow { krb5kdc_t kadmind_t }  var_yp_t:dir { read getattr lock search ioctl };
#line 38
allow { krb5kdc_t kadmind_t }  var_yp_t:file { read getattr lock ioctl };
#line 38
allow { krb5kdc_t kadmind_t }  var_yp_t:lnk_file { getattr read };
#line 38

#line 38
allow { krb5kdc_t kadmind_t }  { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 38
allow { krb5kdc_t kadmind_t }  { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 38
dontaudit { krb5kdc_t kadmind_t }  self:capability net_bind_service;
#line 38
dontaudit { krb5kdc_t kadmind_t }  reserved_port_type:tcp_socket name_connect;
#line 38
dontaudit { krb5kdc_t kadmind_t }  reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 38

#line 38
} else {
#line 38
dontaudit { krb5kdc_t kadmind_t }  var_yp_t:dir search;
#line 38
}
#line 38
 

# allow UDP transfer to/from any program

#line 41
#allow kerberos_port_t krb5kdc_t:udp_socket sendto;
#line 41
#allow krb5kdc_t kerberos_port_t:udp_socket recvfrom;
#line 41


#line 42
#allow krb5kdc_t kerberos_port_t:udp_socket sendto;
#line 42
#allow kerberos_port_t krb5kdc_t:udp_socket recvfrom;
#line 42


#line 43
#allow kerberos_port_t krb5kdc_t:tcp_socket { connectto recvfrom };
#line 43
#allow krb5kdc_t kerberos_port_t:tcp_socket { acceptfrom recvfrom };
#line 43
#allow krb5kdc_t kernel_t:tcp_socket recvfrom;
#line 43
#allow kerberos_port_t kernel_t:tcp_socket recvfrom;
#line 43


#line 44
#allow kerberos_admin_port_t kadmind_t:tcp_socket { connectto recvfrom };
#line 44
#allow kadmind_t kerberos_admin_port_t:tcp_socket { acceptfrom recvfrom };
#line 44
#allow kadmind_t kernel_t:tcp_socket recvfrom;
#line 44
#allow kerberos_admin_port_t kernel_t:tcp_socket recvfrom;
#line 44


# Bind to the kerberos, kerberos-adm ports.
allow krb5kdc_t kerberos_port_t:{ udp_socket tcp_socket } name_bind;
allow kadmind_t kerberos_admin_port_t:{ udp_socket tcp_socket } name_bind;
allow kadmind_t reserved_port_t:tcp_socket name_bind;
dontaudit kadmind_t reserved_port_type:tcp_socket name_bind;

#
# Rules for Kerberos5 KDC daemon
allow krb5kdc_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow krb5kdc_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow kadmind_t  self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow krb5kdc_t krb5kdc_conf_t:dir search;
allow krb5kdc_t krb5kdc_conf_t:file { read getattr lock ioctl };
allow krb5kdc_t krb5kdc_principal_t:file { read getattr lock ioctl };
dontaudit krb5kdc_t krb5kdc_principal_t:file write;
allow krb5kdc_t locale_t:file { getattr read };
dontaudit krb5kdc_t krb5kdc_conf_t:file write;
allow { kadmind_t krb5kdc_t } etc_t:dir { getattr search };
allow { kadmind_t krb5kdc_t } etc_t:file { getattr read };
allow { kadmind_t krb5kdc_t } krb5_conf_t:file { read getattr lock ioctl };
dontaudit { kadmind_t krb5kdc_t } krb5_conf_t:file write;

#line 67
type krb5kdc_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 67

#line 67

#line 67

#line 67

#line 67
#
#line 67
# Allow the process to modify the directory.
#line 67
#
#line 67
allow krb5kdc_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 67

#line 67
#
#line 67
# Allow the process to create the file.
#line 67
#
#line 67

#line 67

#line 67

#line 67

#line 67

#line 67
allow krb5kdc_t krb5kdc_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67
allow krb5kdc_t krb5kdc_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67

#line 67
type_transition krb5kdc_t tmp_t:{ file dir } krb5kdc_tmp_t;
#line 67

#line 67

#line 67


#line 68
type krb5kdc_log_t, file_type, sysadmfile, logfile;
#line 68

#line 68

#line 68

#line 68

#line 68
#
#line 68
# Allow the process to modify the directory.
#line 68
#
#line 68
allow krb5kdc_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 68

#line 68
#
#line 68
# Allow the process to create the file.
#line 68
#
#line 68

#line 68

#line 68

#line 68

#line 68

#line 68
allow krb5kdc_t krb5kdc_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 68

#line 68

#line 68

#line 68

#line 68

#line 68

#line 68

#line 68

#line 68

#line 68
type_transition krb5kdc_t var_log_t:file krb5kdc_log_t;
#line 68

#line 68

#line 68

allow { kadmind_t krb5kdc_t } urandom_device_t:chr_file { getattr read };
allow kadmind_t random_device_t:chr_file { getattr read };
allow krb5kdc_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
allow kadmind_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
allow krb5kdc_t proc_t:dir { read getattr lock search ioctl };
allow krb5kdc_t proc_t:file { getattr read };

#
# Rules for Kerberos5 Kadmin daemon
allow kadmind_t self:unix_dgram_socket { connect create write };
allow kadmind_t krb5kdc_conf_t:dir search;
allow kadmind_t krb5kdc_conf_t:file { read getattr lock ioctl };
allow kadmind_t krb5kdc_principal_t:file { getattr lock read write setattr };

#line 82
allow kadmind_t etc_t:lnk_file read;
#line 82
allow kadmind_t lib_t:file { read getattr lock ioctl };
#line 82

#line 82
allow kadmind_t locale_t:dir { read getattr lock search ioctl };
#line 82
allow kadmind_t locale_t:file { read getattr lock ioctl };
#line 82
allow kadmind_t locale_t:lnk_file { getattr read };
#line 82

#line 82

dontaudit kadmind_t krb5kdc_conf_t:file write;

#line 84
type kadmind_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 84

#line 84

#line 84

#line 84

#line 84
#
#line 84
# Allow the process to modify the directory.
#line 84
#
#line 84
allow kadmind_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 84

#line 84
#
#line 84
# Allow the process to create the file.
#line 84
#
#line 84

#line 84

#line 84

#line 84

#line 84

#line 84
allow kadmind_t kadmind_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84
allow kadmind_t kadmind_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84
type_transition kadmind_t tmp_t:{ file dir } kadmind_tmp_t;
#line 84

#line 84

#line 84


#line 85
type kadmind_log_t, file_type, sysadmfile, logfile;
#line 85

#line 85

#line 85

#line 85

#line 85
#
#line 85
# Allow the process to modify the directory.
#line 85
#
#line 85
allow kadmind_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 85

#line 85
#
#line 85
# Allow the process to create the file.
#line 85
#
#line 85

#line 85

#line 85

#line 85

#line 85

#line 85
allow kadmind_t kadmind_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 85

#line 85

#line 85

#line 85

#line 85

#line 85

#line 85

#line 85

#line 85

#line 85
type_transition kadmind_t var_log_t:file kadmind_log_t;
#line 85

#line 85

#line 85


#
# Allow user programs to talk to KDC
allow krb5kdc_t userdomain:udp_socket recvfrom;
allow userdomain krb5kdc_t:udp_socket recvfrom;
allow initrc_t krb5_conf_t:file ioctl;
#line 1 "domains/program/klogd.te"
#DESC Klogd - Kernel log daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: klogd
#

#################################
#
# Rules for the klogd_t domain.
#

#line 11

#line 11

#line 11

#line 11
type klogd_t, domain, privlog, daemon , privmem, privkmsg, mlsfileread, transitionbool;
#line 11
type klogd_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit klogd_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types klogd_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow klogd_t init_t:fd use;
#line 11
allow klogd_t init_t:process sigchld;
#line 11
allow klogd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow klogd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow klogd_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow klogd_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow klogd_t ld_so_t:file execute_no_trans;
#line 11
allow klogd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow klogd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow klogd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow klogd_t texrel_shlib_t:file execmod;
#line 11
allow klogd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow klogd_t device_t:dir search;
#line 11
allow klogd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow klogd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow klogd_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow klogd_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow klogd_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow klogd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit klogd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit klogd_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow klogd_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow klogd_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow klogd_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow klogd_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit klogd_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit klogd_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
# Read system variables in /sys.
#line 11

#line 11
allow klogd_t sysctl_t:dir search;
#line 11
allow klogd_t sysctl_kernel_t:dir search;
#line 11
allow klogd_t sysctl_kernel_t:file { getattr read };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allows user to define a tunable to disable domain transition
#line 11
#
#line 11

#line 11
bool klogd_disable_trans false;
#line 11
if (klogd_disable_trans) {
#line 11

#line 11
allow initrc_t klogd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11

#line 11
allow sysadm_t klogd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11
 
#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow initrc_t klogd_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit initrc_t klogd_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit initrc_t klogd_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit initrc_t klogd_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow initrc_t klogd_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow klogd_t initrc_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow klogd_t initrc_t:fd use;
#line 11
allow initrc_t klogd_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow klogd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow klogd_t klogd_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow klogd_t klogd_exec_t:file entrypoint;
#line 11

#line 11
type_transition initrc_t klogd_exec_t:process klogd_t;
#line 11

#line 11

#line 11
allow initrc_t klogd_t:process { noatsecure siginh rlimitinh };
#line 11

#line 11
}
#line 11
 
#line 11
allow klogd_t privfd:fd use;
#line 11

#line 11
allow klogd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
# Create pid file.
#line 11
allow klogd_t var_t:dir { getattr search };
#line 11

#line 11
type klogd_var_run_t, file_type, sysadmfile, pidfile;
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow klogd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow klogd_t klogd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition klogd_t var_run_t:file klogd_var_run_t;
#line 11

#line 11

#line 11

#line 11
allow klogd_t var_t:dir search;
#line 11
allow klogd_t klogd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11

#line 11
allow klogd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11
# for daemons that look at /root on startup
#line 11
dontaudit klogd_t sysadm_home_dir_t:dir search;
#line 11

#line 11
# for df
#line 11
allow klogd_t fs_type:filesystem getattr;
#line 11
allow klogd_t removable_t:filesystem getattr;
#line 11

#line 11

#line 11
allow klogd_t etc_t:lnk_file read;
#line 11
allow klogd_t lib_t:file { read getattr lock ioctl };
#line 11

#line 11
allow klogd_t locale_t:dir { read getattr lock search ioctl };
#line 11
allow klogd_t locale_t:file { read getattr lock ioctl };
#line 11
allow klogd_t locale_t:lnk_file { getattr read };
#line 11

#line 11

#line 11

#line 11
# for localization
#line 11
allow klogd_t lib_t:file { getattr read };
#line 11



#line 13
type klogd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow klogd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow klogd_t klogd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow klogd_t klogd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition klogd_t tmp_t:{ file dir } klogd_tmp_t;
#line 13

#line 13

#line 13

allow klogd_t proc_t:dir { read getattr lock search ioctl };
allow klogd_t proc_t:lnk_file { read getattr lock ioctl };
allow klogd_t proc_t:file { getattr read };
allow klogd_t self:dir { read getattr lock search ioctl };
allow klogd_t self:lnk_file { read getattr lock ioctl };

# read /etc/nsswitch.conf
allow klogd_t etc_t:lnk_file read;
allow klogd_t etc_t:file { read getattr lock ioctl };


#line 24
allow klogd_t etc_t:lnk_file read;
#line 24
allow klogd_t lib_t:file { read getattr lock ioctl };
#line 24

#line 24
allow klogd_t locale_t:dir { read getattr lock search ioctl };
#line 24
allow klogd_t locale_t:file { read getattr lock ioctl };
#line 24
allow klogd_t locale_t:lnk_file { getattr read };
#line 24

#line 24


allow klogd_t etc_runtime_t:file { getattr read };

# Create unix sockets
allow klogd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# Use the sys_admin and sys_rawio capabilities.
allow klogd_t self:capability { sys_admin sys_rawio };
dontaudit klogd_t self:capability sys_resource;


# Read /proc/kmsg and /dev/mem.
allow klogd_t proc_kmsg_t:file { read getattr lock ioctl };
allow klogd_t memory_device_t:chr_file { read getattr lock ioctl };

# Control syslog and console logging
allow klogd_t kernel_t:system { syslog_mod syslog_console };

# Read /boot/System.map*
allow klogd_t system_map_t:file { read getattr lock ioctl };
allow klogd_t boot_t:dir { read getattr lock search ioctl };
#line 48

#line 48
allow klogd_t unconfined_t:system syslog_mod;
#line 48

#line 1 "domains/program/ktalkd.te"
#DESC ktalkd -  KDE version of the talk server 
#
# Author:  Dan Walsh <dwalsh@redhat.com>
#
# Depends: inetd.te

#################################
#
# Rules for the ktalkd_t domain.
#
# ktalkd_exec_t is the type of the ktalkd executable.
#


#line 14
type ktalkd_t, domain, privlog, nscd_client_domain;
#line 14
role system_r types ktalkd_t;
#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14
bool ktalkd_disable_trans false;
#line 14
if (ktalkd_disable_trans) {
#line 14

#line 14
allow initrc_t ktalkd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t ktalkd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow inetd_t ktalkd_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit inetd_t ktalkd_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit inetd_t ktalkd_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit inetd_t ktalkd_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow inetd_t ktalkd_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow ktalkd_t inetd_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow ktalkd_t inetd_t:fd use;
#line 14
allow inetd_t ktalkd_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow ktalkd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow ktalkd_t ktalkd_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow ktalkd_t ktalkd_exec_t:file entrypoint;
#line 14

#line 14
type_transition inetd_t ktalkd_exec_t:process ktalkd_t;
#line 14

#line 14
allow inetd_t ktalkd_t:process sigkill;
#line 14
}
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow ktalkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow ktalkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow ktalkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow ktalkd_t node_type:node { tcp_send rawip_send };
#line 14
allow ktalkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow ktalkd_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow ktalkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow ktalkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow ktalkd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow ktalkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow ktalkd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow ktalkd_t node_type:node { udp_send rawip_send };
#line 14
allow ktalkd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow ktalkd_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow ktalkd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow ktalkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
if (allow_ypbind) {
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow ktalkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow ktalkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow ktalkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow ktalkd_t node_type:node { tcp_send rawip_send };
#line 14
allow ktalkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow ktalkd_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow ktalkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow ktalkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow ktalkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow ktalkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow ktalkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow ktalkd_t node_type:node { tcp_send rawip_send };
#line 14
allow ktalkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow ktalkd_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow ktalkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow ktalkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow ktalkd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow ktalkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow ktalkd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow ktalkd_t node_type:node { udp_send rawip_send };
#line 14
allow ktalkd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow ktalkd_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow ktalkd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow ktalkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow ktalkd_t var_yp_t:dir { read getattr lock search ioctl };
#line 14
allow ktalkd_t var_yp_t:file { read getattr lock ioctl };
#line 14
allow ktalkd_t var_yp_t:lnk_file { getattr read };
#line 14

#line 14
allow ktalkd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 14
allow ktalkd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 14
dontaudit ktalkd_t self:capability net_bind_service;
#line 14
dontaudit ktalkd_t reserved_port_type:tcp_socket name_connect;
#line 14
dontaudit ktalkd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 14

#line 14
} else {
#line 14
dontaudit ktalkd_t var_yp_t:dir search;
#line 14
}
#line 14
 
#line 14

#line 14
allow ktalkd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow ktalkd_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow ktalkd_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow ktalkd_t ld_so_t:file execute_no_trans;
#line 14
allow ktalkd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow ktalkd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow ktalkd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow ktalkd_t texrel_shlib_t:file execmod;
#line 14
allow ktalkd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow ktalkd_t device_t:dir search;
#line 14
allow ktalkd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
allow ktalkd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow ktalkd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow ktalkd_t self:fifo_file { ioctl read getattr lock write append };
#line 14
type ktalkd_exec_t, file_type, sysadmfile, exec_type;
#line 14

#line 14
allow ktalkd_t etc_t:lnk_file read;
#line 14
allow ktalkd_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow ktalkd_t locale_t:file { read getattr lock ioctl };
#line 14
allow ktalkd_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14
allow ktalkd_t device_t:dir search;
#line 14
allow ktalkd_t proc_t:dir search;
#line 14
allow ktalkd_t proc_t:{ file lnk_file } { getattr read };
#line 14
allow ktalkd_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 14
allow ktalkd_t fs_t:filesystem getattr;
#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow ktalkd_t sysctl_t:dir search;
#line 14
allow ktalkd_t sysctl_kernel_t:dir search;
#line 14
allow ktalkd_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14
allow ktalkd_t etc_t:file { getattr read };
#line 14

#line 14

#line 14
type ktalkd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow ktalkd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow ktalkd_t ktalkd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow ktalkd_t ktalkd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition ktalkd_t tmp_t:{ file dir } ktalkd_tmp_t;
#line 14

#line 14

#line 14

#line 14
allow ktalkd_t var_t:dir search;
#line 14

#line 14
type ktalkd_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow ktalkd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow ktalkd_t ktalkd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition ktalkd_t var_run_t:file ktalkd_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow ktalkd_t var_t:dir search;
#line 14
allow ktalkd_t ktalkd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
# Inherit and use descriptors from inetd.
#line 14
allow ktalkd_t inetd_t:fd use;
#line 14

#line 14
# for identd
#line 14
allow ktalkd_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 14
allow ktalkd_t self:capability { setuid setgid };
#line 14
allow ktalkd_t home_root_t:dir search;
#line 14
allow ktalkd_t self:dir search;
#line 14
allow ktalkd_t self:{ lnk_file file } { getattr read };
#line 14

#line 14

#line 14
if (allow_kerberos) {
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow ktalkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow ktalkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow ktalkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow ktalkd_t node_type:node { tcp_send rawip_send };
#line 14
allow ktalkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow ktalkd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow ktalkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow ktalkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow ktalkd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow ktalkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow ktalkd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow ktalkd_t node_type:node { udp_send rawip_send };
#line 14
allow ktalkd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow ktalkd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow ktalkd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow ktalkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow ktalkd_t kerberos_port_t:tcp_socket name_connect;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow ktalkd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow ktalkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow ktalkd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow ktalkd_t node_type:node { tcp_send rawip_send };
#line 14
allow ktalkd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow ktalkd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow ktalkd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow ktalkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow ktalkd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow ktalkd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow ktalkd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow ktalkd_t node_type:node { udp_send rawip_send };
#line 14
allow ktalkd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow ktalkd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow ktalkd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow ktalkd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow ktalkd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow ktalkd_t dns_port_t:tcp_socket name_connect;
#line 14

#line 14
}
#line 14
 dontaudit ktalkd_t krb5_conf_t:file write;
#line 14
allow ktalkd_t krb5_conf_t:file { getattr read };
#line 14

#line 14
allow ktalkd_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 14
# Use sockets inherited from inetd.
#line 14

#line 14

#line 14

#line 14
allow inetd_t ktalkd_port_t:udp_socket name_bind;
#line 14
allow ktalkd_t inetd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
#line 14

#line 14

#line 14
allow ktalkd_t proc_net_t:dir { read getattr lock search ioctl };
#line 14
allow ktalkd_t proc_net_t:file { read getattr lock ioctl };
#line 14
allow ktalkd_t proc_net_t:lnk_file { getattr read };
#line 14

#line 14

#line 1 "domains/program/kudzu.te"
#DESC kudzu - Red Hat utility to recognise new hardware
#
# Author:  Russell Coker <russell@coker.com.au>
#


#line 6

#line 6
type kudzu_t, domain, privlog, daemon , etc_writer, privmodule, sysctl_kernel_writer, fs_domain, privmem;
#line 6
type kudzu_exec_t, file_type, sysadmfile, exec_type;
#line 6
dontaudit kudzu_t self:capability sys_tty_config;
#line 6

#line 6
role system_r types kudzu_t;
#line 6

#line 6
# Inherit and use descriptors from init.
#line 6
allow kudzu_t init_t:fd use;
#line 6
allow kudzu_t init_t:process sigchld;
#line 6
allow kudzu_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 6

#line 6

#line 6
allow kudzu_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 6
allow kudzu_t lib_t:lnk_file { read getattr lock ioctl };
#line 6
allow kudzu_t ld_so_t:file { read getattr lock execute ioctl };
#line 6
#allow kudzu_t ld_so_t:file execute_no_trans;
#line 6
allow kudzu_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 6
allow kudzu_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 6
allow kudzu_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 6
allow kudzu_t texrel_shlib_t:file execmod;
#line 6
allow kudzu_t ld_so_cache_t:file { read getattr lock ioctl };
#line 6
allow kudzu_t device_t:dir search;
#line 6
allow kudzu_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 6

#line 6

#line 6
allow kudzu_t { self proc_t }:dir { read getattr lock search ioctl };
#line 6
allow kudzu_t { self proc_t }:lnk_file { getattr read };
#line 6

#line 6
allow kudzu_t device_t:dir { read getattr lock search ioctl };
#line 6

#line 6
allow kudzu_t udev_tdb_t:file { read getattr lock ioctl };
#line 6
allow kudzu_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 6
dontaudit kudzu_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 6
dontaudit kudzu_t unpriv_userdomain:fd use;
#line 6

#line 6

#line 6
allow kudzu_t sysfs_t:dir { read getattr lock search ioctl };
#line 6
allow kudzu_t sysfs_t:file { read getattr lock ioctl };
#line 6
allow kudzu_t sysfs_t:lnk_file { getattr read };
#line 6
 
#line 6

#line 6
allow kudzu_t autofs_t:dir { search getattr };
#line 6

#line 6
dontaudit kudzu_t { tty_device_t devpts_t }:chr_file { read write };
#line 6
dontaudit kudzu_t root_t:file { getattr read };
#line 6
 
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
# Read system variables in /sys.
#line 6

#line 6
allow kudzu_t sysctl_t:dir search;
#line 6
allow kudzu_t sysctl_kernel_t:dir search;
#line 6
allow kudzu_t sysctl_kernel_t:file { getattr read };
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
#
#line 6
# Allows user to define a tunable to disable domain transition
#line 6
#
#line 6
 
#line 6

#line 6

#line 6
#
#line 6
# Allow the process to transition to the new domain.
#line 6
#
#line 6
allow initrc_t kudzu_t:process transition;
#line 6

#line 6
#
#line 6
# Do not audit when glibc secure mode is enabled upon the transition.
#line 6
#
#line 6
dontaudit initrc_t kudzu_t:process noatsecure;
#line 6

#line 6
#
#line 6
# Do not audit when signal-related state is cleared upon the transition.
#line 6
#
#line 6
dontaudit initrc_t kudzu_t:process siginh;
#line 6

#line 6
#
#line 6
# Do not audit when resource limits are reset upon the transition.
#line 6
#
#line 6
dontaudit initrc_t kudzu_t:process rlimitinh;
#line 6

#line 6
#
#line 6
# Allow the process to execute the program.
#line 6
# 
#line 6
allow initrc_t kudzu_exec_t:file { read { getattr execute } };
#line 6

#line 6
#
#line 6
# Allow the process to reap the new domain.
#line 6
#
#line 6
allow kudzu_t initrc_t:process sigchld;
#line 6

#line 6
#
#line 6
# Allow the new domain to inherit and use file 
#line 6
# descriptions from the creating process and vice versa.
#line 6
#
#line 6
allow kudzu_t initrc_t:fd use;
#line 6
allow initrc_t kudzu_t:fd use;
#line 6

#line 6
#
#line 6
# Allow the new domain to write back to the old domain via a pipe.
#line 6
#
#line 6
allow kudzu_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 6

#line 6
#
#line 6
# Allow the new domain to read and execute the program.
#line 6
#
#line 6
allow kudzu_t kudzu_exec_t:file { read getattr lock execute ioctl };
#line 6

#line 6
#
#line 6
# Allow the new domain to be entered via the program.
#line 6
#
#line 6
allow kudzu_t kudzu_exec_t:file entrypoint;
#line 6

#line 6
type_transition initrc_t kudzu_exec_t:process kudzu_t;
#line 6

#line 6

#line 6
allow initrc_t kudzu_t:process { noatsecure siginh rlimitinh };
#line 6
 
#line 6
allow kudzu_t privfd:fd use;
#line 6

#line 6
allow kudzu_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 6



#line 8
allow kudzu_t etc_t:lnk_file read;
#line 8
allow kudzu_t lib_t:file { read getattr lock ioctl };
#line 8

#line 8
allow kudzu_t locale_t:dir { read getattr lock search ioctl };
#line 8
allow kudzu_t locale_t:file { read getattr lock ioctl };
#line 8
allow kudzu_t locale_t:lnk_file { getattr read };
#line 8

#line 8


# for /etc/sysconfig/hwconf - probably need a new type
allow kudzu_t etc_runtime_t:file { ioctl read getattr lock write append };

# for kmodule
if (allow_execmem) {
allow kudzu_t self:process execmem;
}
allow kudzu_t zero_device_t:chr_file { read getattr lock execute ioctl };
allow kudzu_t memory_device_t:chr_file { read write execute };

allow kudzu_t ramfs_t:dir search;
allow kudzu_t ramfs_t:sock_file write;
allow kudzu_t self:capability { dac_override sys_admin sys_rawio net_admin sys_tty_config mknod };
allow kudzu_t modules_conf_t:file { getattr read unlink rename };
allow kudzu_t modules_object_t:dir { read getattr lock search ioctl };
allow kudzu_t { modules_object_t modules_dep_t }:file { getattr read };
allow kudzu_t mouse_device_t:chr_file { read write };
allow kudzu_t proc_net_t:dir { read getattr lock search ioctl };
allow kudzu_t { proc_net_t proc_t }:file { getattr read };
allow kudzu_t { fixed_disk_device_t removable_device_t }:blk_file { ioctl read getattr lock write append };
allow kudzu_t scsi_generic_device_t:chr_file { read getattr lock ioctl };
allow kudzu_t { bin_t sbin_t }:dir { getattr search };
allow kudzu_t { bin_t sbin_t }:lnk_file read;

#line 33
# Read system variables in /sys.
#line 33

#line 33
allow kudzu_t sysctl_t:dir search;
#line 33
allow kudzu_t sysctl_kernel_t:dir search;
#line 33
allow kudzu_t sysctl_kernel_t:file { getattr read };
#line 33

#line 33

#line 33

allow kudzu_t sysctl_dev_t:dir { getattr search read };
allow kudzu_t sysctl_dev_t:file { getattr read };
allow kudzu_t sysctl_kernel_t:file write;
allow kudzu_t usbdevfs_t:dir search;
allow kudzu_t usbdevfs_t:file { getattr read };
allow kudzu_t usbfs_t:dir search;
allow kudzu_t usbfs_t:file { getattr read };

#line 41
type kudzu_var_run_t, file_type, sysadmfile, pidfile;
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
#
#line 41
# Allow the process to modify the directory.
#line 41
#
#line 41
allow kudzu_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 41

#line 41
#
#line 41
# Allow the process to create the file.
#line 41
#
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
allow kudzu_t kudzu_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
type_transition kudzu_t var_run_t:file kudzu_var_run_t;
#line 41

#line 41

#line 41

#line 41
allow kudzu_t var_t:dir search;
#line 41
allow kudzu_t kudzu_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 41

allow kudzu_t kernel_t:system syslog_console;
allow kudzu_t self:udp_socket { create ioctl };
allow kudzu_t var_lock_t:dir search;
allow kudzu_t devpts_t:dir search;

# so it can write messages to the console
allow kudzu_t { tty_device_t devtty_t admin_tty_type }:chr_file { ioctl read getattr lock write append };

role sysadm_r types kudzu_t;
#line 53

#line 56

#line 56

#line 56

#line 56

#line 56
#
#line 56
# Allow the process to transition to the new domain.
#line 56
#
#line 56
allow anaconda_t kudzu_t:process transition;
#line 56

#line 56
#
#line 56
# Do not audit when glibc secure mode is enabled upon the transition.
#line 56
#
#line 56
dontaudit anaconda_t kudzu_t:process noatsecure;
#line 56

#line 56
#
#line 56
# Do not audit when signal-related state is cleared upon the transition.
#line 56
#
#line 56
dontaudit anaconda_t kudzu_t:process siginh;
#line 56

#line 56
#
#line 56
# Do not audit when resource limits are reset upon the transition.
#line 56
#
#line 56
dontaudit anaconda_t kudzu_t:process rlimitinh;
#line 56

#line 56
#
#line 56
# Allow the process to execute the program.
#line 56
# 
#line 56
allow anaconda_t kudzu_exec_t:file { read { getattr execute } };
#line 56

#line 56
#
#line 56
# Allow the process to reap the new domain.
#line 56
#
#line 56
allow kudzu_t anaconda_t:process sigchld;
#line 56

#line 56
#
#line 56
# Allow the new domain to inherit and use file 
#line 56
# descriptions from the creating process and vice versa.
#line 56
#
#line 56
allow kudzu_t anaconda_t:fd use;
#line 56
allow anaconda_t kudzu_t:fd use;
#line 56

#line 56
#
#line 56
# Allow the new domain to write back to the old domain via a pipe.
#line 56
#
#line 56
allow kudzu_t anaconda_t:fifo_file { ioctl read getattr lock write append };
#line 56

#line 56
#
#line 56
# Allow the new domain to read and execute the program.
#line 56
#
#line 56
allow kudzu_t kudzu_exec_t:file { read getattr lock execute ioctl };
#line 56

#line 56
#
#line 56
# Allow the new domain to be entered via the program.
#line 56
#
#line 56
allow kudzu_t kudzu_exec_t:file entrypoint;
#line 56

#line 56
type_transition anaconda_t kudzu_exec_t:process kudzu_t;
#line 56

#line 56


allow kudzu_t sysadm_home_dir_t:dir search;

#line 59
allow kudzu_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 59
allow kudzu_t etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 59
allow kudzu_t etc_t:lnk_file { create read getattr setattr link unlink rename };
#line 59



#line 61
allow kudzu_t mnt_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 61
allow kudzu_t mnt_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 61
allow kudzu_t mnt_t:lnk_file { create read getattr setattr link unlink rename };
#line 61


#line 62
allow kudzu_t { bin_t sbin_t init_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 62

# Read /usr/lib/gconv/gconv-modules.*
allow kudzu_t lib_t:file { read getattr };
# Read /usr/share/hwdata/.* and /usr/share/terminfo/l/linux
allow kudzu_t usr_t:file { read getattr };

#line 67
allow kudzu_t hwdata_t:dir { read getattr lock search ioctl };
#line 67
allow kudzu_t hwdata_t:file { read getattr lock ioctl };
#line 67
allow kudzu_t hwdata_t:lnk_file { getattr read };
#line 67


# Communicate with rhgb-client.
allow kudzu_t self:unix_stream_socket { connectto { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept } };
allow kudzu_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

#line 75


allow kudzu_t self:file { getattr read };
allow kudzu_t self:fifo_file { ioctl read getattr lock write append };
#line 81



#line 83
allow kudzu_t shell_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 83


# Write to /proc/sys/kernel/hotplug.  Why?
allow kudzu_t sysctl_hotplug_t:file { read write };

allow kudzu_t sysfs_t:dir { getattr read search };
allow kudzu_t sysfs_t:file { getattr read };
allow kudzu_t sysfs_t:lnk_file read;

#line 91

#line 91

#line 91

#line 91
#
#line 91
# Allow the process to modify the directory.
#line 91
#
#line 91
allow kudzu_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 91

#line 91
#
#line 91
# Allow the process to create the file.
#line 91
#
#line 91

#line 91

#line 91

#line 91

#line 91

#line 91
allow kudzu_t etc_runtime_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 91

#line 91

#line 91

#line 91

#line 91

#line 91

#line 91

#line 91

#line 91

#line 91
type_transition kudzu_t etc_t:file etc_runtime_t;
#line 91

#line 91

allow kudzu_t tape_device_t:chr_file { read getattr lock ioctl };

#line 93
type kudzu_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 93

#line 93

#line 93

#line 93

#line 93
#
#line 93
# Allow the process to modify the directory.
#line 93
#
#line 93
allow kudzu_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 93

#line 93
#
#line 93
# Allow the process to create the file.
#line 93
#
#line 93

#line 93

#line 93

#line 93

#line 93

#line 93
allow kudzu_t kudzu_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93
allow kudzu_t kudzu_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93
allow kudzu_t kudzu_tmp_t:chr_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93

#line 93
type_transition kudzu_t tmp_t:{ file dir chr_file } kudzu_tmp_t;
#line 93

#line 93

#line 93


# for file systems that are not yet mounted
dontaudit kudzu_t file_t:dir search;
#line 99

#line 99
allow kudzu_t printconf_t:file { getattr read };
#line 99

#line 102

#line 102
allow kudzu_t cupsd_rw_etc_t:dir { read getattr lock search ioctl };
#line 102

dontaudit kudzu_t src_t:dir search;
#line 106


#line 113

#line 113

#line 113

#line 113
typeattribute kudzu_t unrestricted;
#line 113
typeattribute kudzu_t privuser;
#line 113

#line 113
# Mount/unmount any filesystem. 
#line 113
allow kudzu_t fs_type:filesystem *;
#line 113

#line 113
# Mount/unmount any filesystem with the context= option. 
#line 113
allow kudzu_t file_type:filesystem *;
#line 113

#line 113
# Create/access any file in a labeled filesystem;
#line 113
allow kudzu_t file_type:{ file chr_file } ~execmod;
#line 113
allow kudzu_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 113
allow kudzu_t sysctl_t:{ dir file } *;
#line 113
allow kudzu_t device_type:{ chr_file blk_file } *;
#line 113
allow kudzu_t mtrr_device_t:file *;
#line 113

#line 113
# Create/access other files.  fs_type is to pick up various
#line 113
# pseudo filesystem types that are applied to both the filesystem
#line 113
# and its files.
#line 113
allow kudzu_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 113
allow kudzu_t unlabeled_t:association { sendto recvfrom };
#line 113

#line 113
allow kudzu_t proc_fs:{ dir file } *;
#line 113

#line 113
# For /proc/pid
#line 113

#line 113
allow kudzu_t domain:dir { read getattr lock search ioctl };
#line 113
allow kudzu_t domain:file { read getattr lock ioctl };
#line 113
allow kudzu_t domain:lnk_file { getattr read };
#line 113

#line 113
# Write access is for setting attributes under /proc/self/attr.
#line 113
allow kudzu_t self:file { ioctl read getattr lock write append };
#line 113

#line 113
# Read and write sysctls.
#line 113

#line 113
allow kudzu_t sysctl_type:dir { read getattr lock search ioctl };
#line 113
allow kudzu_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 113

#line 113

#line 113
# Access the network.
#line 113
allow kudzu_t node_type:node *;
#line 113
allow kudzu_t netif_type:netif *;
#line 113
allow kudzu_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 113
allow kudzu_t port_type:tcp_socket name_connect;
#line 113

#line 113
# Bind to any network address.
#line 113
allow kudzu_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 113
allow kudzu_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 113
allow kudzu_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 113

#line 113
# Use/sendto/connectto sockets created by any domain.
#line 113
allow kudzu_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 113

#line 113
# Use descriptors and pipes created by any domain.
#line 113
allow kudzu_t domain:fd use;
#line 113
allow kudzu_t domain:fifo_file { ioctl read getattr lock write append };
#line 113

#line 113
# Act upon any other process.
#line 113
allow kudzu_t domain:process ~{ transition dyntransition execmem };
#line 113
# Transition to myself, to make get_ordered_context_list happy.
#line 113
allow kudzu_t self:process transition;
#line 113

#line 113
if (allow_execmem) {
#line 113
# Allow making anonymous memory executable, e.g. 
#line 113
# for runtime-code generation or executable stack.
#line 113
allow kudzu_t self:process execmem;
#line 113
}
#line 113

#line 113
if (allow_execmem && allow_execstack) {
#line 113
# Allow making the stack executable via mprotect.
#line 113
allow kudzu_t self:process execstack;
#line 113
}
#line 113

#line 113
if (allow_execmod) {
#line 113
# Allow text relocations on system shared libraries, e.g. libGL.
#line 113

#line 113
allow kudzu_t file_type:file execmod;
#line 113

#line 113
}
#line 113

#line 113
# Create/access any System V IPC objects.
#line 113
allow kudzu_t domain:{ sem msgq shm } *;
#line 113
allow kudzu_t domain:msg  { send receive };
#line 113

#line 113
# Access the security API.
#line 113
if (!secure_mode_policyload) {
#line 113
allow kudzu_t security_t:security *;
#line 113
auditallow kudzu_t security_t:security { load_policy setenforce setbool };
#line 113
}
#line 113
# Perform certain system operations that lacked individual capabilities.
#line 113
allow kudzu_t kernel_t:system *;
#line 113

#line 113
# Use any Linux capability.
#line 113
allow kudzu_t self:capability *;
#line 113

#line 113
# Set user information and skip authentication.
#line 113
allow kudzu_t self:passwd *;
#line 113

#line 113
# Communicate via dbusd.
#line 113
allow kudzu_t self:dbus *;
#line 113

#line 113
allow kudzu_t system_dbusd_t:dbus *;
#line 113

#line 113

#line 113
# Get info via nscd.
#line 113
allow kudzu_t self:nscd *;
#line 113

#line 113
allow kudzu_t nscd_t:nscd *;
#line 113

#line 113

#line 113

#line 113


allow kudzu_t initrc_t:unix_stream_socket connectto;
allow kudzu_t net_conf_t:file { getattr read };

#line 1 "domains/program/ldconfig.te"
#DESC Ldconfig - Configure dynamic linker bindings
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: libc6
#

#################################
#
# Rules for the ldconfig_t domain.
#
type ldconfig_t, domain, privlog, etc_writer;
type ldconfig_exec_t, file_type, sysadmfile, exec_type;

role sysadm_r types ldconfig_t;
role system_r types ldconfig_t;


#line 17

#line 17

#line 17
#
#line 17
# Allow the process to transition to the new domain.
#line 17
#
#line 17
allow { sysadm_t initrc_t } ldconfig_t:process transition;
#line 17

#line 17
#
#line 17
# Do not audit when glibc secure mode is enabled upon the transition.
#line 17
#
#line 17
dontaudit { sysadm_t initrc_t } ldconfig_t:process noatsecure;
#line 17

#line 17
#
#line 17
# Do not audit when signal-related state is cleared upon the transition.
#line 17
#
#line 17
dontaudit { sysadm_t initrc_t } ldconfig_t:process siginh;
#line 17

#line 17
#
#line 17
# Do not audit when resource limits are reset upon the transition.
#line 17
#
#line 17
dontaudit { sysadm_t initrc_t } ldconfig_t:process rlimitinh;
#line 17

#line 17
#
#line 17
# Allow the process to execute the program.
#line 17
# 
#line 17
allow { sysadm_t initrc_t } ldconfig_exec_t:file { read { getattr execute } };
#line 17

#line 17
#
#line 17
# Allow the process to reap the new domain.
#line 17
#
#line 17
allow ldconfig_t { sysadm_t initrc_t }:process sigchld;
#line 17

#line 17
#
#line 17
# Allow the new domain to inherit and use file 
#line 17
# descriptions from the creating process and vice versa.
#line 17
#
#line 17
allow ldconfig_t { sysadm_t initrc_t }:fd use;
#line 17
allow { sysadm_t initrc_t } ldconfig_t:fd use;
#line 17

#line 17
#
#line 17
# Allow the new domain to write back to the old domain via a pipe.
#line 17
#
#line 17
allow ldconfig_t { sysadm_t initrc_t }:fifo_file { ioctl read getattr lock write append };
#line 17

#line 17
#
#line 17
# Allow the new domain to read and execute the program.
#line 17
#
#line 17
allow ldconfig_t ldconfig_exec_t:file { read getattr lock execute ioctl };
#line 17

#line 17
#
#line 17
# Allow the new domain to be entered via the program.
#line 17
#
#line 17
allow ldconfig_t ldconfig_exec_t:file entrypoint;
#line 17

#line 17
type_transition { sysadm_t initrc_t } ldconfig_exec_t:process ldconfig_t;
#line 17

dontaudit ldconfig_t device_t:dir search;

#line 19
allow ldconfig_t devpts_t:dir { read getattr lock search ioctl };
#line 19
allow ldconfig_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 19

allow ldconfig_t admin_tty_type:chr_file { ioctl read getattr lock write append };
allow ldconfig_t privfd:fd use;


#line 23
allow ldconfig_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 23
allow ldconfig_t lib_t:lnk_file { read getattr lock ioctl };
#line 23
allow ldconfig_t ld_so_t:file { read getattr lock execute ioctl };
#line 23
#allow ldconfig_t ld_so_t:file execute_no_trans;
#line 23
allow ldconfig_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 23
allow ldconfig_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 23
allow ldconfig_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 23
allow ldconfig_t texrel_shlib_t:file execmod;
#line 23
allow ldconfig_t ld_so_cache_t:file { read getattr lock ioctl };
#line 23
allow ldconfig_t device_t:dir search;
#line 23
allow ldconfig_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 23



#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the process to modify the directory.
#line 25
#
#line 25
allow ldconfig_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 25

#line 25
#
#line 25
# Allow the process to create the file.
#line 25
#
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow ldconfig_t ld_so_cache_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
type_transition ldconfig_t etc_t:file ld_so_cache_t;
#line 25

#line 25

allow ldconfig_t lib_t:dir { read getattr lock search ioctl add_name remove_name write };
allow ldconfig_t lib_t:lnk_file { create read getattr setattr link unlink rename };

allow ldconfig_t userdomain:fd use;
# unlink for when /etc/ld.so.cache is mislabeled
allow ldconfig_t etc_t:file { getattr read unlink };
allow ldconfig_t etc_t:lnk_file read;

allow ldconfig_t fs_t:filesystem getattr;
allow ldconfig_t tmp_t:dir search;

#line 40

#line 40
# dontaudit access to /usr/lib/apache, normal programs cannot read these libs anyway
#line 40
dontaudit ldconfig_t httpd_modules_t:dir search;
#line 40


allow ldconfig_t { var_t var_lib_t }:dir search;
allow ldconfig_t proc_t:file { getattr read };
#line 48

#line 48
;
#line 52

#line 52
allow ldconfig_t lib_t:file { read getattr lock ioctl };
#line 52

#line 52

#line 52
typeattribute ldconfig_t unrestricted;
#line 52
typeattribute ldconfig_t privuser;
#line 52

#line 52
# Mount/unmount any filesystem. 
#line 52
allow ldconfig_t fs_type:filesystem *;
#line 52

#line 52
# Mount/unmount any filesystem with the context= option. 
#line 52
allow ldconfig_t file_type:filesystem *;
#line 52

#line 52
# Create/access any file in a labeled filesystem;
#line 52
allow ldconfig_t file_type:{ file chr_file } ~execmod;
#line 52
allow ldconfig_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 52
allow ldconfig_t sysctl_t:{ dir file } *;
#line 52
allow ldconfig_t device_type:{ chr_file blk_file } *;
#line 52
allow ldconfig_t mtrr_device_t:file *;
#line 52

#line 52
# Create/access other files.  fs_type is to pick up various
#line 52
# pseudo filesystem types that are applied to both the filesystem
#line 52
# and its files.
#line 52
allow ldconfig_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 52
allow ldconfig_t unlabeled_t:association { sendto recvfrom };
#line 52

#line 52
allow ldconfig_t proc_fs:{ dir file } *;
#line 52

#line 52
# For /proc/pid
#line 52

#line 52
allow ldconfig_t domain:dir { read getattr lock search ioctl };
#line 52
allow ldconfig_t domain:file { read getattr lock ioctl };
#line 52
allow ldconfig_t domain:lnk_file { getattr read };
#line 52

#line 52
# Write access is for setting attributes under /proc/self/attr.
#line 52
allow ldconfig_t self:file { ioctl read getattr lock write append };
#line 52

#line 52
# Read and write sysctls.
#line 52

#line 52
allow ldconfig_t sysctl_type:dir { read getattr lock search ioctl };
#line 52
allow ldconfig_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 52

#line 52

#line 52
# Access the network.
#line 52
allow ldconfig_t node_type:node *;
#line 52
allow ldconfig_t netif_type:netif *;
#line 52
allow ldconfig_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 52
allow ldconfig_t port_type:tcp_socket name_connect;
#line 52

#line 52
# Bind to any network address.
#line 52
allow ldconfig_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 52
allow ldconfig_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 52
allow ldconfig_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 52

#line 52
# Use/sendto/connectto sockets created by any domain.
#line 52
allow ldconfig_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 52

#line 52
# Use descriptors and pipes created by any domain.
#line 52
allow ldconfig_t domain:fd use;
#line 52
allow ldconfig_t domain:fifo_file { ioctl read getattr lock write append };
#line 52

#line 52
# Act upon any other process.
#line 52
allow ldconfig_t domain:process ~{ transition dyntransition execmem };
#line 52
# Transition to myself, to make get_ordered_context_list happy.
#line 52
allow ldconfig_t self:process transition;
#line 52

#line 52
if (allow_execmem) {
#line 52
# Allow making anonymous memory executable, e.g. 
#line 52
# for runtime-code generation or executable stack.
#line 52
allow ldconfig_t self:process execmem;
#line 52
}
#line 52

#line 52
if (allow_execmem && allow_execstack) {
#line 52
# Allow making the stack executable via mprotect.
#line 52
allow ldconfig_t self:process execstack;
#line 52
}
#line 52

#line 52
if (allow_execmod) {
#line 52
# Allow text relocations on system shared libraries, e.g. libGL.
#line 52

#line 52
allow ldconfig_t file_type:file execmod;
#line 52

#line 52
}
#line 52

#line 52
# Create/access any System V IPC objects.
#line 52
allow ldconfig_t domain:{ sem msgq shm } *;
#line 52
allow ldconfig_t domain:msg  { send receive };
#line 52

#line 52
# Access the security API.
#line 52
if (!secure_mode_policyload) {
#line 52
allow ldconfig_t security_t:security *;
#line 52
auditallow ldconfig_t security_t:security { load_policy setenforce setbool };
#line 52
}
#line 52
# Perform certain system operations that lacked individual capabilities.
#line 52
allow ldconfig_t kernel_t:system *;
#line 52

#line 52
# Use any Linux capability.
#line 52
allow ldconfig_t self:capability *;
#line 52

#line 52
# Set user information and skip authentication.
#line 52
allow ldconfig_t self:passwd *;
#line 52

#line 52
# Communicate via dbusd.
#line 52
allow ldconfig_t self:dbus *;
#line 52

#line 52
allow ldconfig_t system_dbusd_t:dbus *;
#line 52

#line 52

#line 52
# Get info via nscd.
#line 52
allow ldconfig_t self:nscd *;
#line 52

#line 52
allow ldconfig_t nscd_t:nscd *;
#line 52

#line 52

#line 52
 
#line 52

#line 1 "domains/program/load_policy.te"
#DESC LoadPolicy - SELinux policy loading utilities
#
# Authors:  Frank Mayer, mayerf@tresys.com
# X-Debian-Packages: policycoreutils
#

###########################
# load_policy_t is the domain type for load_policy 
# load_policy_exec_t is the file type for the executable

# boolean to determine whether the system permits loading policy, setting
# enforcing mode, and changing boolean values.  Set this to true and you
# have to reboot to set it back
bool secure_mode_policyload false;

type load_policy_t, domain;
role sysadm_r types load_policy_t;
role secadm_r types load_policy_t;
role system_r types load_policy_t;

type load_policy_exec_t, file_type, exec_type, sysadmfile;

##########################
# 
# Rules


#line 27

#line 27

#line 27
#
#line 27
# Allow the process to transition to the new domain.
#line 27
#
#line 27
allow secadmin load_policy_t:process transition;
#line 27

#line 27
#
#line 27
# Do not audit when glibc secure mode is enabled upon the transition.
#line 27
#
#line 27
dontaudit secadmin load_policy_t:process noatsecure;
#line 27

#line 27
#
#line 27
# Do not audit when signal-related state is cleared upon the transition.
#line 27
#
#line 27
dontaudit secadmin load_policy_t:process siginh;
#line 27

#line 27
#
#line 27
# Do not audit when resource limits are reset upon the transition.
#line 27
#
#line 27
dontaudit secadmin load_policy_t:process rlimitinh;
#line 27

#line 27
#
#line 27
# Allow the process to execute the program.
#line 27
# 
#line 27
allow secadmin load_policy_exec_t:file { read { getattr execute } };
#line 27

#line 27
#
#line 27
# Allow the process to reap the new domain.
#line 27
#
#line 27
allow load_policy_t secadmin:process sigchld;
#line 27

#line 27
#
#line 27
# Allow the new domain to inherit and use file 
#line 27
# descriptions from the creating process and vice versa.
#line 27
#
#line 27
allow load_policy_t secadmin:fd use;
#line 27
allow secadmin load_policy_t:fd use;
#line 27

#line 27
#
#line 27
# Allow the new domain to write back to the old domain via a pipe.
#line 27
#
#line 27
allow load_policy_t secadmin:fifo_file { ioctl read getattr lock write append };
#line 27

#line 27
#
#line 27
# Allow the new domain to read and execute the program.
#line 27
#
#line 27
allow load_policy_t load_policy_exec_t:file { read getattr lock execute ioctl };
#line 27

#line 27
#
#line 27
# Allow the new domain to be entered via the program.
#line 27
#
#line 27
allow load_policy_t load_policy_exec_t:file entrypoint;
#line 27

#line 27
type_transition secadmin load_policy_exec_t:process load_policy_t;
#line 27


allow load_policy_t console_device_t:chr_file { read write };

# Reload the policy configuration (sysadm_t no longer has this ability)

#line 32
# Get the selinuxfs mount point via /proc/self/mounts.
#line 32
allow load_policy_t proc_t:dir search;
#line 32
allow load_policy_t proc_t:lnk_file read;
#line 32
allow load_policy_t proc_t:file { getattr read };
#line 32
allow load_policy_t self:dir search;
#line 32
allow load_policy_t self:file { getattr read };
#line 32
# Access selinuxfs.
#line 32
allow load_policy_t security_t:dir { read search getattr };
#line 32
allow load_policy_t security_t:file { getattr read write };
#line 32
if (!secure_mode_policyload) {
#line 32
allow load_policy_t security_t:security load_policy;
#line 32
auditallow load_policy_t security_t:security load_policy;
#line 32
}

# Reset policy boolean values.

#line 35
# Get the selinuxfs mount point via /proc/self/mounts.
#line 35
allow load_policy_t proc_t:dir search;
#line 35
allow load_policy_t proc_t:lnk_file read;
#line 35
allow load_policy_t self:dir search;
#line 35
allow load_policy_t self:file { getattr read };
#line 35
# Access selinuxfs.
#line 35
allow load_policy_t security_t:dir { read search getattr };
#line 35
allow load_policy_t security_t:file { getattr read write };
#line 35
if (!secure_mode_policyload) {
#line 35
allow load_policy_t security_t:security setbool;
#line 35
auditallow load_policy_t security_t:security setbool;
#line 35
}


###########################
# constrain from where load_policy can load a policy, specifically 
# policy_config_t files 
#

# only allow read of policy config files
allow load_policy_t policy_src_t:dir search;

#line 45
allow load_policy_t policy_config_t:dir { read getattr lock search ioctl };
#line 45
allow load_policy_t policy_config_t:file { read getattr lock ioctl };
#line 45
allow load_policy_t policy_config_t:lnk_file { getattr read };
#line 45


#line 46
allow load_policy_t selinux_config_t:dir { read getattr lock search ioctl };
#line 46
allow load_policy_t selinux_config_t:file { read getattr lock ioctl };
#line 46
allow load_policy_t selinux_config_t:lnk_file { getattr read };
#line 46


# directory search permissions for path to binary policy files
allow load_policy_t root_t:dir search;
allow load_policy_t etc_t:dir search;

# for mcs.conf
allow load_policy_t etc_t:file { getattr read };

# Other access

#line 56
allow load_policy_t devpts_t:dir { read getattr lock search ioctl };
#line 56
allow load_policy_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 56

allow load_policy_t { admin_tty_type devtty_t }:chr_file { read write ioctl getattr };

#line 58
allow load_policy_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 58
allow load_policy_t lib_t:lnk_file { read getattr lock ioctl };
#line 58
allow load_policy_t ld_so_t:file { read getattr lock execute ioctl };
#line 58
#allow load_policy_t ld_so_t:file execute_no_trans;
#line 58
allow load_policy_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 58
allow load_policy_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 58
allow load_policy_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 58
allow load_policy_t texrel_shlib_t:file execmod;
#line 58
allow load_policy_t ld_so_cache_t:file { read getattr lock ioctl };
#line 58
allow load_policy_t device_t:dir search;
#line 58
allow load_policy_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 58

allow load_policy_t self:capability dac_override;

allow load_policy_t { userdomain privfd initrc_t }:fd use;

allow load_policy_t fs_t:filesystem getattr;


#line 65
allow load_policy_t etc_t:lnk_file read;
#line 65
allow load_policy_t lib_t:file { read getattr lock ioctl };
#line 65

#line 65
allow load_policy_t locale_t:dir { read getattr lock search ioctl };
#line 65
allow load_policy_t locale_t:file { read getattr lock ioctl };
#line 65
allow load_policy_t locale_t:lnk_file { getattr read };
#line 65

#line 65

#line 1 "domains/program/login.te"
#DESC Login - Local/remote login utilities
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# Macroised by Russell Coker <russell@coker.com.au>
# X-Debian-Packages: login
#

#################################
# 
# Rules for the local_login_t domain
# and the remote_login_t domain.
#

# $1 is the name of the domain (local or remote)
#line 142
#################################
#
# Rules for the local_login_t domain.
#
# local_login_t is the domain of a login process 
# spawned by getty.
#
# remote_login_t is the domain of a login process 
# spawned by rlogind.
#
# login_exec_t is the type of the login program
#
type login_exec_t, file_type, sysadmfile, exec_type;


#line 156
type local_login_t, domain, privuser, privrole, privlog, auth_chkpwd, privowner, privfd, nscd_client_domain, mlsfileread, mlsfilewrite, mlsprocsetsl, mlsfileupgrade, mlsfiledowngrade;
#line 156
role system_r types local_login_t;
#line 156

#line 156
dontaudit local_login_t shadow_t:file { getattr read };
#line 156

#line 156

#line 156
# Access other processes in the same domain.
#line 156
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 156
# These must be granted separately if desired.
#line 156
allow local_login_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 156

#line 156
# Access /proc/PID files for processes in the same domain.
#line 156
allow local_login_t self:dir { read getattr lock search ioctl };
#line 156
allow local_login_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 156

#line 156
# Access file descriptions, pipes, and sockets
#line 156
# created by processes in the same domain.
#line 156
allow local_login_t self:fd *;
#line 156
allow local_login_t self:fifo_file { ioctl read getattr lock write append };
#line 156
allow local_login_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 156
allow local_login_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 156

#line 156
# Allow the domain to communicate with other processes in the same domain.
#line 156
allow local_login_t self:unix_dgram_socket sendto;
#line 156
allow local_login_t self:unix_stream_socket connectto;
#line 156

#line 156
# Access System V IPC objects created by processes in the same domain.
#line 156
allow local_login_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 156
allow local_login_t self:msg  { send receive };
#line 156
allow local_login_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 156
allow local_login_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 156
allow local_login_t unpriv_userdomain:fd use;
#line 156
#
#line 156
# Every app is asking for ypbind so I am adding this here, 
#line 156
# eventually this should become can_nsswitch
#line 156
#
#line 156

#line 156

#line 156
if (allow_ypbind) {
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
#
#line 156
# Allow the domain to create and use tcp sockets.
#line 156
# Other kinds of sockets must be separately authorized for use.
#line 156
allow local_login_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 156

#line 156
allow local_login_t unlabeled_t:association { sendto recvfrom };
#line 156

#line 156
#
#line 156
# Allow the domain to send or receive using any network interface.
#line 156
# netif_type is a type attribute for all network interface types.
#line 156
#
#line 156
allow local_login_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 156
#
#line 156
# Allow the domain to send to or receive from any node.
#line 156
# node_type is a type attribute for all node types.
#line 156
#
#line 156
allow local_login_t node_type:node { tcp_send rawip_send };
#line 156
allow local_login_t node_type:node { tcp_recv rawip_recv };
#line 156

#line 156
#
#line 156
# Allow the domain to send to or receive from any port.
#line 156
# port_type is a type attribute for all port types.
#line 156
#
#line 156

#line 156
allow local_login_t port_type:tcp_socket { send_msg recv_msg };
#line 156

#line 156

#line 156
# XXX Allow binding to any node type.  Remove once
#line 156
# individual rules have been added to all domains that 
#line 156
# bind sockets. 
#line 156
allow local_login_t node_type:tcp_socket node_bind;
#line 156
#
#line 156
# Allow access to network files including /etc/resolv.conf
#line 156
#
#line 156
allow local_login_t net_conf_t:file { read getattr lock ioctl };
#line 156

#line 156
allow local_login_t self:tcp_socket { listen accept };
#line 156

#line 156

#line 156

#line 156
#
#line 156
# Allow the domain to create and use tcp sockets.
#line 156
# Other kinds of sockets must be separately authorized for use.
#line 156
allow local_login_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 156

#line 156
allow local_login_t unlabeled_t:association { sendto recvfrom };
#line 156

#line 156
#
#line 156
# Allow the domain to send or receive using any network interface.
#line 156
# netif_type is a type attribute for all network interface types.
#line 156
#
#line 156
allow local_login_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 156
#
#line 156
# Allow the domain to send to or receive from any node.
#line 156
# node_type is a type attribute for all node types.
#line 156
#
#line 156
allow local_login_t node_type:node { tcp_send rawip_send };
#line 156
allow local_login_t node_type:node { tcp_recv rawip_recv };
#line 156

#line 156
#
#line 156
# Allow the domain to send to or receive from any port.
#line 156
# port_type is a type attribute for all port types.
#line 156
#
#line 156

#line 156
allow local_login_t port_type:tcp_socket { send_msg recv_msg };
#line 156

#line 156

#line 156
# XXX Allow binding to any node type.  Remove once
#line 156
# individual rules have been added to all domains that 
#line 156
# bind sockets. 
#line 156
allow local_login_t node_type:tcp_socket node_bind;
#line 156
#
#line 156
# Allow access to network files including /etc/resolv.conf
#line 156
#
#line 156
allow local_login_t net_conf_t:file { read getattr lock ioctl };
#line 156

#line 156
allow local_login_t self:tcp_socket { connect };
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
#
#line 156
# Allow the domain to create and use udp sockets.
#line 156
# Other kinds of sockets must be separately authorized for use.
#line 156
allow local_login_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 156

#line 156
allow local_login_t unlabeled_t:association { sendto recvfrom };
#line 156

#line 156
#
#line 156
# Allow the domain to send or receive using any network interface.
#line 156
# netif_type is a type attribute for all network interface types.
#line 156
#
#line 156
allow local_login_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 156
#
#line 156
# Allow the domain to send to or receive from any node.
#line 156
# node_type is a type attribute for all node types.
#line 156
#
#line 156
allow local_login_t node_type:node { udp_send rawip_send };
#line 156
allow local_login_t node_type:node { udp_recv rawip_recv };
#line 156

#line 156
#
#line 156
# Allow the domain to send to or receive from any port.
#line 156
# port_type is a type attribute for all port types.
#line 156
#
#line 156

#line 156
allow local_login_t port_type:udp_socket { send_msg recv_msg };
#line 156

#line 156

#line 156
# XXX Allow binding to any node type.  Remove once
#line 156
# individual rules have been added to all domains that 
#line 156
# bind sockets. 
#line 156
allow local_login_t node_type:udp_socket node_bind;
#line 156
#
#line 156
# Allow access to network files including /etc/resolv.conf
#line 156
#
#line 156
allow local_login_t net_conf_t:file { read getattr lock ioctl };
#line 156

#line 156
allow local_login_t self:udp_socket { connect };
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
allow local_login_t var_yp_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t var_yp_t:file { read getattr lock ioctl };
#line 156
allow local_login_t var_yp_t:lnk_file { getattr read };
#line 156

#line 156
allow local_login_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 156
allow local_login_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 156
dontaudit local_login_t self:capability net_bind_service;
#line 156
dontaudit local_login_t reserved_port_type:tcp_socket name_connect;
#line 156
dontaudit local_login_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 156

#line 156
} else {
#line 156
dontaudit local_login_t var_yp_t:dir search;
#line 156
}
#line 156
 
#line 156
allow local_login_t autofs_t:dir { search getattr };
#line 156
;
#line 156

#line 156
# Read system information files in /proc.
#line 156

#line 156
allow local_login_t proc_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t proc_t:file { read getattr lock ioctl };
#line 156
allow local_login_t proc_t:lnk_file { getattr read };
#line 156

#line 156

#line 156

#line 156
# Read /.
#line 156
allow local_login_t root_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t root_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 156

#line 156
# Read /home.
#line 156
allow local_login_t home_root_t:dir { read getattr lock search ioctl };
#line 156

#line 156
# Read /usr.
#line 156
allow local_login_t usr_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t usr_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 156

#line 156
# Read bin and sbin directories.
#line 156
allow local_login_t bin_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t bin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 156
allow local_login_t sbin_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t sbin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 156

#line 156
# Read system variables in /sys.
#line 156

#line 156
allow local_login_t sysctl_t:dir search;
#line 156
allow local_login_t sysctl_kernel_t:dir search;
#line 156
allow local_login_t sysctl_kernel_t:file { getattr read };
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
allow local_login_t selinux_config_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t selinux_config_t:file { read getattr lock ioctl };
#line 156
allow local_login_t selinux_config_t:lnk_file { getattr read };
#line 156

#line 156

#line 156
if (read_default_t) {
#line 156
#
#line 156
# Read default_t
#line 156
#.
#line 156
allow local_login_t default_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t default_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 156
}
#line 156

#line 156

#line 156

#line 156
# Read directories and files with the readable_t type.
#line 156
# This type is a general type for "world"-readable files.
#line 156
allow local_login_t readable_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t readable_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 156

#line 156
# Read /var, /var/spool
#line 156
allow local_login_t { var_t var_spool_t }:dir search;
#line 156

#line 156
# for when /var/mail is a sym-link
#line 156
allow local_login_t var_t:lnk_file read;
#line 156

#line 156
# Read /etc.
#line 156

#line 156
allow local_login_t etc_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t etc_t:file { read getattr lock ioctl };
#line 156
allow local_login_t etc_t:lnk_file { getattr read };
#line 156

#line 156
allow local_login_t etc_runtime_t:{ file lnk_file } { read getattr lock ioctl };
#line 156

#line 156

#line 156
allow local_login_t etc_t:lnk_file read;
#line 156
allow local_login_t lib_t:file { read getattr lock ioctl };
#line 156

#line 156
allow local_login_t locale_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t locale_t:file { read getattr lock ioctl };
#line 156
allow local_login_t locale_t:lnk_file { getattr read };
#line 156

#line 156

#line 156

#line 156
# for SSP/ProPolice
#line 156
allow local_login_t urandom_device_t:chr_file { getattr read };
#line 156

#line 156
# Read executable types.
#line 156
allow local_login_t exec_type:{ file lnk_file } { read getattr lock ioctl };
#line 156

#line 156
# Read /dev directories and any symbolic links.
#line 156
allow local_login_t device_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t device_t:lnk_file { read getattr lock ioctl };
#line 156

#line 156

#line 156
allow local_login_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 156
allow local_login_t lib_t:lnk_file { read getattr lock ioctl };
#line 156
allow local_login_t ld_so_t:file { read getattr lock execute ioctl };
#line 156
#allow local_login_t ld_so_t:file execute_no_trans;
#line 156
allow local_login_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 156
allow local_login_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 156
allow local_login_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 156
allow local_login_t texrel_shlib_t:file execmod;
#line 156
allow local_login_t ld_so_cache_t:file { read getattr lock ioctl };
#line 156
allow local_login_t device_t:dir search;
#line 156
allow local_login_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 156
;
#line 156

#line 156

#line 156
type local_login_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 156

#line 156

#line 156

#line 156

#line 156
#
#line 156
# Allow the process to modify the directory.
#line 156
#
#line 156
allow local_login_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 156

#line 156
#
#line 156
# Allow the process to create the file.
#line 156
#
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
allow local_login_t local_login_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
allow local_login_t local_login_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
type_transition local_login_t tmp_t:{ file dir } local_login_tmp_t;
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
# Use capabilities
#line 156
allow local_login_t self:capability { dac_override chown fowner fsetid kill setgid setuid net_bind_service sys_nice sys_resource sys_tty_config };
#line 156
allow local_login_t self:process setrlimit;
#line 156
dontaudit local_login_t sysfs_t:dir search;
#line 156

#line 156
# Set exec context.
#line 156

#line 156
allow local_login_t self:process setexec;
#line 156
allow local_login_t proc_t:dir search;
#line 156
allow local_login_t proc_t:{ file lnk_file } read;
#line 156
allow local_login_t self:dir search;
#line 156
allow local_login_t self:file { getattr read write };
#line 156

#line 156

#line 156
allow local_login_t autofs_t:dir { search read getattr };
#line 156
allow local_login_t mnt_t:dir { read getattr lock search ioctl };
#line 156

#line 156
if (use_nfs_home_dirs) {
#line 156

#line 156
allow local_login_t nfs_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t nfs_t:file { read getattr lock ioctl };
#line 156
allow local_login_t nfs_t:lnk_file { getattr read };
#line 156

#line 156
}
#line 156

#line 156
if (use_samba_home_dirs) {
#line 156

#line 156
allow local_login_t cifs_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t cifs_t:file { read getattr lock ioctl };
#line 156
allow local_login_t cifs_t:lnk_file { getattr read };
#line 156

#line 156
}
#line 156

#line 156
# Login can polyinstantiate
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
# FIXME: what is this for?
#line 156

#line 156
allow xdm_t local_login_t:process signull;
#line 156

#line 156

#line 156

#line 156

#line 156
# Permit login to search the user home directories.
#line 156
allow local_login_t home_root_t:dir search;
#line 156
allow local_login_t home_dir_type:dir search;
#line 156

#line 156
# Write to /var/run/utmp.
#line 156
allow local_login_t var_run_t:dir search;
#line 156
allow local_login_t initrc_var_run_t:file { ioctl read getattr lock write append };
#line 156

#line 156
# Write to /var/log/wtmp.
#line 156
allow local_login_t var_log_t:dir search;
#line 156
allow local_login_t wtmp_t:file { ioctl read getattr lock write append };
#line 156

#line 156
# Write to /var/log/lastlog.
#line 156
allow local_login_t lastlog_t:file { ioctl read getattr lock write append };
#line 156

#line 156
# Write to /var/log/btmp
#line 156
allow local_login_t faillog_t:file { lock append read write };
#line 156

#line 156
# Search for mail spool file.
#line 156
allow local_login_t mail_spool_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t mail_spool_t:file getattr;
#line 156
allow local_login_t mail_spool_t:lnk_file read;
#line 156

#line 156
# Get security policy decisions.
#line 156

#line 156
# Get the selinuxfs mount point via /proc/self/mounts.
#line 156
allow local_login_t proc_t:dir search;
#line 156
allow local_login_t proc_t:{ file lnk_file } { getattr read };
#line 156
allow local_login_t self:dir search;
#line 156
allow local_login_t self:file { getattr read };
#line 156
# Access selinuxfs.
#line 156
allow local_login_t security_t:dir { read search getattr };
#line 156
allow local_login_t security_t:file { getattr read write };
#line 156
allow local_login_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 156

#line 156

#line 156
# allow read access to default_contexts in /etc/security
#line 156
allow local_login_t default_context_t:file { read getattr lock ioctl };
#line 156
allow local_login_t default_context_t:dir search;
#line 156

#line 156
allow local_login_t selinux_config_t:dir { read getattr lock search ioctl };
#line 156
allow local_login_t selinux_config_t:file { read getattr lock ioctl };
#line 156
allow local_login_t selinux_config_t:lnk_file { getattr read };
#line 156

#line 156

#line 156
allow local_login_t mouse_device_t:chr_file { getattr setattr };
#line 156

#line 156

#line 156

#line 156

#line 156
typeattribute local_login_t unrestricted;
#line 156
typeattribute local_login_t privuser;
#line 156

#line 156
# Mount/unmount any filesystem. 
#line 156
allow local_login_t fs_type:filesystem *;
#line 156

#line 156
# Mount/unmount any filesystem with the context= option. 
#line 156
allow local_login_t file_type:filesystem *;
#line 156

#line 156
# Create/access any file in a labeled filesystem;
#line 156
allow local_login_t file_type:{ file chr_file } ~execmod;
#line 156
allow local_login_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 156
allow local_login_t sysctl_t:{ dir file } *;
#line 156
allow local_login_t device_type:{ chr_file blk_file } *;
#line 156
allow local_login_t mtrr_device_t:file *;
#line 156

#line 156
# Create/access other files.  fs_type is to pick up various
#line 156
# pseudo filesystem types that are applied to both the filesystem
#line 156
# and its files.
#line 156
allow local_login_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 156
allow local_login_t unlabeled_t:association { sendto recvfrom };
#line 156

#line 156
allow local_login_t proc_fs:{ dir file } *;
#line 156

#line 156
# For /proc/pid
#line 156

#line 156
allow local_login_t domain:dir { read getattr lock search ioctl };
#line 156
allow local_login_t domain:file { read getattr lock ioctl };
#line 156
allow local_login_t domain:lnk_file { getattr read };
#line 156

#line 156
# Write access is for setting attributes under /proc/self/attr.
#line 156
allow local_login_t self:file { ioctl read getattr lock write append };
#line 156

#line 156
# Read and write sysctls.
#line 156

#line 156
allow local_login_t sysctl_type:dir { read getattr lock search ioctl };
#line 156
allow local_login_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 156

#line 156

#line 156
# Access the network.
#line 156
allow local_login_t node_type:node *;
#line 156
allow local_login_t netif_type:netif *;
#line 156
allow local_login_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 156
allow local_login_t port_type:tcp_socket name_connect;
#line 156

#line 156
# Bind to any network address.
#line 156
allow local_login_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 156
allow local_login_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 156
allow local_login_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 156

#line 156
# Use/sendto/connectto sockets created by any domain.
#line 156
allow local_login_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 156

#line 156
# Use descriptors and pipes created by any domain.
#line 156
allow local_login_t domain:fd use;
#line 156
allow local_login_t domain:fifo_file { ioctl read getattr lock write append };
#line 156

#line 156
# Act upon any other process.
#line 156
allow local_login_t domain:process ~{ transition dyntransition execmem };
#line 156
# Transition to myself, to make get_ordered_context_list happy.
#line 156
allow local_login_t self:process transition;
#line 156

#line 156
if (allow_execmem) {
#line 156
# Allow making anonymous memory executable, e.g. 
#line 156
# for runtime-code generation or executable stack.
#line 156
allow local_login_t self:process execmem;
#line 156
}
#line 156

#line 156
if (allow_execmem && allow_execstack) {
#line 156
# Allow making the stack executable via mprotect.
#line 156
allow local_login_t self:process execstack;
#line 156
}
#line 156

#line 156
if (allow_execmod) {
#line 156
# Allow text relocations on system shared libraries, e.g. libGL.
#line 156

#line 156
allow local_login_t file_type:file execmod;
#line 156

#line 156
}
#line 156

#line 156
# Create/access any System V IPC objects.
#line 156
allow local_login_t domain:{ sem msgq shm } *;
#line 156
allow local_login_t domain:msg  { send receive };
#line 156

#line 156
# Access the security API.
#line 156
if (!secure_mode_policyload) {
#line 156
allow local_login_t security_t:security *;
#line 156
auditallow local_login_t security_t:security { load_policy setenforce setbool };
#line 156
}
#line 156
# Perform certain system operations that lacked individual capabilities.
#line 156
allow local_login_t kernel_t:system *;
#line 156

#line 156
# Use any Linux capability.
#line 156
allow local_login_t self:capability *;
#line 156

#line 156
# Set user information and skip authentication.
#line 156
allow local_login_t self:passwd *;
#line 156

#line 156
# Communicate via dbusd.
#line 156
allow local_login_t self:dbus *;
#line 156

#line 156
allow local_login_t system_dbusd_t:dbus *;
#line 156

#line 156

#line 156
# Get info via nscd.
#line 156
allow local_login_t self:nscd *;
#line 156

#line 156
allow local_login_t nscd_t:nscd *;
#line 156

#line 156

#line 156

#line 156

#line 156

#line 156

#line 156
#
#line 156
# Allow the process to transition to the new domain.
#line 156
#
#line 156
allow local_login_t unconfined_t:process transition;
#line 156

#line 156
#
#line 156
# Do not audit when glibc secure mode is enabled upon the transition.
#line 156
#
#line 156
dontaudit local_login_t unconfined_t:process noatsecure;
#line 156

#line 156
#
#line 156
# Do not audit when signal-related state is cleared upon the transition.
#line 156
#
#line 156
dontaudit local_login_t unconfined_t:process siginh;
#line 156

#line 156
#
#line 156
# Do not audit when resource limits are reset upon the transition.
#line 156
#
#line 156
dontaudit local_login_t unconfined_t:process rlimitinh;
#line 156

#line 156
#
#line 156
# Allow the process to execute the program.
#line 156
# 
#line 156
allow local_login_t shell_exec_t:file { read { getattr execute } };
#line 156

#line 156
#
#line 156
# Allow the process to reap the new domain.
#line 156
#
#line 156
allow unconfined_t local_login_t:process sigchld;
#line 156

#line 156
#
#line 156
# Allow the new domain to inherit and use file 
#line 156
# descriptions from the creating process and vice versa.
#line 156
#
#line 156
allow unconfined_t local_login_t:fd use;
#line 156
allow local_login_t unconfined_t:fd use;
#line 156

#line 156
#
#line 156
# Allow the new domain to write back to the old domain via a pipe.
#line 156
#
#line 156
allow unconfined_t local_login_t:fifo_file { ioctl read getattr lock write append };
#line 156

#line 156
#
#line 156
# Allow the new domain to read and execute the program.
#line 156
#
#line 156
allow unconfined_t shell_exec_t:file { read getattr lock execute ioctl };
#line 156

#line 156
#
#line 156
# Allow the new domain to be entered via the program.
#line 156
#
#line 156
allow unconfined_t shell_exec_t:file entrypoint;
#line 156

#line 156
type_transition local_login_t shell_exec_t:process unconfined_t;
#line 156

#line 156

#line 156

#line 156


# But also permit other user domains to be entered by login.

#line 159

#line 159

#line 159
#
#line 159
# Allow the process to transition to the new domain.
#line 159
#
#line 159
allow local_login_t userdomain:process transition;
#line 159

#line 159
#
#line 159
# Do not audit when glibc secure mode is enabled upon the transition.
#line 159
#
#line 159
dontaudit local_login_t userdomain:process noatsecure;
#line 159

#line 159
#
#line 159
# Do not audit when signal-related state is cleared upon the transition.
#line 159
#
#line 159
dontaudit local_login_t userdomain:process siginh;
#line 159

#line 159
#
#line 159
# Do not audit when resource limits are reset upon the transition.
#line 159
#
#line 159
dontaudit local_login_t userdomain:process rlimitinh;
#line 159

#line 159
#
#line 159
# Allow the process to execute the program.
#line 159
# 
#line 159
allow local_login_t shell_exec_t:file { read { getattr execute } };
#line 159

#line 159
#
#line 159
# Allow the process to reap the new domain.
#line 159
#
#line 159
allow userdomain local_login_t:process sigchld;
#line 159

#line 159
#
#line 159
# Allow the new domain to inherit and use file 
#line 159
# descriptions from the creating process and vice versa.
#line 159
#
#line 159
allow userdomain local_login_t:fd use;
#line 159
allow local_login_t userdomain:fd use;
#line 159

#line 159
#
#line 159
# Allow the new domain to write back to the old domain via a pipe.
#line 159
#
#line 159
allow userdomain local_login_t:fifo_file { ioctl read getattr lock write append };
#line 159

#line 159
#
#line 159
# Allow the new domain to read and execute the program.
#line 159
#
#line 159
allow userdomain shell_exec_t:file { read getattr lock execute ioctl };
#line 159

#line 159
#
#line 159
# Allow the new domain to be entered via the program.
#line 159
#
#line 159
allow userdomain shell_exec_t:file entrypoint;
#line 159

#line 159

#line 159
# Signal the user domains.
#line 159
allow local_login_t userdomain:process signal;
#line 159


# Do not audit denied attempts to access devices.
dontaudit local_login_t fixed_disk_device_t:blk_file { getattr setattr };
dontaudit local_login_t removable_device_t:blk_file { getattr setattr };
dontaudit local_login_t device_t:{ chr_file blk_file lnk_file } { getattr setattr };
dontaudit local_login_t misc_device_t:{ chr_file blk_file } { getattr setattr };
dontaudit local_login_t framebuf_device_t:chr_file { getattr setattr read };
dontaudit local_login_t apm_bios_t:chr_file { getattr setattr };
dontaudit local_login_t v4l_device_t:chr_file { getattr setattr read };
dontaudit local_login_t removable_device_t:chr_file { getattr setattr };
dontaudit local_login_t scanner_device_t:chr_file { getattr setattr };

# Do not audit denied attempts to access /mnt.
dontaudit local_login_t mnt_t:dir { read getattr lock search ioctl };


# Create lock file.

#line 177
type local_login_lock_t, file_type, sysadmfile, lockfile;
#line 177

#line 177

#line 177

#line 177

#line 177
#
#line 177
# Allow the process to modify the directory.
#line 177
#
#line 177
allow local_login_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 177

#line 177
#
#line 177
# Allow the process to create the file.
#line 177
#
#line 177

#line 177

#line 177

#line 177

#line 177

#line 177
allow local_login_t local_login_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177

#line 177
type_transition local_login_t var_lock_t:file local_login_lock_t;
#line 177

#line 177

#line 177


# Read and write ttys.
allow local_login_t tty_device_t:chr_file { setattr { ioctl read getattr lock write append } };
allow local_login_t ttyfile:chr_file { setattr { ioctl read getattr lock write append } };

# Relabel ttys.
allow local_login_t tty_device_t:chr_file { getattr relabelfrom relabelto };
allow local_login_t ttyfile:chr_file { getattr relabelfrom relabelto };

#line 188


# Allow setting of attributes on sound devices.
allow local_login_t sound_device_t:chr_file { getattr setattr };

# Allow setting of attributes on power management devices.
allow local_login_t power_device_t:chr_file { getattr setattr };
dontaudit local_login_t init_t:fd use;

#################################
#
# Rules for the remote_login_t domain.
#


#line 202
type remote_login_t, domain, privuser, privrole, privlog, auth_chkpwd, privowner, privfd, nscd_client_domain, mlsfileread, mlsfilewrite, mlsprocsetsl, mlsfileupgrade, mlsfiledowngrade;
#line 202
role system_r types remote_login_t;
#line 202

#line 202
dontaudit remote_login_t shadow_t:file { getattr read };
#line 202

#line 202

#line 202
# Access other processes in the same domain.
#line 202
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 202
# These must be granted separately if desired.
#line 202
allow remote_login_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 202

#line 202
# Access /proc/PID files for processes in the same domain.
#line 202
allow remote_login_t self:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 202

#line 202
# Access file descriptions, pipes, and sockets
#line 202
# created by processes in the same domain.
#line 202
allow remote_login_t self:fd *;
#line 202
allow remote_login_t self:fifo_file { ioctl read getattr lock write append };
#line 202
allow remote_login_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 202
allow remote_login_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 202

#line 202
# Allow the domain to communicate with other processes in the same domain.
#line 202
allow remote_login_t self:unix_dgram_socket sendto;
#line 202
allow remote_login_t self:unix_stream_socket connectto;
#line 202

#line 202
# Access System V IPC objects created by processes in the same domain.
#line 202
allow remote_login_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 202
allow remote_login_t self:msg  { send receive };
#line 202
allow remote_login_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 202
allow remote_login_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 202
allow remote_login_t unpriv_userdomain:fd use;
#line 202
#
#line 202
# Every app is asking for ypbind so I am adding this here, 
#line 202
# eventually this should become can_nsswitch
#line 202
#
#line 202

#line 202

#line 202
if (allow_ypbind) {
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
#
#line 202
# Allow the domain to create and use tcp sockets.
#line 202
# Other kinds of sockets must be separately authorized for use.
#line 202
allow remote_login_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 202

#line 202
allow remote_login_t unlabeled_t:association { sendto recvfrom };
#line 202

#line 202
#
#line 202
# Allow the domain to send or receive using any network interface.
#line 202
# netif_type is a type attribute for all network interface types.
#line 202
#
#line 202
allow remote_login_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 202
#
#line 202
# Allow the domain to send to or receive from any node.
#line 202
# node_type is a type attribute for all node types.
#line 202
#
#line 202
allow remote_login_t node_type:node { tcp_send rawip_send };
#line 202
allow remote_login_t node_type:node { tcp_recv rawip_recv };
#line 202

#line 202
#
#line 202
# Allow the domain to send to or receive from any port.
#line 202
# port_type is a type attribute for all port types.
#line 202
#
#line 202

#line 202
allow remote_login_t port_type:tcp_socket { send_msg recv_msg };
#line 202

#line 202

#line 202
# XXX Allow binding to any node type.  Remove once
#line 202
# individual rules have been added to all domains that 
#line 202
# bind sockets. 
#line 202
allow remote_login_t node_type:tcp_socket node_bind;
#line 202
#
#line 202
# Allow access to network files including /etc/resolv.conf
#line 202
#
#line 202
allow remote_login_t net_conf_t:file { read getattr lock ioctl };
#line 202

#line 202
allow remote_login_t self:tcp_socket { listen accept };
#line 202

#line 202

#line 202

#line 202
#
#line 202
# Allow the domain to create and use tcp sockets.
#line 202
# Other kinds of sockets must be separately authorized for use.
#line 202
allow remote_login_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 202

#line 202
allow remote_login_t unlabeled_t:association { sendto recvfrom };
#line 202

#line 202
#
#line 202
# Allow the domain to send or receive using any network interface.
#line 202
# netif_type is a type attribute for all network interface types.
#line 202
#
#line 202
allow remote_login_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 202
#
#line 202
# Allow the domain to send to or receive from any node.
#line 202
# node_type is a type attribute for all node types.
#line 202
#
#line 202
allow remote_login_t node_type:node { tcp_send rawip_send };
#line 202
allow remote_login_t node_type:node { tcp_recv rawip_recv };
#line 202

#line 202
#
#line 202
# Allow the domain to send to or receive from any port.
#line 202
# port_type is a type attribute for all port types.
#line 202
#
#line 202

#line 202
allow remote_login_t port_type:tcp_socket { send_msg recv_msg };
#line 202

#line 202

#line 202
# XXX Allow binding to any node type.  Remove once
#line 202
# individual rules have been added to all domains that 
#line 202
# bind sockets. 
#line 202
allow remote_login_t node_type:tcp_socket node_bind;
#line 202
#
#line 202
# Allow access to network files including /etc/resolv.conf
#line 202
#
#line 202
allow remote_login_t net_conf_t:file { read getattr lock ioctl };
#line 202

#line 202
allow remote_login_t self:tcp_socket { connect };
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
#
#line 202
# Allow the domain to create and use udp sockets.
#line 202
# Other kinds of sockets must be separately authorized for use.
#line 202
allow remote_login_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 202

#line 202
allow remote_login_t unlabeled_t:association { sendto recvfrom };
#line 202

#line 202
#
#line 202
# Allow the domain to send or receive using any network interface.
#line 202
# netif_type is a type attribute for all network interface types.
#line 202
#
#line 202
allow remote_login_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 202
#
#line 202
# Allow the domain to send to or receive from any node.
#line 202
# node_type is a type attribute for all node types.
#line 202
#
#line 202
allow remote_login_t node_type:node { udp_send rawip_send };
#line 202
allow remote_login_t node_type:node { udp_recv rawip_recv };
#line 202

#line 202
#
#line 202
# Allow the domain to send to or receive from any port.
#line 202
# port_type is a type attribute for all port types.
#line 202
#
#line 202

#line 202
allow remote_login_t port_type:udp_socket { send_msg recv_msg };
#line 202

#line 202

#line 202
# XXX Allow binding to any node type.  Remove once
#line 202
# individual rules have been added to all domains that 
#line 202
# bind sockets. 
#line 202
allow remote_login_t node_type:udp_socket node_bind;
#line 202
#
#line 202
# Allow access to network files including /etc/resolv.conf
#line 202
#
#line 202
allow remote_login_t net_conf_t:file { read getattr lock ioctl };
#line 202

#line 202
allow remote_login_t self:udp_socket { connect };
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
allow remote_login_t var_yp_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t var_yp_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t var_yp_t:lnk_file { getattr read };
#line 202

#line 202
allow remote_login_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 202
allow remote_login_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 202
dontaudit remote_login_t self:capability net_bind_service;
#line 202
dontaudit remote_login_t reserved_port_type:tcp_socket name_connect;
#line 202
dontaudit remote_login_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 202

#line 202
} else {
#line 202
dontaudit remote_login_t var_yp_t:dir search;
#line 202
}
#line 202
 
#line 202
allow remote_login_t autofs_t:dir { search getattr };
#line 202
;
#line 202

#line 202
# Read system information files in /proc.
#line 202

#line 202
allow remote_login_t proc_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t proc_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t proc_t:lnk_file { getattr read };
#line 202

#line 202

#line 202

#line 202
# Read /.
#line 202
allow remote_login_t root_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t root_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 202

#line 202
# Read /home.
#line 202
allow remote_login_t home_root_t:dir { read getattr lock search ioctl };
#line 202

#line 202
# Read /usr.
#line 202
allow remote_login_t usr_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t usr_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 202

#line 202
# Read bin and sbin directories.
#line 202
allow remote_login_t bin_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t bin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 202
allow remote_login_t sbin_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t sbin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 202

#line 202
# Read system variables in /sys.
#line 202

#line 202
allow remote_login_t sysctl_t:dir search;
#line 202
allow remote_login_t sysctl_kernel_t:dir search;
#line 202
allow remote_login_t sysctl_kernel_t:file { getattr read };
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
allow remote_login_t selinux_config_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t selinux_config_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t selinux_config_t:lnk_file { getattr read };
#line 202

#line 202

#line 202
if (read_default_t) {
#line 202
#
#line 202
# Read default_t
#line 202
#.
#line 202
allow remote_login_t default_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t default_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 202
}
#line 202

#line 202

#line 202

#line 202
# Read directories and files with the readable_t type.
#line 202
# This type is a general type for "world"-readable files.
#line 202
allow remote_login_t readable_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t readable_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 202

#line 202
# Read /var, /var/spool
#line 202
allow remote_login_t { var_t var_spool_t }:dir search;
#line 202

#line 202
# for when /var/mail is a sym-link
#line 202
allow remote_login_t var_t:lnk_file read;
#line 202

#line 202
# Read /etc.
#line 202

#line 202
allow remote_login_t etc_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t etc_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t etc_t:lnk_file { getattr read };
#line 202

#line 202
allow remote_login_t etc_runtime_t:{ file lnk_file } { read getattr lock ioctl };
#line 202

#line 202

#line 202
allow remote_login_t etc_t:lnk_file read;
#line 202
allow remote_login_t lib_t:file { read getattr lock ioctl };
#line 202

#line 202
allow remote_login_t locale_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t locale_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t locale_t:lnk_file { getattr read };
#line 202

#line 202

#line 202

#line 202
# for SSP/ProPolice
#line 202
allow remote_login_t urandom_device_t:chr_file { getattr read };
#line 202

#line 202
# Read executable types.
#line 202
allow remote_login_t exec_type:{ file lnk_file } { read getattr lock ioctl };
#line 202

#line 202
# Read /dev directories and any symbolic links.
#line 202
allow remote_login_t device_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t device_t:lnk_file { read getattr lock ioctl };
#line 202

#line 202

#line 202
allow remote_login_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t lib_t:lnk_file { read getattr lock ioctl };
#line 202
allow remote_login_t ld_so_t:file { read getattr lock execute ioctl };
#line 202
#allow remote_login_t ld_so_t:file execute_no_trans;
#line 202
allow remote_login_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 202
allow remote_login_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 202
allow remote_login_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 202
allow remote_login_t texrel_shlib_t:file execmod;
#line 202
allow remote_login_t ld_so_cache_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t device_t:dir search;
#line 202
allow remote_login_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 202
;
#line 202

#line 202

#line 202
type remote_login_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 202

#line 202

#line 202

#line 202

#line 202
#
#line 202
# Allow the process to modify the directory.
#line 202
#
#line 202
allow remote_login_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 202

#line 202
#
#line 202
# Allow the process to create the file.
#line 202
#
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
allow remote_login_t remote_login_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
allow remote_login_t remote_login_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
type_transition remote_login_t tmp_t:{ file dir } remote_login_tmp_t;
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
# Use capabilities
#line 202
allow remote_login_t self:capability { dac_override chown fowner fsetid kill setgid setuid net_bind_service sys_nice sys_resource sys_tty_config };
#line 202
allow remote_login_t self:process setrlimit;
#line 202
dontaudit remote_login_t sysfs_t:dir search;
#line 202

#line 202
# Set exec context.
#line 202

#line 202
allow remote_login_t self:process setexec;
#line 202
allow remote_login_t proc_t:dir search;
#line 202
allow remote_login_t proc_t:{ file lnk_file } read;
#line 202
allow remote_login_t self:dir search;
#line 202
allow remote_login_t self:file { getattr read write };
#line 202

#line 202

#line 202
allow remote_login_t autofs_t:dir { search read getattr };
#line 202
allow remote_login_t mnt_t:dir { read getattr lock search ioctl };
#line 202

#line 202
if (use_nfs_home_dirs) {
#line 202

#line 202
allow remote_login_t nfs_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t nfs_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t nfs_t:lnk_file { getattr read };
#line 202

#line 202
}
#line 202

#line 202
if (use_samba_home_dirs) {
#line 202

#line 202
allow remote_login_t cifs_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t cifs_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t cifs_t:lnk_file { getattr read };
#line 202

#line 202
}
#line 202

#line 202
# Login can polyinstantiate
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
# FIXME: what is this for?
#line 202

#line 202
allow xdm_t remote_login_t:process signull;
#line 202

#line 202

#line 202

#line 202

#line 202
# Permit login to search the user home directories.
#line 202
allow remote_login_t home_root_t:dir search;
#line 202
allow remote_login_t home_dir_type:dir search;
#line 202

#line 202
# Write to /var/run/utmp.
#line 202
allow remote_login_t var_run_t:dir search;
#line 202
allow remote_login_t initrc_var_run_t:file { ioctl read getattr lock write append };
#line 202

#line 202
# Write to /var/log/wtmp.
#line 202
allow remote_login_t var_log_t:dir search;
#line 202
allow remote_login_t wtmp_t:file { ioctl read getattr lock write append };
#line 202

#line 202
# Write to /var/log/lastlog.
#line 202
allow remote_login_t lastlog_t:file { ioctl read getattr lock write append };
#line 202

#line 202
# Write to /var/log/btmp
#line 202
allow remote_login_t faillog_t:file { lock append read write };
#line 202

#line 202
# Search for mail spool file.
#line 202
allow remote_login_t mail_spool_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t mail_spool_t:file getattr;
#line 202
allow remote_login_t mail_spool_t:lnk_file read;
#line 202

#line 202
# Get security policy decisions.
#line 202

#line 202
# Get the selinuxfs mount point via /proc/self/mounts.
#line 202
allow remote_login_t proc_t:dir search;
#line 202
allow remote_login_t proc_t:{ file lnk_file } { getattr read };
#line 202
allow remote_login_t self:dir search;
#line 202
allow remote_login_t self:file { getattr read };
#line 202
# Access selinuxfs.
#line 202
allow remote_login_t security_t:dir { read search getattr };
#line 202
allow remote_login_t security_t:file { getattr read write };
#line 202
allow remote_login_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 202

#line 202

#line 202
# allow read access to default_contexts in /etc/security
#line 202
allow remote_login_t default_context_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t default_context_t:dir search;
#line 202

#line 202
allow remote_login_t selinux_config_t:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t selinux_config_t:file { read getattr lock ioctl };
#line 202
allow remote_login_t selinux_config_t:lnk_file { getattr read };
#line 202

#line 202

#line 202
allow remote_login_t mouse_device_t:chr_file { getattr setattr };
#line 202

#line 202

#line 202

#line 202

#line 202
typeattribute remote_login_t unrestricted;
#line 202
typeattribute remote_login_t privuser;
#line 202

#line 202
# Mount/unmount any filesystem. 
#line 202
allow remote_login_t fs_type:filesystem *;
#line 202

#line 202
# Mount/unmount any filesystem with the context= option. 
#line 202
allow remote_login_t file_type:filesystem *;
#line 202

#line 202
# Create/access any file in a labeled filesystem;
#line 202
allow remote_login_t file_type:{ file chr_file } ~execmod;
#line 202
allow remote_login_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 202
allow remote_login_t sysctl_t:{ dir file } *;
#line 202
allow remote_login_t device_type:{ chr_file blk_file } *;
#line 202
allow remote_login_t mtrr_device_t:file *;
#line 202

#line 202
# Create/access other files.  fs_type is to pick up various
#line 202
# pseudo filesystem types that are applied to both the filesystem
#line 202
# and its files.
#line 202
allow remote_login_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 202
allow remote_login_t unlabeled_t:association { sendto recvfrom };
#line 202

#line 202
allow remote_login_t proc_fs:{ dir file } *;
#line 202

#line 202
# For /proc/pid
#line 202

#line 202
allow remote_login_t domain:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t domain:file { read getattr lock ioctl };
#line 202
allow remote_login_t domain:lnk_file { getattr read };
#line 202

#line 202
# Write access is for setting attributes under /proc/self/attr.
#line 202
allow remote_login_t self:file { ioctl read getattr lock write append };
#line 202

#line 202
# Read and write sysctls.
#line 202

#line 202
allow remote_login_t sysctl_type:dir { read getattr lock search ioctl };
#line 202
allow remote_login_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 202

#line 202

#line 202
# Access the network.
#line 202
allow remote_login_t node_type:node *;
#line 202
allow remote_login_t netif_type:netif *;
#line 202
allow remote_login_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 202
allow remote_login_t port_type:tcp_socket name_connect;
#line 202

#line 202
# Bind to any network address.
#line 202
allow remote_login_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 202
allow remote_login_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 202
allow remote_login_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 202

#line 202
# Use/sendto/connectto sockets created by any domain.
#line 202
allow remote_login_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 202

#line 202
# Use descriptors and pipes created by any domain.
#line 202
allow remote_login_t domain:fd use;
#line 202
allow remote_login_t domain:fifo_file { ioctl read getattr lock write append };
#line 202

#line 202
# Act upon any other process.
#line 202
allow remote_login_t domain:process ~{ transition dyntransition execmem };
#line 202
# Transition to myself, to make get_ordered_context_list happy.
#line 202
allow remote_login_t self:process transition;
#line 202

#line 202
if (allow_execmem) {
#line 202
# Allow making anonymous memory executable, e.g. 
#line 202
# for runtime-code generation or executable stack.
#line 202
allow remote_login_t self:process execmem;
#line 202
}
#line 202

#line 202
if (allow_execmem && allow_execstack) {
#line 202
# Allow making the stack executable via mprotect.
#line 202
allow remote_login_t self:process execstack;
#line 202
}
#line 202

#line 202
if (allow_execmod) {
#line 202
# Allow text relocations on system shared libraries, e.g. libGL.
#line 202

#line 202
allow remote_login_t file_type:file execmod;
#line 202

#line 202
}
#line 202

#line 202
# Create/access any System V IPC objects.
#line 202
allow remote_login_t domain:{ sem msgq shm } *;
#line 202
allow remote_login_t domain:msg  { send receive };
#line 202

#line 202
# Access the security API.
#line 202
if (!secure_mode_policyload) {
#line 202
allow remote_login_t security_t:security *;
#line 202
auditallow remote_login_t security_t:security { load_policy setenforce setbool };
#line 202
}
#line 202
# Perform certain system operations that lacked individual capabilities.
#line 202
allow remote_login_t kernel_t:system *;
#line 202

#line 202
# Use any Linux capability.
#line 202
allow remote_login_t self:capability *;
#line 202

#line 202
# Set user information and skip authentication.
#line 202
allow remote_login_t self:passwd *;
#line 202

#line 202
# Communicate via dbusd.
#line 202
allow remote_login_t self:dbus *;
#line 202

#line 202
allow remote_login_t system_dbusd_t:dbus *;
#line 202

#line 202

#line 202
# Get info via nscd.
#line 202
allow remote_login_t self:nscd *;
#line 202

#line 202
allow remote_login_t nscd_t:nscd *;
#line 202

#line 202

#line 202

#line 202

#line 202

#line 202

#line 202
#
#line 202
# Allow the process to transition to the new domain.
#line 202
#
#line 202
allow remote_login_t unconfined_t:process transition;
#line 202

#line 202
#
#line 202
# Do not audit when glibc secure mode is enabled upon the transition.
#line 202
#
#line 202
dontaudit remote_login_t unconfined_t:process noatsecure;
#line 202

#line 202
#
#line 202
# Do not audit when signal-related state is cleared upon the transition.
#line 202
#
#line 202
dontaudit remote_login_t unconfined_t:process siginh;
#line 202

#line 202
#
#line 202
# Do not audit when resource limits are reset upon the transition.
#line 202
#
#line 202
dontaudit remote_login_t unconfined_t:process rlimitinh;
#line 202

#line 202
#
#line 202
# Allow the process to execute the program.
#line 202
# 
#line 202
allow remote_login_t shell_exec_t:file { read { getattr execute } };
#line 202

#line 202
#
#line 202
# Allow the process to reap the new domain.
#line 202
#
#line 202
allow unconfined_t remote_login_t:process sigchld;
#line 202

#line 202
#
#line 202
# Allow the new domain to inherit and use file 
#line 202
# descriptions from the creating process and vice versa.
#line 202
#
#line 202
allow unconfined_t remote_login_t:fd use;
#line 202
allow remote_login_t unconfined_t:fd use;
#line 202

#line 202
#
#line 202
# Allow the new domain to write back to the old domain via a pipe.
#line 202
#
#line 202
allow unconfined_t remote_login_t:fifo_file { ioctl read getattr lock write append };
#line 202

#line 202
#
#line 202
# Allow the new domain to read and execute the program.
#line 202
#
#line 202
allow unconfined_t shell_exec_t:file { read getattr lock execute ioctl };
#line 202

#line 202
#
#line 202
# Allow the new domain to be entered via the program.
#line 202
#
#line 202
allow unconfined_t shell_exec_t:file entrypoint;
#line 202

#line 202
type_transition remote_login_t shell_exec_t:process unconfined_t;
#line 202

#line 202

#line 202

#line 202


# Only permit unprivileged user domains to be entered via rlogin,
# since very weak authentication is used.

#line 206

#line 206

#line 206
#
#line 206
# Allow the process to transition to the new domain.
#line 206
#
#line 206
allow remote_login_t unpriv_userdomain:process transition;
#line 206

#line 206
#
#line 206
# Do not audit when glibc secure mode is enabled upon the transition.
#line 206
#
#line 206
dontaudit remote_login_t unpriv_userdomain:process noatsecure;
#line 206

#line 206
#
#line 206
# Do not audit when signal-related state is cleared upon the transition.
#line 206
#
#line 206
dontaudit remote_login_t unpriv_userdomain:process siginh;
#line 206

#line 206
#
#line 206
# Do not audit when resource limits are reset upon the transition.
#line 206
#
#line 206
dontaudit remote_login_t unpriv_userdomain:process rlimitinh;
#line 206

#line 206
#
#line 206
# Allow the process to execute the program.
#line 206
# 
#line 206
allow remote_login_t shell_exec_t:file { read { getattr execute } };
#line 206

#line 206
#
#line 206
# Allow the process to reap the new domain.
#line 206
#
#line 206
allow unpriv_userdomain remote_login_t:process sigchld;
#line 206

#line 206
#
#line 206
# Allow the new domain to inherit and use file 
#line 206
# descriptions from the creating process and vice versa.
#line 206
#
#line 206
allow unpriv_userdomain remote_login_t:fd use;
#line 206
allow remote_login_t unpriv_userdomain:fd use;
#line 206

#line 206
#
#line 206
# Allow the new domain to write back to the old domain via a pipe.
#line 206
#
#line 206
allow unpriv_userdomain remote_login_t:fifo_file { ioctl read getattr lock write append };
#line 206

#line 206
#
#line 206
# Allow the new domain to read and execute the program.
#line 206
#
#line 206
allow unpriv_userdomain shell_exec_t:file { read getattr lock execute ioctl };
#line 206

#line 206
#
#line 206
# Allow the new domain to be entered via the program.
#line 206
#
#line 206
allow unpriv_userdomain shell_exec_t:file entrypoint;
#line 206

#line 206

#line 206
# Signal the user domains.
#line 206
allow remote_login_t unpriv_userdomain:process signal;
#line 206


allow remote_login_t userpty_type:chr_file { setattr write };

# Use the pty created by rlogind.
#line 215

#line 215

#line 215
allow remote_login_t devpts_t:dir { read getattr lock search ioctl };
#line 215
allow remote_login_t rlogind_devpts_t:chr_file { ioctl read getattr lock write append };
#line 215

#line 215
# Relabel ptys created by rlogind.
#line 215
allow remote_login_t rlogind_devpts_t:chr_file { setattr relabelfrom relabelto };
#line 215


# Use the pty created by telnetd.
#line 222

#line 222

#line 222
allow remote_login_t devpts_t:dir { read getattr lock search ioctl };
#line 222
allow remote_login_t telnetd_devpts_t:chr_file { ioctl read getattr lock write append };
#line 222

#line 222
# Relabel ptys created by telnetd.
#line 222
allow remote_login_t telnetd_devpts_t:chr_file { setattr relabelfrom relabelto };
#line 222


allow remote_login_t ptyfile:chr_file { getattr relabelfrom relabelto ioctl };
allow remote_login_t fs_t:filesystem { getattr };

# Allow remote login to resolve host names (passed in via the -h switch)

#line 228

#line 228

#line 228

#line 228

#line 228
#
#line 228
# Allow the domain to create and use tcp sockets.
#line 228
# Other kinds of sockets must be separately authorized for use.
#line 228
allow remote_login_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 228

#line 228
allow remote_login_t unlabeled_t:association { sendto recvfrom };
#line 228

#line 228
#
#line 228
# Allow the domain to send or receive using any network interface.
#line 228
# netif_type is a type attribute for all network interface types.
#line 228
#
#line 228
allow remote_login_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 228
#
#line 228
# Allow the domain to send to or receive from any node.
#line 228
# node_type is a type attribute for all node types.
#line 228
#
#line 228
allow remote_login_t node_type:node { tcp_send rawip_send };
#line 228
allow remote_login_t node_type:node { tcp_recv rawip_recv };
#line 228

#line 228
#
#line 228
# Allow the domain to send to or receive from any port.
#line 228
# port_type is a type attribute for all port types.
#line 228
#
#line 228

#line 228
allow remote_login_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 228

#line 228

#line 228
# XXX Allow binding to any node type.  Remove once
#line 228
# individual rules have been added to all domains that 
#line 228
# bind sockets. 
#line 228
allow remote_login_t node_type:tcp_socket node_bind;
#line 228
#
#line 228
# Allow access to network files including /etc/resolv.conf
#line 228
#
#line 228
allow remote_login_t net_conf_t:file { read getattr lock ioctl };
#line 228

#line 228
allow remote_login_t self:tcp_socket { connect };
#line 228

#line 228

#line 228

#line 228
#
#line 228
# Allow the domain to create and use udp sockets.
#line 228
# Other kinds of sockets must be separately authorized for use.
#line 228
allow remote_login_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 228

#line 228
allow remote_login_t unlabeled_t:association { sendto recvfrom };
#line 228

#line 228
#
#line 228
# Allow the domain to send or receive using any network interface.
#line 228
# netif_type is a type attribute for all network interface types.
#line 228
#
#line 228
allow remote_login_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 228
#
#line 228
# Allow the domain to send to or receive from any node.
#line 228
# node_type is a type attribute for all node types.
#line 228
#
#line 228
allow remote_login_t node_type:node { udp_send rawip_send };
#line 228
allow remote_login_t node_type:node { udp_recv rawip_recv };
#line 228

#line 228
#
#line 228
# Allow the domain to send to or receive from any port.
#line 228
# port_type is a type attribute for all port types.
#line 228
#
#line 228

#line 228
allow remote_login_t dns_port_t:udp_socket { send_msg recv_msg };
#line 228

#line 228

#line 228
# XXX Allow binding to any node type.  Remove once
#line 228
# individual rules have been added to all domains that 
#line 228
# bind sockets. 
#line 228
allow remote_login_t node_type:udp_socket node_bind;
#line 228
#
#line 228
# Allow access to network files including /etc/resolv.conf
#line 228
#
#line 228
allow remote_login_t net_conf_t:file { read getattr lock ioctl };
#line 228

#line 228
allow remote_login_t self:udp_socket { connect };
#line 228

#line 228

#line 228

#line 228
allow remote_login_t dns_port_t:tcp_socket name_connect;
#line 228


#line 234

#line 1 "domains/program/lpd.te"
#DESC Lpd - Print server
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# Modified by David A. Wheeler <dwheeler@ida.org> for LPRng (Red Hat 7.1)
# Modified by Russell Coker <russell@coker.com.au>
# X-Debian-Packages: lpr
#

#################################
#
# Rules for the lpd_t domain.
#
# lpd_t is the domain of lpd.
# lpd_exec_t is the type of the lpd executable.
# printer_t is the type of the Unix domain socket created
# by lpd.
#

#line 18

#line 18

#line 18

#line 18
type lpd_t, domain, privlog, daemon , transitionbool;
#line 18
type lpd_exec_t, file_type, sysadmfile, exec_type;
#line 18
dontaudit lpd_t self:capability sys_tty_config;
#line 18

#line 18
role system_r types lpd_t;
#line 18

#line 18
# Inherit and use descriptors from init.
#line 18
allow lpd_t init_t:fd use;
#line 18
allow lpd_t init_t:process sigchld;
#line 18
allow lpd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 18

#line 18

#line 18
allow lpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 18
allow lpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 18
allow lpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 18
#allow lpd_t ld_so_t:file execute_no_trans;
#line 18
allow lpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 18
allow lpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 18
allow lpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 18
allow lpd_t texrel_shlib_t:file execmod;
#line 18
allow lpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 18
allow lpd_t device_t:dir search;
#line 18
allow lpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18

#line 18
allow lpd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 18
allow lpd_t { self proc_t }:lnk_file { getattr read };
#line 18

#line 18
allow lpd_t device_t:dir { read getattr lock search ioctl };
#line 18

#line 18
allow lpd_t udev_tdb_t:file { read getattr lock ioctl };
#line 18
allow lpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 18
dontaudit lpd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 18
dontaudit lpd_t unpriv_userdomain:fd use;
#line 18

#line 18

#line 18
allow lpd_t sysfs_t:dir { read getattr lock search ioctl };
#line 18
allow lpd_t sysfs_t:file { read getattr lock ioctl };
#line 18
allow lpd_t sysfs_t:lnk_file { getattr read };
#line 18
 
#line 18

#line 18
allow lpd_t autofs_t:dir { search getattr };
#line 18

#line 18
dontaudit lpd_t { tty_device_t devpts_t }:chr_file { read write };
#line 18
dontaudit lpd_t root_t:file { getattr read };
#line 18
 
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
# Read system variables in /sys.
#line 18

#line 18
allow lpd_t sysctl_t:dir search;
#line 18
allow lpd_t sysctl_kernel_t:dir search;
#line 18
allow lpd_t sysctl_kernel_t:file { getattr read };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allows user to define a tunable to disable domain transition
#line 18
#
#line 18

#line 18
bool lpd_disable_trans false;
#line 18
if (lpd_disable_trans) {
#line 18

#line 18
allow initrc_t lpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 18

#line 18

#line 18
allow sysadm_t lpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 18

#line 18
} else {
#line 18
 
#line 18

#line 18

#line 18
#
#line 18
# Allow the process to transition to the new domain.
#line 18
#
#line 18
allow initrc_t lpd_t:process transition;
#line 18

#line 18
#
#line 18
# Do not audit when glibc secure mode is enabled upon the transition.
#line 18
#
#line 18
dontaudit initrc_t lpd_t:process noatsecure;
#line 18

#line 18
#
#line 18
# Do not audit when signal-related state is cleared upon the transition.
#line 18
#
#line 18
dontaudit initrc_t lpd_t:process siginh;
#line 18

#line 18
#
#line 18
# Do not audit when resource limits are reset upon the transition.
#line 18
#
#line 18
dontaudit initrc_t lpd_t:process rlimitinh;
#line 18

#line 18
#
#line 18
# Allow the process to execute the program.
#line 18
# 
#line 18
allow initrc_t lpd_exec_t:file { read { getattr execute } };
#line 18

#line 18
#
#line 18
# Allow the process to reap the new domain.
#line 18
#
#line 18
allow lpd_t initrc_t:process sigchld;
#line 18

#line 18
#
#line 18
# Allow the new domain to inherit and use file 
#line 18
# descriptions from the creating process and vice versa.
#line 18
#
#line 18
allow lpd_t initrc_t:fd use;
#line 18
allow initrc_t lpd_t:fd use;
#line 18

#line 18
#
#line 18
# Allow the new domain to write back to the old domain via a pipe.
#line 18
#
#line 18
allow lpd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 18

#line 18
#
#line 18
# Allow the new domain to read and execute the program.
#line 18
#
#line 18
allow lpd_t lpd_exec_t:file { read getattr lock execute ioctl };
#line 18

#line 18
#
#line 18
# Allow the new domain to be entered via the program.
#line 18
#
#line 18
allow lpd_t lpd_exec_t:file entrypoint;
#line 18

#line 18
type_transition initrc_t lpd_exec_t:process lpd_t;
#line 18

#line 18

#line 18
allow initrc_t lpd_t:process { noatsecure siginh rlimitinh };
#line 18

#line 18
}
#line 18
 
#line 18
allow lpd_t privfd:fd use;
#line 18

#line 18
allow lpd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18

#line 18
# Create pid file.
#line 18
allow lpd_t var_t:dir { getattr search };
#line 18

#line 18
type lpd_var_run_t, file_type, sysadmfile, pidfile;
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the process to modify the directory.
#line 18
#
#line 18
allow lpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 18

#line 18
#
#line 18
# Allow the process to create the file.
#line 18
#
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
allow lpd_t lpd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
type_transition lpd_t var_run_t:file lpd_var_run_t;
#line 18

#line 18

#line 18

#line 18
allow lpd_t var_t:dir search;
#line 18
allow lpd_t lpd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 18

#line 18

#line 18
allow lpd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 18

#line 18
# for daemons that look at /root on startup
#line 18
dontaudit lpd_t sysadm_home_dir_t:dir search;
#line 18

#line 18
# for df
#line 18
allow lpd_t fs_type:filesystem getattr;
#line 18
allow lpd_t removable_t:filesystem getattr;
#line 18

#line 18

#line 18
allow lpd_t etc_t:lnk_file read;
#line 18
allow lpd_t lib_t:file { read getattr lock ioctl };
#line 18

#line 18
allow lpd_t locale_t:dir { read getattr lock search ioctl };
#line 18
allow lpd_t locale_t:file { read getattr lock ioctl };
#line 18
allow lpd_t locale_t:lnk_file { getattr read };
#line 18

#line 18

#line 18

#line 18
# for localization
#line 18
allow lpd_t lib_t:file { getattr read };
#line 18


allow lpd_t lpd_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };


#line 22

#line 22
# Read global fonts and font config
#line 22

#line 22
allow lpd_t fonts_t:dir { read getattr lock search ioctl };
#line 22
allow lpd_t fonts_t:file { read getattr lock ioctl };
#line 22
allow lpd_t fonts_t:lnk_file { getattr read };
#line 22

#line 22

#line 22
allow lpd_t etc_t:dir { read getattr lock search ioctl };
#line 22
allow lpd_t etc_t:file { read getattr lock ioctl };
#line 22
allow lpd_t etc_t:lnk_file { getattr read };
#line 22

#line 22

#line 22
 

type printer_t, file_type, sysadmfile, dev_fs;

type printconf_t, file_type, sysadmfile;   # Type for files in /usr/share/printconf.


#line 28
type lpd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the process to modify the directory.
#line 28
#
#line 28
allow lpd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 28

#line 28
#
#line 28
# Allow the process to create the file.
#line 28
#
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
allow lpd_t lpd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
allow lpd_t lpd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
type_transition lpd_t tmp_t:{ file dir } lpd_tmp_t;
#line 28

#line 28

#line 28
;

# for postscript include files
allow lpd_t usr_t:{ file lnk_file } { getattr read };

# Allow checkpc to access the lpd spool so it can check & fix it.
# This requires that /usr/sbin/checkpc have type checkpc_t.
type checkpc_t, domain, privlog;
role system_r types checkpc_t;

#line 37
allow checkpc_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 37
allow checkpc_t lib_t:lnk_file { read getattr lock ioctl };
#line 37
allow checkpc_t ld_so_t:file { read getattr lock execute ioctl };
#line 37
#allow checkpc_t ld_so_t:file execute_no_trans;
#line 37
allow checkpc_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 37
allow checkpc_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 37
allow checkpc_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 37
allow checkpc_t texrel_shlib_t:file execmod;
#line 37
allow checkpc_t ld_so_cache_t:file { read getattr lock ioctl };
#line 37
allow checkpc_t device_t:dir search;
#line 37
allow checkpc_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 37


#line 38

#line 38

#line 38

#line 38
#
#line 38
# Allow the domain to create and use tcp sockets.
#line 38
# Other kinds of sockets must be separately authorized for use.
#line 38
allow checkpc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 38

#line 38
allow checkpc_t unlabeled_t:association { sendto recvfrom };
#line 38

#line 38
#
#line 38
# Allow the domain to send or receive using any network interface.
#line 38
# netif_type is a type attribute for all network interface types.
#line 38
#
#line 38
allow checkpc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 38
#
#line 38
# Allow the domain to send to or receive from any node.
#line 38
# node_type is a type attribute for all node types.
#line 38
#
#line 38
allow checkpc_t node_type:node { tcp_send rawip_send };
#line 38
allow checkpc_t node_type:node { tcp_recv rawip_recv };
#line 38

#line 38
#
#line 38
# Allow the domain to send to or receive from any port.
#line 38
# port_type is a type attribute for all port types.
#line 38
#
#line 38

#line 38
allow checkpc_t port_type:tcp_socket { send_msg recv_msg };
#line 38

#line 38

#line 38
# XXX Allow binding to any node type.  Remove once
#line 38
# individual rules have been added to all domains that 
#line 38
# bind sockets. 
#line 38
allow checkpc_t node_type:tcp_socket node_bind;
#line 38
#
#line 38
# Allow access to network files including /etc/resolv.conf
#line 38
#
#line 38
allow checkpc_t net_conf_t:file { read getattr lock ioctl };
#line 38

#line 38
allow checkpc_t self:tcp_socket { connect };
#line 38

#line 38

#line 38

#line 38
#
#line 38
# Allow the domain to create and use udp sockets.
#line 38
# Other kinds of sockets must be separately authorized for use.
#line 38
allow checkpc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 38

#line 38
allow checkpc_t unlabeled_t:association { sendto recvfrom };
#line 38

#line 38
#
#line 38
# Allow the domain to send or receive using any network interface.
#line 38
# netif_type is a type attribute for all network interface types.
#line 38
#
#line 38
allow checkpc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 38
#
#line 38
# Allow the domain to send to or receive from any node.
#line 38
# node_type is a type attribute for all node types.
#line 38
#
#line 38
allow checkpc_t node_type:node { udp_send rawip_send };
#line 38
allow checkpc_t node_type:node { udp_recv rawip_recv };
#line 38

#line 38
#
#line 38
# Allow the domain to send to or receive from any port.
#line 38
# port_type is a type attribute for all port types.
#line 38
#
#line 38

#line 38
allow checkpc_t port_type:udp_socket { send_msg recv_msg };
#line 38

#line 38

#line 38
# XXX Allow binding to any node type.  Remove once
#line 38
# individual rules have been added to all domains that 
#line 38
# bind sockets. 
#line 38
allow checkpc_t node_type:udp_socket node_bind;
#line 38
#
#line 38
# Allow access to network files including /etc/resolv.conf
#line 38
#
#line 38
allow checkpc_t net_conf_t:file { read getattr lock ioctl };
#line 38

#line 38
allow checkpc_t self:udp_socket { connect };
#line 38

#line 38

#line 38

allow checkpc_t port_type:tcp_socket name_connect;

#line 40

#line 40
if (allow_ypbind) {
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use tcp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow checkpc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow checkpc_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow checkpc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow checkpc_t node_type:node { tcp_send rawip_send };
#line 40
allow checkpc_t node_type:node { tcp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow checkpc_t port_type:tcp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow checkpc_t node_type:tcp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow checkpc_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow checkpc_t self:tcp_socket { listen accept };
#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use tcp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow checkpc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow checkpc_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow checkpc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow checkpc_t node_type:node { tcp_send rawip_send };
#line 40
allow checkpc_t node_type:node { tcp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow checkpc_t port_type:tcp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow checkpc_t node_type:tcp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow checkpc_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow checkpc_t self:tcp_socket { connect };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use udp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow checkpc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow checkpc_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow checkpc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow checkpc_t node_type:node { udp_send rawip_send };
#line 40
allow checkpc_t node_type:node { udp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow checkpc_t port_type:udp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow checkpc_t node_type:udp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow checkpc_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow checkpc_t self:udp_socket { connect };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
allow checkpc_t var_yp_t:dir { read getattr lock search ioctl };
#line 40
allow checkpc_t var_yp_t:file { read getattr lock ioctl };
#line 40
allow checkpc_t var_yp_t:lnk_file { getattr read };
#line 40

#line 40
allow checkpc_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 40
allow checkpc_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 40
dontaudit checkpc_t self:capability net_bind_service;
#line 40
dontaudit checkpc_t reserved_port_type:tcp_socket name_connect;
#line 40
dontaudit checkpc_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 40

#line 40
} else {
#line 40
dontaudit checkpc_t var_yp_t:dir search;
#line 40
}
#line 40
 

#line 41
type checkpc_log_t, file_type, sysadmfile, logfile;
#line 41

#line 41

#line 41

#line 41

#line 41
#
#line 41
# Allow the process to modify the directory.
#line 41
#
#line 41
allow checkpc_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 41

#line 41
#
#line 41
# Allow the process to create the file.
#line 41
#
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
allow checkpc_t checkpc_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
type_transition checkpc_t var_log_t:file checkpc_log_t;
#line 41

#line 41

#line 41

type checkpc_exec_t, file_type, sysadmfile, exec_type;

#line 43

#line 43

#line 43
#
#line 43
# Allow the process to transition to the new domain.
#line 43
#
#line 43
allow initrc_t checkpc_t:process transition;
#line 43

#line 43
#
#line 43
# Do not audit when glibc secure mode is enabled upon the transition.
#line 43
#
#line 43
dontaudit initrc_t checkpc_t:process noatsecure;
#line 43

#line 43
#
#line 43
# Do not audit when signal-related state is cleared upon the transition.
#line 43
#
#line 43
dontaudit initrc_t checkpc_t:process siginh;
#line 43

#line 43
#
#line 43
# Do not audit when resource limits are reset upon the transition.
#line 43
#
#line 43
dontaudit initrc_t checkpc_t:process rlimitinh;
#line 43

#line 43
#
#line 43
# Allow the process to execute the program.
#line 43
# 
#line 43
allow initrc_t checkpc_exec_t:file { read { getattr execute } };
#line 43

#line 43
#
#line 43
# Allow the process to reap the new domain.
#line 43
#
#line 43
allow checkpc_t initrc_t:process sigchld;
#line 43

#line 43
#
#line 43
# Allow the new domain to inherit and use file 
#line 43
# descriptions from the creating process and vice versa.
#line 43
#
#line 43
allow checkpc_t initrc_t:fd use;
#line 43
allow initrc_t checkpc_t:fd use;
#line 43

#line 43
#
#line 43
# Allow the new domain to write back to the old domain via a pipe.
#line 43
#
#line 43
allow checkpc_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 43

#line 43
#
#line 43
# Allow the new domain to read and execute the program.
#line 43
#
#line 43
allow checkpc_t checkpc_exec_t:file { read getattr lock execute ioctl };
#line 43

#line 43
#
#line 43
# Allow the new domain to be entered via the program.
#line 43
#
#line 43
allow checkpc_t checkpc_exec_t:file entrypoint;
#line 43

#line 43
type_transition initrc_t checkpc_exec_t:process checkpc_t;
#line 43


#line 44

#line 44

#line 44
#
#line 44
# Allow the process to transition to the new domain.
#line 44
#
#line 44
allow sysadm_t checkpc_t:process transition;
#line 44

#line 44
#
#line 44
# Do not audit when glibc secure mode is enabled upon the transition.
#line 44
#
#line 44
dontaudit sysadm_t checkpc_t:process noatsecure;
#line 44

#line 44
#
#line 44
# Do not audit when signal-related state is cleared upon the transition.
#line 44
#
#line 44
dontaudit sysadm_t checkpc_t:process siginh;
#line 44

#line 44
#
#line 44
# Do not audit when resource limits are reset upon the transition.
#line 44
#
#line 44
dontaudit sysadm_t checkpc_t:process rlimitinh;
#line 44

#line 44
#
#line 44
# Allow the process to execute the program.
#line 44
# 
#line 44
allow sysadm_t checkpc_exec_t:file { read { getattr execute } };
#line 44

#line 44
#
#line 44
# Allow the process to reap the new domain.
#line 44
#
#line 44
allow checkpc_t sysadm_t:process sigchld;
#line 44

#line 44
#
#line 44
# Allow the new domain to inherit and use file 
#line 44
# descriptions from the creating process and vice versa.
#line 44
#
#line 44
allow checkpc_t sysadm_t:fd use;
#line 44
allow sysadm_t checkpc_t:fd use;
#line 44

#line 44
#
#line 44
# Allow the new domain to write back to the old domain via a pipe.
#line 44
#
#line 44
allow checkpc_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 44

#line 44
#
#line 44
# Allow the new domain to read and execute the program.
#line 44
#
#line 44
allow checkpc_t checkpc_exec_t:file { read getattr lock execute ioctl };
#line 44

#line 44
#
#line 44
# Allow the new domain to be entered via the program.
#line 44
#
#line 44
allow checkpc_t checkpc_exec_t:file entrypoint;
#line 44

#line 44
type_transition sysadm_t checkpc_exec_t:process checkpc_t;
#line 44

role sysadm_r types checkpc_t;
allow checkpc_t admin_tty_type:chr_file { read write };
allow checkpc_t privfd:fd use;
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
#
#line 50
# Allow the process to transition to the new domain.
#line 50
#
#line 50
allow system_crond_t checkpc_t:process transition;
#line 50

#line 50
#
#line 50
# Do not audit when glibc secure mode is enabled upon the transition.
#line 50
#
#line 50
dontaudit system_crond_t checkpc_t:process noatsecure;
#line 50

#line 50
#
#line 50
# Do not audit when signal-related state is cleared upon the transition.
#line 50
#
#line 50
dontaudit system_crond_t checkpc_t:process siginh;
#line 50

#line 50
#
#line 50
# Do not audit when resource limits are reset upon the transition.
#line 50
#
#line 50
dontaudit system_crond_t checkpc_t:process rlimitinh;
#line 50

#line 50
#
#line 50
# Allow the process to execute the program.
#line 50
# 
#line 50
allow system_crond_t checkpc_exec_t:file { read { getattr execute } };
#line 50

#line 50
#
#line 50
# Allow the process to reap the new domain.
#line 50
#
#line 50
allow checkpc_t system_crond_t:process sigchld;
#line 50

#line 50
#
#line 50
# Allow the new domain to inherit and use file 
#line 50
# descriptions from the creating process and vice versa.
#line 50
#
#line 50
allow checkpc_t system_crond_t:fd use;
#line 50
allow system_crond_t checkpc_t:fd use;
#line 50

#line 50
#
#line 50
# Allow the new domain to write back to the old domain via a pipe.
#line 50
#
#line 50
allow checkpc_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 50

#line 50
#
#line 50
# Allow the new domain to read and execute the program.
#line 50
#
#line 50
allow checkpc_t checkpc_exec_t:file { read getattr lock execute ioctl };
#line 50

#line 50
#
#line 50
# Allow the new domain to be entered via the program.
#line 50
#
#line 50
allow checkpc_t checkpc_exec_t:file entrypoint;
#line 50

#line 50
type_transition system_crond_t checkpc_exec_t:process checkpc_t;
#line 50

#line 50
allow checkpc_t crond_t:fifo_file { getattr read write ioctl };
#line 50
# a rule for privfd may make this obsolete
#line 50
allow checkpc_t crond_t:fd use;
#line 50
allow checkpc_t crond_t:process sigchld;
#line 50

#line 50

allow checkpc_t self:capability { setgid setuid dac_override };
allow checkpc_t self:process { fork { sigchld sigkill sigstop signull signal } };

allow checkpc_t proc_t:dir search;
allow checkpc_t proc_t:lnk_file read;
allow checkpc_t proc_t:file { getattr read };

#line 57
allow checkpc_t self:dir { read getattr lock search ioctl };
#line 57
allow checkpc_t self:file { read getattr lock ioctl };
#line 57
allow checkpc_t self:lnk_file { getattr read };
#line 57

allow checkpc_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

allow checkpc_t { etc_t etc_runtime_t }:file { getattr read };
allow checkpc_t etc_t:lnk_file read;

allow checkpc_t { var_t var_spool_t }:dir { getattr search };
allow checkpc_t print_spool_t:file { { ioctl read getattr lock write append } unlink };
allow checkpc_t print_spool_t:dir { read write search add_name remove_name getattr };
allow checkpc_t device_t:dir search;
allow checkpc_t printer_device_t:chr_file { getattr append };
allow checkpc_t devtty_t:chr_file { ioctl read getattr lock write append };
allow checkpc_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };

# Allow access to /dev/console through the fd:
allow checkpc_t init_t:fd use;

# This is less desirable, but checkpc demands /bin/bash and /bin/chown:
allow checkpc_t { bin_t sbin_t }:dir search;
allow checkpc_t bin_t:lnk_file read;

#line 77
allow checkpc_t shell_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 77


#line 78
allow checkpc_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 78


# bash wants access to /proc/meminfo
allow lpd_t proc_t:file { getattr read };

# gs-gnu wants to read some sysctl entries, it seems to work without though
dontaudit lpd_t { sysctl_t sysctl_kernel_t }:dir search;

# for defoma

#line 87
allow lpd_t var_lib_t:dir { read getattr lock search ioctl };
#line 87
allow lpd_t var_lib_t:file { read getattr lock ioctl };
#line 87
allow lpd_t var_lib_t:lnk_file { getattr read };
#line 87


allow checkpc_t var_run_t:dir search;
allow checkpc_t lpd_var_run_t:dir { search getattr };

# This is needed to permit chown to read /var/spool/lpd/lp.
# This is opens up security more than necessary; this means that ANYTHING
# running in the initrc_t domain can read the printer spool directory.
# Perhaps executing /etc/rc.d/init.d/lpd should transition
# to domain lpd_t, instead of waiting for executing lpd.
allow initrc_t print_spool_t:dir read;

# for defoma

#line 100
allow lpd_t readable_t:dir { read getattr lock search ioctl };
#line 100
allow lpd_t readable_t:file { read getattr lock ioctl };
#line 100
allow lpd_t readable_t:lnk_file { getattr read };
#line 100


# Use capabilities.
allow lpd_t self:capability { setgid setuid net_bind_service dac_read_search dac_override chown fowner };

# Use the network.

#line 106

#line 106

#line 106

#line 106
#
#line 106
# Allow the domain to create and use tcp sockets.
#line 106
# Other kinds of sockets must be separately authorized for use.
#line 106
allow lpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 106

#line 106
allow lpd_t unlabeled_t:association { sendto recvfrom };
#line 106

#line 106
#
#line 106
# Allow the domain to send or receive using any network interface.
#line 106
# netif_type is a type attribute for all network interface types.
#line 106
#
#line 106
allow lpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 106
#
#line 106
# Allow the domain to send to or receive from any node.
#line 106
# node_type is a type attribute for all node types.
#line 106
#
#line 106
allow lpd_t node_type:node { tcp_send rawip_send };
#line 106
allow lpd_t node_type:node { tcp_recv rawip_recv };
#line 106

#line 106
#
#line 106
# Allow the domain to send to or receive from any port.
#line 106
# port_type is a type attribute for all port types.
#line 106
#
#line 106

#line 106
allow lpd_t port_type:tcp_socket { send_msg recv_msg };
#line 106

#line 106

#line 106
# XXX Allow binding to any node type.  Remove once
#line 106
# individual rules have been added to all domains that 
#line 106
# bind sockets. 
#line 106
allow lpd_t node_type:tcp_socket node_bind;
#line 106
#
#line 106
# Allow access to network files including /etc/resolv.conf
#line 106
#
#line 106
allow lpd_t net_conf_t:file { read getattr lock ioctl };
#line 106

#line 106
allow lpd_t self:tcp_socket { listen accept };
#line 106

#line 106

#line 106

#line 106
#
#line 106
# Allow the domain to create and use udp sockets.
#line 106
# Other kinds of sockets must be separately authorized for use.
#line 106
allow lpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 106

#line 106
allow lpd_t unlabeled_t:association { sendto recvfrom };
#line 106

#line 106
#
#line 106
# Allow the domain to send or receive using any network interface.
#line 106
# netif_type is a type attribute for all network interface types.
#line 106
#
#line 106
allow lpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 106
#
#line 106
# Allow the domain to send to or receive from any node.
#line 106
# node_type is a type attribute for all node types.
#line 106
#
#line 106
allow lpd_t node_type:node { udp_send rawip_send };
#line 106
allow lpd_t node_type:node { udp_recv rawip_recv };
#line 106

#line 106
#
#line 106
# Allow the domain to send to or receive from any port.
#line 106
# port_type is a type attribute for all port types.
#line 106
#
#line 106

#line 106
allow lpd_t port_type:udp_socket { send_msg recv_msg };
#line 106

#line 106

#line 106
# XXX Allow binding to any node type.  Remove once
#line 106
# individual rules have been added to all domains that 
#line 106
# bind sockets. 
#line 106
allow lpd_t node_type:udp_socket node_bind;
#line 106
#
#line 106
# Allow access to network files including /etc/resolv.conf
#line 106
#
#line 106
allow lpd_t net_conf_t:file { read getattr lock ioctl };
#line 106

#line 106
allow lpd_t self:udp_socket { connect };
#line 106

#line 106

#line 106


#line 107

#line 107
if (allow_ypbind) {
#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107
#
#line 107
# Allow the domain to create and use tcp sockets.
#line 107
# Other kinds of sockets must be separately authorized for use.
#line 107
allow lpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 107

#line 107
allow lpd_t unlabeled_t:association { sendto recvfrom };
#line 107

#line 107
#
#line 107
# Allow the domain to send or receive using any network interface.
#line 107
# netif_type is a type attribute for all network interface types.
#line 107
#
#line 107
allow lpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 107
#
#line 107
# Allow the domain to send to or receive from any node.
#line 107
# node_type is a type attribute for all node types.
#line 107
#
#line 107
allow lpd_t node_type:node { tcp_send rawip_send };
#line 107
allow lpd_t node_type:node { tcp_recv rawip_recv };
#line 107

#line 107
#
#line 107
# Allow the domain to send to or receive from any port.
#line 107
# port_type is a type attribute for all port types.
#line 107
#
#line 107

#line 107
allow lpd_t port_type:tcp_socket { send_msg recv_msg };
#line 107

#line 107

#line 107
# XXX Allow binding to any node type.  Remove once
#line 107
# individual rules have been added to all domains that 
#line 107
# bind sockets. 
#line 107
allow lpd_t node_type:tcp_socket node_bind;
#line 107
#
#line 107
# Allow access to network files including /etc/resolv.conf
#line 107
#
#line 107
allow lpd_t net_conf_t:file { read getattr lock ioctl };
#line 107

#line 107
allow lpd_t self:tcp_socket { listen accept };
#line 107

#line 107

#line 107

#line 107
#
#line 107
# Allow the domain to create and use tcp sockets.
#line 107
# Other kinds of sockets must be separately authorized for use.
#line 107
allow lpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 107

#line 107
allow lpd_t unlabeled_t:association { sendto recvfrom };
#line 107

#line 107
#
#line 107
# Allow the domain to send or receive using any network interface.
#line 107
# netif_type is a type attribute for all network interface types.
#line 107
#
#line 107
allow lpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 107
#
#line 107
# Allow the domain to send to or receive from any node.
#line 107
# node_type is a type attribute for all node types.
#line 107
#
#line 107
allow lpd_t node_type:node { tcp_send rawip_send };
#line 107
allow lpd_t node_type:node { tcp_recv rawip_recv };
#line 107

#line 107
#
#line 107
# Allow the domain to send to or receive from any port.
#line 107
# port_type is a type attribute for all port types.
#line 107
#
#line 107

#line 107
allow lpd_t port_type:tcp_socket { send_msg recv_msg };
#line 107

#line 107

#line 107
# XXX Allow binding to any node type.  Remove once
#line 107
# individual rules have been added to all domains that 
#line 107
# bind sockets. 
#line 107
allow lpd_t node_type:tcp_socket node_bind;
#line 107
#
#line 107
# Allow access to network files including /etc/resolv.conf
#line 107
#
#line 107
allow lpd_t net_conf_t:file { read getattr lock ioctl };
#line 107

#line 107
allow lpd_t self:tcp_socket { connect };
#line 107

#line 107

#line 107

#line 107

#line 107

#line 107
#
#line 107
# Allow the domain to create and use udp sockets.
#line 107
# Other kinds of sockets must be separately authorized for use.
#line 107
allow lpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 107

#line 107
allow lpd_t unlabeled_t:association { sendto recvfrom };
#line 107

#line 107
#
#line 107
# Allow the domain to send or receive using any network interface.
#line 107
# netif_type is a type attribute for all network interface types.
#line 107
#
#line 107
allow lpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 107
#
#line 107
# Allow the domain to send to or receive from any node.
#line 107
# node_type is a type attribute for all node types.
#line 107
#
#line 107
allow lpd_t node_type:node { udp_send rawip_send };
#line 107
allow lpd_t node_type:node { udp_recv rawip_recv };
#line 107

#line 107
#
#line 107
# Allow the domain to send to or receive from any port.
#line 107
# port_type is a type attribute for all port types.
#line 107
#
#line 107

#line 107
allow lpd_t port_type:udp_socket { send_msg recv_msg };
#line 107

#line 107

#line 107
# XXX Allow binding to any node type.  Remove once
#line 107
# individual rules have been added to all domains that 
#line 107
# bind sockets. 
#line 107
allow lpd_t node_type:udp_socket node_bind;
#line 107
#
#line 107
# Allow access to network files including /etc/resolv.conf
#line 107
#
#line 107
allow lpd_t net_conf_t:file { read getattr lock ioctl };
#line 107

#line 107
allow lpd_t self:udp_socket { connect };
#line 107

#line 107

#line 107

#line 107

#line 107

#line 107

#line 107
allow lpd_t var_yp_t:dir { read getattr lock search ioctl };
#line 107
allow lpd_t var_yp_t:file { read getattr lock ioctl };
#line 107
allow lpd_t var_yp_t:lnk_file { getattr read };
#line 107

#line 107
allow lpd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 107
allow lpd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 107
dontaudit lpd_t self:capability net_bind_service;
#line 107
dontaudit lpd_t reserved_port_type:tcp_socket name_connect;
#line 107
dontaudit lpd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 107

#line 107
} else {
#line 107
dontaudit lpd_t var_yp_t:dir search;
#line 107
}
#line 107
 
allow lpd_t self:fifo_file { ioctl read getattr lock write append };
allow lpd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow lpd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

allow lpd_t self:file { getattr read };
allow lpd_t etc_runtime_t:file { getattr read };

# Bind to the printer port.
allow lpd_t printer_port_t:tcp_socket name_bind;

# Send to portmap.

#line 119
#allow lpd_t portmap_t:udp_socket sendto;
#line 119
#allow portmap_t lpd_t:udp_socket recvfrom;
#line 119


#line 123
# Connect to ypbind.
#line 123

#line 123
#allow lpd_t ypbind_t:tcp_socket { connectto recvfrom };
#line 123
#allow ypbind_t lpd_t:tcp_socket { acceptfrom recvfrom };
#line 123
#allow ypbind_t kernel_t:tcp_socket recvfrom;
#line 123
#allow lpd_t kernel_t:tcp_socket recvfrom;
#line 123


# Create and bind to /dev/printer.

#line 126

#line 126

#line 126

#line 126
#
#line 126
# Allow the process to modify the directory.
#line 126
#
#line 126
allow lpd_t device_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 126

#line 126
#
#line 126
# Allow the process to create the file.
#line 126
#
#line 126

#line 126

#line 126

#line 126

#line 126

#line 126
allow lpd_t printer_t:lnk_file { create read getattr setattr link unlink rename };
#line 126

#line 126

#line 126

#line 126

#line 126

#line 126

#line 126

#line 126

#line 126

#line 126
type_transition lpd_t device_t:lnk_file printer_t;
#line 126

#line 126

allow lpd_t printer_t:unix_stream_socket name_bind;
allow lpd_t printer_t:unix_dgram_socket name_bind;
allow lpd_t printer_device_t:chr_file { ioctl read getattr lock write append };

# Write to /var/spool/lpd.
allow lpd_t var_spool_t:dir search;
allow lpd_t print_spool_t:dir { read getattr lock search ioctl add_name remove_name write };
allow lpd_t print_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
allow lpd_t print_spool_t:file { ioctl read getattr lock write append };

# Execute filter scripts.
# can_exec(lpd_t, print_spool_t)

# Filter scripts may be shell scripts, and may invoke progs like /bin/mktemp
allow lpd_t bin_t:dir search;
allow lpd_t bin_t:lnk_file read;

#line 143
allow lpd_t { bin_t sbin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 143


# lpd must be able to execute the filter utilities in /usr/share/printconf.

#line 146
allow lpd_t printconf_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 146

allow lpd_t printconf_t:file { read getattr lock execute ioctl };
allow lpd_t printconf_t:dir { getattr search read };

# config files for lpd are of type etc_t, probably should change this
allow lpd_t etc_t:file { getattr read };
allow lpd_t etc_t:lnk_file read;

# checkpc needs similar permissions.
allow checkpc_t printconf_t:file getattr;
allow checkpc_t printconf_t:dir { getattr search read };

# Read printconf files.
allow initrc_t printconf_t:dir { read getattr lock search ioctl };
allow initrc_t printconf_t:file { read getattr lock ioctl };

#line 1 "domains/program/mailman.te"
#DESC Mailman - GNU Mailman mailing list manager
#
# Author: Russell Coker <russell@coker.com.au>
# X-Debian-Packages: mailman

type mailman_data_t, file_type, sysadmfile;
type mailman_archive_t, file_type, sysadmfile;

type mailman_log_t, file_type, sysadmfile, logfile;
type mailman_lock_t, file_type, sysadmfile, lockfile;

#line 38



#line 40
type mailman_queue_t, domain, privlog , auth_chkpwd, nscd_client_domain;
#line 40
type mailman_queue_exec_t, file_type, sysadmfile, exec_type;
#line 40
role system_r types mailman_queue_t;
#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the process to modify the directory.
#line 40
#
#line 40
allow mailman_queue_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 40

#line 40
#
#line 40
# Allow the process to create the file.
#line 40
#
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
allow mailman_queue_t mailman_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
type_transition mailman_queue_t var_log_t:file mailman_log_t;
#line 40

#line 40

#line 40
allow mailman_queue_t mailman_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 40

#line 40
allow mailman_queue_t mailman_data_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 40
allow mailman_queue_t mailman_data_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 40
allow mailman_queue_t mailman_data_t:lnk_file { create read getattr setattr link unlink rename };
#line 40

#line 40

#line 40
allow mailman_queue_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 40
allow mailman_queue_t lib_t:lnk_file { read getattr lock ioctl };
#line 40
allow mailman_queue_t ld_so_t:file { read getattr lock execute ioctl };
#line 40
#allow mailman_queue_t ld_so_t:file execute_no_trans;
#line 40
allow mailman_queue_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 40
allow mailman_queue_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 40
allow mailman_queue_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 40
allow mailman_queue_t texrel_shlib_t:file execmod;
#line 40
allow mailman_queue_t ld_so_cache_t:file { read getattr lock ioctl };
#line 40
allow mailman_queue_t device_t:dir search;
#line 40
allow mailman_queue_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 40

#line 40

#line 40
allow mailman_queue_t { bin_t sbin_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 40
allow mailman_queue_t { bin_t sbin_t etc_t }:lnk_file { getattr read };
#line 40

#line 40
allow mailman_queue_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 40
allow mailman_queue_t lib_t:lnk_file { read getattr lock ioctl };
#line 40
allow mailman_queue_t ld_so_t:file { read getattr lock execute ioctl };
#line 40
#allow mailman_queue_t ld_so_t:file execute_no_trans;
#line 40
allow mailman_queue_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 40
allow mailman_queue_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 40
allow mailman_queue_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 40
allow mailman_queue_t texrel_shlib_t:file execmod;
#line 40
allow mailman_queue_t ld_so_cache_t:file { read getattr lock ioctl };
#line 40
allow mailman_queue_t device_t:dir search;
#line 40
allow mailman_queue_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 40

#line 40

#line 40
allow mailman_queue_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 40

#line 40

#line 40
allow mailman_queue_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 40

#line 40

#line 40
allow mailman_queue_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 40

#line 40

#line 40
allow mailman_queue_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 40

#line 40

#line 40
allow mailman_queue_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 40

#line 40

#line 40
allow mailman_queue_t ld_so_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 40

#line 40

#line 40

#line 40
# Read system variables in /sys.
#line 40

#line 40
allow mailman_queue_t sysctl_t:dir search;
#line 40
allow mailman_queue_t sysctl_kernel_t:dir search;
#line 40
allow mailman_queue_t sysctl_kernel_t:file { getattr read };
#line 40

#line 40

#line 40

#line 40
allow mailman_queue_t proc_t:dir search;
#line 40
allow mailman_queue_t proc_t:file { read getattr };
#line 40
allow mailman_queue_t var_lib_t:dir { read getattr lock search ioctl };
#line 40
allow mailman_queue_t var_lib_t:lnk_file read;
#line 40
allow mailman_queue_t device_t:dir search;
#line 40
allow mailman_queue_t etc_runtime_t:file { read getattr };
#line 40

#line 40
allow mailman_queue_t etc_t:lnk_file read;
#line 40
allow mailman_queue_t lib_t:file { read getattr lock ioctl };
#line 40

#line 40
allow mailman_queue_t locale_t:dir { read getattr lock search ioctl };
#line 40
allow mailman_queue_t locale_t:file { read getattr lock ioctl };
#line 40
allow mailman_queue_t locale_t:lnk_file { getattr read };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the process to modify the directory.
#line 40
#
#line 40
allow mailman_queue_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 40

#line 40
#
#line 40
# Allow the process to create the file.
#line 40
#
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
allow mailman_queue_t mailman_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
type_transition mailman_queue_t var_lock_t:file mailman_lock_t;
#line 40

#line 40

#line 40
allow mailman_queue_t mailman_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 40
allow mailman_queue_t fs_t:filesystem getattr;
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use tcp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow mailman_queue_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow mailman_queue_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow mailman_queue_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow mailman_queue_t node_type:node { tcp_send rawip_send };
#line 40
allow mailman_queue_t node_type:node { tcp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow mailman_queue_t port_type:tcp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow mailman_queue_t node_type:tcp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow mailman_queue_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow mailman_queue_t self:tcp_socket { listen accept };
#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use tcp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow mailman_queue_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow mailman_queue_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow mailman_queue_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow mailman_queue_t node_type:node { tcp_send rawip_send };
#line 40
allow mailman_queue_t node_type:node { tcp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow mailman_queue_t port_type:tcp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow mailman_queue_t node_type:tcp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow mailman_queue_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow mailman_queue_t self:tcp_socket { connect };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use udp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow mailman_queue_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow mailman_queue_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow mailman_queue_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow mailman_queue_t node_type:node { udp_send rawip_send };
#line 40
allow mailman_queue_t node_type:node { udp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow mailman_queue_t port_type:udp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow mailman_queue_t node_type:udp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow mailman_queue_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow mailman_queue_t self:udp_socket { connect };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
allow mailman_queue_t smtp_port_t:tcp_socket name_connect;
#line 40

#line 40

#line 40
if (allow_ypbind) {
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use tcp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow mailman_queue_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow mailman_queue_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow mailman_queue_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow mailman_queue_t node_type:node { tcp_send rawip_send };
#line 40
allow mailman_queue_t node_type:node { tcp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow mailman_queue_t port_type:tcp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow mailman_queue_t node_type:tcp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow mailman_queue_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow mailman_queue_t self:tcp_socket { listen accept };
#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use tcp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow mailman_queue_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow mailman_queue_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow mailman_queue_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow mailman_queue_t node_type:node { tcp_send rawip_send };
#line 40
allow mailman_queue_t node_type:node { tcp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow mailman_queue_t port_type:tcp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow mailman_queue_t node_type:tcp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow mailman_queue_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow mailman_queue_t self:tcp_socket { connect };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use udp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow mailman_queue_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow mailman_queue_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow mailman_queue_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow mailman_queue_t node_type:node { udp_send rawip_send };
#line 40
allow mailman_queue_t node_type:node { udp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow mailman_queue_t port_type:udp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow mailman_queue_t node_type:udp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow mailman_queue_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow mailman_queue_t self:udp_socket { connect };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
allow mailman_queue_t var_yp_t:dir { read getattr lock search ioctl };
#line 40
allow mailman_queue_t var_yp_t:file { read getattr lock ioctl };
#line 40
allow mailman_queue_t var_yp_t:lnk_file { getattr read };
#line 40

#line 40
allow mailman_queue_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 40
allow mailman_queue_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 40
dontaudit mailman_queue_t self:capability net_bind_service;
#line 40
dontaudit mailman_queue_t reserved_port_type:tcp_socket name_connect;
#line 40
dontaudit mailman_queue_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 40

#line 40
} else {
#line 40
dontaudit mailman_queue_t var_yp_t:dir search;
#line 40
}
#line 40
 
#line 40
allow mailman_queue_t self:{ unix_stream_socket unix_dgram_socket } { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 40
allow mailman_queue_t var_t:dir { read getattr lock search ioctl };
#line 40

#line 40
type mailman_queue_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the process to modify the directory.
#line 40
#
#line 40
allow mailman_queue_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 40

#line 40
#
#line 40
# Allow the process to create the file.
#line 40
#
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
allow mailman_queue_t mailman_queue_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
allow mailman_queue_t mailman_queue_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
type_transition mailman_queue_t tmp_t:{ file dir } mailman_queue_tmp_t;
#line 40

#line 40

#line 40

#line 40


#line 41
#allow mailman_queue_t mail_server_domain:tcp_socket { connectto recvfrom };
#line 41
#allow mail_server_domain mailman_queue_t:tcp_socket { acceptfrom recvfrom };
#line 41
#allow mail_server_domain kernel_t:tcp_socket recvfrom;
#line 41
#allow mailman_queue_t kernel_t:tcp_socket recvfrom;
#line 41



#line 43
allow mailman_queue_t su_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 43

allow mailman_queue_t self:capability { setgid setuid };
allow mailman_queue_t self:fifo_file { ioctl read getattr lock write append };
dontaudit mailman_queue_t var_run_t:dir search;
allow mailman_queue_t proc_t:lnk_file { getattr read };

# for su
dontaudit mailman_queue_t selinux_config_t:dir search;
allow mailman_queue_t self:dir search;
allow mailman_queue_t self:file { getattr read };
allow mailman_queue_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow mailman_queue_t self:lnk_file { getattr read };

# some of the following could probably be changed to dontaudit, someone who
# knows mailman well should test this out and send the changes
allow mailman_queue_t sysadm_home_dir_t:dir { getattr search };


#line 60
type mailman_mail_t, domain, privlog ;
#line 60
type mailman_mail_exec_t, file_type, sysadmfile, exec_type;
#line 60
role system_r types mailman_mail_t;
#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the process to modify the directory.
#line 60
#
#line 60
allow mailman_mail_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 60

#line 60
#
#line 60
# Allow the process to create the file.
#line 60
#
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
allow mailman_mail_t mailman_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
type_transition mailman_mail_t var_log_t:file mailman_log_t;
#line 60

#line 60

#line 60
allow mailman_mail_t mailman_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 60

#line 60
allow mailman_mail_t mailman_data_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 60
allow mailman_mail_t mailman_data_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 60
allow mailman_mail_t mailman_data_t:lnk_file { create read getattr setattr link unlink rename };
#line 60

#line 60

#line 60
allow mailman_mail_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 60
allow mailman_mail_t lib_t:lnk_file { read getattr lock ioctl };
#line 60
allow mailman_mail_t ld_so_t:file { read getattr lock execute ioctl };
#line 60
#allow mailman_mail_t ld_so_t:file execute_no_trans;
#line 60
allow mailman_mail_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 60
allow mailman_mail_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 60
allow mailman_mail_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 60
allow mailman_mail_t texrel_shlib_t:file execmod;
#line 60
allow mailman_mail_t ld_so_cache_t:file { read getattr lock ioctl };
#line 60
allow mailman_mail_t device_t:dir search;
#line 60
allow mailman_mail_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 60

#line 60

#line 60
allow mailman_mail_t { bin_t sbin_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 60
allow mailman_mail_t { bin_t sbin_t etc_t }:lnk_file { getattr read };
#line 60

#line 60
allow mailman_mail_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 60
allow mailman_mail_t lib_t:lnk_file { read getattr lock ioctl };
#line 60
allow mailman_mail_t ld_so_t:file { read getattr lock execute ioctl };
#line 60
#allow mailman_mail_t ld_so_t:file execute_no_trans;
#line 60
allow mailman_mail_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 60
allow mailman_mail_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 60
allow mailman_mail_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 60
allow mailman_mail_t texrel_shlib_t:file execmod;
#line 60
allow mailman_mail_t ld_so_cache_t:file { read getattr lock ioctl };
#line 60
allow mailman_mail_t device_t:dir search;
#line 60
allow mailman_mail_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 60

#line 60

#line 60
allow mailman_mail_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 60

#line 60

#line 60
allow mailman_mail_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 60

#line 60

#line 60
allow mailman_mail_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 60

#line 60

#line 60
allow mailman_mail_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 60

#line 60

#line 60
allow mailman_mail_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 60

#line 60

#line 60
allow mailman_mail_t ld_so_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 60

#line 60

#line 60

#line 60
# Read system variables in /sys.
#line 60

#line 60
allow mailman_mail_t sysctl_t:dir search;
#line 60
allow mailman_mail_t sysctl_kernel_t:dir search;
#line 60
allow mailman_mail_t sysctl_kernel_t:file { getattr read };
#line 60

#line 60

#line 60

#line 60
allow mailman_mail_t proc_t:dir search;
#line 60
allow mailman_mail_t proc_t:file { read getattr };
#line 60
allow mailman_mail_t var_lib_t:dir { read getattr lock search ioctl };
#line 60
allow mailman_mail_t var_lib_t:lnk_file read;
#line 60
allow mailman_mail_t device_t:dir search;
#line 60
allow mailman_mail_t etc_runtime_t:file { read getattr };
#line 60

#line 60
allow mailman_mail_t etc_t:lnk_file read;
#line 60
allow mailman_mail_t lib_t:file { read getattr lock ioctl };
#line 60

#line 60
allow mailman_mail_t locale_t:dir { read getattr lock search ioctl };
#line 60
allow mailman_mail_t locale_t:file { read getattr lock ioctl };
#line 60
allow mailman_mail_t locale_t:lnk_file { getattr read };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the process to modify the directory.
#line 60
#
#line 60
allow mailman_mail_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 60

#line 60
#
#line 60
# Allow the process to create the file.
#line 60
#
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
allow mailman_mail_t mailman_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
type_transition mailman_mail_t var_lock_t:file mailman_lock_t;
#line 60

#line 60

#line 60
allow mailman_mail_t mailman_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 60
allow mailman_mail_t fs_t:filesystem getattr;
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use tcp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow mailman_mail_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow mailman_mail_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow mailman_mail_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow mailman_mail_t node_type:node { tcp_send rawip_send };
#line 60
allow mailman_mail_t node_type:node { tcp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow mailman_mail_t port_type:tcp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow mailman_mail_t node_type:tcp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow mailman_mail_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow mailman_mail_t self:tcp_socket { listen accept };
#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use tcp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow mailman_mail_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow mailman_mail_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow mailman_mail_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow mailman_mail_t node_type:node { tcp_send rawip_send };
#line 60
allow mailman_mail_t node_type:node { tcp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow mailman_mail_t port_type:tcp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow mailman_mail_t node_type:tcp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow mailman_mail_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow mailman_mail_t self:tcp_socket { connect };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use udp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow mailman_mail_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow mailman_mail_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow mailman_mail_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow mailman_mail_t node_type:node { udp_send rawip_send };
#line 60
allow mailman_mail_t node_type:node { udp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow mailman_mail_t port_type:udp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow mailman_mail_t node_type:udp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow mailman_mail_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow mailman_mail_t self:udp_socket { connect };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
allow mailman_mail_t smtp_port_t:tcp_socket name_connect;
#line 60

#line 60

#line 60
if (allow_ypbind) {
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use tcp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow mailman_mail_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow mailman_mail_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow mailman_mail_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow mailman_mail_t node_type:node { tcp_send rawip_send };
#line 60
allow mailman_mail_t node_type:node { tcp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow mailman_mail_t port_type:tcp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow mailman_mail_t node_type:tcp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow mailman_mail_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow mailman_mail_t self:tcp_socket { listen accept };
#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use tcp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow mailman_mail_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow mailman_mail_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow mailman_mail_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow mailman_mail_t node_type:node { tcp_send rawip_send };
#line 60
allow mailman_mail_t node_type:node { tcp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow mailman_mail_t port_type:tcp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow mailman_mail_t node_type:tcp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow mailman_mail_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow mailman_mail_t self:tcp_socket { connect };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use udp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow mailman_mail_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow mailman_mail_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow mailman_mail_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow mailman_mail_t node_type:node { udp_send rawip_send };
#line 60
allow mailman_mail_t node_type:node { udp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow mailman_mail_t port_type:udp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow mailman_mail_t node_type:udp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow mailman_mail_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow mailman_mail_t self:udp_socket { connect };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
allow mailman_mail_t var_yp_t:dir { read getattr lock search ioctl };
#line 60
allow mailman_mail_t var_yp_t:file { read getattr lock ioctl };
#line 60
allow mailman_mail_t var_yp_t:lnk_file { getattr read };
#line 60

#line 60
allow mailman_mail_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 60
allow mailman_mail_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 60
dontaudit mailman_mail_t self:capability net_bind_service;
#line 60
dontaudit mailman_mail_t reserved_port_type:tcp_socket name_connect;
#line 60
dontaudit mailman_mail_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 60

#line 60
} else {
#line 60
dontaudit mailman_mail_t var_yp_t:dir search;
#line 60
}
#line 60
 
#line 60
allow mailman_mail_t self:{ unix_stream_socket unix_dgram_socket } { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 60
allow mailman_mail_t var_t:dir { read getattr lock search ioctl };
#line 60

#line 60
type mailman_mail_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the process to modify the directory.
#line 60
#
#line 60
allow mailman_mail_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 60

#line 60
#
#line 60
# Allow the process to create the file.
#line 60
#
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
allow mailman_mail_t mailman_mail_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
allow mailman_mail_t mailman_mail_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
type_transition mailman_mail_t tmp_t:{ file dir } mailman_mail_tmp_t;
#line 60

#line 60

#line 60

#line 60

dontaudit mailman_mail_t mta_delivery_agent:tcp_socket { read write };
allow mailman_mail_t mta_delivery_agent:fd use;
#line 67



#line 69
allow mailman_queue_t mailman_archive_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 69
allow mailman_queue_t mailman_archive_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 69
allow mailman_queue_t mailman_archive_t:lnk_file { create read getattr setattr link unlink rename };
#line 69


#line 90

#line 90

#line 90
type mailman_cgi_t, domain, privlog ;
#line 90
type mailman_cgi_exec_t, file_type, sysadmfile, exec_type;
#line 90
role system_r types mailman_cgi_t;
#line 90

#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the process to modify the directory.
#line 90
#
#line 90
allow mailman_cgi_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 90

#line 90
#
#line 90
# Allow the process to create the file.
#line 90
#
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
allow mailman_cgi_t mailman_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
type_transition mailman_cgi_t var_log_t:file mailman_log_t;
#line 90

#line 90

#line 90
allow mailman_cgi_t mailman_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 90

#line 90
allow mailman_cgi_t mailman_data_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 90
allow mailman_cgi_t mailman_data_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 90
allow mailman_cgi_t mailman_data_t:lnk_file { create read getattr setattr link unlink rename };
#line 90

#line 90

#line 90
allow mailman_cgi_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 90
allow mailman_cgi_t lib_t:lnk_file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t ld_so_t:file { read getattr lock execute ioctl };
#line 90
#allow mailman_cgi_t ld_so_t:file execute_no_trans;
#line 90
allow mailman_cgi_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 90
allow mailman_cgi_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t texrel_shlib_t:file execmod;
#line 90
allow mailman_cgi_t ld_so_cache_t:file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t device_t:dir search;
#line 90
allow mailman_cgi_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 90

#line 90

#line 90
allow mailman_cgi_t { bin_t sbin_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 90
allow mailman_cgi_t { bin_t sbin_t etc_t }:lnk_file { getattr read };
#line 90

#line 90
allow mailman_cgi_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 90
allow mailman_cgi_t lib_t:lnk_file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t ld_so_t:file { read getattr lock execute ioctl };
#line 90
#allow mailman_cgi_t ld_so_t:file execute_no_trans;
#line 90
allow mailman_cgi_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 90
allow mailman_cgi_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t texrel_shlib_t:file execmod;
#line 90
allow mailman_cgi_t ld_so_cache_t:file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t device_t:dir search;
#line 90
allow mailman_cgi_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 90

#line 90

#line 90
allow mailman_cgi_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 90

#line 90

#line 90
allow mailman_cgi_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 90

#line 90

#line 90
allow mailman_cgi_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 90

#line 90

#line 90
allow mailman_cgi_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 90

#line 90

#line 90
allow mailman_cgi_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 90

#line 90

#line 90
allow mailman_cgi_t ld_so_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 90

#line 90

#line 90

#line 90
# Read system variables in /sys.
#line 90

#line 90
allow mailman_cgi_t sysctl_t:dir search;
#line 90
allow mailman_cgi_t sysctl_kernel_t:dir search;
#line 90
allow mailman_cgi_t sysctl_kernel_t:file { getattr read };
#line 90

#line 90

#line 90

#line 90
allow mailman_cgi_t proc_t:dir search;
#line 90
allow mailman_cgi_t proc_t:file { read getattr };
#line 90
allow mailman_cgi_t var_lib_t:dir { read getattr lock search ioctl };
#line 90
allow mailman_cgi_t var_lib_t:lnk_file read;
#line 90
allow mailman_cgi_t device_t:dir search;
#line 90
allow mailman_cgi_t etc_runtime_t:file { read getattr };
#line 90

#line 90
allow mailman_cgi_t etc_t:lnk_file read;
#line 90
allow mailman_cgi_t lib_t:file { read getattr lock ioctl };
#line 90

#line 90
allow mailman_cgi_t locale_t:dir { read getattr lock search ioctl };
#line 90
allow mailman_cgi_t locale_t:file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t locale_t:lnk_file { getattr read };
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the process to modify the directory.
#line 90
#
#line 90
allow mailman_cgi_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 90

#line 90
#
#line 90
# Allow the process to create the file.
#line 90
#
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
allow mailman_cgi_t mailman_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
type_transition mailman_cgi_t var_lock_t:file mailman_lock_t;
#line 90

#line 90

#line 90
allow mailman_cgi_t mailman_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 90
allow mailman_cgi_t fs_t:filesystem getattr;
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the domain to create and use tcp sockets.
#line 90
# Other kinds of sockets must be separately authorized for use.
#line 90
allow mailman_cgi_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 90

#line 90
allow mailman_cgi_t unlabeled_t:association { sendto recvfrom };
#line 90

#line 90
#
#line 90
# Allow the domain to send or receive using any network interface.
#line 90
# netif_type is a type attribute for all network interface types.
#line 90
#
#line 90
allow mailman_cgi_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 90
#
#line 90
# Allow the domain to send to or receive from any node.
#line 90
# node_type is a type attribute for all node types.
#line 90
#
#line 90
allow mailman_cgi_t node_type:node { tcp_send rawip_send };
#line 90
allow mailman_cgi_t node_type:node { tcp_recv rawip_recv };
#line 90

#line 90
#
#line 90
# Allow the domain to send to or receive from any port.
#line 90
# port_type is a type attribute for all port types.
#line 90
#
#line 90

#line 90
allow mailman_cgi_t port_type:tcp_socket { send_msg recv_msg };
#line 90

#line 90

#line 90
# XXX Allow binding to any node type.  Remove once
#line 90
# individual rules have been added to all domains that 
#line 90
# bind sockets. 
#line 90
allow mailman_cgi_t node_type:tcp_socket node_bind;
#line 90
#
#line 90
# Allow access to network files including /etc/resolv.conf
#line 90
#
#line 90
allow mailman_cgi_t net_conf_t:file { read getattr lock ioctl };
#line 90

#line 90
allow mailman_cgi_t self:tcp_socket { listen accept };
#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the domain to create and use tcp sockets.
#line 90
# Other kinds of sockets must be separately authorized for use.
#line 90
allow mailman_cgi_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 90

#line 90
allow mailman_cgi_t unlabeled_t:association { sendto recvfrom };
#line 90

#line 90
#
#line 90
# Allow the domain to send or receive using any network interface.
#line 90
# netif_type is a type attribute for all network interface types.
#line 90
#
#line 90
allow mailman_cgi_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 90
#
#line 90
# Allow the domain to send to or receive from any node.
#line 90
# node_type is a type attribute for all node types.
#line 90
#
#line 90
allow mailman_cgi_t node_type:node { tcp_send rawip_send };
#line 90
allow mailman_cgi_t node_type:node { tcp_recv rawip_recv };
#line 90

#line 90
#
#line 90
# Allow the domain to send to or receive from any port.
#line 90
# port_type is a type attribute for all port types.
#line 90
#
#line 90

#line 90
allow mailman_cgi_t port_type:tcp_socket { send_msg recv_msg };
#line 90

#line 90

#line 90
# XXX Allow binding to any node type.  Remove once
#line 90
# individual rules have been added to all domains that 
#line 90
# bind sockets. 
#line 90
allow mailman_cgi_t node_type:tcp_socket node_bind;
#line 90
#
#line 90
# Allow access to network files including /etc/resolv.conf
#line 90
#
#line 90
allow mailman_cgi_t net_conf_t:file { read getattr lock ioctl };
#line 90

#line 90
allow mailman_cgi_t self:tcp_socket { connect };
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the domain to create and use udp sockets.
#line 90
# Other kinds of sockets must be separately authorized for use.
#line 90
allow mailman_cgi_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 90

#line 90
allow mailman_cgi_t unlabeled_t:association { sendto recvfrom };
#line 90

#line 90
#
#line 90
# Allow the domain to send or receive using any network interface.
#line 90
# netif_type is a type attribute for all network interface types.
#line 90
#
#line 90
allow mailman_cgi_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 90
#
#line 90
# Allow the domain to send to or receive from any node.
#line 90
# node_type is a type attribute for all node types.
#line 90
#
#line 90
allow mailman_cgi_t node_type:node { udp_send rawip_send };
#line 90
allow mailman_cgi_t node_type:node { udp_recv rawip_recv };
#line 90

#line 90
#
#line 90
# Allow the domain to send to or receive from any port.
#line 90
# port_type is a type attribute for all port types.
#line 90
#
#line 90

#line 90
allow mailman_cgi_t port_type:udp_socket { send_msg recv_msg };
#line 90

#line 90

#line 90
# XXX Allow binding to any node type.  Remove once
#line 90
# individual rules have been added to all domains that 
#line 90
# bind sockets. 
#line 90
allow mailman_cgi_t node_type:udp_socket node_bind;
#line 90
#
#line 90
# Allow access to network files including /etc/resolv.conf
#line 90
#
#line 90
allow mailman_cgi_t net_conf_t:file { read getattr lock ioctl };
#line 90

#line 90
allow mailman_cgi_t self:udp_socket { connect };
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
allow mailman_cgi_t smtp_port_t:tcp_socket name_connect;
#line 90

#line 90

#line 90
if (allow_ypbind) {
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the domain to create and use tcp sockets.
#line 90
# Other kinds of sockets must be separately authorized for use.
#line 90
allow mailman_cgi_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 90

#line 90
allow mailman_cgi_t unlabeled_t:association { sendto recvfrom };
#line 90

#line 90
#
#line 90
# Allow the domain to send or receive using any network interface.
#line 90
# netif_type is a type attribute for all network interface types.
#line 90
#
#line 90
allow mailman_cgi_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 90
#
#line 90
# Allow the domain to send to or receive from any node.
#line 90
# node_type is a type attribute for all node types.
#line 90
#
#line 90
allow mailman_cgi_t node_type:node { tcp_send rawip_send };
#line 90
allow mailman_cgi_t node_type:node { tcp_recv rawip_recv };
#line 90

#line 90
#
#line 90
# Allow the domain to send to or receive from any port.
#line 90
# port_type is a type attribute for all port types.
#line 90
#
#line 90

#line 90
allow mailman_cgi_t port_type:tcp_socket { send_msg recv_msg };
#line 90

#line 90

#line 90
# XXX Allow binding to any node type.  Remove once
#line 90
# individual rules have been added to all domains that 
#line 90
# bind sockets. 
#line 90
allow mailman_cgi_t node_type:tcp_socket node_bind;
#line 90
#
#line 90
# Allow access to network files including /etc/resolv.conf
#line 90
#
#line 90
allow mailman_cgi_t net_conf_t:file { read getattr lock ioctl };
#line 90

#line 90
allow mailman_cgi_t self:tcp_socket { listen accept };
#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the domain to create and use tcp sockets.
#line 90
# Other kinds of sockets must be separately authorized for use.
#line 90
allow mailman_cgi_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 90

#line 90
allow mailman_cgi_t unlabeled_t:association { sendto recvfrom };
#line 90

#line 90
#
#line 90
# Allow the domain to send or receive using any network interface.
#line 90
# netif_type is a type attribute for all network interface types.
#line 90
#
#line 90
allow mailman_cgi_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 90
#
#line 90
# Allow the domain to send to or receive from any node.
#line 90
# node_type is a type attribute for all node types.
#line 90
#
#line 90
allow mailman_cgi_t node_type:node { tcp_send rawip_send };
#line 90
allow mailman_cgi_t node_type:node { tcp_recv rawip_recv };
#line 90

#line 90
#
#line 90
# Allow the domain to send to or receive from any port.
#line 90
# port_type is a type attribute for all port types.
#line 90
#
#line 90

#line 90
allow mailman_cgi_t port_type:tcp_socket { send_msg recv_msg };
#line 90

#line 90

#line 90
# XXX Allow binding to any node type.  Remove once
#line 90
# individual rules have been added to all domains that 
#line 90
# bind sockets. 
#line 90
allow mailman_cgi_t node_type:tcp_socket node_bind;
#line 90
#
#line 90
# Allow access to network files including /etc/resolv.conf
#line 90
#
#line 90
allow mailman_cgi_t net_conf_t:file { read getattr lock ioctl };
#line 90

#line 90
allow mailman_cgi_t self:tcp_socket { connect };
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the domain to create and use udp sockets.
#line 90
# Other kinds of sockets must be separately authorized for use.
#line 90
allow mailman_cgi_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 90

#line 90
allow mailman_cgi_t unlabeled_t:association { sendto recvfrom };
#line 90

#line 90
#
#line 90
# Allow the domain to send or receive using any network interface.
#line 90
# netif_type is a type attribute for all network interface types.
#line 90
#
#line 90
allow mailman_cgi_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 90
#
#line 90
# Allow the domain to send to or receive from any node.
#line 90
# node_type is a type attribute for all node types.
#line 90
#
#line 90
allow mailman_cgi_t node_type:node { udp_send rawip_send };
#line 90
allow mailman_cgi_t node_type:node { udp_recv rawip_recv };
#line 90

#line 90
#
#line 90
# Allow the domain to send to or receive from any port.
#line 90
# port_type is a type attribute for all port types.
#line 90
#
#line 90

#line 90
allow mailman_cgi_t port_type:udp_socket { send_msg recv_msg };
#line 90

#line 90

#line 90
# XXX Allow binding to any node type.  Remove once
#line 90
# individual rules have been added to all domains that 
#line 90
# bind sockets. 
#line 90
allow mailman_cgi_t node_type:udp_socket node_bind;
#line 90
#
#line 90
# Allow access to network files including /etc/resolv.conf
#line 90
#
#line 90
allow mailman_cgi_t net_conf_t:file { read getattr lock ioctl };
#line 90

#line 90
allow mailman_cgi_t self:udp_socket { connect };
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
allow mailman_cgi_t var_yp_t:dir { read getattr lock search ioctl };
#line 90
allow mailman_cgi_t var_yp_t:file { read getattr lock ioctl };
#line 90
allow mailman_cgi_t var_yp_t:lnk_file { getattr read };
#line 90

#line 90
allow mailman_cgi_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 90
allow mailman_cgi_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 90
dontaudit mailman_cgi_t self:capability net_bind_service;
#line 90
dontaudit mailman_cgi_t reserved_port_type:tcp_socket name_connect;
#line 90
dontaudit mailman_cgi_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 90

#line 90
} else {
#line 90
dontaudit mailman_cgi_t var_yp_t:dir search;
#line 90
}
#line 90
 
#line 90
allow mailman_cgi_t self:{ unix_stream_socket unix_dgram_socket } { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 90
allow mailman_cgi_t var_t:dir { read getattr lock search ioctl };
#line 90

#line 90
type mailman_cgi_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 90

#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the process to modify the directory.
#line 90
#
#line 90
allow mailman_cgi_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 90

#line 90
#
#line 90
# Allow the process to create the file.
#line 90
#
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
allow mailman_cgi_t mailman_cgi_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
allow mailman_cgi_t mailman_cgi_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
type_transition mailman_cgi_t tmp_t:{ file dir } mailman_cgi_tmp_t;
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
#allow mailman_cgi_t mail_server_domain:tcp_socket { connectto recvfrom };
#line 90
#allow mail_server_domain mailman_cgi_t:tcp_socket { acceptfrom recvfrom };
#line 90
#allow mail_server_domain kernel_t:tcp_socket recvfrom;
#line 90
#allow mailman_cgi_t kernel_t:tcp_socket recvfrom;
#line 90

#line 90

#line 90

#line 90

#line 90

#line 90
#
#line 90
# Allow the process to transition to the new domain.
#line 90
#
#line 90
allow { httpd_t httpd_suexec_t } mailman_cgi_t:process transition;
#line 90

#line 90
#
#line 90
# Do not audit when glibc secure mode is enabled upon the transition.
#line 90
#
#line 90
dontaudit { httpd_t httpd_suexec_t } mailman_cgi_t:process noatsecure;
#line 90

#line 90
#
#line 90
# Do not audit when signal-related state is cleared upon the transition.
#line 90
#
#line 90
dontaudit { httpd_t httpd_suexec_t } mailman_cgi_t:process siginh;
#line 90

#line 90
#
#line 90
# Do not audit when resource limits are reset upon the transition.
#line 90
#
#line 90
dontaudit { httpd_t httpd_suexec_t } mailman_cgi_t:process rlimitinh;
#line 90

#line 90
#
#line 90
# Allow the process to execute the program.
#line 90
# 
#line 90
allow { httpd_t httpd_suexec_t } mailman_cgi_exec_t:file { read { getattr execute } };
#line 90

#line 90
#
#line 90
# Allow the process to reap the new domain.
#line 90
#
#line 90
allow mailman_cgi_t { httpd_t httpd_suexec_t }:process sigchld;
#line 90

#line 90
#
#line 90
# Allow the new domain to inherit and use file 
#line 90
# descriptions from the creating process and vice versa.
#line 90
#
#line 90
allow mailman_cgi_t { httpd_t httpd_suexec_t }:fd use;
#line 90
allow { httpd_t httpd_suexec_t } mailman_cgi_t:fd use;
#line 90

#line 90
#
#line 90
# Allow the new domain to write back to the old domain via a pipe.
#line 90
#
#line 90
allow mailman_cgi_t { httpd_t httpd_suexec_t }:fifo_file { ioctl read getattr lock write append };
#line 90

#line 90
#
#line 90
# Allow the new domain to read and execute the program.
#line 90
#
#line 90
allow mailman_cgi_t mailman_cgi_exec_t:file { read getattr lock execute ioctl };
#line 90

#line 90
#
#line 90
# Allow the new domain to be entered via the program.
#line 90
#
#line 90
allow mailman_cgi_t mailman_cgi_exec_t:file entrypoint;
#line 90

#line 90
type_transition { httpd_t httpd_suexec_t } mailman_cgi_exec_t:process mailman_cgi_t;
#line 90

#line 90
# should have separate types for public and private archives
#line 90

#line 90
allow httpd_t mailman_archive_t:dir { read getattr lock search ioctl };
#line 90
allow httpd_t mailman_archive_t:file { read getattr lock ioctl };
#line 90
allow httpd_t mailman_archive_t:lnk_file { getattr read };
#line 90

#line 90

#line 90
allow mailman_cgi_t mailman_archive_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 90
allow mailman_cgi_t mailman_archive_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 90
allow mailman_cgi_t mailman_archive_t:lnk_file { create read getattr setattr link unlink rename };
#line 90

#line 90
allow httpd_t mailman_data_t:dir { getattr search };
#line 90

#line 90
dontaudit mailman_cgi_t httpd_log_t:file append;
#line 90
allow httpd_t mailman_cgi_t:process signal;
#line 90
allow mailman_cgi_t httpd_t:process sigchld;
#line 90
allow mailman_cgi_t httpd_t:fd use;
#line 90
allow mailman_cgi_t httpd_t:fifo_file { getattr read write ioctl };
#line 90
allow mailman_cgi_t httpd_sys_script_t:dir search;
#line 90
allow mailman_cgi_t devtty_t:chr_file { read write };
#line 90
allow mailman_cgi_t self:process { fork sigchld };
#line 90
allow mailman_cgi_t var_spool_t:dir search;
#line 90


allow mta_delivery_agent mailman_data_t:dir search;
allow mta_delivery_agent mailman_data_t:lnk_file read;
allow initrc_t mailman_data_t:lnk_file read;
allow initrc_t mailman_data_t:dir { read getattr lock search ioctl };

#line 96

#line 96

#line 96
#
#line 96
# Allow the process to transition to the new domain.
#line 96
#
#line 96
allow { mta_delivery_agent initrc_t } mailman_mail_t:process transition;
#line 96

#line 96
#
#line 96
# Do not audit when glibc secure mode is enabled upon the transition.
#line 96
#
#line 96
dontaudit { mta_delivery_agent initrc_t } mailman_mail_t:process noatsecure;
#line 96

#line 96
#
#line 96
# Do not audit when signal-related state is cleared upon the transition.
#line 96
#
#line 96
dontaudit { mta_delivery_agent initrc_t } mailman_mail_t:process siginh;
#line 96

#line 96
#
#line 96
# Do not audit when resource limits are reset upon the transition.
#line 96
#
#line 96
dontaudit { mta_delivery_agent initrc_t } mailman_mail_t:process rlimitinh;
#line 96

#line 96
#
#line 96
# Allow the process to execute the program.
#line 96
# 
#line 96
allow { mta_delivery_agent initrc_t } mailman_mail_exec_t:file { read { getattr execute } };
#line 96

#line 96
#
#line 96
# Allow the process to reap the new domain.
#line 96
#
#line 96
allow mailman_mail_t { mta_delivery_agent initrc_t }:process sigchld;
#line 96

#line 96
#
#line 96
# Allow the new domain to inherit and use file 
#line 96
# descriptions from the creating process and vice versa.
#line 96
#
#line 96
allow mailman_mail_t { mta_delivery_agent initrc_t }:fd use;
#line 96
allow { mta_delivery_agent initrc_t } mailman_mail_t:fd use;
#line 96

#line 96
#
#line 96
# Allow the new domain to write back to the old domain via a pipe.
#line 96
#
#line 96
allow mailman_mail_t { mta_delivery_agent initrc_t }:fifo_file { ioctl read getattr lock write append };
#line 96

#line 96
#
#line 96
# Allow the new domain to read and execute the program.
#line 96
#
#line 96
allow mailman_mail_t mailman_mail_exec_t:file { read getattr lock execute ioctl };
#line 96

#line 96
#
#line 96
# Allow the new domain to be entered via the program.
#line 96
#
#line 96
allow mailman_mail_t mailman_mail_exec_t:file entrypoint;
#line 96

#line 96
type_transition { mta_delivery_agent initrc_t } mailman_mail_exec_t:process mailman_mail_t;
#line 96

#line 99

allow mailman_mail_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };


#line 102

#line 102

#line 102

#line 102

#line 102
#
#line 102
# Allow the process to transition to the new domain.
#line 102
#
#line 102
allow system_crond_t mailman_queue_t:process transition;
#line 102

#line 102
#
#line 102
# Do not audit when glibc secure mode is enabled upon the transition.
#line 102
#
#line 102
dontaudit system_crond_t mailman_queue_t:process noatsecure;
#line 102

#line 102
#
#line 102
# Do not audit when signal-related state is cleared upon the transition.
#line 102
#
#line 102
dontaudit system_crond_t mailman_queue_t:process siginh;
#line 102

#line 102
#
#line 102
# Do not audit when resource limits are reset upon the transition.
#line 102
#
#line 102
dontaudit system_crond_t mailman_queue_t:process rlimitinh;
#line 102

#line 102
#
#line 102
# Allow the process to execute the program.
#line 102
# 
#line 102
allow system_crond_t mailman_queue_exec_t:file { read { getattr execute } };
#line 102

#line 102
#
#line 102
# Allow the process to reap the new domain.
#line 102
#
#line 102
allow mailman_queue_t system_crond_t:process sigchld;
#line 102

#line 102
#
#line 102
# Allow the new domain to inherit and use file 
#line 102
# descriptions from the creating process and vice versa.
#line 102
#
#line 102
allow mailman_queue_t system_crond_t:fd use;
#line 102
allow system_crond_t mailman_queue_t:fd use;
#line 102

#line 102
#
#line 102
# Allow the new domain to write back to the old domain via a pipe.
#line 102
#
#line 102
allow mailman_queue_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 102

#line 102
#
#line 102
# Allow the new domain to read and execute the program.
#line 102
#
#line 102
allow mailman_queue_t mailman_queue_exec_t:file { read getattr lock execute ioctl };
#line 102

#line 102
#
#line 102
# Allow the new domain to be entered via the program.
#line 102
#
#line 102
allow mailman_queue_t mailman_queue_exec_t:file entrypoint;
#line 102

#line 102
type_transition system_crond_t mailman_queue_exec_t:process mailman_queue_t;
#line 102

#line 102
allow mailman_queue_t crond_t:fifo_file { getattr read write ioctl };
#line 102
# a rule for privfd may make this obsolete
#line 102
allow mailman_queue_t crond_t:fd use;
#line 102
allow mailman_queue_t crond_t:process sigchld;
#line 102

allow mailman_queue_t devtty_t:chr_file { read write };
allow mailman_queue_t self:process { fork signal sigchld };
allow mailman_queue_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };

# so MTA can access /var/lib/mailman/mail/wrapper
allow mta_delivery_agent var_lib_t:dir search;

# Handle mailman log files

#line 111
allow logrotate_t mailman_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 111
allow logrotate_t mailman_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 111
allow logrotate_t mailman_log_t:lnk_file { create read getattr setattr link unlink rename };
#line 111

allow logrotate_t mailman_data_t:dir search;

#line 113
allow logrotate_t mailman_mail_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 113

#line 1 "domains/program/modutil.te"
#DESC Modutil - Dynamic module utilities
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: modutils
#

#################################
#
# Rules for the module utility domains.
#
type modules_dep_t, file_type, sysadmfile;
type modules_conf_t, file_type, sysadmfile;
type modules_object_t, file_type, sysadmfile;


#line 69

#line 69
#################################
#line 69
#
#line 69
# Rules for the depmod_t domain.
#line 69
#
#line 69
type depmod_t, domain;
#line 69
role system_r types depmod_t;
#line 69
role sysadm_r types depmod_t;
#line 69

#line 69

#line 69
allow depmod_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 69
allow depmod_t lib_t:lnk_file { read getattr lock ioctl };
#line 69
allow depmod_t ld_so_t:file { read getattr lock execute ioctl };
#line 69
#allow depmod_t ld_so_t:file execute_no_trans;
#line 69
allow depmod_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 69
allow depmod_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 69
allow depmod_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 69
allow depmod_t texrel_shlib_t:file execmod;
#line 69
allow depmod_t ld_so_cache_t:file { read getattr lock ioctl };
#line 69
allow depmod_t device_t:dir search;
#line 69
allow depmod_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 69

#line 69

#line 69

#line 69
allow depmod_t src_t:dir { read getattr lock search ioctl };
#line 69
allow depmod_t src_t:file { read getattr lock ioctl };
#line 69
allow depmod_t src_t:lnk_file { getattr read };
#line 69

#line 69

#line 69
type depmod_exec_t, file_type, exec_type, sysadmfile;
#line 69

#line 69

#line 69

#line 69
#
#line 69
# Allow the process to transition to the new domain.
#line 69
#
#line 69
allow initrc_t depmod_t:process transition;
#line 69

#line 69
#
#line 69
# Do not audit when glibc secure mode is enabled upon the transition.
#line 69
#
#line 69
dontaudit initrc_t depmod_t:process noatsecure;
#line 69

#line 69
#
#line 69
# Do not audit when signal-related state is cleared upon the transition.
#line 69
#
#line 69
dontaudit initrc_t depmod_t:process siginh;
#line 69

#line 69
#
#line 69
# Do not audit when resource limits are reset upon the transition.
#line 69
#
#line 69
dontaudit initrc_t depmod_t:process rlimitinh;
#line 69

#line 69
#
#line 69
# Allow the process to execute the program.
#line 69
# 
#line 69
allow initrc_t depmod_exec_t:file { read { getattr execute } };
#line 69

#line 69
#
#line 69
# Allow the process to reap the new domain.
#line 69
#
#line 69
allow depmod_t initrc_t:process sigchld;
#line 69

#line 69
#
#line 69
# Allow the new domain to inherit and use file 
#line 69
# descriptions from the creating process and vice versa.
#line 69
#
#line 69
allow depmod_t initrc_t:fd use;
#line 69
allow initrc_t depmod_t:fd use;
#line 69

#line 69
#
#line 69
# Allow the new domain to write back to the old domain via a pipe.
#line 69
#
#line 69
allow depmod_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 69

#line 69
#
#line 69
# Allow the new domain to read and execute the program.
#line 69
#
#line 69
allow depmod_t depmod_exec_t:file { read getattr lock execute ioctl };
#line 69

#line 69
#
#line 69
# Allow the new domain to be entered via the program.
#line 69
#
#line 69
allow depmod_t depmod_exec_t:file entrypoint;
#line 69

#line 69
type_transition initrc_t depmod_exec_t:process depmod_t;
#line 69

#line 69
allow depmod_t { bin_t sbin_t }:dir search;
#line 69

#line 69
allow depmod_t depmod_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 69

#line 69

#line 69

#line 69
# Inherit and use descriptors from init and login programs.
#line 69
allow depmod_t { init_t privfd }:fd use;
#line 69

#line 69
allow depmod_t { etc_t etc_runtime_t }:file { getattr read };
#line 69
allow depmod_t { device_t proc_t }:dir search;
#line 69
allow depmod_t proc_t:file { getattr read };
#line 69
allow depmod_t fs_t:filesystem getattr;
#line 69

#line 69
# read system.map
#line 69
allow depmod_t boot_t:dir search;
#line 69
allow depmod_t boot_t:file { getattr read };
#line 69
allow depmod_t system_map_t:file { getattr read };
#line 69

#line 69
# Read conf.modules.
#line 69
allow depmod_t modules_conf_t:file { read getattr lock ioctl };
#line 69

#line 69
# Create modules.dep.
#line 69

#line 69

#line 69

#line 69

#line 69
#
#line 69
# Allow the process to modify the directory.
#line 69
#
#line 69
allow depmod_t modules_object_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 69

#line 69
#
#line 69
# Allow the process to create the file.
#line 69
#
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
allow depmod_t modules_dep_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69

#line 69
type_transition depmod_t modules_object_t:file modules_dep_t;
#line 69

#line 69

#line 69

#line 69
# Read module objects.
#line 69
allow depmod_t modules_object_t:dir { read getattr lock search ioctl };
#line 69
allow depmod_t modules_object_t:{ file lnk_file } { read getattr lock ioctl };
#line 69
allow depmod_t modules_object_t:file unlink;
#line 69

#line 69
# Access terminals.
#line 69

#line 69
allow depmod_t devpts_t:dir { read getattr lock search ioctl };
#line 69
allow depmod_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 69

#line 69
allow depmod_t { console_device_t admin_tty_type }:chr_file { ioctl read getattr lock write append };
#line 69

#line 69

#line 69
# Read System.map from home directories.
#line 69
allow depmod_t { home_root_t staff_home_dir_t sysadm_home_dir_t }:dir { read getattr lock search ioctl };
#line 69

#line 69
allow depmod_t { staff_home_t sysadm_home_t }:dir { read getattr lock search ioctl };
#line 69
allow depmod_t { staff_home_t sysadm_home_t }:file { read getattr lock ioctl };
#line 69
allow depmod_t { staff_home_t sysadm_home_t }:lnk_file { getattr read };
#line 69


#################################
#
# Rules for the insmod_t domain.
#

type insmod_t, domain, privlog, sysctl_kernel_writer, privmem, privsysmod , admin, etc_writer, fs_domain, auth_write, privowner, privmodule , mlsfilewrite, nscd_client_domain
;
role system_r types insmod_t;
role sysadm_r types insmod_t;
type insmod_exec_t, file_type, exec_type, sysadmfile;

bool secure_mode_insmod false;


#line 84

#line 84
if (allow_ypbind) {
#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84
#
#line 84
# Allow the domain to create and use tcp sockets.
#line 84
# Other kinds of sockets must be separately authorized for use.
#line 84
allow insmod_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 84

#line 84
allow insmod_t unlabeled_t:association { sendto recvfrom };
#line 84

#line 84
#
#line 84
# Allow the domain to send or receive using any network interface.
#line 84
# netif_type is a type attribute for all network interface types.
#line 84
#
#line 84
allow insmod_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 84
#
#line 84
# Allow the domain to send to or receive from any node.
#line 84
# node_type is a type attribute for all node types.
#line 84
#
#line 84
allow insmod_t node_type:node { tcp_send rawip_send };
#line 84
allow insmod_t node_type:node { tcp_recv rawip_recv };
#line 84

#line 84
#
#line 84
# Allow the domain to send to or receive from any port.
#line 84
# port_type is a type attribute for all port types.
#line 84
#
#line 84

#line 84
allow insmod_t port_type:tcp_socket { send_msg recv_msg };
#line 84

#line 84

#line 84
# XXX Allow binding to any node type.  Remove once
#line 84
# individual rules have been added to all domains that 
#line 84
# bind sockets. 
#line 84
allow insmod_t node_type:tcp_socket node_bind;
#line 84
#
#line 84
# Allow access to network files including /etc/resolv.conf
#line 84
#
#line 84
allow insmod_t net_conf_t:file { read getattr lock ioctl };
#line 84

#line 84
allow insmod_t self:tcp_socket { listen accept };
#line 84

#line 84

#line 84

#line 84
#
#line 84
# Allow the domain to create and use tcp sockets.
#line 84
# Other kinds of sockets must be separately authorized for use.
#line 84
allow insmod_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 84

#line 84
allow insmod_t unlabeled_t:association { sendto recvfrom };
#line 84

#line 84
#
#line 84
# Allow the domain to send or receive using any network interface.
#line 84
# netif_type is a type attribute for all network interface types.
#line 84
#
#line 84
allow insmod_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 84
#
#line 84
# Allow the domain to send to or receive from any node.
#line 84
# node_type is a type attribute for all node types.
#line 84
#
#line 84
allow insmod_t node_type:node { tcp_send rawip_send };
#line 84
allow insmod_t node_type:node { tcp_recv rawip_recv };
#line 84

#line 84
#
#line 84
# Allow the domain to send to or receive from any port.
#line 84
# port_type is a type attribute for all port types.
#line 84
#
#line 84

#line 84
allow insmod_t port_type:tcp_socket { send_msg recv_msg };
#line 84

#line 84

#line 84
# XXX Allow binding to any node type.  Remove once
#line 84
# individual rules have been added to all domains that 
#line 84
# bind sockets. 
#line 84
allow insmod_t node_type:tcp_socket node_bind;
#line 84
#
#line 84
# Allow access to network files including /etc/resolv.conf
#line 84
#
#line 84
allow insmod_t net_conf_t:file { read getattr lock ioctl };
#line 84

#line 84
allow insmod_t self:tcp_socket { connect };
#line 84

#line 84

#line 84

#line 84

#line 84

#line 84
#
#line 84
# Allow the domain to create and use udp sockets.
#line 84
# Other kinds of sockets must be separately authorized for use.
#line 84
allow insmod_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 84

#line 84
allow insmod_t unlabeled_t:association { sendto recvfrom };
#line 84

#line 84
#
#line 84
# Allow the domain to send or receive using any network interface.
#line 84
# netif_type is a type attribute for all network interface types.
#line 84
#
#line 84
allow insmod_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 84
#
#line 84
# Allow the domain to send to or receive from any node.
#line 84
# node_type is a type attribute for all node types.
#line 84
#
#line 84
allow insmod_t node_type:node { udp_send rawip_send };
#line 84
allow insmod_t node_type:node { udp_recv rawip_recv };
#line 84

#line 84
#
#line 84
# Allow the domain to send to or receive from any port.
#line 84
# port_type is a type attribute for all port types.
#line 84
#
#line 84

#line 84
allow insmod_t port_type:udp_socket { send_msg recv_msg };
#line 84

#line 84

#line 84
# XXX Allow binding to any node type.  Remove once
#line 84
# individual rules have been added to all domains that 
#line 84
# bind sockets. 
#line 84
allow insmod_t node_type:udp_socket node_bind;
#line 84
#
#line 84
# Allow access to network files including /etc/resolv.conf
#line 84
#
#line 84
allow insmod_t net_conf_t:file { read getattr lock ioctl };
#line 84

#line 84
allow insmod_t self:udp_socket { connect };
#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84
allow insmod_t var_yp_t:dir { read getattr lock search ioctl };
#line 84
allow insmod_t var_yp_t:file { read getattr lock ioctl };
#line 84
allow insmod_t var_yp_t:lnk_file { getattr read };
#line 84

#line 84
allow insmod_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 84
allow insmod_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 84
dontaudit insmod_t self:capability net_bind_service;
#line 84
dontaudit insmod_t reserved_port_type:tcp_socket name_connect;
#line 84
dontaudit insmod_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 84

#line 84
} else {
#line 84
dontaudit insmod_t var_yp_t:dir search;
#line 84
}
#line 84
 

#line 88

#line 88

#line 88

#line 88
typeattribute insmod_t unrestricted;
#line 88
typeattribute insmod_t privuser;
#line 88

#line 88
# Mount/unmount any filesystem. 
#line 88
allow insmod_t fs_type:filesystem *;
#line 88

#line 88
# Mount/unmount any filesystem with the context= option. 
#line 88
allow insmod_t file_type:filesystem *;
#line 88

#line 88
# Create/access any file in a labeled filesystem;
#line 88
allow insmod_t file_type:{ file chr_file } ~execmod;
#line 88
allow insmod_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 88
allow insmod_t sysctl_t:{ dir file } *;
#line 88
allow insmod_t device_type:{ chr_file blk_file } *;
#line 88
allow insmod_t mtrr_device_t:file *;
#line 88

#line 88
# Create/access other files.  fs_type is to pick up various
#line 88
# pseudo filesystem types that are applied to both the filesystem
#line 88
# and its files.
#line 88
allow insmod_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 88
allow insmod_t unlabeled_t:association { sendto recvfrom };
#line 88

#line 88
allow insmod_t proc_fs:{ dir file } *;
#line 88

#line 88
# For /proc/pid
#line 88

#line 88
allow insmod_t domain:dir { read getattr lock search ioctl };
#line 88
allow insmod_t domain:file { read getattr lock ioctl };
#line 88
allow insmod_t domain:lnk_file { getattr read };
#line 88

#line 88
# Write access is for setting attributes under /proc/self/attr.
#line 88
allow insmod_t self:file { ioctl read getattr lock write append };
#line 88

#line 88
# Read and write sysctls.
#line 88

#line 88
allow insmod_t sysctl_type:dir { read getattr lock search ioctl };
#line 88
allow insmod_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 88

#line 88

#line 88
# Access the network.
#line 88
allow insmod_t node_type:node *;
#line 88
allow insmod_t netif_type:netif *;
#line 88
allow insmod_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 88
allow insmod_t port_type:tcp_socket name_connect;
#line 88

#line 88
# Bind to any network address.
#line 88
allow insmod_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 88
allow insmod_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 88
allow insmod_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 88

#line 88
# Use/sendto/connectto sockets created by any domain.
#line 88
allow insmod_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 88

#line 88
# Use descriptors and pipes created by any domain.
#line 88
allow insmod_t domain:fd use;
#line 88
allow insmod_t domain:fifo_file { ioctl read getattr lock write append };
#line 88

#line 88
# Act upon any other process.
#line 88
allow insmod_t domain:process ~{ transition dyntransition execmem };
#line 88
# Transition to myself, to make get_ordered_context_list happy.
#line 88
allow insmod_t self:process transition;
#line 88

#line 88
if (allow_execmem) {
#line 88
# Allow making anonymous memory executable, e.g. 
#line 88
# for runtime-code generation or executable stack.
#line 88
allow insmod_t self:process execmem;
#line 88
}
#line 88

#line 88
if (allow_execmem && allow_execstack) {
#line 88
# Allow making the stack executable via mprotect.
#line 88
allow insmod_t self:process execstack;
#line 88
}
#line 88

#line 88
if (allow_execmod) {
#line 88
# Allow text relocations on system shared libraries, e.g. libGL.
#line 88

#line 88
allow insmod_t file_type:file execmod;
#line 88

#line 88
}
#line 88

#line 88
# Create/access any System V IPC objects.
#line 88
allow insmod_t domain:{ sem msgq shm } *;
#line 88
allow insmod_t domain:msg  { send receive };
#line 88

#line 88
# Access the security API.
#line 88
if (!secure_mode_policyload) {
#line 88
allow insmod_t security_t:security *;
#line 88
auditallow insmod_t security_t:security { load_policy setenforce setbool };
#line 88
}
#line 88
# Perform certain system operations that lacked individual capabilities.
#line 88
allow insmod_t kernel_t:system *;
#line 88

#line 88
# Use any Linux capability.
#line 88
allow insmod_t self:capability *;
#line 88

#line 88
# Set user information and skip authentication.
#line 88
allow insmod_t self:passwd *;
#line 88

#line 88
# Communicate via dbusd.
#line 88
allow insmod_t self:dbus *;
#line 88

#line 88
allow insmod_t system_dbusd_t:dbus *;
#line 88

#line 88

#line 88
# Get info via nscd.
#line 88
allow insmod_t self:nscd *;
#line 88

#line 88
allow insmod_t nscd_t:nscd *;
#line 88

#line 88

#line 88
 
#line 88


#line 89
allow insmod_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 89
allow insmod_t lib_t:lnk_file { read getattr lock ioctl };
#line 89
allow insmod_t ld_so_t:file { read getattr lock execute ioctl };
#line 89
#allow insmod_t ld_so_t:file execute_no_trans;
#line 89
allow insmod_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 89
allow insmod_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 89
allow insmod_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 89
allow insmod_t texrel_shlib_t:file execmod;
#line 89
allow insmod_t ld_so_cache_t:file { read getattr lock ioctl };
#line 89
allow insmod_t device_t:dir search;
#line 89
allow insmod_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 89


#line 90
allow insmod_t etc_t:lnk_file read;
#line 90
allow insmod_t lib_t:file { read getattr lock ioctl };
#line 90

#line 90
allow insmod_t locale_t:dir { read getattr lock search ioctl };
#line 90
allow insmod_t locale_t:file { read getattr lock ioctl };
#line 90
allow insmod_t locale_t:lnk_file { getattr read };
#line 90

#line 90


# for SSP
allow insmod_t urandom_device_t:chr_file read;
allow insmod_t lib_t:file { getattr read };

allow insmod_t { bin_t sbin_t }:dir search;
allow insmod_t { bin_t sbin_t }:lnk_file read;

allow insmod_t self:dir search;
allow insmod_t self:lnk_file read;

allow insmod_t usr_t:file { getattr read };

allow insmod_t privfd:fd use;

#line 105
allow insmod_t devpts_t:dir { read getattr lock search ioctl };
#line 105
allow insmod_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 105

allow insmod_t admin_tty_type:chr_file { ioctl read getattr lock write append };


allow insmod_t { agp_device_t apm_bios_t }:chr_file { read write };

allow insmod_t sound_device_t:chr_file { read ioctl write };
allow insmod_t zero_device_t:chr_file read;
allow insmod_t memory_device_t:chr_file { ioctl read getattr lock write append };

# Read module config and dependency information
allow insmod_t { modules_conf_t modules_dep_t }:file { getattr read };

# Read module objects.

#line 119
allow insmod_t modules_object_t:dir { read getattr lock search ioctl };
#line 119
allow insmod_t modules_object_t:file { read getattr lock ioctl };
#line 119
allow insmod_t modules_object_t:lnk_file { getattr read };
#line 119

# for locking
allow insmod_t modules_object_t:file write;

allow insmod_t { var_t var_log_t }:dir search;
#line 127


#line 128
allow insmod_t var_log_ksyms_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 128
allow insmod_t var_log_ksyms_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 128
allow insmod_t var_log_ksyms_t:lnk_file { create read getattr setattr link unlink rename };
#line 128

allow insmod_t { etc_t etc_runtime_t }:file { getattr read };

allow insmod_t self:udp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow insmod_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow insmod_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow insmod_t self:rawip_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow insmod_t self:capability { dac_override kill net_raw sys_tty_config };
allow insmod_t domain:process signal;
allow insmod_t self:process { fork { sigchld sigkill sigstop signull signal } };
allow insmod_t device_t:dir search;
allow insmod_t etc_runtime_t:file { getattr read };

# for loading modules at boot time
allow insmod_t { init_t initrc_t }:fd use;
allow insmod_t initrc_t:fifo_file { getattr read write };

allow insmod_t fs_t:filesystem getattr;
allow insmod_t sysfs_t:dir search;
allow insmod_t { usbfs_t usbdevfs_t }:dir search;
allow insmod_t { usbfs_t usbdevfs_t debugfs_t }:filesystem mount;

#line 149
allow insmod_t debugfs_t:dir { read getattr lock search ioctl };
#line 149
allow insmod_t debugfs_t:file { read getattr lock ioctl };
#line 149
allow insmod_t debugfs_t:lnk_file { getattr read };
#line 149


# Rules for /proc/sys/kernel/tainted

#line 152
# Read system variables in /sys.
#line 152

#line 152
allow insmod_t sysctl_t:dir search;
#line 152
allow insmod_t sysctl_kernel_t:dir search;
#line 152
allow insmod_t sysctl_kernel_t:file { getattr read };
#line 152

#line 152

#line 152

allow insmod_t proc_t:dir search;
allow insmod_t sysctl_kernel_t:file { setattr { ioctl read getattr lock write append } };

allow insmod_t proc_t:file { ioctl read getattr lock write append };
allow insmod_t proc_t:lnk_file read;

# Write to /proc/mtrr.
allow insmod_t mtrr_device_t:file write;

# Read /proc/sys/kernel/hotplug.
allow insmod_t sysctl_hotplug_t:file { getattr read };

allow insmod_t device_t:dir read;
allow insmod_t devpts_t:dir { getattr search };

if (!secure_mode_insmod) {

#line 169

#line 169

#line 169
#
#line 169
# Allow the process to transition to the new domain.
#line 169
#
#line 169
allow privmodule insmod_t:process transition;
#line 169

#line 169
#
#line 169
# Do not audit when glibc secure mode is enabled upon the transition.
#line 169
#
#line 169
dontaudit privmodule insmod_t:process noatsecure;
#line 169

#line 169
#
#line 169
# Do not audit when signal-related state is cleared upon the transition.
#line 169
#
#line 169
dontaudit privmodule insmod_t:process siginh;
#line 169

#line 169
#
#line 169
# Do not audit when resource limits are reset upon the transition.
#line 169
#
#line 169
dontaudit privmodule insmod_t:process rlimitinh;
#line 169

#line 169
#
#line 169
# Allow the process to execute the program.
#line 169
# 
#line 169
allow privmodule insmod_exec_t:file { read { getattr execute } };
#line 169

#line 169
#
#line 169
# Allow the process to reap the new domain.
#line 169
#
#line 169
allow insmod_t privmodule:process sigchld;
#line 169

#line 169
#
#line 169
# Allow the new domain to inherit and use file 
#line 169
# descriptions from the creating process and vice versa.
#line 169
#
#line 169
allow insmod_t privmodule:fd use;
#line 169
allow privmodule insmod_t:fd use;
#line 169

#line 169
#
#line 169
# Allow the new domain to write back to the old domain via a pipe.
#line 169
#
#line 169
allow insmod_t privmodule:fifo_file { ioctl read getattr lock write append };
#line 169

#line 169
#
#line 169
# Allow the new domain to read and execute the program.
#line 169
#
#line 169
allow insmod_t insmod_exec_t:file { read getattr lock execute ioctl };
#line 169

#line 169
#
#line 169
# Allow the new domain to be entered via the program.
#line 169
#
#line 169
allow insmod_t insmod_exec_t:file entrypoint;
#line 169

#line 169
type_transition privmodule insmod_exec_t:process insmod_t;
#line 169

allow insmod_t self:capability sys_module;
}
#line 173

#line 173
allow insmod_t { insmod_exec_t shell_exec_t bin_t sbin_t etc_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 173

allow insmod_t devtty_t:chr_file { ioctl read getattr lock write append };
allow insmod_t privmodule:process sigchld;
dontaudit sysadm_t self:capability sys_module;

#line 181

# for when /var is not mounted early in the boot
dontaudit insmod_t file_t:dir search;

# for nscd
dontaudit insmod_t var_run_t:dir search;

#line 190

#line 190

#line 190
allow system_crond_t var_log_ksyms_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 190
allow system_crond_t var_log_ksyms_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 190
allow system_crond_t var_log_ksyms_t:lnk_file { create read getattr setattr link unlink rename };
#line 190

#line 190


#line 243

#line 243
#################################
#line 243
#
#line 243
# Rules for the update_modules_t domain.
#line 243
#
#line 243
type update_modules_t, domain, privlog;
#line 243
type update_modules_exec_t, file_type, exec_type, sysadmfile;
#line 243

#line 243
role system_r types update_modules_t;
#line 243
role sysadm_r types update_modules_t;
#line 243

#line 243

#line 243

#line 243

#line 243
#
#line 243
# Allow the process to transition to the new domain.
#line 243
#
#line 243
allow { initrc_t sysadm_t } update_modules_t:process transition;
#line 243

#line 243
#
#line 243
# Do not audit when glibc secure mode is enabled upon the transition.
#line 243
#
#line 243
dontaudit { initrc_t sysadm_t } update_modules_t:process noatsecure;
#line 243

#line 243
#
#line 243
# Do not audit when signal-related state is cleared upon the transition.
#line 243
#
#line 243
dontaudit { initrc_t sysadm_t } update_modules_t:process siginh;
#line 243

#line 243
#
#line 243
# Do not audit when resource limits are reset upon the transition.
#line 243
#
#line 243
dontaudit { initrc_t sysadm_t } update_modules_t:process rlimitinh;
#line 243

#line 243
#
#line 243
# Allow the process to execute the program.
#line 243
# 
#line 243
allow { initrc_t sysadm_t } update_modules_exec_t:file { read { getattr execute } };
#line 243

#line 243
#
#line 243
# Allow the process to reap the new domain.
#line 243
#
#line 243
allow update_modules_t { initrc_t sysadm_t }:process sigchld;
#line 243

#line 243
#
#line 243
# Allow the new domain to inherit and use file 
#line 243
# descriptions from the creating process and vice versa.
#line 243
#
#line 243
allow update_modules_t { initrc_t sysadm_t }:fd use;
#line 243
allow { initrc_t sysadm_t } update_modules_t:fd use;
#line 243

#line 243
#
#line 243
# Allow the new domain to write back to the old domain via a pipe.
#line 243
#
#line 243
allow update_modules_t { initrc_t sysadm_t }:fifo_file { ioctl read getattr lock write append };
#line 243

#line 243
#
#line 243
# Allow the new domain to read and execute the program.
#line 243
#
#line 243
allow update_modules_t update_modules_exec_t:file { read getattr lock execute ioctl };
#line 243

#line 243
#
#line 243
# Allow the new domain to be entered via the program.
#line 243
#
#line 243
allow update_modules_t update_modules_exec_t:file entrypoint;
#line 243

#line 243
type_transition { initrc_t sysadm_t } update_modules_exec_t:process update_modules_t;
#line 243

#line 243
allow update_modules_t privfd:fd use;
#line 243
allow update_modules_t init_t:fd use;
#line 243

#line 243
allow update_modules_t device_t:dir { getattr search };
#line 243
allow update_modules_t { console_device_t devtty_t }:chr_file { ioctl read getattr lock write append };
#line 243

#line 243
allow update_modules_t devpts_t:dir { read getattr lock search ioctl };
#line 243
allow update_modules_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 243

#line 243
allow update_modules_t admin_tty_type:chr_file { ioctl read getattr lock write append };
#line 243

#line 243

#line 243
allow update_modules_t insmod_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 243

#line 243
allow update_modules_t urandom_device_t:chr_file { getattr read };
#line 243

#line 243
dontaudit update_modules_t sysadm_home_dir_t:dir search;
#line 243

#line 243

#line 243
allow update_modules_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 243
allow update_modules_t lib_t:lnk_file { read getattr lock ioctl };
#line 243
allow update_modules_t ld_so_t:file { read getattr lock execute ioctl };
#line 243
#allow update_modules_t ld_so_t:file execute_no_trans;
#line 243
allow update_modules_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 243
allow update_modules_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 243
allow update_modules_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 243
allow update_modules_t texrel_shlib_t:file execmod;
#line 243
allow update_modules_t ld_so_cache_t:file { read getattr lock ioctl };
#line 243
allow update_modules_t device_t:dir search;
#line 243
allow update_modules_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 243

#line 243

#line 243
allow update_modules_t etc_t:lnk_file read;
#line 243
allow update_modules_t lib_t:file { read getattr lock ioctl };
#line 243

#line 243
allow update_modules_t locale_t:dir { read getattr lock search ioctl };
#line 243
allow update_modules_t locale_t:file { read getattr lock ioctl };
#line 243
allow update_modules_t locale_t:lnk_file { getattr read };
#line 243

#line 243

#line 243
allow update_modules_t lib_t:file { getattr read };
#line 243
allow update_modules_t self:process { fork sigchld };
#line 243
allow update_modules_t self:fifo_file { ioctl read getattr lock write append };
#line 243
allow update_modules_t self:file { getattr read };
#line 243
allow update_modules_t modules_dep_t:file { ioctl read getattr lock write append };
#line 243

#line 243

#line 243

#line 243

#line 243
#
#line 243
# Allow the process to modify the directory.
#line 243
#
#line 243
allow update_modules_t modules_object_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 243

#line 243
#
#line 243
# Allow the process to create the file.
#line 243
#
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
allow update_modules_t modules_conf_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
type_transition update_modules_t modules_object_t:file modules_conf_t;
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
#
#line 243
# Allow the process to transition to the new domain.
#line 243
#
#line 243
allow update_modules_t depmod_t:process transition;
#line 243

#line 243
#
#line 243
# Do not audit when glibc secure mode is enabled upon the transition.
#line 243
#
#line 243
dontaudit update_modules_t depmod_t:process noatsecure;
#line 243

#line 243
#
#line 243
# Do not audit when signal-related state is cleared upon the transition.
#line 243
#
#line 243
dontaudit update_modules_t depmod_t:process siginh;
#line 243

#line 243
#
#line 243
# Do not audit when resource limits are reset upon the transition.
#line 243
#
#line 243
dontaudit update_modules_t depmod_t:process rlimitinh;
#line 243

#line 243
#
#line 243
# Allow the process to execute the program.
#line 243
# 
#line 243
allow update_modules_t depmod_exec_t:file { read { getattr execute } };
#line 243

#line 243
#
#line 243
# Allow the process to reap the new domain.
#line 243
#
#line 243
allow depmod_t update_modules_t:process sigchld;
#line 243

#line 243
#
#line 243
# Allow the new domain to inherit and use file 
#line 243
# descriptions from the creating process and vice versa.
#line 243
#
#line 243
allow depmod_t update_modules_t:fd use;
#line 243
allow update_modules_t depmod_t:fd use;
#line 243

#line 243
#
#line 243
# Allow the new domain to write back to the old domain via a pipe.
#line 243
#
#line 243
allow depmod_t update_modules_t:fifo_file { ioctl read getattr lock write append };
#line 243

#line 243
#
#line 243
# Allow the new domain to read and execute the program.
#line 243
#
#line 243
allow depmod_t depmod_exec_t:file { read getattr lock execute ioctl };
#line 243

#line 243
#
#line 243
# Allow the new domain to be entered via the program.
#line 243
#
#line 243
allow depmod_t depmod_exec_t:file entrypoint;
#line 243

#line 243
type_transition update_modules_t depmod_exec_t:process depmod_t;
#line 243

#line 243

#line 243
allow update_modules_t { shell_exec_t bin_t sbin_t update_modules_exec_t etc_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 243

#line 243
allow update_modules_t { sbin_t bin_t }:lnk_file read;
#line 243
allow update_modules_t { sbin_t bin_t }:dir search;
#line 243
allow update_modules_t { etc_t etc_runtime_t }:file { read getattr lock ioctl };
#line 243
allow update_modules_t etc_t:lnk_file read;
#line 243
allow update_modules_t fs_t:filesystem getattr;
#line 243

#line 243
allow update_modules_t proc_t:dir search;
#line 243
allow update_modules_t proc_t:file { read getattr lock ioctl };
#line 243
allow update_modules_t { self proc_t }:lnk_file read;
#line 243

#line 243
# Read system variables in /sys.
#line 243

#line 243
allow update_modules_t sysctl_t:dir search;
#line 243
allow update_modules_t sysctl_kernel_t:dir search;
#line 243
allow update_modules_t sysctl_kernel_t:file { getattr read };
#line 243

#line 243

#line 243

#line 243
allow update_modules_t self:dir search;
#line 243
allow update_modules_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
#
#line 243
# Allow the process to modify the directory.
#line 243
#
#line 243
allow update_modules_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 243

#line 243
#
#line 243
# Allow the process to create the file.
#line 243
#
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
allow update_modules_t modules_conf_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
type_transition update_modules_t etc_t:file modules_conf_t;
#line 243

#line 243

#line 243

#line 243

#line 243
type update_modules_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 243

#line 243

#line 243

#line 243

#line 243
#
#line 243
# Allow the process to modify the directory.
#line 243
#
#line 243
allow update_modules_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 243

#line 243
#
#line 243
# Allow the process to create the file.
#line 243
#
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
allow update_modules_t update_modules_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
allow update_modules_t update_modules_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243

#line 243
type_transition update_modules_t tmp_t:{ file dir } update_modules_tmp_t;
#line 243

#line 243

#line 243

#line 1 "domains/program/mta.te"
#DESC MTA - Mail agents
#
# Author: Russell Coker <russell@coker.com.au>
# X-Debian-Packages: postfix exim sendmail sendmail-wide
#
# policy for all mail servers, including allowing user to send mail from the
# command-line and for cron jobs to use sendmail -t

#
# sendmail_exec_t is the type of /usr/sbin/sendmail
#
# define sendmail_exec_t if sendmail.te does not do it for us
#line 15


# create a system_mail_t domain for daemons, init scripts, etc when they run
# "mail user@domain"

#line 19
# Derived domain based on the calling user domain and the program.
#line 19
type system_mail_t, domain, privlog, user_mail_domain, nscd_client_domain;
#line 19

#line 19

#line 19

#line 19

#line 19
# Use capabilities
#line 19
allow system_mail_t self:capability net_bind_service;
#line 19

#line 19

#line 19
type system_mail_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the process to modify the directory.
#line 19
#
#line 19
allow system_mail_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 19

#line 19
#
#line 19
# Allow the process to create the file.
#line 19
#
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow system_mail_t system_mail_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow system_mail_t system_mail_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
type_transition system_mail_t tmp_t:{ file dir } system_mail_tmp_t;
#line 19

#line 19

#line 19

#line 19

#line 19
# Write to /var/spool/mail and /var/spool/mqueue.
#line 19
allow system_mail_t mail_spool_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 19
allow system_mail_t mail_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19
allow system_mail_t mqueue_spool_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 19
allow system_mail_t mqueue_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19

#line 19
# Write to /var/log/sendmail.st
#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the process to modify the directory.
#line 19
#
#line 19
allow system_mail_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 19

#line 19
#
#line 19
# Allow the process to create the file.
#line 19
#
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow system_mail_t sendmail_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow system_mail_t sendmail_log_t:lnk_file { create read getattr setattr link unlink rename };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow system_mail_t sendmail_log_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow system_mail_t sendmail_log_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow system_mail_t sendmail_log_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
type_transition system_mail_t var_log_t:dir sendmail_log_t;
#line 19
type_transition system_mail_t var_log_t:{ file lnk_file sock_file fifo_file } sendmail_log_t;
#line 19

#line 19

#line 19

#line 19
allow system_mail_t etc_mail_t:dir { getattr search };
#line 19

#line 19
allow system_mail_t { var_t var_spool_t }:dir getattr;
#line 19

#line 19
allow system_mail_t etc_runtime_t:file { getattr read };
#line 19

#line 19
# Check available space.
#line 19
allow system_mail_t fs_t:filesystem getattr;
#line 19

#line 19
allow system_mail_t sysctl_kernel_t:dir search;
#line 19

#line 19

#line 19
dontaudit system_mail_t proc_t:dir search;
#line 19
dontaudit system_mail_t sysctl_kernel_t:file read;
#line 19

#line 19

#line 19

#line 19

#line 19
allow system_mail_t sendmail_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 19

#line 19
allow system_mail_t sendmail_exec_t:lnk_file { getattr read };
#line 19

#line 19
# The user role is authorized for this domain.
#line 19
role system_r types system_mail_t;
#line 19

#line 19

#line 19
allow system_mail_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 19
allow system_mail_t lib_t:lnk_file { read getattr lock ioctl };
#line 19
allow system_mail_t ld_so_t:file { read getattr lock execute ioctl };
#line 19
#allow system_mail_t ld_so_t:file execute_no_trans;
#line 19
allow system_mail_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 19
allow system_mail_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 19
allow system_mail_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 19
allow system_mail_t texrel_shlib_t:file execmod;
#line 19
allow system_mail_t ld_so_cache_t:file { read getattr lock ioctl };
#line 19
allow system_mail_t device_t:dir search;
#line 19
allow system_mail_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow system_mail_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow system_mail_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow system_mail_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow system_mail_t node_type:node { tcp_send rawip_send };
#line 19
allow system_mail_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow system_mail_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow system_mail_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow system_mail_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow system_mail_t self:tcp_socket { connect };
#line 19

#line 19
allow system_mail_t { smtp_port_t port_type }:tcp_socket name_connect;
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow system_mail_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow system_mail_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow system_mail_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow system_mail_t node_type:node { tcp_send rawip_send };
#line 19
allow system_mail_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow system_mail_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow system_mail_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow system_mail_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow system_mail_t self:tcp_socket { connect };
#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use udp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow system_mail_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow system_mail_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow system_mail_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow system_mail_t node_type:node { udp_send rawip_send };
#line 19
allow system_mail_t node_type:node { udp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow system_mail_t dns_port_t:udp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow system_mail_t node_type:udp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow system_mail_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow system_mail_t self:udp_socket { connect };
#line 19

#line 19

#line 19

#line 19
allow system_mail_t dns_port_t:tcp_socket name_connect;
#line 19

#line 19

#line 19

#line 19
if (allow_ypbind) {
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow system_mail_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow system_mail_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow system_mail_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow system_mail_t node_type:node { tcp_send rawip_send };
#line 19
allow system_mail_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow system_mail_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow system_mail_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow system_mail_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow system_mail_t self:tcp_socket { listen accept };
#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow system_mail_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow system_mail_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow system_mail_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow system_mail_t node_type:node { tcp_send rawip_send };
#line 19
allow system_mail_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow system_mail_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow system_mail_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow system_mail_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow system_mail_t self:tcp_socket { connect };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use udp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow system_mail_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow system_mail_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow system_mail_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow system_mail_t node_type:node { udp_send rawip_send };
#line 19
allow system_mail_t node_type:node { udp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow system_mail_t port_type:udp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow system_mail_t node_type:udp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow system_mail_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow system_mail_t self:udp_socket { connect };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow system_mail_t var_yp_t:dir { read getattr lock search ioctl };
#line 19
allow system_mail_t var_yp_t:file { read getattr lock ioctl };
#line 19
allow system_mail_t var_yp_t:lnk_file { getattr read };
#line 19

#line 19
allow system_mail_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 19
allow system_mail_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 19
dontaudit system_mail_t self:capability net_bind_service;
#line 19
dontaudit system_mail_t reserved_port_type:tcp_socket name_connect;
#line 19
dontaudit system_mail_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 19

#line 19
} else {
#line 19
dontaudit system_mail_t var_yp_t:dir search;
#line 19
}
#line 19
 
#line 19
allow system_mail_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 19
allow system_mail_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 19

#line 19

#line 19
allow system_mail_t etc_t:lnk_file read;
#line 19
allow system_mail_t lib_t:file { read getattr lock ioctl };
#line 19

#line 19
allow system_mail_t locale_t:dir { read getattr lock search ioctl };
#line 19
allow system_mail_t locale_t:file { read getattr lock ioctl };
#line 19
allow system_mail_t locale_t:lnk_file { getattr read };
#line 19

#line 19

#line 19

#line 19
# Read system variables in /sys.
#line 19

#line 19
allow system_mail_t sysctl_t:dir search;
#line 19
allow system_mail_t sysctl_kernel_t:dir search;
#line 19
allow system_mail_t sysctl_kernel_t:file { getattr read };
#line 19

#line 19

#line 19

#line 19
allow system_mail_t device_t:dir search;
#line 19
allow system_mail_t { var_t var_spool_t }:dir search;
#line 19
allow system_mail_t self:process { fork { sigchld sigkill sigstop signull signal } setrlimit };
#line 19
allow system_mail_t sbin_t:dir search;
#line 19

#line 19
# It wants to check for nscd
#line 19
dontaudit system_mail_t var_run_t:dir search;
#line 19

#line 19
# Use capabilities
#line 19
allow system_mail_t self:capability { setuid setgid chown };
#line 19

#line 19
# Execute procmail.
#line 19

#line 19
allow system_mail_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 19

#line 19

#line 19

#line 19

#line 19
# Transition from a system domain to the derived domain.
#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the process to transition to the new domain.
#line 19
#
#line 19
allow privmail system_mail_t:process transition;
#line 19

#line 19
#
#line 19
# Do not audit when glibc secure mode is enabled upon the transition.
#line 19
#
#line 19
dontaudit privmail system_mail_t:process noatsecure;
#line 19

#line 19
#
#line 19
# Do not audit when signal-related state is cleared upon the transition.
#line 19
#
#line 19
dontaudit privmail system_mail_t:process siginh;
#line 19

#line 19
#
#line 19
# Do not audit when resource limits are reset upon the transition.
#line 19
#
#line 19
dontaudit privmail system_mail_t:process rlimitinh;
#line 19

#line 19
#
#line 19
# Allow the process to execute the program.
#line 19
# 
#line 19
allow privmail sendmail_exec_t:file { read { getattr execute } };
#line 19

#line 19
#
#line 19
# Allow the process to reap the new domain.
#line 19
#
#line 19
allow system_mail_t privmail:process sigchld;
#line 19

#line 19
#
#line 19
# Allow the new domain to inherit and use file 
#line 19
# descriptions from the creating process and vice versa.
#line 19
#
#line 19
allow system_mail_t privmail:fd use;
#line 19
allow privmail system_mail_t:fd use;
#line 19

#line 19
#
#line 19
# Allow the new domain to write back to the old domain via a pipe.
#line 19
#
#line 19
allow system_mail_t privmail:fifo_file { ioctl read getattr lock write append };
#line 19

#line 19
#
#line 19
# Allow the new domain to read and execute the program.
#line 19
#
#line 19
allow system_mail_t sendmail_exec_t:file { read getattr lock execute ioctl };
#line 19

#line 19
#
#line 19
# Allow the new domain to be entered via the program.
#line 19
#
#line 19
allow system_mail_t sendmail_exec_t:file entrypoint;
#line 19

#line 19
type_transition privmail sendmail_exec_t:process system_mail_t;
#line 19

#line 19
allow privmail sendmail_exec_t:lnk_file { getattr read };
#line 19

#line 19

#line 19
# Read cron temporary files.
#line 19
allow system_mail_t system_crond_tmp_t:file { read getattr ioctl };
#line 19
allow mta_user_agent system_crond_tmp_t:file { read getattr };
#line 19

#line 19

#line 19
allow system_mail_t devpts_t:dir { read getattr lock search ioctl };
#line 19
allow system_mail_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 19

#line 19

#line 19

#line 19
allow system_mail_t etc_t:file { getattr read };
#line 19

#line 19


#line 51

#line 51
# rules are currently defined in sendmail.te, but it is not included in 
#line 51
# targeted policy.  We could move these rules permanantly here.
#line 51

#line 51
allow system_mail_t self:dir search;
#line 51
allow system_mail_t self:lnk_file read;
#line 51

#line 51
allow system_mail_t { proc_t proc_net_t }:dir { read getattr lock search ioctl };
#line 51
allow system_mail_t { proc_t proc_net_t }:file { read getattr lock ioctl };
#line 51
allow system_mail_t { proc_t proc_net_t }:lnk_file { getattr read };
#line 51

#line 51
allow system_mail_t fs_t:filesystem getattr;
#line 51
allow system_mail_t { var_t var_spool_t }:dir getattr;
#line 51

#line 51
allow system_mail_t mqueue_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 51
allow system_mail_t mqueue_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 51
allow system_mail_t mqueue_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 51

#line 51

#line 51
allow system_mail_t mail_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 51
allow system_mail_t mail_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 51
allow system_mail_t mail_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 51

#line 51
allow system_mail_t mail_spool_t:fifo_file { ioctl read getattr lock write append };
#line 51
allow system_mail_t etc_mail_t:file { getattr read };
#line 51

#line 51
# for reading .forward - maybe we need a new type for it?
#line 51
# also for delivering mail to maildir
#line 51

#line 51

#line 51

#line 51

#line 51
#
#line 51
# Allow the process to modify the directory.
#line 51
#
#line 51
allow mta_delivery_agent user_home_dir_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 51

#line 51
#
#line 51
# Allow the process to create the file.
#line 51
#
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
allow mta_delivery_agent user_home_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
allow mta_delivery_agent user_home_t:lnk_file { create read getattr setattr link unlink rename };
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
allow mta_delivery_agent user_home_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
allow mta_delivery_agent user_home_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
allow mta_delivery_agent user_home_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
type_transition mta_delivery_agent user_home_dir_t:dir user_home_t;
#line 51
type_transition mta_delivery_agent user_home_dir_t:{ file lnk_file sock_file fifo_file } user_home_t;
#line 51

#line 51

#line 51

# for a mail server process that does things in response to a user command
allow mta_user_agent userdomain:process sigchld;
allow mta_user_agent { userdomain privfd }:fd use;
#line 57

#line 57
allow mta_user_agent crond_t:process sigchld;
#line 57

allow mta_user_agent sysadm_t:fifo_file { read write };

allow { system_mail_t mta_user_agent } privmail:fd use;
allow { system_mail_t mta_user_agent } privmail:process sigchld;
allow { system_mail_t mta_user_agent } privmail:fifo_file { read write };
allow { system_mail_t mta_user_agent } admin_tty_type:chr_file { read write };

allow mta_delivery_agent home_root_t:dir { getattr search };

# for /var/spool/mail

#line 68
allow mta_delivery_agent mail_spool_t:dir { read getattr lock search ioctl add_name write };
#line 68
allow mta_delivery_agent mail_spool_t:file { create { ioctl read getattr lock append } };
#line 68
allow mta_delivery_agent mail_spool_t:lnk_file { create read getattr };
#line 68


# for piping mail to a command

#line 71
allow mta_delivery_agent shell_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 71

allow mta_delivery_agent bin_t:dir search;
allow mta_delivery_agent bin_t:lnk_file read;
allow mta_delivery_agent devtty_t:chr_file { ioctl read getattr lock write append };
allow mta_delivery_agent { etc_runtime_t proc_t }:file { getattr read };

allow system_mail_t etc_runtime_t:file { getattr read };
allow system_mail_t { random_device_t urandom_device_t }:chr_file { getattr read };
#line 81

#line 81
typealias system_mail_t alias sysadm_mail_t;
#line 81

#line 1 "domains/program/mysqld.te"
#DESC Mysqld - Database server
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: mysql-server
#

#################################
#
# Rules for the mysqld_t domain.
#
# mysqld_exec_t is the type of the mysqld executable.
#

#line 13

#line 13

#line 13

#line 13
type mysqld_t, domain, privlog, daemon , nscd_client_domain, transitionbool;
#line 13
type mysqld_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit mysqld_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types mysqld_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow mysqld_t init_t:fd use;
#line 13
allow mysqld_t init_t:process sigchld;
#line 13
allow mysqld_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow mysqld_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow mysqld_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow mysqld_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow mysqld_t ld_so_t:file execute_no_trans;
#line 13
allow mysqld_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow mysqld_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow mysqld_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow mysqld_t texrel_shlib_t:file execmod;
#line 13
allow mysqld_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow mysqld_t device_t:dir search;
#line 13
allow mysqld_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow mysqld_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow mysqld_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow mysqld_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow mysqld_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow mysqld_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit mysqld_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit mysqld_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow mysqld_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow mysqld_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow mysqld_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow mysqld_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit mysqld_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit mysqld_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow mysqld_t sysctl_t:dir search;
#line 13
allow mysqld_t sysctl_kernel_t:dir search;
#line 13
allow mysqld_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13

#line 13
bool mysqld_disable_trans false;
#line 13
if (mysqld_disable_trans) {
#line 13

#line 13
allow initrc_t mysqld_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13

#line 13
allow sysadm_t mysqld_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13
} else {
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t mysqld_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t mysqld_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t mysqld_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t mysqld_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t mysqld_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow mysqld_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow mysqld_t initrc_t:fd use;
#line 13
allow initrc_t mysqld_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow mysqld_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow mysqld_t mysqld_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow mysqld_t mysqld_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t mysqld_exec_t:process mysqld_t;
#line 13

#line 13

#line 13
allow initrc_t mysqld_t:process { noatsecure siginh rlimitinh };
#line 13

#line 13
}
#line 13
 
#line 13
allow mysqld_t privfd:fd use;
#line 13

#line 13
allow mysqld_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
# Create pid file.
#line 13
allow mysqld_t var_t:dir { getattr search };
#line 13

#line 13
type mysqld_var_run_t, file_type, sysadmfile, pidfile;
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow mysqld_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow mysqld_t mysqld_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition mysqld_t var_run_t:file mysqld_var_run_t;
#line 13

#line 13

#line 13

#line 13
allow mysqld_t var_t:dir search;
#line 13
allow mysqld_t mysqld_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13

#line 13
allow mysqld_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13
# for daemons that look at /root on startup
#line 13
dontaudit mysqld_t sysadm_home_dir_t:dir search;
#line 13

#line 13
# for df
#line 13
allow mysqld_t fs_type:filesystem getattr;
#line 13
allow mysqld_t removable_t:filesystem getattr;
#line 13

#line 13

#line 13
allow mysqld_t etc_t:lnk_file read;
#line 13
allow mysqld_t lib_t:file { read getattr lock ioctl };
#line 13

#line 13
allow mysqld_t locale_t:dir { read getattr lock search ioctl };
#line 13
allow mysqld_t locale_t:file { read getattr lock ioctl };
#line 13
allow mysqld_t locale_t:lnk_file { getattr read };
#line 13

#line 13

#line 13

#line 13
# for localization
#line 13
allow mysqld_t lib_t:file { getattr read };
#line 13


allow mysqld_t mysqld_port_t:tcp_socket { name_bind name_connect };

allow mysqld_t mysqld_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };


#line 19

#line 19
type mysqld_etc_t, file_type, sysadmfile, usercanread;
#line 19
allow mysqld_t mysqld_etc_t:file { read getattr lock ioctl };
#line 19

#line 19
allow mysqld_t mysqld_etc_t:dir { read getattr lock search ioctl };
#line 19
allow mysqld_t mysqld_etc_t:lnk_file { getattr read };
#line 19

type mysqld_db_t, file_type, sysadmfile;


#line 22
type mysqld_log_t, file_type, sysadmfile, logfile;
#line 22

#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the process to modify the directory.
#line 22
#
#line 22
allow mysqld_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 22

#line 22
#
#line 22
# Allow the process to create the file.
#line 22
#
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
allow mysqld_t mysqld_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
type_transition mysqld_t var_log_t:file mysqld_log_t;
#line 22

#line 22

#line 22


# for temporary tables

#line 25
type mysqld_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 25

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the process to modify the directory.
#line 25
#
#line 25
allow mysqld_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 25

#line 25
#
#line 25
# Allow the process to create the file.
#line 25
#
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow mysqld_t mysqld_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow mysqld_t mysqld_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
type_transition mysqld_t tmp_t:{ file dir } mysqld_tmp_t;
#line 25

#line 25

#line 25


allow mysqld_t usr_t:file { getattr read };

allow mysqld_t self:fifo_file { read write };
allow mysqld_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow initrc_t mysqld_t:unix_stream_socket connectto;
allow initrc_t mysqld_var_run_t:sock_file write;

allow initrc_t mysqld_log_t:file { write append setattr ioctl };

allow mysqld_t self:capability { dac_override setgid setuid net_bind_service sys_resource };
allow mysqld_t self:process { setrlimit setsched getsched };

allow mysqld_t proc_t:file { getattr read };

# Allow access to the mysqld databases

#line 42
allow mysqld_t mysqld_db_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 42
allow mysqld_t mysqld_db_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 42
allow mysqld_t mysqld_db_t:lnk_file { create read getattr setattr link unlink rename };
#line 42


#line 43

#line 43

#line 43

#line 43
#
#line 43
# Allow the process to modify the directory.
#line 43
#
#line 43
allow mysqld_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 43

#line 43
#
#line 43
# Allow the process to create the file.
#line 43
#
#line 43

#line 43

#line 43

#line 43

#line 43

#line 43
allow mysqld_t mysqld_db_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43
allow mysqld_t mysqld_db_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43
type_transition mysqld_t var_lib_t:{ dir file } mysqld_db_t;
#line 43

#line 43



#line 45

#line 45

#line 45

#line 45

#line 45

#line 45
#
#line 45
# Allow the domain to create and use tcp sockets.
#line 45
# Other kinds of sockets must be separately authorized for use.
#line 45
allow mysqld_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 45

#line 45
allow mysqld_t unlabeled_t:association { sendto recvfrom };
#line 45

#line 45
#
#line 45
# Allow the domain to send or receive using any network interface.
#line 45
# netif_type is a type attribute for all network interface types.
#line 45
#
#line 45
allow mysqld_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 45
#
#line 45
# Allow the domain to send to or receive from any node.
#line 45
# node_type is a type attribute for all node types.
#line 45
#
#line 45
allow mysqld_t node_type:node { tcp_send rawip_send };
#line 45
allow mysqld_t node_type:node { tcp_recv rawip_recv };
#line 45

#line 45
#
#line 45
# Allow the domain to send to or receive from any port.
#line 45
# port_type is a type attribute for all port types.
#line 45
#
#line 45

#line 45
allow mysqld_t port_type:tcp_socket { send_msg recv_msg };
#line 45

#line 45

#line 45
# XXX Allow binding to any node type.  Remove once
#line 45
# individual rules have been added to all domains that 
#line 45
# bind sockets. 
#line 45
allow mysqld_t node_type:tcp_socket node_bind;
#line 45
#
#line 45
# Allow access to network files including /etc/resolv.conf
#line 45
#
#line 45
allow mysqld_t net_conf_t:file { read getattr lock ioctl };
#line 45

#line 45
allow mysqld_t self:tcp_socket { listen accept };
#line 45

#line 45

#line 45

#line 45
#
#line 45
# Allow the domain to create and use tcp sockets.
#line 45
# Other kinds of sockets must be separately authorized for use.
#line 45
allow mysqld_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 45

#line 45
allow mysqld_t unlabeled_t:association { sendto recvfrom };
#line 45

#line 45
#
#line 45
# Allow the domain to send or receive using any network interface.
#line 45
# netif_type is a type attribute for all network interface types.
#line 45
#
#line 45
allow mysqld_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 45
#
#line 45
# Allow the domain to send to or receive from any node.
#line 45
# node_type is a type attribute for all node types.
#line 45
#
#line 45
allow mysqld_t node_type:node { tcp_send rawip_send };
#line 45
allow mysqld_t node_type:node { tcp_recv rawip_recv };
#line 45

#line 45
#
#line 45
# Allow the domain to send to or receive from any port.
#line 45
# port_type is a type attribute for all port types.
#line 45
#
#line 45

#line 45
allow mysqld_t port_type:tcp_socket { send_msg recv_msg };
#line 45

#line 45

#line 45
# XXX Allow binding to any node type.  Remove once
#line 45
# individual rules have been added to all domains that 
#line 45
# bind sockets. 
#line 45
allow mysqld_t node_type:tcp_socket node_bind;
#line 45
#
#line 45
# Allow access to network files including /etc/resolv.conf
#line 45
#
#line 45
allow mysqld_t net_conf_t:file { read getattr lock ioctl };
#line 45

#line 45
allow mysqld_t self:tcp_socket { connect };
#line 45

#line 45

#line 45

#line 45

#line 45

#line 45
#
#line 45
# Allow the domain to create and use udp sockets.
#line 45
# Other kinds of sockets must be separately authorized for use.
#line 45
allow mysqld_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 45

#line 45
allow mysqld_t unlabeled_t:association { sendto recvfrom };
#line 45

#line 45
#
#line 45
# Allow the domain to send or receive using any network interface.
#line 45
# netif_type is a type attribute for all network interface types.
#line 45
#
#line 45
allow mysqld_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 45
#
#line 45
# Allow the domain to send to or receive from any node.
#line 45
# node_type is a type attribute for all node types.
#line 45
#
#line 45
allow mysqld_t node_type:node { udp_send rawip_send };
#line 45
allow mysqld_t node_type:node { udp_recv rawip_recv };
#line 45

#line 45
#
#line 45
# Allow the domain to send to or receive from any port.
#line 45
# port_type is a type attribute for all port types.
#line 45
#
#line 45

#line 45
allow mysqld_t port_type:udp_socket { send_msg recv_msg };
#line 45

#line 45

#line 45
# XXX Allow binding to any node type.  Remove once
#line 45
# individual rules have been added to all domains that 
#line 45
# bind sockets. 
#line 45
allow mysqld_t node_type:udp_socket node_bind;
#line 45
#
#line 45
# Allow access to network files including /etc/resolv.conf
#line 45
#
#line 45
allow mysqld_t net_conf_t:file { read getattr lock ioctl };
#line 45

#line 45
allow mysqld_t self:udp_socket { connect };
#line 45

#line 45

#line 45

#line 45

#line 45


#line 46

#line 46
if (allow_ypbind) {
#line 46

#line 46

#line 46

#line 46

#line 46

#line 46

#line 46

#line 46
#
#line 46
# Allow the domain to create and use tcp sockets.
#line 46
# Other kinds of sockets must be separately authorized for use.
#line 46
allow mysqld_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 46

#line 46
allow mysqld_t unlabeled_t:association { sendto recvfrom };
#line 46

#line 46
#
#line 46
# Allow the domain to send or receive using any network interface.
#line 46
# netif_type is a type attribute for all network interface types.
#line 46
#
#line 46
allow mysqld_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 46
#
#line 46
# Allow the domain to send to or receive from any node.
#line 46
# node_type is a type attribute for all node types.
#line 46
#
#line 46
allow mysqld_t node_type:node { tcp_send rawip_send };
#line 46
allow mysqld_t node_type:node { tcp_recv rawip_recv };
#line 46

#line 46
#
#line 46
# Allow the domain to send to or receive from any port.
#line 46
# port_type is a type attribute for all port types.
#line 46
#
#line 46

#line 46
allow mysqld_t port_type:tcp_socket { send_msg recv_msg };
#line 46

#line 46

#line 46
# XXX Allow binding to any node type.  Remove once
#line 46
# individual rules have been added to all domains that 
#line 46
# bind sockets. 
#line 46
allow mysqld_t node_type:tcp_socket node_bind;
#line 46
#
#line 46
# Allow access to network files including /etc/resolv.conf
#line 46
#
#line 46
allow mysqld_t net_conf_t:file { read getattr lock ioctl };
#line 46

#line 46
allow mysqld_t self:tcp_socket { listen accept };
#line 46

#line 46

#line 46

#line 46
#
#line 46
# Allow the domain to create and use tcp sockets.
#line 46
# Other kinds of sockets must be separately authorized for use.
#line 46
allow mysqld_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 46

#line 46
allow mysqld_t unlabeled_t:association { sendto recvfrom };
#line 46

#line 46
#
#line 46
# Allow the domain to send or receive using any network interface.
#line 46
# netif_type is a type attribute for all network interface types.
#line 46
#
#line 46
allow mysqld_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 46
#
#line 46
# Allow the domain to send to or receive from any node.
#line 46
# node_type is a type attribute for all node types.
#line 46
#
#line 46
allow mysqld_t node_type:node { tcp_send rawip_send };
#line 46
allow mysqld_t node_type:node { tcp_recv rawip_recv };
#line 46

#line 46
#
#line 46
# Allow the domain to send to or receive from any port.
#line 46
# port_type is a type attribute for all port types.
#line 46
#
#line 46

#line 46
allow mysqld_t port_type:tcp_socket { send_msg recv_msg };
#line 46

#line 46

#line 46
# XXX Allow binding to any node type.  Remove once
#line 46
# individual rules have been added to all domains that 
#line 46
# bind sockets. 
#line 46
allow mysqld_t node_type:tcp_socket node_bind;
#line 46
#
#line 46
# Allow access to network files including /etc/resolv.conf
#line 46
#
#line 46
allow mysqld_t net_conf_t:file { read getattr lock ioctl };
#line 46

#line 46
allow mysqld_t self:tcp_socket { connect };
#line 46

#line 46

#line 46

#line 46

#line 46

#line 46
#
#line 46
# Allow the domain to create and use udp sockets.
#line 46
# Other kinds of sockets must be separately authorized for use.
#line 46
allow mysqld_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 46

#line 46
allow mysqld_t unlabeled_t:association { sendto recvfrom };
#line 46

#line 46
#
#line 46
# Allow the domain to send or receive using any network interface.
#line 46
# netif_type is a type attribute for all network interface types.
#line 46
#
#line 46
allow mysqld_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 46
#
#line 46
# Allow the domain to send to or receive from any node.
#line 46
# node_type is a type attribute for all node types.
#line 46
#
#line 46
allow mysqld_t node_type:node { udp_send rawip_send };
#line 46
allow mysqld_t node_type:node { udp_recv rawip_recv };
#line 46

#line 46
#
#line 46
# Allow the domain to send to or receive from any port.
#line 46
# port_type is a type attribute for all port types.
#line 46
#
#line 46

#line 46
allow mysqld_t port_type:udp_socket { send_msg recv_msg };
#line 46

#line 46

#line 46
# XXX Allow binding to any node type.  Remove once
#line 46
# individual rules have been added to all domains that 
#line 46
# bind sockets. 
#line 46
allow mysqld_t node_type:udp_socket node_bind;
#line 46
#
#line 46
# Allow access to network files including /etc/resolv.conf
#line 46
#
#line 46
allow mysqld_t net_conf_t:file { read getattr lock ioctl };
#line 46

#line 46
allow mysqld_t self:udp_socket { connect };
#line 46

#line 46

#line 46

#line 46

#line 46

#line 46

#line 46
allow mysqld_t var_yp_t:dir { read getattr lock search ioctl };
#line 46
allow mysqld_t var_yp_t:file { read getattr lock ioctl };
#line 46
allow mysqld_t var_yp_t:lnk_file { getattr read };
#line 46

#line 46
allow mysqld_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 46
allow mysqld_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 46
dontaudit mysqld_t self:capability net_bind_service;
#line 46
dontaudit mysqld_t reserved_port_type:tcp_socket name_connect;
#line 46
dontaudit mysqld_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 46

#line 46
} else {
#line 46
dontaudit mysqld_t var_yp_t:dir search;
#line 46
}
#line 46
 

# read config files

#line 49
allow initrc_t mysqld_etc_t:dir { read getattr lock search ioctl };
#line 49
allow initrc_t mysqld_etc_t:file { read getattr lock ioctl };
#line 49
allow initrc_t mysqld_etc_t:lnk_file { getattr read };
#line 49

allow mysqld_t { etc_t etc_runtime_t }:{ file lnk_file } { read getattr };

allow mysqld_t etc_t:dir search;


#line 54
# Read system variables in /sys.
#line 54

#line 54
allow mysqld_t sysctl_t:dir search;
#line 54
allow mysqld_t sysctl_kernel_t:dir search;
#line 54
allow mysqld_t sysctl_kernel_t:file { getattr read };
#line 54

#line 54

#line 54



#line 56
allow sysadm_t mysqld_t:unix_stream_socket connectto;
#line 56


# for /root/.my.cnf - should not be needed
allow mysqld_t sysadm_home_dir_t:dir search;
allow mysqld_t sysadm_home_t:file { read getattr };

#line 68


#line 75

#line 81

#line 81
allow initrc_t mysqld_db_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 81

#line 81
# because Fedora has the sock_file in the database directory
#line 81

#line 81

#line 81

#line 81

#line 81
#
#line 81
# Allow the process to modify the directory.
#line 81
#
#line 81
allow mysqld_t mysqld_db_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 81

#line 81
#
#line 81
# Allow the process to create the file.
#line 81
#
#line 81

#line 81

#line 81

#line 81

#line 81

#line 81
allow mysqld_t mysqld_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81

#line 81
type_transition mysqld_t mysqld_db_t:sock_file mysqld_var_run_t;
#line 81

#line 81

#line 81

#line 89


#line 93

#line 93
allow system_crond_t mysqld_etc_t:file { getattr read };
#line 93

allow mysqld_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 1 "domains/program/named.te"
#DESC BIND - Name server
#
# Authors:  Yuichi Nakamura <ynakam@ori.hitachi-sk.co.jp>,
#           Russell Coker
# X-Debian-Packages: bind bind9
# 
#

#################################
#
# Rules for the named_t domain.
#


#line 14

#line 14

#line 14

#line 14
type named_t, domain, privlog, daemon , nscd_client_domain, transitionbool;
#line 14
type named_exec_t, file_type, sysadmfile, exec_type;
#line 14
dontaudit named_t self:capability sys_tty_config;
#line 14

#line 14
role system_r types named_t;
#line 14

#line 14
# Inherit and use descriptors from init.
#line 14
allow named_t init_t:fd use;
#line 14
allow named_t init_t:process sigchld;
#line 14
allow named_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 14

#line 14

#line 14
allow named_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow named_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow named_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow named_t ld_so_t:file execute_no_trans;
#line 14
allow named_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow named_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow named_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow named_t texrel_shlib_t:file execmod;
#line 14
allow named_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow named_t device_t:dir search;
#line 14
allow named_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
allow named_t { self proc_t }:dir { read getattr lock search ioctl };
#line 14
allow named_t { self proc_t }:lnk_file { getattr read };
#line 14

#line 14
allow named_t device_t:dir { read getattr lock search ioctl };
#line 14

#line 14
allow named_t udev_tdb_t:file { read getattr lock ioctl };
#line 14
allow named_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit named_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit named_t unpriv_userdomain:fd use;
#line 14

#line 14

#line 14
allow named_t sysfs_t:dir { read getattr lock search ioctl };
#line 14
allow named_t sysfs_t:file { read getattr lock ioctl };
#line 14
allow named_t sysfs_t:lnk_file { getattr read };
#line 14
 
#line 14

#line 14
allow named_t autofs_t:dir { search getattr };
#line 14

#line 14
dontaudit named_t { tty_device_t devpts_t }:chr_file { read write };
#line 14
dontaudit named_t root_t:file { getattr read };
#line 14
 
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow named_t sysctl_t:dir search;
#line 14
allow named_t sysctl_kernel_t:dir search;
#line 14
allow named_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14

#line 14
bool named_disable_trans false;
#line 14
if (named_disable_trans) {
#line 14

#line 14
allow initrc_t named_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t named_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14
 
#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow initrc_t named_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit initrc_t named_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit initrc_t named_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit initrc_t named_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow initrc_t named_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow named_t initrc_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow named_t initrc_t:fd use;
#line 14
allow initrc_t named_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow named_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow named_t named_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow named_t named_exec_t:file entrypoint;
#line 14

#line 14
type_transition initrc_t named_exec_t:process named_t;
#line 14

#line 14

#line 14
allow initrc_t named_t:process { noatsecure siginh rlimitinh };
#line 14

#line 14
}
#line 14
 
#line 14
allow named_t privfd:fd use;
#line 14

#line 14
allow named_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
# Create pid file.
#line 14
allow named_t var_t:dir { getattr search };
#line 14

#line 14
type named_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow named_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow named_t named_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition named_t var_run_t:file named_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow named_t var_t:dir search;
#line 14
allow named_t named_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
allow named_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
# for daemons that look at /root on startup
#line 14
dontaudit named_t sysadm_home_dir_t:dir search;
#line 14

#line 14
# for df
#line 14
allow named_t fs_type:filesystem getattr;
#line 14
allow named_t removable_t:filesystem getattr;
#line 14

#line 14

#line 14
allow named_t etc_t:lnk_file read;
#line 14
allow named_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow named_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow named_t locale_t:file { read getattr lock ioctl };
#line 14
allow named_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14

#line 14
# for localization
#line 14
allow named_t lib_t:file { getattr read };
#line 14


#line 15
type named_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 15

#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the process to modify the directory.
#line 15
#
#line 15
allow named_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 15

#line 15
#
#line 15
# Allow the process to create the file.
#line 15
#
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
allow named_t named_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
allow named_t named_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
type_transition named_t tmp_t:{ file dir } named_tmp_t;
#line 15

#line 15

#line 15


type named_checkconf_exec_t, file_type, exec_type, sysadmfile;

#line 18

#line 18

#line 18
#
#line 18
# Allow the process to transition to the new domain.
#line 18
#
#line 18
allow initrc_t named_t:process transition;
#line 18

#line 18
#
#line 18
# Do not audit when glibc secure mode is enabled upon the transition.
#line 18
#
#line 18
dontaudit initrc_t named_t:process noatsecure;
#line 18

#line 18
#
#line 18
# Do not audit when signal-related state is cleared upon the transition.
#line 18
#
#line 18
dontaudit initrc_t named_t:process siginh;
#line 18

#line 18
#
#line 18
# Do not audit when resource limits are reset upon the transition.
#line 18
#
#line 18
dontaudit initrc_t named_t:process rlimitinh;
#line 18

#line 18
#
#line 18
# Allow the process to execute the program.
#line 18
# 
#line 18
allow initrc_t named_checkconf_exec_t:file { read { getattr execute } };
#line 18

#line 18
#
#line 18
# Allow the process to reap the new domain.
#line 18
#
#line 18
allow named_t initrc_t:process sigchld;
#line 18

#line 18
#
#line 18
# Allow the new domain to inherit and use file 
#line 18
# descriptions from the creating process and vice versa.
#line 18
#
#line 18
allow named_t initrc_t:fd use;
#line 18
allow initrc_t named_t:fd use;
#line 18

#line 18
#
#line 18
# Allow the new domain to write back to the old domain via a pipe.
#line 18
#
#line 18
allow named_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 18

#line 18
#
#line 18
# Allow the new domain to read and execute the program.
#line 18
#
#line 18
allow named_t named_checkconf_exec_t:file { read getattr lock execute ioctl };
#line 18

#line 18
#
#line 18
# Allow the new domain to be entered via the program.
#line 18
#
#line 18
allow named_t named_checkconf_exec_t:file entrypoint;
#line 18

#line 18
type_transition initrc_t named_checkconf_exec_t:process named_t;
#line 18


# For /var/run/ndc used in BIND 8

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the process to modify the directory.
#line 21
#
#line 21
allow named_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 21

#line 21
#
#line 21
# Allow the process to create the file.
#line 21
#
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
allow named_t named_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
type_transition named_t var_run_t:sock_file named_var_run_t;
#line 21

#line 21


# ndc_t is the domain for the ndc program
type ndc_t, domain, privlog, nscd_client_domain;
role sysadm_r types ndc_t;
role system_r types ndc_t;

#line 31

#line 31
dontaudit ndc_t root_t:file { getattr read };
#line 31
dontaudit ndc_t unlabeled_t:file { getattr read };	
#line 31



#line 33
allow named_t named_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 33

allow named_t sbin_t:dir search;

allow named_t self:process { setsched setcap setrlimit };

# A type for configuration files of named.
type named_conf_t, file_type, sysadmfile, mount_point;

# for primary zone files
type named_zone_t, file_type, sysadmfile;

# for secondary zone files
type named_cache_t, file_type, sysadmfile;

# for DNSSEC key files
type dnssec_t, file_type, sysadmfile, secure_file_type;
allow { ndc_t named_t } dnssec_t:file { getattr read };

# Use capabilities. Surplus capabilities may be allowed.
allow named_t self:capability { chown dac_override fowner setgid setuid net_bind_service sys_chroot sys_nice sys_resource };

allow named_t etc_t:file { getattr read };
allow named_t etc_runtime_t:{ file lnk_file } { getattr read };

#Named can use network

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58
#
#line 58
# Allow the domain to create and use tcp sockets.
#line 58
# Other kinds of sockets must be separately authorized for use.
#line 58
allow named_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 58

#line 58
allow named_t unlabeled_t:association { sendto recvfrom };
#line 58

#line 58
#
#line 58
# Allow the domain to send or receive using any network interface.
#line 58
# netif_type is a type attribute for all network interface types.
#line 58
#
#line 58
allow named_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 58
#
#line 58
# Allow the domain to send to or receive from any node.
#line 58
# node_type is a type attribute for all node types.
#line 58
#
#line 58
allow named_t node_type:node { tcp_send rawip_send };
#line 58
allow named_t node_type:node { tcp_recv rawip_recv };
#line 58

#line 58
#
#line 58
# Allow the domain to send to or receive from any port.
#line 58
# port_type is a type attribute for all port types.
#line 58
#
#line 58

#line 58
allow named_t port_type:tcp_socket { send_msg recv_msg };
#line 58

#line 58

#line 58
# XXX Allow binding to any node type.  Remove once
#line 58
# individual rules have been added to all domains that 
#line 58
# bind sockets. 
#line 58
allow named_t node_type:tcp_socket node_bind;
#line 58
#
#line 58
# Allow access to network files including /etc/resolv.conf
#line 58
#
#line 58
allow named_t net_conf_t:file { read getattr lock ioctl };
#line 58

#line 58
allow named_t self:tcp_socket { listen accept };
#line 58

#line 58

#line 58

#line 58
#
#line 58
# Allow the domain to create and use tcp sockets.
#line 58
# Other kinds of sockets must be separately authorized for use.
#line 58
allow named_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 58

#line 58
allow named_t unlabeled_t:association { sendto recvfrom };
#line 58

#line 58
#
#line 58
# Allow the domain to send or receive using any network interface.
#line 58
# netif_type is a type attribute for all network interface types.
#line 58
#
#line 58
allow named_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 58
#
#line 58
# Allow the domain to send to or receive from any node.
#line 58
# node_type is a type attribute for all node types.
#line 58
#
#line 58
allow named_t node_type:node { tcp_send rawip_send };
#line 58
allow named_t node_type:node { tcp_recv rawip_recv };
#line 58

#line 58
#
#line 58
# Allow the domain to send to or receive from any port.
#line 58
# port_type is a type attribute for all port types.
#line 58
#
#line 58

#line 58
allow named_t port_type:tcp_socket { send_msg recv_msg };
#line 58

#line 58

#line 58
# XXX Allow binding to any node type.  Remove once
#line 58
# individual rules have been added to all domains that 
#line 58
# bind sockets. 
#line 58
allow named_t node_type:tcp_socket node_bind;
#line 58
#
#line 58
# Allow access to network files including /etc/resolv.conf
#line 58
#
#line 58
allow named_t net_conf_t:file { read getattr lock ioctl };
#line 58

#line 58
allow named_t self:tcp_socket { connect };
#line 58

#line 58

#line 58

#line 58

#line 58

#line 58
#
#line 58
# Allow the domain to create and use udp sockets.
#line 58
# Other kinds of sockets must be separately authorized for use.
#line 58
allow named_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 58

#line 58
allow named_t unlabeled_t:association { sendto recvfrom };
#line 58

#line 58
#
#line 58
# Allow the domain to send or receive using any network interface.
#line 58
# netif_type is a type attribute for all network interface types.
#line 58
#
#line 58
allow named_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 58
#
#line 58
# Allow the domain to send to or receive from any node.
#line 58
# node_type is a type attribute for all node types.
#line 58
#
#line 58
allow named_t node_type:node { udp_send rawip_send };
#line 58
allow named_t node_type:node { udp_recv rawip_recv };
#line 58

#line 58
#
#line 58
# Allow the domain to send to or receive from any port.
#line 58
# port_type is a type attribute for all port types.
#line 58
#
#line 58

#line 58
allow named_t port_type:udp_socket { send_msg recv_msg };
#line 58

#line 58

#line 58
# XXX Allow binding to any node type.  Remove once
#line 58
# individual rules have been added to all domains that 
#line 58
# bind sockets. 
#line 58
allow named_t node_type:udp_socket node_bind;
#line 58
#
#line 58
# Allow access to network files including /etc/resolv.conf
#line 58
#
#line 58
allow named_t net_conf_t:file { read getattr lock ioctl };
#line 58

#line 58
allow named_t self:udp_socket { connect };
#line 58

#line 58

#line 58

#line 58

#line 58

allow named_t port_type:tcp_socket name_connect;

#line 60

#line 60
if (allow_ypbind) {
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use tcp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow named_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow named_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow named_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow named_t node_type:node { tcp_send rawip_send };
#line 60
allow named_t node_type:node { tcp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow named_t port_type:tcp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow named_t node_type:tcp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow named_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow named_t self:tcp_socket { listen accept };
#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use tcp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow named_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow named_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow named_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow named_t node_type:node { tcp_send rawip_send };
#line 60
allow named_t node_type:node { tcp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow named_t port_type:tcp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow named_t node_type:tcp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow named_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow named_t self:tcp_socket { connect };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
#
#line 60
# Allow the domain to create and use udp sockets.
#line 60
# Other kinds of sockets must be separately authorized for use.
#line 60
allow named_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 60

#line 60
allow named_t unlabeled_t:association { sendto recvfrom };
#line 60

#line 60
#
#line 60
# Allow the domain to send or receive using any network interface.
#line 60
# netif_type is a type attribute for all network interface types.
#line 60
#
#line 60
allow named_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 60
#
#line 60
# Allow the domain to send to or receive from any node.
#line 60
# node_type is a type attribute for all node types.
#line 60
#
#line 60
allow named_t node_type:node { udp_send rawip_send };
#line 60
allow named_t node_type:node { udp_recv rawip_recv };
#line 60

#line 60
#
#line 60
# Allow the domain to send to or receive from any port.
#line 60
# port_type is a type attribute for all port types.
#line 60
#
#line 60

#line 60
allow named_t port_type:udp_socket { send_msg recv_msg };
#line 60

#line 60

#line 60
# XXX Allow binding to any node type.  Remove once
#line 60
# individual rules have been added to all domains that 
#line 60
# bind sockets. 
#line 60
allow named_t node_type:udp_socket node_bind;
#line 60
#
#line 60
# Allow access to network files including /etc/resolv.conf
#line 60
#
#line 60
allow named_t net_conf_t:file { read getattr lock ioctl };
#line 60

#line 60
allow named_t self:udp_socket { connect };
#line 60

#line 60

#line 60

#line 60

#line 60

#line 60

#line 60
allow named_t var_yp_t:dir { read getattr lock search ioctl };
#line 60
allow named_t var_yp_t:file { read getattr lock ioctl };
#line 60
allow named_t var_yp_t:lnk_file { getattr read };
#line 60

#line 60
allow named_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 60
allow named_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 60
dontaudit named_t self:capability net_bind_service;
#line 60
dontaudit named_t reserved_port_type:tcp_socket name_connect;
#line 60
dontaudit named_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 60

#line 60
} else {
#line 60
dontaudit named_t var_yp_t:dir search;
#line 60
}
#line 60
 
# allow UDP transfer to/from any program

#line 62
#allow domain named_t:udp_socket sendto;
#line 62
#allow named_t domain:udp_socket recvfrom;
#line 62


#line 63
#allow named_t domain:udp_socket sendto;
#line 63
#allow domain named_t:udp_socket recvfrom;
#line 63


#line 64
#allow domain named_t:tcp_socket { connectto recvfrom };
#line 64
#allow named_t domain:tcp_socket { acceptfrom recvfrom };
#line 64
#allow named_t kernel_t:tcp_socket recvfrom;
#line 64
#allow domain kernel_t:tcp_socket recvfrom;
#line 64


#line 65
type named_log_t, file_type, sysadmfile, logfile;
#line 65

#line 65

#line 65

#line 65

#line 65
#
#line 65
# Allow the process to modify the directory.
#line 65
#
#line 65
allow named_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 65

#line 65
#
#line 65
# Allow the process to create the file.
#line 65
#
#line 65

#line 65

#line 65

#line 65

#line 65

#line 65
allow named_t named_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65
type_transition named_t var_log_t:file named_log_t;
#line 65

#line 65

#line 65


# Bind to the named port.
allow named_t dns_port_t:udp_socket name_bind;
allow named_t { dns_port_t rndc_port_t }:tcp_socket name_bind;

bool named_write_master_zones false;

#read configuration files

#line 74
allow named_t named_conf_t:dir { read getattr lock search ioctl };
#line 74
allow named_t named_conf_t:file { read getattr lock ioctl };
#line 74
allow named_t named_conf_t:lnk_file { getattr read };
#line 74


if (named_write_master_zones) {
#create and modify zone files

#line 78
allow named_t named_zone_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 78
allow named_t named_zone_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 78
allow named_t named_zone_t:lnk_file { create read getattr setattr link unlink rename };
#line 78

}
#read zone files

#line 81
allow named_t named_zone_t:dir { read getattr lock search ioctl };
#line 81
allow named_t named_zone_t:file { read getattr lock ioctl };
#line 81
allow named_t named_zone_t:lnk_file { getattr read };
#line 81


#write cache for secondary zones

#line 84
allow named_t named_cache_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 84
allow named_t named_cache_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 84
allow named_t named_cache_t:lnk_file { create read getattr setattr link unlink rename };
#line 84


allow named_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow named_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow named_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };

# Read sysctl kernel variables.

#line 91
# Read system variables in /sys.
#line 91

#line 91
allow named_t sysctl_t:dir search;
#line 91
allow named_t sysctl_kernel_t:dir search;
#line 91
allow named_t sysctl_kernel_t:file { getattr read };
#line 91

#line 91

#line 91


# Read /proc/cpuinfo and /proc/net

#line 94
allow named_t proc_t:dir { read getattr lock search ioctl };
#line 94
allow named_t proc_t:file { read getattr lock ioctl };
#line 94
allow named_t proc_t:lnk_file { getattr read };
#line 94


#line 95
allow named_t proc_net_t:dir { read getattr lock search ioctl };
#line 95
allow named_t proc_net_t:file { read getattr lock ioctl };
#line 95
allow named_t proc_net_t:lnk_file { getattr read };
#line 95


# Read /dev/random.
allow named_t device_t:dir { read getattr lock search ioctl };
allow named_t random_device_t:chr_file { read getattr lock ioctl };

# Use a pipe created by self.
allow named_t self:fifo_file { ioctl read getattr lock write append };

# Enable named dbus support:
#line 116

#line 116

#line 116

#line 116

#line 116
# Derived type used for connection
#line 116
type named_dbusd_system_t;
#line 116
type_change named_t system_dbusd_t:dbus named_dbusd_system_t;
#line 116

#line 116
# SE-DBus specific permissions
#line 116
allow named_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 116

#line 116
# For connecting to the bus
#line 116
allow named_t system_dbusd_t:unix_stream_socket connectto;
#line 116

#line 116

#line 116
allow { named_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 116
allow { named_t } system_dbusd_var_run_t:sock_file write;
#line 116
  
#line 116

#line 116

#line 116

#line 116
#
#line 116
# Allow the process to transition to the new domain.
#line 116
#
#line 116
allow system_dbusd_t named_t:process transition;
#line 116

#line 116
#
#line 116
# Do not audit when glibc secure mode is enabled upon the transition.
#line 116
#
#line 116
dontaudit system_dbusd_t named_t:process noatsecure;
#line 116

#line 116
#
#line 116
# Do not audit when signal-related state is cleared upon the transition.
#line 116
#
#line 116
dontaudit system_dbusd_t named_t:process siginh;
#line 116

#line 116
#
#line 116
# Do not audit when resource limits are reset upon the transition.
#line 116
#
#line 116
dontaudit system_dbusd_t named_t:process rlimitinh;
#line 116

#line 116
#
#line 116
# Allow the process to execute the program.
#line 116
# 
#line 116
allow system_dbusd_t named_exec_t:file { read { getattr execute } };
#line 116

#line 116
#
#line 116
# Allow the process to reap the new domain.
#line 116
#
#line 116
allow named_t system_dbusd_t:process sigchld;
#line 116

#line 116
#
#line 116
# Allow the new domain to inherit and use file 
#line 116
# descriptions from the creating process and vice versa.
#line 116
#
#line 116
allow named_t system_dbusd_t:fd use;
#line 116
allow system_dbusd_t named_t:fd use;
#line 116

#line 116
#
#line 116
# Allow the new domain to write back to the old domain via a pipe.
#line 116
#
#line 116
allow named_t system_dbusd_t:fifo_file { ioctl read getattr lock write append };
#line 116

#line 116
#
#line 116
# Allow the new domain to read and execute the program.
#line 116
#
#line 116
allow named_t named_exec_t:file { read getattr lock execute ioctl };
#line 116

#line 116
#
#line 116
# Allow the new domain to be entered via the program.
#line 116
#
#line 116
allow named_t named_exec_t:file entrypoint;
#line 116

#line 116
type_transition system_dbusd_t named_exec_t:process named_t;
#line 116

#line 116
allow named_t system_dbusd_t:dbus { acquire_svc send_msg };
#line 116
allow named_t self:dbus send_msg;
#line 116
allow { NetworkManager_t dhcpc_t initrc_t } named_t:dbus send_msg;
#line 116
allow named_t { NetworkManager_t dhcpc_t initrc_t }:dbus send_msg;
#line 116

#line 116



# Set own capabilities.
#A type for /usr/sbin/ndc
type ndc_exec_t, file_type,sysadmfile, exec_type;

#line 122

#line 122

#line 122
#
#line 122
# Allow the process to transition to the new domain.
#line 122
#
#line 122
allow { sysadm_t initrc_t } ndc_t:process transition;
#line 122

#line 122
#
#line 122
# Do not audit when glibc secure mode is enabled upon the transition.
#line 122
#
#line 122
dontaudit { sysadm_t initrc_t } ndc_t:process noatsecure;
#line 122

#line 122
#
#line 122
# Do not audit when signal-related state is cleared upon the transition.
#line 122
#
#line 122
dontaudit { sysadm_t initrc_t } ndc_t:process siginh;
#line 122

#line 122
#
#line 122
# Do not audit when resource limits are reset upon the transition.
#line 122
#
#line 122
dontaudit { sysadm_t initrc_t } ndc_t:process rlimitinh;
#line 122

#line 122
#
#line 122
# Allow the process to execute the program.
#line 122
# 
#line 122
allow { sysadm_t initrc_t } ndc_exec_t:file { read { getattr execute } };
#line 122

#line 122
#
#line 122
# Allow the process to reap the new domain.
#line 122
#
#line 122
allow ndc_t { sysadm_t initrc_t }:process sigchld;
#line 122

#line 122
#
#line 122
# Allow the new domain to inherit and use file 
#line 122
# descriptions from the creating process and vice versa.
#line 122
#
#line 122
allow ndc_t { sysadm_t initrc_t }:fd use;
#line 122
allow { sysadm_t initrc_t } ndc_t:fd use;
#line 122

#line 122
#
#line 122
# Allow the new domain to write back to the old domain via a pipe.
#line 122
#
#line 122
allow ndc_t { sysadm_t initrc_t }:fifo_file { ioctl read getattr lock write append };
#line 122

#line 122
#
#line 122
# Allow the new domain to read and execute the program.
#line 122
#
#line 122
allow ndc_t ndc_exec_t:file { read getattr lock execute ioctl };
#line 122

#line 122
#
#line 122
# Allow the new domain to be entered via the program.
#line 122
#
#line 122
allow ndc_t ndc_exec_t:file entrypoint;
#line 122

#line 122
type_transition { sysadm_t initrc_t } ndc_exec_t:process ndc_t;
#line 122


#line 123
allow ndc_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 123
allow ndc_t lib_t:lnk_file { read getattr lock ioctl };
#line 123
allow ndc_t ld_so_t:file { read getattr lock execute ioctl };
#line 123
#allow ndc_t ld_so_t:file execute_no_trans;
#line 123
allow ndc_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 123
allow ndc_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 123
allow ndc_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 123
allow ndc_t texrel_shlib_t:file execmod;
#line 123
allow ndc_t ld_so_cache_t:file { read getattr lock ioctl };
#line 123
allow ndc_t device_t:dir search;
#line 123
allow ndc_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 123


#line 124

#line 124
#
#line 124
# Allow the domain to create and use tcp sockets.
#line 124
# Other kinds of sockets must be separately authorized for use.
#line 124
allow ndc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 124

#line 124
allow ndc_t unlabeled_t:association { sendto recvfrom };
#line 124

#line 124
#
#line 124
# Allow the domain to send or receive using any network interface.
#line 124
# netif_type is a type attribute for all network interface types.
#line 124
#
#line 124
allow ndc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 124
#
#line 124
# Allow the domain to send to or receive from any node.
#line 124
# node_type is a type attribute for all node types.
#line 124
#
#line 124
allow ndc_t node_type:node { tcp_send rawip_send };
#line 124
allow ndc_t node_type:node { tcp_recv rawip_recv };
#line 124

#line 124
#
#line 124
# Allow the domain to send to or receive from any port.
#line 124
# port_type is a type attribute for all port types.
#line 124
#
#line 124

#line 124
allow ndc_t port_type:tcp_socket { send_msg recv_msg };
#line 124

#line 124

#line 124
# XXX Allow binding to any node type.  Remove once
#line 124
# individual rules have been added to all domains that 
#line 124
# bind sockets. 
#line 124
allow ndc_t node_type:tcp_socket node_bind;
#line 124
#
#line 124
# Allow access to network files including /etc/resolv.conf
#line 124
#
#line 124
allow ndc_t net_conf_t:file { read getattr lock ioctl };
#line 124

#line 124
allow ndc_t self:tcp_socket { connect };
#line 124

allow ndc_t rndc_port_t:tcp_socket name_connect;

#line 126

#line 126
if (allow_ypbind) {
#line 126

#line 126

#line 126

#line 126

#line 126

#line 126

#line 126

#line 126
#
#line 126
# Allow the domain to create and use tcp sockets.
#line 126
# Other kinds of sockets must be separately authorized for use.
#line 126
allow ndc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 126

#line 126
allow ndc_t unlabeled_t:association { sendto recvfrom };
#line 126

#line 126
#
#line 126
# Allow the domain to send or receive using any network interface.
#line 126
# netif_type is a type attribute for all network interface types.
#line 126
#
#line 126
allow ndc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 126
#
#line 126
# Allow the domain to send to or receive from any node.
#line 126
# node_type is a type attribute for all node types.
#line 126
#
#line 126
allow ndc_t node_type:node { tcp_send rawip_send };
#line 126
allow ndc_t node_type:node { tcp_recv rawip_recv };
#line 126

#line 126
#
#line 126
# Allow the domain to send to or receive from any port.
#line 126
# port_type is a type attribute for all port types.
#line 126
#
#line 126

#line 126
allow ndc_t port_type:tcp_socket { send_msg recv_msg };
#line 126

#line 126

#line 126
# XXX Allow binding to any node type.  Remove once
#line 126
# individual rules have been added to all domains that 
#line 126
# bind sockets. 
#line 126
allow ndc_t node_type:tcp_socket node_bind;
#line 126
#
#line 126
# Allow access to network files including /etc/resolv.conf
#line 126
#
#line 126
allow ndc_t net_conf_t:file { read getattr lock ioctl };
#line 126

#line 126
allow ndc_t self:tcp_socket { listen accept };
#line 126

#line 126

#line 126

#line 126
#
#line 126
# Allow the domain to create and use tcp sockets.
#line 126
# Other kinds of sockets must be separately authorized for use.
#line 126
allow ndc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 126

#line 126
allow ndc_t unlabeled_t:association { sendto recvfrom };
#line 126

#line 126
#
#line 126
# Allow the domain to send or receive using any network interface.
#line 126
# netif_type is a type attribute for all network interface types.
#line 126
#
#line 126
allow ndc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 126
#
#line 126
# Allow the domain to send to or receive from any node.
#line 126
# node_type is a type attribute for all node types.
#line 126
#
#line 126
allow ndc_t node_type:node { tcp_send rawip_send };
#line 126
allow ndc_t node_type:node { tcp_recv rawip_recv };
#line 126

#line 126
#
#line 126
# Allow the domain to send to or receive from any port.
#line 126
# port_type is a type attribute for all port types.
#line 126
#
#line 126

#line 126
allow ndc_t port_type:tcp_socket { send_msg recv_msg };
#line 126

#line 126

#line 126
# XXX Allow binding to any node type.  Remove once
#line 126
# individual rules have been added to all domains that 
#line 126
# bind sockets. 
#line 126
allow ndc_t node_type:tcp_socket node_bind;
#line 126
#
#line 126
# Allow access to network files including /etc/resolv.conf
#line 126
#
#line 126
allow ndc_t net_conf_t:file { read getattr lock ioctl };
#line 126

#line 126
allow ndc_t self:tcp_socket { connect };
#line 126

#line 126

#line 126

#line 126

#line 126

#line 126
#
#line 126
# Allow the domain to create and use udp sockets.
#line 126
# Other kinds of sockets must be separately authorized for use.
#line 126
allow ndc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 126

#line 126
allow ndc_t unlabeled_t:association { sendto recvfrom };
#line 126

#line 126
#
#line 126
# Allow the domain to send or receive using any network interface.
#line 126
# netif_type is a type attribute for all network interface types.
#line 126
#
#line 126
allow ndc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 126
#
#line 126
# Allow the domain to send to or receive from any node.
#line 126
# node_type is a type attribute for all node types.
#line 126
#
#line 126
allow ndc_t node_type:node { udp_send rawip_send };
#line 126
allow ndc_t node_type:node { udp_recv rawip_recv };
#line 126

#line 126
#
#line 126
# Allow the domain to send to or receive from any port.
#line 126
# port_type is a type attribute for all port types.
#line 126
#
#line 126

#line 126
allow ndc_t port_type:udp_socket { send_msg recv_msg };
#line 126

#line 126

#line 126
# XXX Allow binding to any node type.  Remove once
#line 126
# individual rules have been added to all domains that 
#line 126
# bind sockets. 
#line 126
allow ndc_t node_type:udp_socket node_bind;
#line 126
#
#line 126
# Allow access to network files including /etc/resolv.conf
#line 126
#
#line 126
allow ndc_t net_conf_t:file { read getattr lock ioctl };
#line 126

#line 126
allow ndc_t self:udp_socket { connect };
#line 126

#line 126

#line 126

#line 126

#line 126

#line 126

#line 126
allow ndc_t var_yp_t:dir { read getattr lock search ioctl };
#line 126
allow ndc_t var_yp_t:file { read getattr lock ioctl };
#line 126
allow ndc_t var_yp_t:lnk_file { getattr read };
#line 126

#line 126
allow ndc_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 126
allow ndc_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 126
dontaudit ndc_t self:capability net_bind_service;
#line 126
dontaudit ndc_t reserved_port_type:tcp_socket name_connect;
#line 126
dontaudit ndc_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 126

#line 126
} else {
#line 126
dontaudit ndc_t var_yp_t:dir search;
#line 126
}
#line 126
 

#line 127

#line 127

#line 127

#line 127

#line 127
#
#line 127
# Allow the domain to create and use tcp sockets.
#line 127
# Other kinds of sockets must be separately authorized for use.
#line 127
allow ndc_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 127

#line 127
allow ndc_t unlabeled_t:association { sendto recvfrom };
#line 127

#line 127
#
#line 127
# Allow the domain to send or receive using any network interface.
#line 127
# netif_type is a type attribute for all network interface types.
#line 127
#
#line 127
allow ndc_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 127
#
#line 127
# Allow the domain to send to or receive from any node.
#line 127
# node_type is a type attribute for all node types.
#line 127
#
#line 127
allow ndc_t node_type:node { tcp_send rawip_send };
#line 127
allow ndc_t node_type:node { tcp_recv rawip_recv };
#line 127

#line 127
#
#line 127
# Allow the domain to send to or receive from any port.
#line 127
# port_type is a type attribute for all port types.
#line 127
#
#line 127

#line 127
allow ndc_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 127

#line 127

#line 127
# XXX Allow binding to any node type.  Remove once
#line 127
# individual rules have been added to all domains that 
#line 127
# bind sockets. 
#line 127
allow ndc_t node_type:tcp_socket node_bind;
#line 127
#
#line 127
# Allow access to network files including /etc/resolv.conf
#line 127
#
#line 127
allow ndc_t net_conf_t:file { read getattr lock ioctl };
#line 127

#line 127
allow ndc_t self:tcp_socket { connect };
#line 127

#line 127

#line 127

#line 127
#
#line 127
# Allow the domain to create and use udp sockets.
#line 127
# Other kinds of sockets must be separately authorized for use.
#line 127
allow ndc_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 127

#line 127
allow ndc_t unlabeled_t:association { sendto recvfrom };
#line 127

#line 127
#
#line 127
# Allow the domain to send or receive using any network interface.
#line 127
# netif_type is a type attribute for all network interface types.
#line 127
#
#line 127
allow ndc_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 127
#
#line 127
# Allow the domain to send to or receive from any node.
#line 127
# node_type is a type attribute for all node types.
#line 127
#
#line 127
allow ndc_t node_type:node { udp_send rawip_send };
#line 127
allow ndc_t node_type:node { udp_recv rawip_recv };
#line 127

#line 127
#
#line 127
# Allow the domain to send to or receive from any port.
#line 127
# port_type is a type attribute for all port types.
#line 127
#
#line 127

#line 127
allow ndc_t dns_port_t:udp_socket { send_msg recv_msg };
#line 127

#line 127

#line 127
# XXX Allow binding to any node type.  Remove once
#line 127
# individual rules have been added to all domains that 
#line 127
# bind sockets. 
#line 127
allow ndc_t node_type:udp_socket node_bind;
#line 127
#
#line 127
# Allow access to network files including /etc/resolv.conf
#line 127
#
#line 127
allow ndc_t net_conf_t:file { read getattr lock ioctl };
#line 127

#line 127
allow ndc_t self:udp_socket { connect };
#line 127

#line 127

#line 127

#line 127
allow ndc_t dns_port_t:tcp_socket name_connect;
#line 127


#line 128
allow ndc_t etc_t:lnk_file read;
#line 128
allow ndc_t lib_t:file { read getattr lock ioctl };
#line 128

#line 128
allow ndc_t locale_t:dir { read getattr lock search ioctl };
#line 128
allow ndc_t locale_t:file { read getattr lock ioctl };
#line 128
allow ndc_t locale_t:lnk_file { getattr read };
#line 128

#line 128


#line 129
#allow ndc_t named_t:tcp_socket { connectto recvfrom };
#line 129
#allow named_t ndc_t:tcp_socket { acceptfrom recvfrom };
#line 129
#allow named_t kernel_t:tcp_socket recvfrom;
#line 129
#allow ndc_t kernel_t:tcp_socket recvfrom;
#line 129


#line 142

#line 142
# for /etc/rndc.key
#line 142
allow { ndc_t initrc_t } named_conf_t:dir search;
#line 142
# Allow init script to cp localtime to named_conf_t
#line 142
allow initrc_t named_conf_t:file { setattr write };
#line 142
allow initrc_t named_conf_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 142
allow initrc_t var_run_t:lnk_file { create ioctl read getattr lock write setattr append link unlink rename };

allow { ndc_t initrc_t } named_conf_t:file { getattr read };

allow ndc_t etc_t:dir { read getattr lock search ioctl };
allow ndc_t etc_t:file { read getattr lock ioctl };
allow ndc_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow ndc_t self:unix_stream_socket connect;
allow ndc_t self:capability { dac_override net_admin };
allow ndc_t var_t:dir search;
allow ndc_t var_run_t:dir search;
allow ndc_t named_var_run_t:sock_file { ioctl read getattr lock write append };
allow ndc_t named_t:unix_stream_socket connectto;
allow ndc_t { privfd init_t }:fd use;
# seems to need read as well for some reason
allow ndc_t { admin_tty_type initrc_devpts_t }:chr_file { getattr read write };
allow ndc_t fs_t:filesystem getattr;

# Read sysctl kernel variables.

#line 161
# Read system variables in /sys.
#line 161

#line 161
allow ndc_t sysctl_t:dir search;
#line 161
allow ndc_t sysctl_kernel_t:dir search;
#line 161
allow ndc_t sysctl_kernel_t:file { getattr read };
#line 161

#line 161

#line 161


allow ndc_t self:process { fork { sigchld sigkill sigstop signull signal } };
allow ndc_t self:fifo_file { read write getattr ioctl };
allow ndc_t named_zone_t:dir search;

# for chmod in start script
dontaudit initrc_t named_var_run_t:dir setattr;

# for ndc_t to be used for restart shell scripts
#line 182

allow ndc_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
dontaudit ndc_t sysadm_tty_device_t:chr_file { ioctl };
#line 1 "domains/program/netutils.te"
#DESC Netutils - Network utilities
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil>
# X-Debian-Packages: netbase iputils arping tcpdump 
#

#
# Rules for the netutils_t domain.
# This domain is for network utilities that require access to
# special protocol families.
#
type netutils_t, domain, privlog;
type netutils_exec_t, file_type, sysadmfile, exec_type;
role system_r types netutils_t;
role sysadm_r types netutils_t;


#line 17
allow netutils_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 17
allow netutils_t lib_t:lnk_file { read getattr lock ioctl };
#line 17
allow netutils_t ld_so_t:file { read getattr lock execute ioctl };
#line 17
#allow netutils_t ld_so_t:file execute_no_trans;
#line 17
allow netutils_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 17
allow netutils_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 17
allow netutils_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 17
allow netutils_t texrel_shlib_t:file execmod;
#line 17
allow netutils_t ld_so_cache_t:file { read getattr lock ioctl };
#line 17
allow netutils_t device_t:dir search;
#line 17
allow netutils_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 17


#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow netutils_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow netutils_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow netutils_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow netutils_t node_type:node { tcp_send rawip_send };
#line 18
allow netutils_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow netutils_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow netutils_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow netutils_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow netutils_t self:tcp_socket { listen accept };
#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow netutils_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow netutils_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow netutils_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow netutils_t node_type:node { tcp_send rawip_send };
#line 18
allow netutils_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow netutils_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow netutils_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow netutils_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow netutils_t self:tcp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use udp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow netutils_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow netutils_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow netutils_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow netutils_t node_type:node { udp_send rawip_send };
#line 18
allow netutils_t node_type:node { udp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow netutils_t port_type:udp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow netutils_t node_type:udp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow netutils_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow netutils_t self:udp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

allow netutils_t port_type:tcp_socket name_connect;

#line 20

#line 20
if (allow_ypbind) {
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use tcp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow netutils_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow netutils_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow netutils_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow netutils_t node_type:node { tcp_send rawip_send };
#line 20
allow netutils_t node_type:node { tcp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow netutils_t port_type:tcp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow netutils_t node_type:tcp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow netutils_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow netutils_t self:tcp_socket { listen accept };
#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use tcp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow netutils_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow netutils_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow netutils_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow netutils_t node_type:node { tcp_send rawip_send };
#line 20
allow netutils_t node_type:node { tcp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow netutils_t port_type:tcp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow netutils_t node_type:tcp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow netutils_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow netutils_t self:tcp_socket { connect };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use udp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow netutils_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow netutils_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow netutils_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow netutils_t node_type:node { udp_send rawip_send };
#line 20
allow netutils_t node_type:node { udp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow netutils_t port_type:udp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow netutils_t node_type:udp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow netutils_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow netutils_t self:udp_socket { connect };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
allow netutils_t var_yp_t:dir { read getattr lock search ioctl };
#line 20
allow netutils_t var_yp_t:file { read getattr lock ioctl };
#line 20
allow netutils_t var_yp_t:lnk_file { getattr read };
#line 20

#line 20
allow netutils_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 20
allow netutils_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 20
dontaudit netutils_t self:capability net_bind_service;
#line 20
dontaudit netutils_t reserved_port_type:tcp_socket name_connect;
#line 20
dontaudit netutils_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 20

#line 20
} else {
#line 20
dontaudit netutils_t var_yp_t:dir search;
#line 20
}
#line 20
 

#line 21
type netutils_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the process to modify the directory.
#line 21
#
#line 21
allow netutils_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 21

#line 21
#
#line 21
# Allow the process to create the file.
#line 21
#
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
allow netutils_t netutils_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
allow netutils_t netutils_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
type_transition netutils_t tmp_t:{ file dir } netutils_tmp_t;
#line 21

#line 21

#line 21



#line 23

#line 23

#line 23
#
#line 23
# Allow the process to transition to the new domain.
#line 23
#
#line 23
allow initrc_t netutils_t:process transition;
#line 23

#line 23
#
#line 23
# Do not audit when glibc secure mode is enabled upon the transition.
#line 23
#
#line 23
dontaudit initrc_t netutils_t:process noatsecure;
#line 23

#line 23
#
#line 23
# Do not audit when signal-related state is cleared upon the transition.
#line 23
#
#line 23
dontaudit initrc_t netutils_t:process siginh;
#line 23

#line 23
#
#line 23
# Do not audit when resource limits are reset upon the transition.
#line 23
#
#line 23
dontaudit initrc_t netutils_t:process rlimitinh;
#line 23

#line 23
#
#line 23
# Allow the process to execute the program.
#line 23
# 
#line 23
allow initrc_t netutils_exec_t:file { read { getattr execute } };
#line 23

#line 23
#
#line 23
# Allow the process to reap the new domain.
#line 23
#
#line 23
allow netutils_t initrc_t:process sigchld;
#line 23

#line 23
#
#line 23
# Allow the new domain to inherit and use file 
#line 23
# descriptions from the creating process and vice versa.
#line 23
#
#line 23
allow netutils_t initrc_t:fd use;
#line 23
allow initrc_t netutils_t:fd use;
#line 23

#line 23
#
#line 23
# Allow the new domain to write back to the old domain via a pipe.
#line 23
#
#line 23
allow netutils_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 23

#line 23
#
#line 23
# Allow the new domain to read and execute the program.
#line 23
#
#line 23
allow netutils_t netutils_exec_t:file { read getattr lock execute ioctl };
#line 23

#line 23
#
#line 23
# Allow the new domain to be entered via the program.
#line 23
#
#line 23
allow netutils_t netutils_exec_t:file entrypoint;
#line 23

#line 23
type_transition initrc_t netutils_exec_t:process netutils_t;
#line 23

#line 26


# Inherit and use descriptors from init.
allow netutils_t { userdomain init_t }:fd use;

allow netutils_t self:process { fork { sigchld sigkill sigstop signull signal } };

# Perform network administration operations and have raw access to the network.
allow netutils_t self:capability { net_admin net_raw setuid setgid };

# Create and use netlink sockets.
allow netutils_t self:netlink_route_socket { bind create getattr nlmsg_read nlmsg_write read write };

# Create and use packet sockets.
allow netutils_t self:packet_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# Create and use UDP sockets.
allow netutils_t self:udp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# Create and use TCP sockets.
allow netutils_t self:tcp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

allow netutils_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# Read certain files in /etc
allow netutils_t etc_t:file { read getattr lock ioctl };

#line 52
allow netutils_t etc_t:lnk_file read;
#line 52
allow netutils_t lib_t:file { read getattr lock ioctl };
#line 52

#line 52
allow netutils_t locale_t:dir { read getattr lock search ioctl };
#line 52
allow netutils_t locale_t:file { read getattr lock ioctl };
#line 52
allow netutils_t locale_t:lnk_file { getattr read };
#line 52

#line 52


allow netutils_t fs_t:filesystem getattr;

# Access terminals.
allow netutils_t privfd:fd use;

#line 58
allow netutils_t devpts_t:dir { read getattr lock search ioctl };
#line 58
allow netutils_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 58

allow netutils_t admin_tty_type:chr_file { ioctl read getattr lock write append };

allow netutils_t proc_t:dir search;

# for nscd
dontaudit netutils_t var_t:dir search;
#line 1 "domains/program/NetworkManager.te"
#DESC NetworkManager - 
#
# Authors: Dan Walsh <dwalsh@redhat.com>
#
#

#################################
#
# Rules for the NetworkManager_t domain.
#
# NetworkManager_t is the domain for the NetworkManager daemon. 
# NetworkManager_exec_t is the type of the NetworkManager executable.
#

#line 14

#line 14

#line 14

#line 14
type NetworkManager_t, domain, privlog, daemon , nscd_client_domain, privsysmod, mlsfileread , transitionbool;
#line 14
type NetworkManager_exec_t, file_type, sysadmfile, exec_type;
#line 14
dontaudit NetworkManager_t self:capability sys_tty_config;
#line 14

#line 14
role system_r types NetworkManager_t;
#line 14

#line 14
# Inherit and use descriptors from init.
#line 14
allow NetworkManager_t init_t:fd use;
#line 14
allow NetworkManager_t init_t:process sigchld;
#line 14
allow NetworkManager_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 14

#line 14

#line 14
allow NetworkManager_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow NetworkManager_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow NetworkManager_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow NetworkManager_t ld_so_t:file execute_no_trans;
#line 14
allow NetworkManager_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow NetworkManager_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow NetworkManager_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow NetworkManager_t texrel_shlib_t:file execmod;
#line 14
allow NetworkManager_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow NetworkManager_t device_t:dir search;
#line 14
allow NetworkManager_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
allow NetworkManager_t { self proc_t }:dir { read getattr lock search ioctl };
#line 14
allow NetworkManager_t { self proc_t }:lnk_file { getattr read };
#line 14

#line 14
allow NetworkManager_t device_t:dir { read getattr lock search ioctl };
#line 14

#line 14
allow NetworkManager_t udev_tdb_t:file { read getattr lock ioctl };
#line 14
allow NetworkManager_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit NetworkManager_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit NetworkManager_t unpriv_userdomain:fd use;
#line 14

#line 14

#line 14
allow NetworkManager_t sysfs_t:dir { read getattr lock search ioctl };
#line 14
allow NetworkManager_t sysfs_t:file { read getattr lock ioctl };
#line 14
allow NetworkManager_t sysfs_t:lnk_file { getattr read };
#line 14
 
#line 14

#line 14
allow NetworkManager_t autofs_t:dir { search getattr };
#line 14

#line 14
dontaudit NetworkManager_t { tty_device_t devpts_t }:chr_file { read write };
#line 14
dontaudit NetworkManager_t root_t:file { getattr read };
#line 14
 
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow NetworkManager_t sysctl_t:dir search;
#line 14
allow NetworkManager_t sysctl_kernel_t:dir search;
#line 14
allow NetworkManager_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14

#line 14
bool NetworkManager_disable_trans false;
#line 14
if (NetworkManager_disable_trans) {
#line 14

#line 14
allow initrc_t NetworkManager_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t NetworkManager_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14
 
#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow initrc_t NetworkManager_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit initrc_t NetworkManager_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit initrc_t NetworkManager_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit initrc_t NetworkManager_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow initrc_t NetworkManager_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow NetworkManager_t initrc_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow NetworkManager_t initrc_t:fd use;
#line 14
allow initrc_t NetworkManager_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow NetworkManager_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow NetworkManager_t NetworkManager_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow NetworkManager_t NetworkManager_exec_t:file entrypoint;
#line 14

#line 14
type_transition initrc_t NetworkManager_exec_t:process NetworkManager_t;
#line 14

#line 14

#line 14
allow initrc_t NetworkManager_t:process { noatsecure siginh rlimitinh };
#line 14

#line 14
}
#line 14
 
#line 14
allow NetworkManager_t privfd:fd use;
#line 14

#line 14
allow NetworkManager_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
# Create pid file.
#line 14
allow NetworkManager_t var_t:dir { getattr search };
#line 14

#line 14
type NetworkManager_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow NetworkManager_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow NetworkManager_t NetworkManager_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition NetworkManager_t var_run_t:file NetworkManager_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow NetworkManager_t var_t:dir search;
#line 14
allow NetworkManager_t NetworkManager_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
allow NetworkManager_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
# for daemons that look at /root on startup
#line 14
dontaudit NetworkManager_t sysadm_home_dir_t:dir search;
#line 14

#line 14
# for df
#line 14
allow NetworkManager_t fs_type:filesystem getattr;
#line 14
allow NetworkManager_t removable_t:filesystem getattr;
#line 14

#line 14

#line 14
allow NetworkManager_t etc_t:lnk_file read;
#line 14
allow NetworkManager_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow NetworkManager_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow NetworkManager_t locale_t:file { read getattr lock ioctl };
#line 14
allow NetworkManager_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14

#line 14
# for localization
#line 14
allow NetworkManager_t lib_t:file { getattr read };
#line 14



#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow NetworkManager_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow NetworkManager_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow NetworkManager_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow NetworkManager_t node_type:node { tcp_send rawip_send };
#line 16
allow NetworkManager_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow NetworkManager_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow NetworkManager_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow NetworkManager_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow NetworkManager_t self:tcp_socket { listen accept };
#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow NetworkManager_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow NetworkManager_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow NetworkManager_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow NetworkManager_t node_type:node { tcp_send rawip_send };
#line 16
allow NetworkManager_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow NetworkManager_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow NetworkManager_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow NetworkManager_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow NetworkManager_t self:tcp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use udp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow NetworkManager_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow NetworkManager_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow NetworkManager_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow NetworkManager_t node_type:node { udp_send rawip_send };
#line 16
allow NetworkManager_t node_type:node { udp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow NetworkManager_t port_type:udp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow NetworkManager_t node_type:udp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow NetworkManager_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow NetworkManager_t self:udp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

allow NetworkManager_t port_type:tcp_socket name_connect;
allow NetworkManager_t { isakmp_port_t dhcpc_port_t }:udp_socket name_bind;
allow NetworkManager_t dhcpc_t:process signal;


#line 21

#line 21
if (allow_ypbind) {
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use tcp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow NetworkManager_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow NetworkManager_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow NetworkManager_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow NetworkManager_t node_type:node { tcp_send rawip_send };
#line 21
allow NetworkManager_t node_type:node { tcp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow NetworkManager_t port_type:tcp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow NetworkManager_t node_type:tcp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow NetworkManager_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow NetworkManager_t self:tcp_socket { listen accept };
#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use tcp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow NetworkManager_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow NetworkManager_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow NetworkManager_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow NetworkManager_t node_type:node { tcp_send rawip_send };
#line 21
allow NetworkManager_t node_type:node { tcp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow NetworkManager_t port_type:tcp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow NetworkManager_t node_type:tcp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow NetworkManager_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow NetworkManager_t self:tcp_socket { connect };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use udp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow NetworkManager_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow NetworkManager_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow NetworkManager_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow NetworkManager_t node_type:node { udp_send rawip_send };
#line 21
allow NetworkManager_t node_type:node { udp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow NetworkManager_t port_type:udp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow NetworkManager_t node_type:udp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow NetworkManager_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow NetworkManager_t self:udp_socket { connect };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
allow NetworkManager_t var_yp_t:dir { read getattr lock search ioctl };
#line 21
allow NetworkManager_t var_yp_t:file { read getattr lock ioctl };
#line 21
allow NetworkManager_t var_yp_t:lnk_file { getattr read };
#line 21

#line 21
allow NetworkManager_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 21
allow NetworkManager_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 21
dontaudit NetworkManager_t self:capability net_bind_service;
#line 21
dontaudit NetworkManager_t reserved_port_type:tcp_socket name_connect;
#line 21
dontaudit NetworkManager_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 21

#line 21
} else {
#line 21
dontaudit NetworkManager_t var_yp_t:dir search;
#line 21
}
#line 21
 

#line 22
allow NetworkManager_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 22
allow NetworkManager_t lib_t:lnk_file { read getattr lock ioctl };
#line 22
allow NetworkManager_t ld_so_t:file { read getattr lock execute ioctl };
#line 22
#allow NetworkManager_t ld_so_t:file execute_no_trans;
#line 22
allow NetworkManager_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 22
allow NetworkManager_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 22
allow NetworkManager_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 22
allow NetworkManager_t texrel_shlib_t:file execmod;
#line 22
allow NetworkManager_t ld_so_cache_t:file { read getattr lock ioctl };
#line 22
allow NetworkManager_t device_t:dir search;
#line 22
allow NetworkManager_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 22

allow NetworkManager_t self:capability { kill setgid setuid sys_nice dac_override net_admin net_raw net_bind_service sys_module ipc_lock};

allow NetworkManager_t { random_device_t urandom_device_t }:chr_file { getattr read };

allow NetworkManager_t self:process { setcap getsched };
allow NetworkManager_t self:fifo_file { ioctl read getattr lock write append };
allow NetworkManager_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow NetworkManager_t self:file { getattr read };
allow NetworkManager_t self:packet_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow NetworkManager_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };


#
# Communicate with Caching Name Server
#
#line 46

#line 46
allow NetworkManager_t named_zone_t:dir search;
#line 46

#line 46
allow NetworkManager_t named_cache_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 46
allow NetworkManager_t named_cache_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 46
allow NetworkManager_t named_cache_t:lnk_file { create read getattr setattr link unlink rename };
#line 46

#line 46

#line 46

#line 46

#line 46
#
#line 46
# Allow the process to transition to the new domain.
#line 46
#
#line 46
allow NetworkManager_t named_t:process transition;
#line 46

#line 46
#
#line 46
# Do not audit when glibc secure mode is enabled upon the transition.
#line 46
#
#line 46
dontaudit NetworkManager_t named_t:process noatsecure;
#line 46

#line 46
#
#line 46
# Do not audit when signal-related state is cleared upon the transition.
#line 46
#
#line 46
dontaudit NetworkManager_t named_t:process siginh;
#line 46

#line 46
#
#line 46
# Do not audit when resource limits are reset upon the transition.
#line 46
#
#line 46
dontaudit NetworkManager_t named_t:process rlimitinh;
#line 46

#line 46
#
#line 46
# Allow the process to execute the program.
#line 46
# 
#line 46
allow NetworkManager_t named_exec_t:file { read { getattr execute } };
#line 46

#line 46
#
#line 46
# Allow the process to reap the new domain.
#line 46
#
#line 46
allow named_t NetworkManager_t:process sigchld;
#line 46

#line 46
#
#line 46
# Allow the new domain to inherit and use file 
#line 46
# descriptions from the creating process and vice versa.
#line 46
#
#line 46
allow named_t NetworkManager_t:fd use;
#line 46
allow NetworkManager_t named_t:fd use;
#line 46

#line 46
#
#line 46
# Allow the new domain to write back to the old domain via a pipe.
#line 46
#
#line 46
allow named_t NetworkManager_t:fifo_file { ioctl read getattr lock write append };
#line 46

#line 46
#
#line 46
# Allow the new domain to read and execute the program.
#line 46
#
#line 46
allow named_t named_exec_t:file { read getattr lock execute ioctl };
#line 46

#line 46
#
#line 46
# Allow the new domain to be entered via the program.
#line 46
#
#line 46
allow named_t named_exec_t:file entrypoint;
#line 46

#line 46
type_transition NetworkManager_t named_exec_t:process named_t;
#line 46

#line 46
allow named_t NetworkManager_t:udp_socket { read write };
#line 46
allow named_t NetworkManager_t:netlink_route_socket { read write };
#line 46
allow NetworkManager_t named_t:process signal;
#line 46
allow named_t NetworkManager_t:packet_socket { read write };
#line 46


allow NetworkManager_t selinux_config_t:dir search;
allow NetworkManager_t selinux_config_t:file { getattr read };

#line 67

#line 67

#line 67

#line 67

#line 67
# Derived type used for connection
#line 67
type NetworkManager_dbusd_system_t;
#line 67
type_change NetworkManager_t system_dbusd_t:dbus NetworkManager_dbusd_system_t;
#line 67

#line 67
# SE-DBus specific permissions
#line 67
allow NetworkManager_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 67

#line 67
# For connecting to the bus
#line 67
allow NetworkManager_t system_dbusd_t:unix_stream_socket connectto;
#line 67

#line 67

#line 67
allow { NetworkManager_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 67
allow { NetworkManager_t } system_dbusd_var_run_t:sock_file write;
#line 67
  
#line 67
allow NetworkManager_t system_dbusd_t:dbus { acquire_svc send_msg };
#line 67
allow NetworkManager_t self:dbus send_msg;
#line 67

#line 67
allow NetworkManager_t hald_t:dbus send_msg;
#line 67
allow hald_t NetworkManager_t:dbus send_msg;
#line 67

#line 67
allow NetworkManager_t initrc_t:dbus send_msg;
#line 67
allow initrc_t NetworkManager_t:dbus send_msg;
#line 67

#line 67
allow NetworkManager_t unconfined_t:dbus send_msg;
#line 67
allow unconfined_t NetworkManager_t:dbus send_msg;
#line 67

#line 67
allow NetworkManager_t userdomain:dbus send_msg;
#line 67
allow userdomain NetworkManager_t:dbus send_msg;
#line 67


allow NetworkManager_t usr_t:file { getattr read };

#line 73

#line 73

#line 73

#line 73

#line 73
#
#line 73
# Allow the process to transition to the new domain.
#line 73
#
#line 73
allow NetworkManager_t ifconfig_t:process transition;
#line 73

#line 73
#
#line 73
# Do not audit when glibc secure mode is enabled upon the transition.
#line 73
#
#line 73
dontaudit NetworkManager_t ifconfig_t:process noatsecure;
#line 73

#line 73
#
#line 73
# Do not audit when signal-related state is cleared upon the transition.
#line 73
#
#line 73
dontaudit NetworkManager_t ifconfig_t:process siginh;
#line 73

#line 73
#
#line 73
# Do not audit when resource limits are reset upon the transition.
#line 73
#
#line 73
dontaudit NetworkManager_t ifconfig_t:process rlimitinh;
#line 73

#line 73
#
#line 73
# Allow the process to execute the program.
#line 73
# 
#line 73
allow NetworkManager_t ifconfig_exec_t:file { read { getattr execute } };
#line 73

#line 73
#
#line 73
# Allow the process to reap the new domain.
#line 73
#
#line 73
allow ifconfig_t NetworkManager_t:process sigchld;
#line 73

#line 73
#
#line 73
# Allow the new domain to inherit and use file 
#line 73
# descriptions from the creating process and vice versa.
#line 73
#
#line 73
allow ifconfig_t NetworkManager_t:fd use;
#line 73
allow NetworkManager_t ifconfig_t:fd use;
#line 73

#line 73
#
#line 73
# Allow the new domain to write back to the old domain via a pipe.
#line 73
#
#line 73
allow ifconfig_t NetworkManager_t:fifo_file { ioctl read getattr lock write append };
#line 73

#line 73
#
#line 73
# Allow the new domain to read and execute the program.
#line 73
#
#line 73
allow ifconfig_t ifconfig_exec_t:file { read getattr lock execute ioctl };
#line 73

#line 73
#
#line 73
# Allow the new domain to be entered via the program.
#line 73
#
#line 73
allow ifconfig_t ifconfig_exec_t:file entrypoint;
#line 73

#line 73
type_transition NetworkManager_t ifconfig_exec_t:process ifconfig_t;
#line 73


allow NetworkManager_t { sbin_t bin_t }:dir search;
allow NetworkManager_t bin_t:lnk_file read;

#line 77
allow NetworkManager_t { ls_exec_t sbin_t bin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 77


# in /etc created by NetworkManager will be labelled net_conf_t.

#line 80

#line 80

#line 80

#line 80
#
#line 80
# Allow the process to modify the directory.
#line 80
#
#line 80
allow NetworkManager_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 80

#line 80
#
#line 80
# Allow the process to create the file.
#line 80
#
#line 80

#line 80

#line 80

#line 80

#line 80

#line 80
allow NetworkManager_t net_conf_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80

#line 80
type_transition NetworkManager_t etc_t:file net_conf_t;
#line 80

#line 80


allow NetworkManager_t { etc_t etc_runtime_t }:file { getattr read };
allow NetworkManager_t proc_t:file { getattr read };

#line 84
allow NetworkManager_t proc_net_t:dir { read getattr lock search ioctl };
#line 84
allow NetworkManager_t proc_net_t:file { read getattr lock ioctl };
#line 84
allow NetworkManager_t proc_net_t:lnk_file { getattr read };
#line 84


allow NetworkManager_t { domain -unrestricted }:dir search;
allow NetworkManager_t { domain -unrestricted }:file { getattr read };
dontaudit NetworkManager_t unrestricted:dir search;
dontaudit NetworkManager_t unrestricted:file { getattr read };

allow NetworkManager_t howl_t:process signal;
allow NetworkManager_t initrc_var_run_t:file { getattr read };

#line 98

#line 98
if (!secure_mode_insmod) {
#line 98

#line 98

#line 98

#line 98
#
#line 98
# Allow the process to transition to the new domain.
#line 98
#
#line 98
allow NetworkManager_t insmod_t:process transition;
#line 98

#line 98
#
#line 98
# Do not audit when glibc secure mode is enabled upon the transition.
#line 98
#
#line 98
dontaudit NetworkManager_t insmod_t:process noatsecure;
#line 98

#line 98
#
#line 98
# Do not audit when signal-related state is cleared upon the transition.
#line 98
#
#line 98
dontaudit NetworkManager_t insmod_t:process siginh;
#line 98

#line 98
#
#line 98
# Do not audit when resource limits are reset upon the transition.
#line 98
#
#line 98
dontaudit NetworkManager_t insmod_t:process rlimitinh;
#line 98

#line 98
#
#line 98
# Allow the process to execute the program.
#line 98
# 
#line 98
allow NetworkManager_t insmod_exec_t:file { read { getattr execute } };
#line 98

#line 98
#
#line 98
# Allow the process to reap the new domain.
#line 98
#
#line 98
allow insmod_t NetworkManager_t:process sigchld;
#line 98

#line 98
#
#line 98
# Allow the new domain to inherit and use file 
#line 98
# descriptions from the creating process and vice versa.
#line 98
#
#line 98
allow insmod_t NetworkManager_t:fd use;
#line 98
allow NetworkManager_t insmod_t:fd use;
#line 98

#line 98
#
#line 98
# Allow the new domain to write back to the old domain via a pipe.
#line 98
#
#line 98
allow insmod_t NetworkManager_t:fifo_file { ioctl read getattr lock write append };
#line 98

#line 98
#
#line 98
# Allow the new domain to read and execute the program.
#line 98
#
#line 98
allow insmod_t insmod_exec_t:file { read getattr lock execute ioctl };
#line 98

#line 98
#
#line 98
# Allow the new domain to be entered via the program.
#line 98
#
#line 98
allow insmod_t insmod_exec_t:file entrypoint;
#line 98

#line 98
type_transition NetworkManager_t insmod_exec_t:process insmod_t;
#line 98

#line 98
}
#line 98


allow NetworkManager_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
# allow vpnc connections
allow NetworkManager_t self:rawip_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow NetworkManager_t tun_tap_device_t:chr_file { ioctl read getattr lock write append };


#line 105

#line 105

#line 105
#
#line 105
# Allow the process to transition to the new domain.
#line 105
#
#line 105
allow NetworkManager_t initrc_t:process transition;
#line 105

#line 105
#
#line 105
# Do not audit when glibc secure mode is enabled upon the transition.
#line 105
#
#line 105
dontaudit NetworkManager_t initrc_t:process noatsecure;
#line 105

#line 105
#
#line 105
# Do not audit when signal-related state is cleared upon the transition.
#line 105
#
#line 105
dontaudit NetworkManager_t initrc_t:process siginh;
#line 105

#line 105
#
#line 105
# Do not audit when resource limits are reset upon the transition.
#line 105
#
#line 105
dontaudit NetworkManager_t initrc_t:process rlimitinh;
#line 105

#line 105
#
#line 105
# Allow the process to execute the program.
#line 105
# 
#line 105
allow NetworkManager_t initrc_exec_t:file { read { getattr execute } };
#line 105

#line 105
#
#line 105
# Allow the process to reap the new domain.
#line 105
#
#line 105
allow initrc_t NetworkManager_t:process sigchld;
#line 105

#line 105
#
#line 105
# Allow the new domain to inherit and use file 
#line 105
# descriptions from the creating process and vice versa.
#line 105
#
#line 105
allow initrc_t NetworkManager_t:fd use;
#line 105
allow NetworkManager_t initrc_t:fd use;
#line 105

#line 105
#
#line 105
# Allow the new domain to write back to the old domain via a pipe.
#line 105
#
#line 105
allow initrc_t NetworkManager_t:fifo_file { ioctl read getattr lock write append };
#line 105

#line 105
#
#line 105
# Allow the new domain to read and execute the program.
#line 105
#
#line 105
allow initrc_t initrc_exec_t:file { read getattr lock execute ioctl };
#line 105

#line 105
#
#line 105
# Allow the new domain to be entered via the program.
#line 105
#
#line 105
allow initrc_t initrc_exec_t:file entrypoint;
#line 105

#line 105
type_transition NetworkManager_t initrc_exec_t:process initrc_t;
#line 105


#line 106

#line 106

#line 106
#
#line 106
# Allow the process to transition to the new domain.
#line 106
#
#line 106
allow NetworkManager_t dhcpc_t:process transition;
#line 106

#line 106
#
#line 106
# Do not audit when glibc secure mode is enabled upon the transition.
#line 106
#
#line 106
dontaudit NetworkManager_t dhcpc_t:process noatsecure;
#line 106

#line 106
#
#line 106
# Do not audit when signal-related state is cleared upon the transition.
#line 106
#
#line 106
dontaudit NetworkManager_t dhcpc_t:process siginh;
#line 106

#line 106
#
#line 106
# Do not audit when resource limits are reset upon the transition.
#line 106
#
#line 106
dontaudit NetworkManager_t dhcpc_t:process rlimitinh;
#line 106

#line 106
#
#line 106
# Allow the process to execute the program.
#line 106
# 
#line 106
allow NetworkManager_t dhcpc_exec_t:file { read { getattr execute } };
#line 106

#line 106
#
#line 106
# Allow the process to reap the new domain.
#line 106
#
#line 106
allow dhcpc_t NetworkManager_t:process sigchld;
#line 106

#line 106
#
#line 106
# Allow the new domain to inherit and use file 
#line 106
# descriptions from the creating process and vice versa.
#line 106
#
#line 106
allow dhcpc_t NetworkManager_t:fd use;
#line 106
allow NetworkManager_t dhcpc_t:fd use;
#line 106

#line 106
#
#line 106
# Allow the new domain to write back to the old domain via a pipe.
#line 106
#
#line 106
allow dhcpc_t NetworkManager_t:fifo_file { ioctl read getattr lock write append };
#line 106

#line 106
#
#line 106
# Allow the new domain to read and execute the program.
#line 106
#
#line 106
allow dhcpc_t dhcpc_exec_t:file { read getattr lock execute ioctl };
#line 106

#line 106
#
#line 106
# Allow the new domain to be entered via the program.
#line 106
#
#line 106
allow dhcpc_t dhcpc_exec_t:file entrypoint;
#line 106

#line 106
type_transition NetworkManager_t dhcpc_exec_t:process dhcpc_t;
#line 106

#line 109


#line 114

#line 114
allow NetworkManager_t dhcp_state_t:dir search;
#line 114
allow NetworkManager_t dhcpc_var_run_t:file { getattr read unlink };
#line 114

allow NetworkManager_t var_lib_t:dir search;
dontaudit NetworkManager_t user_tty_type:chr_file { read write };
dontaudit NetworkManager_t security_t:dir search;

#line 121

#line 121

#line 121
allow NetworkManager_t consoletype_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 121

#line 121


#line 1 "domains/program/nscd.te"
#DESC NSCD - Name service cache daemon cache lookup of user-name
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: nscd
#
#line 15

#################################
#
# Rules for the nscd_t domain.
#
# nscd is both the client program and the daemon.

#line 21

#line 21

#line 21

#line 21
type nscd_t, domain, privlog, daemon , userspace_objmgr, transitionbool;
#line 21
type nscd_exec_t, file_type, sysadmfile, exec_type;
#line 21
dontaudit nscd_t self:capability sys_tty_config;
#line 21

#line 21
role system_r types nscd_t;
#line 21

#line 21
# Inherit and use descriptors from init.
#line 21
allow nscd_t init_t:fd use;
#line 21
allow nscd_t init_t:process sigchld;
#line 21
allow nscd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 21

#line 21

#line 21
allow nscd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 21
allow nscd_t lib_t:lnk_file { read getattr lock ioctl };
#line 21
allow nscd_t ld_so_t:file { read getattr lock execute ioctl };
#line 21
#allow nscd_t ld_so_t:file execute_no_trans;
#line 21
allow nscd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 21
allow nscd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 21
allow nscd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 21
allow nscd_t texrel_shlib_t:file execmod;
#line 21
allow nscd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 21
allow nscd_t device_t:dir search;
#line 21
allow nscd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 21

#line 21

#line 21
allow nscd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 21
allow nscd_t { self proc_t }:lnk_file { getattr read };
#line 21

#line 21
allow nscd_t device_t:dir { read getattr lock search ioctl };
#line 21

#line 21
allow nscd_t udev_tdb_t:file { read getattr lock ioctl };
#line 21
allow nscd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 21
dontaudit nscd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 21
dontaudit nscd_t unpriv_userdomain:fd use;
#line 21

#line 21

#line 21
allow nscd_t sysfs_t:dir { read getattr lock search ioctl };
#line 21
allow nscd_t sysfs_t:file { read getattr lock ioctl };
#line 21
allow nscd_t sysfs_t:lnk_file { getattr read };
#line 21
 
#line 21

#line 21
allow nscd_t autofs_t:dir { search getattr };
#line 21

#line 21
dontaudit nscd_t { tty_device_t devpts_t }:chr_file { read write };
#line 21
dontaudit nscd_t root_t:file { getattr read };
#line 21
 
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
# Read system variables in /sys.
#line 21

#line 21
allow nscd_t sysctl_t:dir search;
#line 21
allow nscd_t sysctl_kernel_t:dir search;
#line 21
allow nscd_t sysctl_kernel_t:file { getattr read };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allows user to define a tunable to disable domain transition
#line 21
#
#line 21

#line 21
bool nscd_disable_trans false;
#line 21
if (nscd_disable_trans) {
#line 21

#line 21
allow initrc_t nscd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 21

#line 21

#line 21
allow sysadm_t nscd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 21

#line 21
} else {
#line 21
 
#line 21

#line 21

#line 21
#
#line 21
# Allow the process to transition to the new domain.
#line 21
#
#line 21
allow initrc_t nscd_t:process transition;
#line 21

#line 21
#
#line 21
# Do not audit when glibc secure mode is enabled upon the transition.
#line 21
#
#line 21
dontaudit initrc_t nscd_t:process noatsecure;
#line 21

#line 21
#
#line 21
# Do not audit when signal-related state is cleared upon the transition.
#line 21
#
#line 21
dontaudit initrc_t nscd_t:process siginh;
#line 21

#line 21
#
#line 21
# Do not audit when resource limits are reset upon the transition.
#line 21
#
#line 21
dontaudit initrc_t nscd_t:process rlimitinh;
#line 21

#line 21
#
#line 21
# Allow the process to execute the program.
#line 21
# 
#line 21
allow initrc_t nscd_exec_t:file { read { getattr execute } };
#line 21

#line 21
#
#line 21
# Allow the process to reap the new domain.
#line 21
#
#line 21
allow nscd_t initrc_t:process sigchld;
#line 21

#line 21
#
#line 21
# Allow the new domain to inherit and use file 
#line 21
# descriptions from the creating process and vice versa.
#line 21
#
#line 21
allow nscd_t initrc_t:fd use;
#line 21
allow initrc_t nscd_t:fd use;
#line 21

#line 21
#
#line 21
# Allow the new domain to write back to the old domain via a pipe.
#line 21
#
#line 21
allow nscd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 21

#line 21
#
#line 21
# Allow the new domain to read and execute the program.
#line 21
#
#line 21
allow nscd_t nscd_exec_t:file { read getattr lock execute ioctl };
#line 21

#line 21
#
#line 21
# Allow the new domain to be entered via the program.
#line 21
#
#line 21
allow nscd_t nscd_exec_t:file entrypoint;
#line 21

#line 21
type_transition initrc_t nscd_exec_t:process nscd_t;
#line 21

#line 21

#line 21
allow initrc_t nscd_t:process { noatsecure siginh rlimitinh };
#line 21

#line 21
}
#line 21
 
#line 21
allow nscd_t privfd:fd use;
#line 21

#line 21
allow nscd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 21

#line 21

#line 21
# Create pid file.
#line 21
allow nscd_t var_t:dir { getattr search };
#line 21

#line 21
type nscd_var_run_t, file_type, sysadmfile, pidfile;
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the process to modify the directory.
#line 21
#
#line 21
allow nscd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 21

#line 21
#
#line 21
# Allow the process to create the file.
#line 21
#
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
allow nscd_t nscd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
type_transition nscd_t var_run_t:file nscd_var_run_t;
#line 21

#line 21

#line 21

#line 21
allow nscd_t var_t:dir search;
#line 21
allow nscd_t nscd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 21

#line 21

#line 21
allow nscd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 21

#line 21
# for daemons that look at /root on startup
#line 21
dontaudit nscd_t sysadm_home_dir_t:dir search;
#line 21

#line 21
# for df
#line 21
allow nscd_t fs_type:filesystem getattr;
#line 21
allow nscd_t removable_t:filesystem getattr;
#line 21

#line 21

#line 21
allow nscd_t etc_t:lnk_file read;
#line 21
allow nscd_t lib_t:file { read getattr lock ioctl };
#line 21

#line 21
allow nscd_t locale_t:dir { read getattr lock search ioctl };
#line 21
allow nscd_t locale_t:file { read getattr lock ioctl };
#line 21
allow nscd_t locale_t:lnk_file { getattr read };
#line 21

#line 21

#line 21

#line 21
# for localization
#line 21
allow nscd_t lib_t:file { getattr read };
#line 21


allow nscd_t etc_t:file { read getattr lock ioctl };
allow nscd_t etc_t:lnk_file read;

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use tcp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow nscd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow nscd_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow nscd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow nscd_t node_type:node { tcp_send rawip_send };
#line 25
allow nscd_t node_type:node { tcp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow nscd_t port_type:tcp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow nscd_t node_type:tcp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow nscd_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow nscd_t self:tcp_socket { connect };
#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use udp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow nscd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow nscd_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow nscd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow nscd_t node_type:node { udp_send rawip_send };
#line 25
allow nscd_t node_type:node { udp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow nscd_t port_type:udp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow nscd_t node_type:udp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow nscd_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow nscd_t self:udp_socket { connect };
#line 25

#line 25

#line 25

allow nscd_t port_type:tcp_socket name_connect;

#line 27

#line 27
if (allow_ypbind) {
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
#
#line 27
# Allow the domain to create and use tcp sockets.
#line 27
# Other kinds of sockets must be separately authorized for use.
#line 27
allow nscd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 27

#line 27
allow nscd_t unlabeled_t:association { sendto recvfrom };
#line 27

#line 27
#
#line 27
# Allow the domain to send or receive using any network interface.
#line 27
# netif_type is a type attribute for all network interface types.
#line 27
#
#line 27
allow nscd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 27
#
#line 27
# Allow the domain to send to or receive from any node.
#line 27
# node_type is a type attribute for all node types.
#line 27
#
#line 27
allow nscd_t node_type:node { tcp_send rawip_send };
#line 27
allow nscd_t node_type:node { tcp_recv rawip_recv };
#line 27

#line 27
#
#line 27
# Allow the domain to send to or receive from any port.
#line 27
# port_type is a type attribute for all port types.
#line 27
#
#line 27

#line 27
allow nscd_t port_type:tcp_socket { send_msg recv_msg };
#line 27

#line 27

#line 27
# XXX Allow binding to any node type.  Remove once
#line 27
# individual rules have been added to all domains that 
#line 27
# bind sockets. 
#line 27
allow nscd_t node_type:tcp_socket node_bind;
#line 27
#
#line 27
# Allow access to network files including /etc/resolv.conf
#line 27
#
#line 27
allow nscd_t net_conf_t:file { read getattr lock ioctl };
#line 27

#line 27
allow nscd_t self:tcp_socket { listen accept };
#line 27

#line 27

#line 27

#line 27
#
#line 27
# Allow the domain to create and use tcp sockets.
#line 27
# Other kinds of sockets must be separately authorized for use.
#line 27
allow nscd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 27

#line 27
allow nscd_t unlabeled_t:association { sendto recvfrom };
#line 27

#line 27
#
#line 27
# Allow the domain to send or receive using any network interface.
#line 27
# netif_type is a type attribute for all network interface types.
#line 27
#
#line 27
allow nscd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 27
#
#line 27
# Allow the domain to send to or receive from any node.
#line 27
# node_type is a type attribute for all node types.
#line 27
#
#line 27
allow nscd_t node_type:node { tcp_send rawip_send };
#line 27
allow nscd_t node_type:node { tcp_recv rawip_recv };
#line 27

#line 27
#
#line 27
# Allow the domain to send to or receive from any port.
#line 27
# port_type is a type attribute for all port types.
#line 27
#
#line 27

#line 27
allow nscd_t port_type:tcp_socket { send_msg recv_msg };
#line 27

#line 27

#line 27
# XXX Allow binding to any node type.  Remove once
#line 27
# individual rules have been added to all domains that 
#line 27
# bind sockets. 
#line 27
allow nscd_t node_type:tcp_socket node_bind;
#line 27
#
#line 27
# Allow access to network files including /etc/resolv.conf
#line 27
#
#line 27
allow nscd_t net_conf_t:file { read getattr lock ioctl };
#line 27

#line 27
allow nscd_t self:tcp_socket { connect };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
#
#line 27
# Allow the domain to create and use udp sockets.
#line 27
# Other kinds of sockets must be separately authorized for use.
#line 27
allow nscd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 27

#line 27
allow nscd_t unlabeled_t:association { sendto recvfrom };
#line 27

#line 27
#
#line 27
# Allow the domain to send or receive using any network interface.
#line 27
# netif_type is a type attribute for all network interface types.
#line 27
#
#line 27
allow nscd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 27
#
#line 27
# Allow the domain to send to or receive from any node.
#line 27
# node_type is a type attribute for all node types.
#line 27
#
#line 27
allow nscd_t node_type:node { udp_send rawip_send };
#line 27
allow nscd_t node_type:node { udp_recv rawip_recv };
#line 27

#line 27
#
#line 27
# Allow the domain to send to or receive from any port.
#line 27
# port_type is a type attribute for all port types.
#line 27
#
#line 27

#line 27
allow nscd_t port_type:udp_socket { send_msg recv_msg };
#line 27

#line 27

#line 27
# XXX Allow binding to any node type.  Remove once
#line 27
# individual rules have been added to all domains that 
#line 27
# bind sockets. 
#line 27
allow nscd_t node_type:udp_socket node_bind;
#line 27
#
#line 27
# Allow access to network files including /etc/resolv.conf
#line 27
#
#line 27
allow nscd_t net_conf_t:file { read getattr lock ioctl };
#line 27

#line 27
allow nscd_t self:udp_socket { connect };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
allow nscd_t var_yp_t:dir { read getattr lock search ioctl };
#line 27
allow nscd_t var_yp_t:file { read getattr lock ioctl };
#line 27
allow nscd_t var_yp_t:lnk_file { getattr read };
#line 27

#line 27
allow nscd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 27
allow nscd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 27
dontaudit nscd_t self:capability net_bind_service;
#line 27
dontaudit nscd_t reserved_port_type:tcp_socket name_connect;
#line 27
dontaudit nscd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 27

#line 27
} else {
#line 27
dontaudit nscd_t var_yp_t:dir search;
#line 27
}
#line 27
 


#line 29

#line 29

#line 29

#line 29
#
#line 29
# Allow the process to modify the directory.
#line 29
#
#line 29
allow nscd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 29

#line 29
#
#line 29
# Allow the process to create the file.
#line 29
#
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
allow nscd_t nscd_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
type_transition nscd_t var_run_t:sock_file nscd_var_run_t;
#line 29

#line 29


allow nscd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };


#line 33

#line 33
allow nscd_client_domain nscd_t:unix_stream_socket connectto;
#line 33

#line 33
allow nscd_client_domain nscd_var_run_t:sock_file { ioctl read getattr lock write append };
#line 33
allow nscd_client_domain { var_run_t var_t }:dir search;
#line 33
allow nscd_client_domain nscd_t:nscd { getpwd getgrp gethost };
#line 33
dontaudit nscd_client_domain nscd_t:fd use;
#line 33
dontaudit nscd_client_domain nscd_var_run_t:dir { search getattr };
#line 33
dontaudit nscd_client_domain nscd_var_run_t:file { getattr read };
#line 33
dontaudit nscd_client_domain nscd_t:nscd { shmempwd shmemgrp shmemhost };
#line 33


#line 34

#line 34
allow daemon nscd_t:unix_stream_socket connectto;
#line 34

#line 34
allow daemon nscd_var_run_t:sock_file { ioctl read getattr lock write append };
#line 34
allow daemon { var_run_t var_t }:dir search;
#line 34
allow daemon nscd_t:nscd { getpwd getgrp gethost };
#line 34
dontaudit daemon nscd_t:fd use;
#line 34
dontaudit daemon nscd_var_run_t:dir { search getattr };
#line 34
dontaudit daemon nscd_var_run_t:file { getattr read };
#line 34
dontaudit daemon nscd_t:nscd { shmempwd shmemgrp shmemhost };
#line 34


# Clients that are allowed to map the database via a fd obtained from nscd.

#line 37

#line 37
allow nscd_shmem_domain nscd_t:unix_stream_socket connectto;
#line 37

#line 37
allow nscd_shmem_domain nscd_var_run_t:sock_file { ioctl read getattr lock write append };
#line 37
allow nscd_shmem_domain { var_run_t var_t }:dir search;
#line 37
allow nscd_shmem_domain nscd_t:nscd { getpwd getgrp gethost };
#line 37
dontaudit nscd_shmem_domain nscd_t:fd use;
#line 37
dontaudit nscd_shmem_domain nscd_var_run_t:dir { search getattr };
#line 37
dontaudit nscd_shmem_domain nscd_var_run_t:file { getattr read };
#line 37
dontaudit nscd_shmem_domain nscd_t:nscd { shmempwd shmemgrp shmemhost };
#line 37

allow nscd_shmem_domain nscd_var_run_t:dir { read getattr lock search ioctl };
allow nscd_shmem_domain nscd_t:nscd { shmempwd shmemgrp shmemhost };
# Receive fd from nscd and map the backing file with read access.
allow nscd_shmem_domain nscd_t:fd use;

# For client program operation, invoked from sysadm_t.
# Transition occurs to nscd_t due to direct_sysadm_daemon. 
allow nscd_t self:nscd { admin getstat };
allow nscd_t admin_tty_type:chr_file { ioctl read getattr lock write append };


#line 48
# Read system variables in /sys.
#line 48

#line 48
allow nscd_t sysctl_t:dir search;
#line 48
allow nscd_t sysctl_kernel_t:dir search;
#line 48
allow nscd_t sysctl_kernel_t:file { getattr read };
#line 48

#line 48

#line 48

allow nscd_t self:process { getattr setsched };
allow nscd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow nscd_t self:fifo_file { read write };
allow nscd_t self:capability { kill setgid setuid net_bind_service };

# for when /etc/passwd has just been updated and has the wrong type
allow nscd_t shadow_t:file getattr;

dontaudit nscd_t sysadm_home_dir_t:dir search;

#line 67

#line 67
#
#line 67
# Handle winbind for samba, Might only be needed for targeted policy
#line 67
#
#line 67
allow nscd_t winbind_var_run_t:sock_file { read write getattr };
#line 67

#line 67
allow nscd_t winbind_t:unix_stream_socket connectto;
#line 67

#line 67
allow nscd_t samba_var_t:dir search;
#line 67
allow nscd_t winbind_var_run_t:dir { getattr search };
#line 67



#line 69
allow nscd_t selinux_config_t:dir { read getattr lock search ioctl };
#line 69
allow nscd_t selinux_config_t:file { read getattr lock ioctl };
#line 69
allow nscd_t selinux_config_t:lnk_file { getattr read };
#line 69


#line 70
# Get the selinuxfs mount point via /proc/self/mounts.
#line 70
allow nscd_t proc_t:dir search;
#line 70
allow nscd_t proc_t:{ file lnk_file } { getattr read };
#line 70
allow nscd_t self:dir search;
#line 70
allow nscd_t self:file { getattr read };
#line 70
# Access selinuxfs.
#line 70
allow nscd_t security_t:dir { read search getattr };
#line 70
allow nscd_t security_t:file { getattr read write };
#line 70
allow nscd_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 70

allow nscd_t self:netlink_selinux_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow nscd_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
allow nscd_t tmp_t:dir { search getattr };
allow nscd_t tmp_t:lnk_file read;
allow nscd_t { urandom_device_t random_device_t }:chr_file { getattr read };

#line 76
type nscd_log_t, file_type, sysadmfile, logfile;
#line 76

#line 76

#line 76

#line 76

#line 76
#
#line 76
# Allow the process to modify the directory.
#line 76
#
#line 76
allow nscd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 76

#line 76
#
#line 76
# Allow the process to create the file.
#line 76
#
#line 76

#line 76

#line 76

#line 76

#line 76

#line 76
allow nscd_t nscd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 76

#line 76

#line 76

#line 76

#line 76

#line 76

#line 76

#line 76

#line 76

#line 76
type_transition nscd_t var_log_t:file nscd_log_t;
#line 76

#line 76

#line 76


#line 77
allow nscd_t cert_t:dir { read getattr lock search ioctl };
#line 77
allow nscd_t cert_t:file { read getattr lock ioctl };
#line 77
allow nscd_t cert_t:lnk_file { getattr read };
#line 77

allow nscd_t tun_tap_device_t:chr_file { read write };
allow nscd_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };
#line 1 "domains/program/ntpd.te"
#DESC NTPD - Time synchronisation daemon
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: ntp ntp-simple
#

#################################
#
# Rules for the ntpd_t domain.
#

#line 11

#line 11

#line 11

#line 11
type ntpd_t, domain, privlog, daemon , nscd_client_domain, transitionbool;
#line 11
type ntpd_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit ntpd_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types ntpd_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow ntpd_t init_t:fd use;
#line 11
allow ntpd_t init_t:process sigchld;
#line 11
allow ntpd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow ntpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow ntpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow ntpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow ntpd_t ld_so_t:file execute_no_trans;
#line 11
allow ntpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow ntpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow ntpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow ntpd_t texrel_shlib_t:file execmod;
#line 11
allow ntpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow ntpd_t device_t:dir search;
#line 11
allow ntpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow ntpd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow ntpd_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow ntpd_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow ntpd_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow ntpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit ntpd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit ntpd_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow ntpd_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow ntpd_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow ntpd_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow ntpd_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit ntpd_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit ntpd_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
# Read system variables in /sys.
#line 11

#line 11
allow ntpd_t sysctl_t:dir search;
#line 11
allow ntpd_t sysctl_kernel_t:dir search;
#line 11
allow ntpd_t sysctl_kernel_t:file { getattr read };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allows user to define a tunable to disable domain transition
#line 11
#
#line 11

#line 11
bool ntpd_disable_trans false;
#line 11
if (ntpd_disable_trans) {
#line 11

#line 11
allow initrc_t ntpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11

#line 11
allow sysadm_t ntpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11
 
#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow initrc_t ntpd_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit initrc_t ntpd_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit initrc_t ntpd_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit initrc_t ntpd_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow initrc_t ntpd_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow ntpd_t initrc_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow ntpd_t initrc_t:fd use;
#line 11
allow initrc_t ntpd_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow ntpd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow ntpd_t ntpd_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow ntpd_t ntpd_exec_t:file entrypoint;
#line 11

#line 11
type_transition initrc_t ntpd_exec_t:process ntpd_t;
#line 11

#line 11

#line 11
allow initrc_t ntpd_t:process { noatsecure siginh rlimitinh };
#line 11

#line 11
}
#line 11
 
#line 11
allow ntpd_t privfd:fd use;
#line 11

#line 11
allow ntpd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
# Create pid file.
#line 11
allow ntpd_t var_t:dir { getattr search };
#line 11

#line 11
type ntpd_var_run_t, file_type, sysadmfile, pidfile;
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow ntpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow ntpd_t ntpd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition ntpd_t var_run_t:file ntpd_var_run_t;
#line 11

#line 11

#line 11

#line 11
allow ntpd_t var_t:dir search;
#line 11
allow ntpd_t ntpd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11

#line 11
allow ntpd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11
# for daemons that look at /root on startup
#line 11
dontaudit ntpd_t sysadm_home_dir_t:dir search;
#line 11

#line 11
# for df
#line 11
allow ntpd_t fs_type:filesystem getattr;
#line 11
allow ntpd_t removable_t:filesystem getattr;
#line 11

#line 11

#line 11
allow ntpd_t etc_t:lnk_file read;
#line 11
allow ntpd_t lib_t:file { read getattr lock ioctl };
#line 11

#line 11
allow ntpd_t locale_t:dir { read getattr lock search ioctl };
#line 11
allow ntpd_t locale_t:file { read getattr lock ioctl };
#line 11
allow ntpd_t locale_t:lnk_file { getattr read };
#line 11

#line 11

#line 11

#line 11
# for localization
#line 11
allow ntpd_t lib_t:file { getattr read };
#line 11

type ntp_drift_t, file_type, sysadmfile;

type ntpdate_exec_t, file_type, sysadmfile, exec_type;

#line 15

#line 15

#line 15
#
#line 15
# Allow the process to transition to the new domain.
#line 15
#
#line 15
allow initrc_t ntpd_t:process transition;
#line 15

#line 15
#
#line 15
# Do not audit when glibc secure mode is enabled upon the transition.
#line 15
#
#line 15
dontaudit initrc_t ntpd_t:process noatsecure;
#line 15

#line 15
#
#line 15
# Do not audit when signal-related state is cleared upon the transition.
#line 15
#
#line 15
dontaudit initrc_t ntpd_t:process siginh;
#line 15

#line 15
#
#line 15
# Do not audit when resource limits are reset upon the transition.
#line 15
#
#line 15
dontaudit initrc_t ntpd_t:process rlimitinh;
#line 15

#line 15
#
#line 15
# Allow the process to execute the program.
#line 15
# 
#line 15
allow initrc_t ntpdate_exec_t:file { read { getattr execute } };
#line 15

#line 15
#
#line 15
# Allow the process to reap the new domain.
#line 15
#
#line 15
allow ntpd_t initrc_t:process sigchld;
#line 15

#line 15
#
#line 15
# Allow the new domain to inherit and use file 
#line 15
# descriptions from the creating process and vice versa.
#line 15
#
#line 15
allow ntpd_t initrc_t:fd use;
#line 15
allow initrc_t ntpd_t:fd use;
#line 15

#line 15
#
#line 15
# Allow the new domain to write back to the old domain via a pipe.
#line 15
#
#line 15
allow ntpd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 15

#line 15
#
#line 15
# Allow the new domain to read and execute the program.
#line 15
#
#line 15
allow ntpd_t ntpdate_exec_t:file { read getattr lock execute ioctl };
#line 15

#line 15
#
#line 15
# Allow the new domain to be entered via the program.
#line 15
#
#line 15
allow ntpd_t ntpdate_exec_t:file entrypoint;
#line 15

#line 15
type_transition initrc_t ntpdate_exec_t:process ntpd_t;
#line 15



#line 17

#line 17
type ntpd_log_t, file_type, sysadmfile, logfile;
#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the process to modify the directory.
#line 17
#
#line 17
allow ntpd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17

#line 17
#
#line 17
# Allow the process to create the file.
#line 17
#
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow ntpd_t ntpd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
type_transition ntpd_t var_log_t:file ntpd_log_t;
#line 17

#line 17

#line 17

#line 17
allow ntpd_t ntpd_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 17


allow ntpd_t var_lib_t:dir { read getattr lock search ioctl };
allow ntpd_t usr_t:file { read getattr lock ioctl };
# reading  /usr/share/ssl/cert.pem requires
allow ntpd_t usr_t:lnk_file read;
allow ntpd_t ntp_drift_t:dir { read getattr lock search ioctl add_name remove_name write };
allow ntpd_t ntp_drift_t:file { create ioctl read getattr lock write setattr append link unlink rename };

# for SSP
allow ntpd_t urandom_device_t:chr_file { getattr read };

# sys_resource and setrlimit is for locking memory
allow ntpd_t self:capability { chown dac_override kill setgid setuid sys_time net_bind_service ipc_lock ipc_owner sys_chroot sys_nice sys_resource };
dontaudit ntpd_t self:capability { fsetid net_admin };
allow ntpd_t self:process { setcap setsched setrlimit };
# ntpdate wants sys_nice

# for some reason it creates a file in /tmp

#line 36
type ntpd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 36

#line 36

#line 36

#line 36

#line 36
#
#line 36
# Allow the process to modify the directory.
#line 36
#
#line 36
allow ntpd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 36

#line 36
#
#line 36
# Allow the process to create the file.
#line 36
#
#line 36

#line 36

#line 36

#line 36

#line 36

#line 36
allow ntpd_t ntpd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36
allow ntpd_t ntpd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36
type_transition ntpd_t tmp_t:{ file dir } ntpd_tmp_t;
#line 36

#line 36

#line 36


allow ntpd_t etc_t:dir { read getattr lock search ioctl };
allow ntpd_t etc_t:file { read getattr };

# Use the network.

#line 42

#line 42

#line 42

#line 42

#line 42

#line 42
#
#line 42
# Allow the domain to create and use tcp sockets.
#line 42
# Other kinds of sockets must be separately authorized for use.
#line 42
allow ntpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 42

#line 42
allow ntpd_t unlabeled_t:association { sendto recvfrom };
#line 42

#line 42
#
#line 42
# Allow the domain to send or receive using any network interface.
#line 42
# netif_type is a type attribute for all network interface types.
#line 42
#
#line 42
allow ntpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 42
#
#line 42
# Allow the domain to send to or receive from any node.
#line 42
# node_type is a type attribute for all node types.
#line 42
#
#line 42
allow ntpd_t node_type:node { tcp_send rawip_send };
#line 42
allow ntpd_t node_type:node { tcp_recv rawip_recv };
#line 42

#line 42
#
#line 42
# Allow the domain to send to or receive from any port.
#line 42
# port_type is a type attribute for all port types.
#line 42
#
#line 42

#line 42
allow ntpd_t port_type:tcp_socket { send_msg recv_msg };
#line 42

#line 42

#line 42
# XXX Allow binding to any node type.  Remove once
#line 42
# individual rules have been added to all domains that 
#line 42
# bind sockets. 
#line 42
allow ntpd_t node_type:tcp_socket node_bind;
#line 42
#
#line 42
# Allow access to network files including /etc/resolv.conf
#line 42
#
#line 42
allow ntpd_t net_conf_t:file { read getattr lock ioctl };
#line 42

#line 42
allow ntpd_t self:tcp_socket { listen accept };
#line 42

#line 42

#line 42

#line 42
#
#line 42
# Allow the domain to create and use tcp sockets.
#line 42
# Other kinds of sockets must be separately authorized for use.
#line 42
allow ntpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 42

#line 42
allow ntpd_t unlabeled_t:association { sendto recvfrom };
#line 42

#line 42
#
#line 42
# Allow the domain to send or receive using any network interface.
#line 42
# netif_type is a type attribute for all network interface types.
#line 42
#
#line 42
allow ntpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 42
#
#line 42
# Allow the domain to send to or receive from any node.
#line 42
# node_type is a type attribute for all node types.
#line 42
#
#line 42
allow ntpd_t node_type:node { tcp_send rawip_send };
#line 42
allow ntpd_t node_type:node { tcp_recv rawip_recv };
#line 42

#line 42
#
#line 42
# Allow the domain to send to or receive from any port.
#line 42
# port_type is a type attribute for all port types.
#line 42
#
#line 42

#line 42
allow ntpd_t port_type:tcp_socket { send_msg recv_msg };
#line 42

#line 42

#line 42
# XXX Allow binding to any node type.  Remove once
#line 42
# individual rules have been added to all domains that 
#line 42
# bind sockets. 
#line 42
allow ntpd_t node_type:tcp_socket node_bind;
#line 42
#
#line 42
# Allow access to network files including /etc/resolv.conf
#line 42
#
#line 42
allow ntpd_t net_conf_t:file { read getattr lock ioctl };
#line 42

#line 42
allow ntpd_t self:tcp_socket { connect };
#line 42

#line 42

#line 42

#line 42

#line 42

#line 42
#
#line 42
# Allow the domain to create and use udp sockets.
#line 42
# Other kinds of sockets must be separately authorized for use.
#line 42
allow ntpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 42

#line 42
allow ntpd_t unlabeled_t:association { sendto recvfrom };
#line 42

#line 42
#
#line 42
# Allow the domain to send or receive using any network interface.
#line 42
# netif_type is a type attribute for all network interface types.
#line 42
#
#line 42
allow ntpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 42
#
#line 42
# Allow the domain to send to or receive from any node.
#line 42
# node_type is a type attribute for all node types.
#line 42
#
#line 42
allow ntpd_t node_type:node { udp_send rawip_send };
#line 42
allow ntpd_t node_type:node { udp_recv rawip_recv };
#line 42

#line 42
#
#line 42
# Allow the domain to send to or receive from any port.
#line 42
# port_type is a type attribute for all port types.
#line 42
#
#line 42

#line 42
allow ntpd_t port_type:udp_socket { send_msg recv_msg };
#line 42

#line 42

#line 42
# XXX Allow binding to any node type.  Remove once
#line 42
# individual rules have been added to all domains that 
#line 42
# bind sockets. 
#line 42
allow ntpd_t node_type:udp_socket node_bind;
#line 42
#
#line 42
# Allow access to network files including /etc/resolv.conf
#line 42
#
#line 42
allow ntpd_t net_conf_t:file { read getattr lock ioctl };
#line 42

#line 42
allow ntpd_t self:udp_socket { connect };
#line 42

#line 42

#line 42

#line 42

#line 42

allow ntpd_t ntp_port_t:tcp_socket name_connect;

#line 44

#line 44
if (allow_ypbind) {
#line 44

#line 44

#line 44

#line 44

#line 44

#line 44

#line 44

#line 44
#
#line 44
# Allow the domain to create and use tcp sockets.
#line 44
# Other kinds of sockets must be separately authorized for use.
#line 44
allow ntpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 44

#line 44
allow ntpd_t unlabeled_t:association { sendto recvfrom };
#line 44

#line 44
#
#line 44
# Allow the domain to send or receive using any network interface.
#line 44
# netif_type is a type attribute for all network interface types.
#line 44
#
#line 44
allow ntpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 44
#
#line 44
# Allow the domain to send to or receive from any node.
#line 44
# node_type is a type attribute for all node types.
#line 44
#
#line 44
allow ntpd_t node_type:node { tcp_send rawip_send };
#line 44
allow ntpd_t node_type:node { tcp_recv rawip_recv };
#line 44

#line 44
#
#line 44
# Allow the domain to send to or receive from any port.
#line 44
# port_type is a type attribute for all port types.
#line 44
#
#line 44

#line 44
allow ntpd_t port_type:tcp_socket { send_msg recv_msg };
#line 44

#line 44

#line 44
# XXX Allow binding to any node type.  Remove once
#line 44
# individual rules have been added to all domains that 
#line 44
# bind sockets. 
#line 44
allow ntpd_t node_type:tcp_socket node_bind;
#line 44
#
#line 44
# Allow access to network files including /etc/resolv.conf
#line 44
#
#line 44
allow ntpd_t net_conf_t:file { read getattr lock ioctl };
#line 44

#line 44
allow ntpd_t self:tcp_socket { listen accept };
#line 44

#line 44

#line 44

#line 44
#
#line 44
# Allow the domain to create and use tcp sockets.
#line 44
# Other kinds of sockets must be separately authorized for use.
#line 44
allow ntpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 44

#line 44
allow ntpd_t unlabeled_t:association { sendto recvfrom };
#line 44

#line 44
#
#line 44
# Allow the domain to send or receive using any network interface.
#line 44
# netif_type is a type attribute for all network interface types.
#line 44
#
#line 44
allow ntpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 44
#
#line 44
# Allow the domain to send to or receive from any node.
#line 44
# node_type is a type attribute for all node types.
#line 44
#
#line 44
allow ntpd_t node_type:node { tcp_send rawip_send };
#line 44
allow ntpd_t node_type:node { tcp_recv rawip_recv };
#line 44

#line 44
#
#line 44
# Allow the domain to send to or receive from any port.
#line 44
# port_type is a type attribute for all port types.
#line 44
#
#line 44

#line 44
allow ntpd_t port_type:tcp_socket { send_msg recv_msg };
#line 44

#line 44

#line 44
# XXX Allow binding to any node type.  Remove once
#line 44
# individual rules have been added to all domains that 
#line 44
# bind sockets. 
#line 44
allow ntpd_t node_type:tcp_socket node_bind;
#line 44
#
#line 44
# Allow access to network files including /etc/resolv.conf
#line 44
#
#line 44
allow ntpd_t net_conf_t:file { read getattr lock ioctl };
#line 44

#line 44
allow ntpd_t self:tcp_socket { connect };
#line 44

#line 44

#line 44

#line 44

#line 44

#line 44
#
#line 44
# Allow the domain to create and use udp sockets.
#line 44
# Other kinds of sockets must be separately authorized for use.
#line 44
allow ntpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 44

#line 44
allow ntpd_t unlabeled_t:association { sendto recvfrom };
#line 44

#line 44
#
#line 44
# Allow the domain to send or receive using any network interface.
#line 44
# netif_type is a type attribute for all network interface types.
#line 44
#
#line 44
allow ntpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 44
#
#line 44
# Allow the domain to send to or receive from any node.
#line 44
# node_type is a type attribute for all node types.
#line 44
#
#line 44
allow ntpd_t node_type:node { udp_send rawip_send };
#line 44
allow ntpd_t node_type:node { udp_recv rawip_recv };
#line 44

#line 44
#
#line 44
# Allow the domain to send to or receive from any port.
#line 44
# port_type is a type attribute for all port types.
#line 44
#
#line 44

#line 44
allow ntpd_t port_type:udp_socket { send_msg recv_msg };
#line 44

#line 44

#line 44
# XXX Allow binding to any node type.  Remove once
#line 44
# individual rules have been added to all domains that 
#line 44
# bind sockets. 
#line 44
allow ntpd_t node_type:udp_socket node_bind;
#line 44
#
#line 44
# Allow access to network files including /etc/resolv.conf
#line 44
#
#line 44
allow ntpd_t net_conf_t:file { read getattr lock ioctl };
#line 44

#line 44
allow ntpd_t self:udp_socket { connect };
#line 44

#line 44

#line 44

#line 44

#line 44

#line 44

#line 44
allow ntpd_t var_yp_t:dir { read getattr lock search ioctl };
#line 44
allow ntpd_t var_yp_t:file { read getattr lock ioctl };
#line 44
allow ntpd_t var_yp_t:lnk_file { getattr read };
#line 44

#line 44
allow ntpd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 44
allow ntpd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 44
dontaudit ntpd_t self:capability net_bind_service;
#line 44
dontaudit ntpd_t reserved_port_type:tcp_socket name_connect;
#line 44
dontaudit ntpd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 44

#line 44
} else {
#line 44
dontaudit ntpd_t var_yp_t:dir search;
#line 44
}
#line 44
 
allow ntpd_t ntp_port_t:udp_socket name_bind;
allow sysadm_t ntp_port_t:udp_socket name_bind;
allow ntpd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow ntpd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow ntpd_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };

# so the start script can change firewall entries
allow initrc_t net_conf_t:file { getattr read ioctl };

# for cron jobs
# system_crond_t is not right, cron is not doing what it should
#line 58

#line 58

#line 58

#line 58

#line 58

#line 58

#line 58
#
#line 58
# Allow the process to transition to the new domain.
#line 58
#
#line 58
allow system_crond_t ntpd_t:process transition;
#line 58

#line 58
#
#line 58
# Do not audit when glibc secure mode is enabled upon the transition.
#line 58
#
#line 58
dontaudit system_crond_t ntpd_t:process noatsecure;
#line 58

#line 58
#
#line 58
# Do not audit when signal-related state is cleared upon the transition.
#line 58
#
#line 58
dontaudit system_crond_t ntpd_t:process siginh;
#line 58

#line 58
#
#line 58
# Do not audit when resource limits are reset upon the transition.
#line 58
#
#line 58
dontaudit system_crond_t ntpd_t:process rlimitinh;
#line 58

#line 58
#
#line 58
# Allow the process to execute the program.
#line 58
# 
#line 58
allow system_crond_t ntpdate_exec_t:file { read { getattr execute } };
#line 58

#line 58
#
#line 58
# Allow the process to reap the new domain.
#line 58
#
#line 58
allow ntpd_t system_crond_t:process sigchld;
#line 58

#line 58
#
#line 58
# Allow the new domain to inherit and use file 
#line 58
# descriptions from the creating process and vice versa.
#line 58
#
#line 58
allow ntpd_t system_crond_t:fd use;
#line 58
allow system_crond_t ntpd_t:fd use;
#line 58

#line 58
#
#line 58
# Allow the new domain to write back to the old domain via a pipe.
#line 58
#
#line 58
allow ntpd_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 58

#line 58
#
#line 58
# Allow the new domain to read and execute the program.
#line 58
#
#line 58
allow ntpd_t ntpdate_exec_t:file { read getattr lock execute ioctl };
#line 58

#line 58
#
#line 58
# Allow the new domain to be entered via the program.
#line 58
#
#line 58
allow ntpd_t ntpdate_exec_t:file entrypoint;
#line 58

#line 58
type_transition system_crond_t ntpdate_exec_t:process ntpd_t;
#line 58

#line 58
allow ntpd_t crond_t:fifo_file { getattr read write ioctl };
#line 58
# a rule for privfd may make this obsolete
#line 58
allow ntpd_t crond_t:fd use;
#line 58
allow ntpd_t crond_t:process sigchld;
#line 58

#line 58



#line 60
allow ntpd_t initrc_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 60

allow ntpd_t self:fifo_file { read write getattr };
allow ntpd_t etc_runtime_t:file { read getattr lock ioctl };

#line 63
allow ntpd_t { bin_t shell_exec_t sbin_t ls_exec_t ntpd_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 63

allow ntpd_t { sbin_t bin_t }:dir search;
allow ntpd_t bin_t:lnk_file read;

#line 66
# Read system variables in /sys.
#line 66

#line 66
allow ntpd_t sysctl_t:dir search;
#line 66
allow ntpd_t sysctl_kernel_t:dir search;
#line 66
allow ntpd_t sysctl_kernel_t:file { getattr read };
#line 66

#line 66

#line 66
;
allow ntpd_t proc_t:file { read getattr lock ioctl };
allow ntpd_t sysadm_home_dir_t:dir { read getattr lock search ioctl };
allow ntpd_t self:file { getattr read };
dontaudit ntpd_t domain:dir search;
#line 73


allow ntpd_t devtty_t:chr_file { ioctl read getattr lock write append };


#line 77
#allow ntpd_t sysadm_t:udp_socket sendto;
#line 77
#allow sysadm_t ntpd_t:udp_socket recvfrom;
#line 77


#line 78
#allow sysadm_t ntpd_t:udp_socket sendto;
#line 78
#allow ntpd_t sysadm_t:udp_socket recvfrom;
#line 78


#line 79
#allow ntpd_t ntpd_t:udp_socket sendto;
#line 79
#allow ntpd_t ntpd_t:udp_socket recvfrom;
#line 79

#line 82

#line 82
dontaudit ntpd_t firstboot_t:fd use;
#line 82

#line 86

#line 86
allow ntpd_t winbind_var_run_t:dir { read getattr lock search ioctl };
#line 86
allow ntpd_t winbind_var_run_t:sock_file { ioctl read getattr lock write append };
#line 86

# For clock devices like wwvb1
allow ntpd_t device_t:lnk_file read;
#line 1 "domains/program/passwd.te"
#DESC Passwd - Password utilities
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: passwd
#

#################################
#
# Rules for the passwd_t domain.
#
#line 68


#################################
#
# Rules for the passwd_t domain.
#
#line 80



#line 82

#line 82
type passwd_t, domain, privlog, auth_write, privowner;
#line 82

#line 82
# for SSP
#line 82
allow passwd_t urandom_device_t:chr_file read;
#line 82

#line 82
allow passwd_t self:process setrlimit;
#line 82

#line 82

#line 82
# Access other processes in the same domain.
#line 82
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 82
# These must be granted separately if desired.
#line 82
allow passwd_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 82

#line 82
# Access /proc/PID files for processes in the same domain.
#line 82
allow passwd_t self:dir { read getattr lock search ioctl };
#line 82
allow passwd_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 82

#line 82
# Access file descriptions, pipes, and sockets
#line 82
# created by processes in the same domain.
#line 82
allow passwd_t self:fd *;
#line 82
allow passwd_t self:fifo_file { ioctl read getattr lock write append };
#line 82
allow passwd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 82
allow passwd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 82

#line 82
# Allow the domain to communicate with other processes in the same domain.
#line 82
allow passwd_t self:unix_dgram_socket sendto;
#line 82
allow passwd_t self:unix_stream_socket connectto;
#line 82

#line 82
# Access System V IPC objects created by processes in the same domain.
#line 82
allow passwd_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 82
allow passwd_t self:msg  { send receive };
#line 82
allow passwd_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 82
allow passwd_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 82
allow passwd_t unpriv_userdomain:fd use;
#line 82
#
#line 82
# Every app is asking for ypbind so I am adding this here, 
#line 82
# eventually this should become can_nsswitch
#line 82
#
#line 82

#line 82

#line 82
if (allow_ypbind) {
#line 82

#line 82

#line 82

#line 82

#line 82

#line 82

#line 82

#line 82
#
#line 82
# Allow the domain to create and use tcp sockets.
#line 82
# Other kinds of sockets must be separately authorized for use.
#line 82
allow passwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 82

#line 82
allow passwd_t unlabeled_t:association { sendto recvfrom };
#line 82

#line 82
#
#line 82
# Allow the domain to send or receive using any network interface.
#line 82
# netif_type is a type attribute for all network interface types.
#line 82
#
#line 82
allow passwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 82
#
#line 82
# Allow the domain to send to or receive from any node.
#line 82
# node_type is a type attribute for all node types.
#line 82
#
#line 82
allow passwd_t node_type:node { tcp_send rawip_send };
#line 82
allow passwd_t node_type:node { tcp_recv rawip_recv };
#line 82

#line 82
#
#line 82
# Allow the domain to send to or receive from any port.
#line 82
# port_type is a type attribute for all port types.
#line 82
#
#line 82

#line 82
allow passwd_t port_type:tcp_socket { send_msg recv_msg };
#line 82

#line 82

#line 82
# XXX Allow binding to any node type.  Remove once
#line 82
# individual rules have been added to all domains that 
#line 82
# bind sockets. 
#line 82
allow passwd_t node_type:tcp_socket node_bind;
#line 82
#
#line 82
# Allow access to network files including /etc/resolv.conf
#line 82
#
#line 82
allow passwd_t net_conf_t:file { read getattr lock ioctl };
#line 82

#line 82
allow passwd_t self:tcp_socket { listen accept };
#line 82

#line 82

#line 82

#line 82
#
#line 82
# Allow the domain to create and use tcp sockets.
#line 82
# Other kinds of sockets must be separately authorized for use.
#line 82
allow passwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 82

#line 82
allow passwd_t unlabeled_t:association { sendto recvfrom };
#line 82

#line 82
#
#line 82
# Allow the domain to send or receive using any network interface.
#line 82
# netif_type is a type attribute for all network interface types.
#line 82
#
#line 82
allow passwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 82
#
#line 82
# Allow the domain to send to or receive from any node.
#line 82
# node_type is a type attribute for all node types.
#line 82
#
#line 82
allow passwd_t node_type:node { tcp_send rawip_send };
#line 82
allow passwd_t node_type:node { tcp_recv rawip_recv };
#line 82

#line 82
#
#line 82
# Allow the domain to send to or receive from any port.
#line 82
# port_type is a type attribute for all port types.
#line 82
#
#line 82

#line 82
allow passwd_t port_type:tcp_socket { send_msg recv_msg };
#line 82

#line 82

#line 82
# XXX Allow binding to any node type.  Remove once
#line 82
# individual rules have been added to all domains that 
#line 82
# bind sockets. 
#line 82
allow passwd_t node_type:tcp_socket node_bind;
#line 82
#
#line 82
# Allow access to network files including /etc/resolv.conf
#line 82
#
#line 82
allow passwd_t net_conf_t:file { read getattr lock ioctl };
#line 82

#line 82
allow passwd_t self:tcp_socket { connect };
#line 82

#line 82

#line 82

#line 82

#line 82

#line 82
#
#line 82
# Allow the domain to create and use udp sockets.
#line 82
# Other kinds of sockets must be separately authorized for use.
#line 82
allow passwd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 82

#line 82
allow passwd_t unlabeled_t:association { sendto recvfrom };
#line 82

#line 82
#
#line 82
# Allow the domain to send or receive using any network interface.
#line 82
# netif_type is a type attribute for all network interface types.
#line 82
#
#line 82
allow passwd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 82
#
#line 82
# Allow the domain to send to or receive from any node.
#line 82
# node_type is a type attribute for all node types.
#line 82
#
#line 82
allow passwd_t node_type:node { udp_send rawip_send };
#line 82
allow passwd_t node_type:node { udp_recv rawip_recv };
#line 82

#line 82
#
#line 82
# Allow the domain to send to or receive from any port.
#line 82
# port_type is a type attribute for all port types.
#line 82
#
#line 82

#line 82
allow passwd_t port_type:udp_socket { send_msg recv_msg };
#line 82

#line 82

#line 82
# XXX Allow binding to any node type.  Remove once
#line 82
# individual rules have been added to all domains that 
#line 82
# bind sockets. 
#line 82
allow passwd_t node_type:udp_socket node_bind;
#line 82
#
#line 82
# Allow access to network files including /etc/resolv.conf
#line 82
#
#line 82
allow passwd_t net_conf_t:file { read getattr lock ioctl };
#line 82

#line 82
allow passwd_t self:udp_socket { connect };
#line 82

#line 82

#line 82

#line 82

#line 82

#line 82

#line 82
allow passwd_t var_yp_t:dir { read getattr lock search ioctl };
#line 82
allow passwd_t var_yp_t:file { read getattr lock ioctl };
#line 82
allow passwd_t var_yp_t:lnk_file { getattr read };
#line 82

#line 82
allow passwd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 82
allow passwd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 82
dontaudit passwd_t self:capability net_bind_service;
#line 82
dontaudit passwd_t reserved_port_type:tcp_socket name_connect;
#line 82
dontaudit passwd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 82

#line 82
} else {
#line 82
dontaudit passwd_t var_yp_t:dir search;
#line 82
}
#line 82
 
#line 82
allow passwd_t autofs_t:dir { search getattr };
#line 82
;
#line 82

#line 82
allow passwd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 82
allow passwd_t lib_t:lnk_file { read getattr lock ioctl };
#line 82
allow passwd_t ld_so_t:file { read getattr lock execute ioctl };
#line 82
#allow passwd_t ld_so_t:file execute_no_trans;
#line 82
allow passwd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 82
allow passwd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 82
allow passwd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 82
allow passwd_t texrel_shlib_t:file execmod;
#line 82
allow passwd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 82
allow passwd_t device_t:dir search;
#line 82
allow passwd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 82
;
#line 82

#line 82
# Inherit and use descriptors from login.
#line 82
allow passwd_t privfd:fd use;
#line 82

#line 82

#line 82

#line 82
allow passwd_t etc_t:lnk_file read;
#line 82
allow passwd_t lib_t:file { read getattr lock ioctl };
#line 82

#line 82
allow passwd_t locale_t:dir { read getattr lock search ioctl };
#line 82
allow passwd_t locale_t:file { read getattr lock ioctl };
#line 82
allow passwd_t locale_t:lnk_file { getattr read };
#line 82

#line 82

#line 82

#line 82
allow passwd_t fs_t:filesystem getattr;
#line 82

#line 82
# allow checking if a shell is executable
#line 82
allow passwd_t shell_exec_t:file execute;
#line 82

#line 82
# Obtain contexts
#line 82

#line 82
# Get the selinuxfs mount point via /proc/self/mounts.
#line 82
allow passwd_t proc_t:dir search;
#line 82
allow passwd_t proc_t:{ file lnk_file } { getattr read };
#line 82
allow passwd_t self:dir search;
#line 82
allow passwd_t self:file { getattr read };
#line 82
# Access selinuxfs.
#line 82
allow passwd_t security_t:dir { read search getattr };
#line 82
allow passwd_t security_t:file { getattr read write };
#line 82
allow passwd_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 82

#line 82

#line 82
allow passwd_t etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 82

#line 82
# read /etc/mtab
#line 82
allow passwd_t etc_runtime_t:file { getattr read };
#line 82

#line 82
# Allow etc_t symlinks for /etc/alternatives on Debian.
#line 82
allow passwd_t etc_t:lnk_file read;
#line 82

#line 82
# Use capabilities.
#line 82
allow passwd_t self:capability { chown dac_override fsetid setuid setgid sys_resource audit_control audit_write };
#line 82

#line 82
# Access terminals.
#line 82
allow passwd_t { ttyfile ptyfile }:chr_file { ioctl read getattr lock write append };
#line 82
allow passwd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 82

#line 82
dontaudit passwd_t devpts_t:dir getattr;
#line 82

#line 82
# /usr/bin/passwd asks for w access to utmp, but it will operate
#line 82
# correctly without it.  Do not audit write denials to utmp.
#line 82
dontaudit passwd_t initrc_var_run_t:file { read write };
#line 82

#line 82
# user generally runs this from their home directory, so do not audit a search
#line 82
# on user home dir
#line 82
dontaudit passwd_t { user_home_dir_type user_home_type }:dir search;
#line 82

#line 82
# When the wrong current passwd is entered, passwd, for some reason, 
#line 82
# attempts to access /proc and /dev, but handles failure appropriately. So
#line 82
# do not audit those denials.
#line 82
dontaudit passwd_t { proc_t device_t }:dir { search read };
#line 82

#line 82
allow passwd_t device_t:dir getattr;
#line 82

#line 82
# Read system variables in /sys.
#line 82

#line 82
allow passwd_t sysctl_t:dir search;
#line 82
allow passwd_t sysctl_kernel_t:dir search;
#line 82
allow passwd_t sysctl_kernel_t:file { getattr read };
#line 82

#line 82

#line 82

#line 82

#line 82
# Update /etc/shadow and /etc/passwd
#line 82

#line 82

#line 82

#line 82

#line 82
#
#line 82
# Allow the process to modify the directory.
#line 82
#
#line 82
allow passwd_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 82

#line 82
#
#line 82
# Allow the process to create the file.
#line 82
#
#line 82

#line 82

#line 82

#line 82

#line 82

#line 82
allow passwd_t shadow_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 82

#line 82

#line 82

#line 82

#line 82

#line 82

#line 82

#line 82

#line 82

#line 82
type_transition passwd_t etc_t:file shadow_t;
#line 82

#line 82

#line 82
allow passwd_t { etc_t shadow_t }:file { relabelfrom relabelto };
#line 82

#line 82
allow passwd_t self:process setfscreate;
#line 82
allow passwd_t proc_t:dir search;
#line 82
allow passwd_t proc_t:{ file lnk_file } read;
#line 82
allow passwd_t self:dir search;
#line 82
allow passwd_t self:file { getattr read write };
#line 82

#line 82


#line 83

#line 83
type sysadm_passwd_t, domain, privlog, auth_write, privowner;
#line 83

#line 83
# for SSP
#line 83
allow sysadm_passwd_t urandom_device_t:chr_file read;
#line 83

#line 83
allow sysadm_passwd_t self:process setrlimit;
#line 83

#line 83

#line 83
# Access other processes in the same domain.
#line 83
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 83
# These must be granted separately if desired.
#line 83
allow sysadm_passwd_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 83

#line 83
# Access /proc/PID files for processes in the same domain.
#line 83
allow sysadm_passwd_t self:dir { read getattr lock search ioctl };
#line 83
allow sysadm_passwd_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 83

#line 83
# Access file descriptions, pipes, and sockets
#line 83
# created by processes in the same domain.
#line 83
allow sysadm_passwd_t self:fd *;
#line 83
allow sysadm_passwd_t self:fifo_file { ioctl read getattr lock write append };
#line 83
allow sysadm_passwd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 83
allow sysadm_passwd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 83

#line 83
# Allow the domain to communicate with other processes in the same domain.
#line 83
allow sysadm_passwd_t self:unix_dgram_socket sendto;
#line 83
allow sysadm_passwd_t self:unix_stream_socket connectto;
#line 83

#line 83
# Access System V IPC objects created by processes in the same domain.
#line 83
allow sysadm_passwd_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 83
allow sysadm_passwd_t self:msg  { send receive };
#line 83
allow sysadm_passwd_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 83
allow sysadm_passwd_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 83
allow sysadm_passwd_t unpriv_userdomain:fd use;
#line 83
#
#line 83
# Every app is asking for ypbind so I am adding this here, 
#line 83
# eventually this should become can_nsswitch
#line 83
#
#line 83

#line 83

#line 83
if (allow_ypbind) {
#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83
#
#line 83
# Allow the domain to create and use tcp sockets.
#line 83
# Other kinds of sockets must be separately authorized for use.
#line 83
allow sysadm_passwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 83

#line 83
allow sysadm_passwd_t unlabeled_t:association { sendto recvfrom };
#line 83

#line 83
#
#line 83
# Allow the domain to send or receive using any network interface.
#line 83
# netif_type is a type attribute for all network interface types.
#line 83
#
#line 83
allow sysadm_passwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 83
#
#line 83
# Allow the domain to send to or receive from any node.
#line 83
# node_type is a type attribute for all node types.
#line 83
#
#line 83
allow sysadm_passwd_t node_type:node { tcp_send rawip_send };
#line 83
allow sysadm_passwd_t node_type:node { tcp_recv rawip_recv };
#line 83

#line 83
#
#line 83
# Allow the domain to send to or receive from any port.
#line 83
# port_type is a type attribute for all port types.
#line 83
#
#line 83

#line 83
allow sysadm_passwd_t port_type:tcp_socket { send_msg recv_msg };
#line 83

#line 83

#line 83
# XXX Allow binding to any node type.  Remove once
#line 83
# individual rules have been added to all domains that 
#line 83
# bind sockets. 
#line 83
allow sysadm_passwd_t node_type:tcp_socket node_bind;
#line 83
#
#line 83
# Allow access to network files including /etc/resolv.conf
#line 83
#
#line 83
allow sysadm_passwd_t net_conf_t:file { read getattr lock ioctl };
#line 83

#line 83
allow sysadm_passwd_t self:tcp_socket { listen accept };
#line 83

#line 83

#line 83

#line 83
#
#line 83
# Allow the domain to create and use tcp sockets.
#line 83
# Other kinds of sockets must be separately authorized for use.
#line 83
allow sysadm_passwd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 83

#line 83
allow sysadm_passwd_t unlabeled_t:association { sendto recvfrom };
#line 83

#line 83
#
#line 83
# Allow the domain to send or receive using any network interface.
#line 83
# netif_type is a type attribute for all network interface types.
#line 83
#
#line 83
allow sysadm_passwd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 83
#
#line 83
# Allow the domain to send to or receive from any node.
#line 83
# node_type is a type attribute for all node types.
#line 83
#
#line 83
allow sysadm_passwd_t node_type:node { tcp_send rawip_send };
#line 83
allow sysadm_passwd_t node_type:node { tcp_recv rawip_recv };
#line 83

#line 83
#
#line 83
# Allow the domain to send to or receive from any port.
#line 83
# port_type is a type attribute for all port types.
#line 83
#
#line 83

#line 83
allow sysadm_passwd_t port_type:tcp_socket { send_msg recv_msg };
#line 83

#line 83

#line 83
# XXX Allow binding to any node type.  Remove once
#line 83
# individual rules have been added to all domains that 
#line 83
# bind sockets. 
#line 83
allow sysadm_passwd_t node_type:tcp_socket node_bind;
#line 83
#
#line 83
# Allow access to network files including /etc/resolv.conf
#line 83
#
#line 83
allow sysadm_passwd_t net_conf_t:file { read getattr lock ioctl };
#line 83

#line 83
allow sysadm_passwd_t self:tcp_socket { connect };
#line 83

#line 83

#line 83

#line 83

#line 83

#line 83
#
#line 83
# Allow the domain to create and use udp sockets.
#line 83
# Other kinds of sockets must be separately authorized for use.
#line 83
allow sysadm_passwd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 83

#line 83
allow sysadm_passwd_t unlabeled_t:association { sendto recvfrom };
#line 83

#line 83
#
#line 83
# Allow the domain to send or receive using any network interface.
#line 83
# netif_type is a type attribute for all network interface types.
#line 83
#
#line 83
allow sysadm_passwd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 83
#
#line 83
# Allow the domain to send to or receive from any node.
#line 83
# node_type is a type attribute for all node types.
#line 83
#
#line 83
allow sysadm_passwd_t node_type:node { udp_send rawip_send };
#line 83
allow sysadm_passwd_t node_type:node { udp_recv rawip_recv };
#line 83

#line 83
#
#line 83
# Allow the domain to send to or receive from any port.
#line 83
# port_type is a type attribute for all port types.
#line 83
#
#line 83

#line 83
allow sysadm_passwd_t port_type:udp_socket { send_msg recv_msg };
#line 83

#line 83

#line 83
# XXX Allow binding to any node type.  Remove once
#line 83
# individual rules have been added to all domains that 
#line 83
# bind sockets. 
#line 83
allow sysadm_passwd_t node_type:udp_socket node_bind;
#line 83
#
#line 83
# Allow access to network files including /etc/resolv.conf
#line 83
#
#line 83
allow sysadm_passwd_t net_conf_t:file { read getattr lock ioctl };
#line 83

#line 83
allow sysadm_passwd_t self:udp_socket { connect };
#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83
allow sysadm_passwd_t var_yp_t:dir { read getattr lock search ioctl };
#line 83
allow sysadm_passwd_t var_yp_t:file { read getattr lock ioctl };
#line 83
allow sysadm_passwd_t var_yp_t:lnk_file { getattr read };
#line 83

#line 83
allow sysadm_passwd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 83
allow sysadm_passwd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 83
dontaudit sysadm_passwd_t self:capability net_bind_service;
#line 83
dontaudit sysadm_passwd_t reserved_port_type:tcp_socket name_connect;
#line 83
dontaudit sysadm_passwd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 83

#line 83
} else {
#line 83
dontaudit sysadm_passwd_t var_yp_t:dir search;
#line 83
}
#line 83
 
#line 83
allow sysadm_passwd_t autofs_t:dir { search getattr };
#line 83
;
#line 83

#line 83
allow sysadm_passwd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 83
allow sysadm_passwd_t lib_t:lnk_file { read getattr lock ioctl };
#line 83
allow sysadm_passwd_t ld_so_t:file { read getattr lock execute ioctl };
#line 83
#allow sysadm_passwd_t ld_so_t:file execute_no_trans;
#line 83
allow sysadm_passwd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 83
allow sysadm_passwd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 83
allow sysadm_passwd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 83
allow sysadm_passwd_t texrel_shlib_t:file execmod;
#line 83
allow sysadm_passwd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 83
allow sysadm_passwd_t device_t:dir search;
#line 83
allow sysadm_passwd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 83
;
#line 83

#line 83
# Inherit and use descriptors from login.
#line 83
allow sysadm_passwd_t privfd:fd use;
#line 83

#line 83

#line 83

#line 83
allow sysadm_passwd_t etc_t:lnk_file read;
#line 83
allow sysadm_passwd_t lib_t:file { read getattr lock ioctl };
#line 83

#line 83
allow sysadm_passwd_t locale_t:dir { read getattr lock search ioctl };
#line 83
allow sysadm_passwd_t locale_t:file { read getattr lock ioctl };
#line 83
allow sysadm_passwd_t locale_t:lnk_file { getattr read };
#line 83

#line 83

#line 83

#line 83
allow sysadm_passwd_t fs_t:filesystem getattr;
#line 83

#line 83
# allow checking if a shell is executable
#line 83
allow sysadm_passwd_t shell_exec_t:file execute;
#line 83

#line 83
# Obtain contexts
#line 83

#line 83
# Get the selinuxfs mount point via /proc/self/mounts.
#line 83
allow sysadm_passwd_t proc_t:dir search;
#line 83
allow sysadm_passwd_t proc_t:{ file lnk_file } { getattr read };
#line 83
allow sysadm_passwd_t self:dir search;
#line 83
allow sysadm_passwd_t self:file { getattr read };
#line 83
# Access selinuxfs.
#line 83
allow sysadm_passwd_t security_t:dir { read search getattr };
#line 83
allow sysadm_passwd_t security_t:file { getattr read write };
#line 83
allow sysadm_passwd_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 83

#line 83

#line 83
allow sysadm_passwd_t etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 83

#line 83
# read /etc/mtab
#line 83
allow sysadm_passwd_t etc_runtime_t:file { getattr read };
#line 83

#line 83
# Allow etc_t symlinks for /etc/alternatives on Debian.
#line 83
allow sysadm_passwd_t etc_t:lnk_file read;
#line 83

#line 83
# Use capabilities.
#line 83
allow sysadm_passwd_t self:capability { chown dac_override fsetid setuid setgid sys_resource audit_control audit_write };
#line 83

#line 83
# Access terminals.
#line 83
allow sysadm_passwd_t { ttyfile ptyfile }:chr_file { ioctl read getattr lock write append };
#line 83
allow sysadm_passwd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 83

#line 83
dontaudit sysadm_passwd_t devpts_t:dir getattr;
#line 83

#line 83
# /usr/bin/passwd asks for w access to utmp, but it will operate
#line 83
# correctly without it.  Do not audit write denials to utmp.
#line 83
dontaudit sysadm_passwd_t initrc_var_run_t:file { read write };
#line 83

#line 83
# user generally runs this from their home directory, so do not audit a search
#line 83
# on user home dir
#line 83
dontaudit sysadm_passwd_t { user_home_dir_type user_home_type }:dir search;
#line 83

#line 83
# When the wrong current passwd is entered, passwd, for some reason, 
#line 83
# attempts to access /proc and /dev, but handles failure appropriately. So
#line 83
# do not audit those denials.
#line 83
dontaudit sysadm_passwd_t { proc_t device_t }:dir { search read };
#line 83

#line 83
allow sysadm_passwd_t device_t:dir getattr;
#line 83

#line 83
# Read system variables in /sys.
#line 83

#line 83
allow sysadm_passwd_t sysctl_t:dir search;
#line 83
allow sysadm_passwd_t sysctl_kernel_t:dir search;
#line 83
allow sysadm_passwd_t sysctl_kernel_t:file { getattr read };
#line 83

#line 83

#line 83

#line 83

#line 83
# Update /etc/shadow and /etc/passwd
#line 83

#line 83

#line 83

#line 83

#line 83
#
#line 83
# Allow the process to modify the directory.
#line 83
#
#line 83
allow sysadm_passwd_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 83

#line 83
#
#line 83
# Allow the process to create the file.
#line 83
#
#line 83

#line 83

#line 83

#line 83

#line 83

#line 83
allow sysadm_passwd_t shadow_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83

#line 83
type_transition sysadm_passwd_t etc_t:file shadow_t;
#line 83

#line 83

#line 83
allow sysadm_passwd_t { etc_t shadow_t }:file { relabelfrom relabelto };
#line 83

#line 83
allow sysadm_passwd_t self:process setfscreate;
#line 83
allow sysadm_passwd_t proc_t:dir search;
#line 83
allow sysadm_passwd_t proc_t:{ file lnk_file } read;
#line 83
allow sysadm_passwd_t self:dir search;
#line 83
allow sysadm_passwd_t self:file { getattr read write };
#line 83

#line 83


#line 84
type chfn_t, domain, privlog, auth_chkpwd, etc_writer, privowner;
#line 84

#line 84
# for SSP
#line 84
allow chfn_t urandom_device_t:chr_file read;
#line 84

#line 84
allow chfn_t self:process setrlimit;
#line 84

#line 84

#line 84
# Access other processes in the same domain.
#line 84
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 84
# These must be granted separately if desired.
#line 84
allow chfn_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 84

#line 84
# Access /proc/PID files for processes in the same domain.
#line 84
allow chfn_t self:dir { read getattr lock search ioctl };
#line 84
allow chfn_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 84

#line 84
# Access file descriptions, pipes, and sockets
#line 84
# created by processes in the same domain.
#line 84
allow chfn_t self:fd *;
#line 84
allow chfn_t self:fifo_file { ioctl read getattr lock write append };
#line 84
allow chfn_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 84
allow chfn_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 84

#line 84
# Allow the domain to communicate with other processes in the same domain.
#line 84
allow chfn_t self:unix_dgram_socket sendto;
#line 84
allow chfn_t self:unix_stream_socket connectto;
#line 84

#line 84
# Access System V IPC objects created by processes in the same domain.
#line 84
allow chfn_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 84
allow chfn_t self:msg  { send receive };
#line 84
allow chfn_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 84
allow chfn_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 84
allow chfn_t unpriv_userdomain:fd use;
#line 84
#
#line 84
# Every app is asking for ypbind so I am adding this here, 
#line 84
# eventually this should become can_nsswitch
#line 84
#
#line 84

#line 84

#line 84
if (allow_ypbind) {
#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84
#
#line 84
# Allow the domain to create and use tcp sockets.
#line 84
# Other kinds of sockets must be separately authorized for use.
#line 84
allow chfn_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 84

#line 84
allow chfn_t unlabeled_t:association { sendto recvfrom };
#line 84

#line 84
#
#line 84
# Allow the domain to send or receive using any network interface.
#line 84
# netif_type is a type attribute for all network interface types.
#line 84
#
#line 84
allow chfn_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 84
#
#line 84
# Allow the domain to send to or receive from any node.
#line 84
# node_type is a type attribute for all node types.
#line 84
#
#line 84
allow chfn_t node_type:node { tcp_send rawip_send };
#line 84
allow chfn_t node_type:node { tcp_recv rawip_recv };
#line 84

#line 84
#
#line 84
# Allow the domain to send to or receive from any port.
#line 84
# port_type is a type attribute for all port types.
#line 84
#
#line 84

#line 84
allow chfn_t port_type:tcp_socket { send_msg recv_msg };
#line 84

#line 84

#line 84
# XXX Allow binding to any node type.  Remove once
#line 84
# individual rules have been added to all domains that 
#line 84
# bind sockets. 
#line 84
allow chfn_t node_type:tcp_socket node_bind;
#line 84
#
#line 84
# Allow access to network files including /etc/resolv.conf
#line 84
#
#line 84
allow chfn_t net_conf_t:file { read getattr lock ioctl };
#line 84

#line 84
allow chfn_t self:tcp_socket { listen accept };
#line 84

#line 84

#line 84

#line 84
#
#line 84
# Allow the domain to create and use tcp sockets.
#line 84
# Other kinds of sockets must be separately authorized for use.
#line 84
allow chfn_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 84

#line 84
allow chfn_t unlabeled_t:association { sendto recvfrom };
#line 84

#line 84
#
#line 84
# Allow the domain to send or receive using any network interface.
#line 84
# netif_type is a type attribute for all network interface types.
#line 84
#
#line 84
allow chfn_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 84
#
#line 84
# Allow the domain to send to or receive from any node.
#line 84
# node_type is a type attribute for all node types.
#line 84
#
#line 84
allow chfn_t node_type:node { tcp_send rawip_send };
#line 84
allow chfn_t node_type:node { tcp_recv rawip_recv };
#line 84

#line 84
#
#line 84
# Allow the domain to send to or receive from any port.
#line 84
# port_type is a type attribute for all port types.
#line 84
#
#line 84

#line 84
allow chfn_t port_type:tcp_socket { send_msg recv_msg };
#line 84

#line 84

#line 84
# XXX Allow binding to any node type.  Remove once
#line 84
# individual rules have been added to all domains that 
#line 84
# bind sockets. 
#line 84
allow chfn_t node_type:tcp_socket node_bind;
#line 84
#
#line 84
# Allow access to network files including /etc/resolv.conf
#line 84
#
#line 84
allow chfn_t net_conf_t:file { read getattr lock ioctl };
#line 84

#line 84
allow chfn_t self:tcp_socket { connect };
#line 84

#line 84

#line 84

#line 84

#line 84

#line 84
#
#line 84
# Allow the domain to create and use udp sockets.
#line 84
# Other kinds of sockets must be separately authorized for use.
#line 84
allow chfn_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 84

#line 84
allow chfn_t unlabeled_t:association { sendto recvfrom };
#line 84

#line 84
#
#line 84
# Allow the domain to send or receive using any network interface.
#line 84
# netif_type is a type attribute for all network interface types.
#line 84
#
#line 84
allow chfn_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 84
#
#line 84
# Allow the domain to send to or receive from any node.
#line 84
# node_type is a type attribute for all node types.
#line 84
#
#line 84
allow chfn_t node_type:node { udp_send rawip_send };
#line 84
allow chfn_t node_type:node { udp_recv rawip_recv };
#line 84

#line 84
#
#line 84
# Allow the domain to send to or receive from any port.
#line 84
# port_type is a type attribute for all port types.
#line 84
#
#line 84

#line 84
allow chfn_t port_type:udp_socket { send_msg recv_msg };
#line 84

#line 84

#line 84
# XXX Allow binding to any node type.  Remove once
#line 84
# individual rules have been added to all domains that 
#line 84
# bind sockets. 
#line 84
allow chfn_t node_type:udp_socket node_bind;
#line 84
#
#line 84
# Allow access to network files including /etc/resolv.conf
#line 84
#
#line 84
allow chfn_t net_conf_t:file { read getattr lock ioctl };
#line 84

#line 84
allow chfn_t self:udp_socket { connect };
#line 84

#line 84

#line 84

#line 84

#line 84

#line 84

#line 84
allow chfn_t var_yp_t:dir { read getattr lock search ioctl };
#line 84
allow chfn_t var_yp_t:file { read getattr lock ioctl };
#line 84
allow chfn_t var_yp_t:lnk_file { getattr read };
#line 84

#line 84
allow chfn_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 84
allow chfn_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 84
dontaudit chfn_t self:capability net_bind_service;
#line 84
dontaudit chfn_t reserved_port_type:tcp_socket name_connect;
#line 84
dontaudit chfn_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 84

#line 84
} else {
#line 84
dontaudit chfn_t var_yp_t:dir search;
#line 84
}
#line 84
 
#line 84
allow chfn_t autofs_t:dir { search getattr };
#line 84
;
#line 84

#line 84
allow chfn_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 84
allow chfn_t lib_t:lnk_file { read getattr lock ioctl };
#line 84
allow chfn_t ld_so_t:file { read getattr lock execute ioctl };
#line 84
#allow chfn_t ld_so_t:file execute_no_trans;
#line 84
allow chfn_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 84
allow chfn_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 84
allow chfn_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 84
allow chfn_t texrel_shlib_t:file execmod;
#line 84
allow chfn_t ld_so_cache_t:file { read getattr lock ioctl };
#line 84
allow chfn_t device_t:dir search;
#line 84
allow chfn_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 84
;
#line 84

#line 84
# Inherit and use descriptors from login.
#line 84
allow chfn_t privfd:fd use;
#line 84

#line 84

#line 84

#line 84
allow chfn_t etc_t:lnk_file read;
#line 84
allow chfn_t lib_t:file { read getattr lock ioctl };
#line 84

#line 84
allow chfn_t locale_t:dir { read getattr lock search ioctl };
#line 84
allow chfn_t locale_t:file { read getattr lock ioctl };
#line 84
allow chfn_t locale_t:lnk_file { getattr read };
#line 84

#line 84

#line 84

#line 84
allow chfn_t fs_t:filesystem getattr;
#line 84

#line 84
# allow checking if a shell is executable
#line 84
allow chfn_t shell_exec_t:file execute;
#line 84

#line 84
# Obtain contexts
#line 84

#line 84
# Get the selinuxfs mount point via /proc/self/mounts.
#line 84
allow chfn_t proc_t:dir search;
#line 84
allow chfn_t proc_t:{ file lnk_file } { getattr read };
#line 84
allow chfn_t self:dir search;
#line 84
allow chfn_t self:file { getattr read };
#line 84
# Access selinuxfs.
#line 84
allow chfn_t security_t:dir { read search getattr };
#line 84
allow chfn_t security_t:file { getattr read write };
#line 84
allow chfn_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 84

#line 84

#line 84
allow chfn_t etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 84

#line 84
# read /etc/mtab
#line 84
allow chfn_t etc_runtime_t:file { getattr read };
#line 84

#line 84
# Allow etc_t symlinks for /etc/alternatives on Debian.
#line 84
allow chfn_t etc_t:lnk_file read;
#line 84

#line 84
# Use capabilities.
#line 84
allow chfn_t self:capability { chown dac_override fsetid setuid setgid sys_resource audit_control audit_write };
#line 84

#line 84
# Access terminals.
#line 84
allow chfn_t { ttyfile ptyfile }:chr_file { ioctl read getattr lock write append };
#line 84
allow chfn_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 84

#line 84
dontaudit chfn_t devpts_t:dir getattr;
#line 84

#line 84
# /usr/bin/passwd asks for w access to utmp, but it will operate
#line 84
# correctly without it.  Do not audit write denials to utmp.
#line 84
dontaudit chfn_t initrc_var_run_t:file { read write };
#line 84

#line 84
# user generally runs this from their home directory, so do not audit a search
#line 84
# on user home dir
#line 84
dontaudit chfn_t { user_home_dir_type user_home_type }:dir search;
#line 84

#line 84
# When the wrong current passwd is entered, passwd, for some reason, 
#line 84
# attempts to access /proc and /dev, but handles failure appropriately. So
#line 84
# do not audit those denials.
#line 84
dontaudit chfn_t { proc_t device_t }:dir { search read };
#line 84

#line 84
allow chfn_t device_t:dir getattr;
#line 84

#line 84
# Read system variables in /sys.
#line 84

#line 84
allow chfn_t sysctl_t:dir search;
#line 84
allow chfn_t sysctl_kernel_t:dir search;
#line 84
allow chfn_t sysctl_kernel_t:file { getattr read };
#line 84

#line 84

#line 84

#line 84


#line 85
allow chfn_t self:process setfscreate;
#line 85
allow chfn_t proc_t:dir search;
#line 85
allow chfn_t proc_t:{ file lnk_file } read;
#line 85
allow chfn_t self:dir search;
#line 85
allow chfn_t self:file { getattr read write };
#line 85


# can exec /sbin/unix_chkpwd
allow chfn_t { bin_t sbin_t }:dir search;

# uses unix_chkpwd for checking passwords
dontaudit chfn_t shadow_t:file read;
allow chfn_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
allow chfn_t etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
allow chfn_t proc_t:file { getattr read };
allow chfn_t self:file write;


#line 97
role user_r types passwd_t;
#line 97
role staff_r types passwd_t;
#line 97


#line 98
role user_r types chfn_t;
#line 98
role staff_r types chfn_t;
#line 98

role sysadm_r types passwd_t;
role sysadm_r types sysadm_passwd_t;
role sysadm_r types chfn_t;
role system_r types passwd_t;
role system_r types chfn_t;

type admin_passwd_exec_t, file_type, sysadmfile;
type passwd_exec_t, file_type, sysadmfile, exec_type;
type chfn_exec_t, file_type, sysadmfile, exec_type;


#line 109

#line 109

#line 109
#
#line 109
# Allow the process to transition to the new domain.
#line 109
#
#line 109
allow { userdomain firstboot_t } passwd_t:process transition;
#line 109

#line 109
#
#line 109
# Do not audit when glibc secure mode is enabled upon the transition.
#line 109
#
#line 109
dontaudit { userdomain firstboot_t } passwd_t:process noatsecure;
#line 109

#line 109
#
#line 109
# Do not audit when signal-related state is cleared upon the transition.
#line 109
#
#line 109
dontaudit { userdomain firstboot_t } passwd_t:process siginh;
#line 109

#line 109
#
#line 109
# Do not audit when resource limits are reset upon the transition.
#line 109
#
#line 109
dontaudit { userdomain firstboot_t } passwd_t:process rlimitinh;
#line 109

#line 109
#
#line 109
# Allow the process to execute the program.
#line 109
# 
#line 109
allow { userdomain firstboot_t } passwd_exec_t:file { read { getattr execute } };
#line 109

#line 109
#
#line 109
# Allow the process to reap the new domain.
#line 109
#
#line 109
allow passwd_t { userdomain firstboot_t }:process sigchld;
#line 109

#line 109
#
#line 109
# Allow the new domain to inherit and use file 
#line 109
# descriptions from the creating process and vice versa.
#line 109
#
#line 109
allow passwd_t { userdomain firstboot_t }:fd use;
#line 109
allow { userdomain firstboot_t } passwd_t:fd use;
#line 109

#line 109
#
#line 109
# Allow the new domain to write back to the old domain via a pipe.
#line 109
#
#line 109
allow passwd_t { userdomain firstboot_t }:fifo_file { ioctl read getattr lock write append };
#line 109

#line 109
#
#line 109
# Allow the new domain to read and execute the program.
#line 109
#
#line 109
allow passwd_t passwd_exec_t:file { read getattr lock execute ioctl };
#line 109

#line 109
#
#line 109
# Allow the new domain to be entered via the program.
#line 109
#
#line 109
allow passwd_t passwd_exec_t:file entrypoint;
#line 109

#line 109
type_transition { userdomain firstboot_t } passwd_exec_t:process passwd_t;
#line 109


#line 110

#line 110

#line 110
#
#line 110
# Allow the process to transition to the new domain.
#line 110
#
#line 110
allow { userdomain firstboot_t } chfn_t:process transition;
#line 110

#line 110
#
#line 110
# Do not audit when glibc secure mode is enabled upon the transition.
#line 110
#
#line 110
dontaudit { userdomain firstboot_t } chfn_t:process noatsecure;
#line 110

#line 110
#
#line 110
# Do not audit when signal-related state is cleared upon the transition.
#line 110
#
#line 110
dontaudit { userdomain firstboot_t } chfn_t:process siginh;
#line 110

#line 110
#
#line 110
# Do not audit when resource limits are reset upon the transition.
#line 110
#
#line 110
dontaudit { userdomain firstboot_t } chfn_t:process rlimitinh;
#line 110

#line 110
#
#line 110
# Allow the process to execute the program.
#line 110
# 
#line 110
allow { userdomain firstboot_t } chfn_exec_t:file { read { getattr execute } };
#line 110

#line 110
#
#line 110
# Allow the process to reap the new domain.
#line 110
#
#line 110
allow chfn_t { userdomain firstboot_t }:process sigchld;
#line 110

#line 110
#
#line 110
# Allow the new domain to inherit and use file 
#line 110
# descriptions from the creating process and vice versa.
#line 110
#
#line 110
allow chfn_t { userdomain firstboot_t }:fd use;
#line 110
allow { userdomain firstboot_t } chfn_t:fd use;
#line 110

#line 110
#
#line 110
# Allow the new domain to write back to the old domain via a pipe.
#line 110
#
#line 110
allow chfn_t { userdomain firstboot_t }:fifo_file { ioctl read getattr lock write append };
#line 110

#line 110
#
#line 110
# Allow the new domain to read and execute the program.
#line 110
#
#line 110
allow chfn_t chfn_exec_t:file { read getattr lock execute ioctl };
#line 110

#line 110
#
#line 110
# Allow the new domain to be entered via the program.
#line 110
#
#line 110
allow chfn_t chfn_exec_t:file entrypoint;
#line 110

#line 110
type_transition { userdomain firstboot_t } chfn_exec_t:process chfn_t;
#line 110


#line 111

#line 111

#line 111
#
#line 111
# Allow the process to transition to the new domain.
#line 111
#
#line 111
allow sysadm_t sysadm_passwd_t:process transition;
#line 111

#line 111
#
#line 111
# Do not audit when glibc secure mode is enabled upon the transition.
#line 111
#
#line 111
dontaudit sysadm_t sysadm_passwd_t:process noatsecure;
#line 111

#line 111
#
#line 111
# Do not audit when signal-related state is cleared upon the transition.
#line 111
#
#line 111
dontaudit sysadm_t sysadm_passwd_t:process siginh;
#line 111

#line 111
#
#line 111
# Do not audit when resource limits are reset upon the transition.
#line 111
#
#line 111
dontaudit sysadm_t sysadm_passwd_t:process rlimitinh;
#line 111

#line 111
#
#line 111
# Allow the process to execute the program.
#line 111
# 
#line 111
allow sysadm_t admin_passwd_exec_t:file { read { getattr execute } };
#line 111

#line 111
#
#line 111
# Allow the process to reap the new domain.
#line 111
#
#line 111
allow sysadm_passwd_t sysadm_t:process sigchld;
#line 111

#line 111
#
#line 111
# Allow the new domain to inherit and use file 
#line 111
# descriptions from the creating process and vice versa.
#line 111
#
#line 111
allow sysadm_passwd_t sysadm_t:fd use;
#line 111
allow sysadm_t sysadm_passwd_t:fd use;
#line 111

#line 111
#
#line 111
# Allow the new domain to write back to the old domain via a pipe.
#line 111
#
#line 111
allow sysadm_passwd_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 111

#line 111
#
#line 111
# Allow the new domain to read and execute the program.
#line 111
#
#line 111
allow sysadm_passwd_t admin_passwd_exec_t:file { read getattr lock execute ioctl };
#line 111

#line 111
#
#line 111
# Allow the new domain to be entered via the program.
#line 111
#
#line 111
allow sysadm_passwd_t admin_passwd_exec_t:file entrypoint;
#line 111

#line 111
type_transition sysadm_t admin_passwd_exec_t:process sysadm_passwd_t;
#line 111


dontaudit chfn_t var_t:dir search;

#line 122

#line 122
dontaudit passwd_t var_t:dir search;
#line 122


# allow vipw to exec the editor
allow sysadm_passwd_t { root_t bin_t sbin_t }:dir search;
allow sysadm_passwd_t bin_t:lnk_file read;

#line 127
allow sysadm_passwd_t { shell_exec_t bin_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 127


#line 128
allow sysadm_passwd_t usr_t:dir { read getattr lock search ioctl };
#line 128
allow sysadm_passwd_t usr_t:file { read getattr lock ioctl };
#line 128
allow sysadm_passwd_t usr_t:lnk_file { getattr read };
#line 128


# allow vipw to create temporary files under /var/tmp/vi.recover
allow sysadm_passwd_t var_t:dir search;

#line 132
type sysadm_passwd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 132

#line 132

#line 132

#line 132

#line 132
#
#line 132
# Allow the process to modify the directory.
#line 132
#
#line 132
allow sysadm_passwd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 132

#line 132
#
#line 132
# Allow the process to create the file.
#line 132
#
#line 132

#line 132

#line 132

#line 132

#line 132

#line 132
allow sysadm_passwd_t sysadm_passwd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 132

#line 132

#line 132

#line 132

#line 132

#line 132

#line 132
allow sysadm_passwd_t sysadm_passwd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 132

#line 132

#line 132

#line 132

#line 132

#line 132

#line 132

#line 132

#line 132

#line 132

#line 132

#line 132
type_transition sysadm_passwd_t tmp_t:{ file dir } sysadm_passwd_tmp_t;
#line 132

#line 132

#line 132

# for vipw - vi looks in the root home directory for config
dontaudit sysadm_passwd_t sysadm_home_dir_t:dir { getattr search };
# for /etc/alternatives/vi
allow sysadm_passwd_t etc_t:lnk_file read;

# for nscd lookups
dontaudit sysadm_passwd_t var_run_t:dir search;

# for /proc/meminfo
allow sysadm_passwd_t proc_t:file { getattr read };

dontaudit { chfn_t passwd_t sysadm_passwd_t } selinux_config_t:dir search;
dontaudit sysadm_passwd_t devpts_t:dir search;

# make sure that getcon succeeds
allow passwd_t userdomain:dir search;
allow passwd_t userdomain:file { getattr read };
allow passwd_t userdomain:process getattr;

allow passwd_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };

#line 157

#line 157
role system_r types sysadm_passwd_t;
#line 157
allow sysadm_passwd_t devpts_t:chr_file { ioctl read getattr lock write append };
#line 157

#line 1 "domains/program/pegasus.te"
#DESC pegasus - The Open Group Pegasus CIM/WBEM Server 
#
# Author:  Jason Vas Dias <jvdias@redhat.com>
# Package: tog-pegasus
# 
#################################
#
# Rules for the pegasus domain
#

#line 10

#line 10

#line 10

#line 10
type pegasus_t, domain, privlog, daemon , nscd_client_domain, auth_chkpwd, transitionbool;
#line 10
type pegasus_exec_t, file_type, sysadmfile, exec_type;
#line 10
dontaudit pegasus_t self:capability sys_tty_config;
#line 10

#line 10
role system_r types pegasus_t;
#line 10

#line 10
# Inherit and use descriptors from init.
#line 10
allow pegasus_t init_t:fd use;
#line 10
allow pegasus_t init_t:process sigchld;
#line 10
allow pegasus_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 10

#line 10

#line 10
allow pegasus_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 10
allow pegasus_t lib_t:lnk_file { read getattr lock ioctl };
#line 10
allow pegasus_t ld_so_t:file { read getattr lock execute ioctl };
#line 10
#allow pegasus_t ld_so_t:file execute_no_trans;
#line 10
allow pegasus_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 10
allow pegasus_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 10
allow pegasus_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 10
allow pegasus_t texrel_shlib_t:file execmod;
#line 10
allow pegasus_t ld_so_cache_t:file { read getattr lock ioctl };
#line 10
allow pegasus_t device_t:dir search;
#line 10
allow pegasus_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 10

#line 10

#line 10
allow pegasus_t { self proc_t }:dir { read getattr lock search ioctl };
#line 10
allow pegasus_t { self proc_t }:lnk_file { getattr read };
#line 10

#line 10
allow pegasus_t device_t:dir { read getattr lock search ioctl };
#line 10

#line 10
allow pegasus_t udev_tdb_t:file { read getattr lock ioctl };
#line 10
allow pegasus_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 10
dontaudit pegasus_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 10
dontaudit pegasus_t unpriv_userdomain:fd use;
#line 10

#line 10

#line 10
allow pegasus_t sysfs_t:dir { read getattr lock search ioctl };
#line 10
allow pegasus_t sysfs_t:file { read getattr lock ioctl };
#line 10
allow pegasus_t sysfs_t:lnk_file { getattr read };
#line 10
 
#line 10

#line 10
allow pegasus_t autofs_t:dir { search getattr };
#line 10

#line 10
dontaudit pegasus_t { tty_device_t devpts_t }:chr_file { read write };
#line 10
dontaudit pegasus_t root_t:file { getattr read };
#line 10
 
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
# Read system variables in /sys.
#line 10

#line 10
allow pegasus_t sysctl_t:dir search;
#line 10
allow pegasus_t sysctl_kernel_t:dir search;
#line 10
allow pegasus_t sysctl_kernel_t:file { getattr read };
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
#
#line 10
# Allows user to define a tunable to disable domain transition
#line 10
#
#line 10

#line 10
bool pegasus_disable_trans false;
#line 10
if (pegasus_disable_trans) {
#line 10

#line 10
allow initrc_t pegasus_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 10

#line 10

#line 10
allow sysadm_t pegasus_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 10

#line 10
} else {
#line 10
 
#line 10

#line 10

#line 10
#
#line 10
# Allow the process to transition to the new domain.
#line 10
#
#line 10
allow initrc_t pegasus_t:process transition;
#line 10

#line 10
#
#line 10
# Do not audit when glibc secure mode is enabled upon the transition.
#line 10
#
#line 10
dontaudit initrc_t pegasus_t:process noatsecure;
#line 10

#line 10
#
#line 10
# Do not audit when signal-related state is cleared upon the transition.
#line 10
#
#line 10
dontaudit initrc_t pegasus_t:process siginh;
#line 10

#line 10
#
#line 10
# Do not audit when resource limits are reset upon the transition.
#line 10
#
#line 10
dontaudit initrc_t pegasus_t:process rlimitinh;
#line 10

#line 10
#
#line 10
# Allow the process to execute the program.
#line 10
# 
#line 10
allow initrc_t pegasus_exec_t:file { read { getattr execute } };
#line 10

#line 10
#
#line 10
# Allow the process to reap the new domain.
#line 10
#
#line 10
allow pegasus_t initrc_t:process sigchld;
#line 10

#line 10
#
#line 10
# Allow the new domain to inherit and use file 
#line 10
# descriptions from the creating process and vice versa.
#line 10
#
#line 10
allow pegasus_t initrc_t:fd use;
#line 10
allow initrc_t pegasus_t:fd use;
#line 10

#line 10
#
#line 10
# Allow the new domain to write back to the old domain via a pipe.
#line 10
#
#line 10
allow pegasus_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 10

#line 10
#
#line 10
# Allow the new domain to read and execute the program.
#line 10
#
#line 10
allow pegasus_t pegasus_exec_t:file { read getattr lock execute ioctl };
#line 10

#line 10
#
#line 10
# Allow the new domain to be entered via the program.
#line 10
#
#line 10
allow pegasus_t pegasus_exec_t:file entrypoint;
#line 10

#line 10
type_transition initrc_t pegasus_exec_t:process pegasus_t;
#line 10

#line 10

#line 10
allow initrc_t pegasus_t:process { noatsecure siginh rlimitinh };
#line 10

#line 10
}
#line 10
 
#line 10
allow pegasus_t privfd:fd use;
#line 10

#line 10
allow pegasus_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 10

#line 10

#line 10
# Create pid file.
#line 10
allow pegasus_t var_t:dir { getattr search };
#line 10

#line 10
type pegasus_var_run_t, file_type, sysadmfile, pidfile;
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
#
#line 10
# Allow the process to modify the directory.
#line 10
#
#line 10
allow pegasus_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 10

#line 10
#
#line 10
# Allow the process to create the file.
#line 10
#
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
allow pegasus_t pegasus_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
type_transition pegasus_t var_run_t:file pegasus_var_run_t;
#line 10

#line 10

#line 10

#line 10
allow pegasus_t var_t:dir search;
#line 10
allow pegasus_t pegasus_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 10

#line 10

#line 10
allow pegasus_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 10

#line 10
# for daemons that look at /root on startup
#line 10
dontaudit pegasus_t sysadm_home_dir_t:dir search;
#line 10

#line 10
# for df
#line 10
allow pegasus_t fs_type:filesystem getattr;
#line 10
allow pegasus_t removable_t:filesystem getattr;
#line 10

#line 10

#line 10
allow pegasus_t etc_t:lnk_file read;
#line 10
allow pegasus_t lib_t:file { read getattr lock ioctl };
#line 10

#line 10
allow pegasus_t locale_t:dir { read getattr lock search ioctl };
#line 10
allow pegasus_t locale_t:file { read getattr lock ioctl };
#line 10
allow pegasus_t locale_t:lnk_file { getattr read };
#line 10

#line 10

#line 10

#line 10
# for localization
#line 10
allow pegasus_t lib_t:file { getattr read };
#line 10

type pegasus_data_t, file_type, sysadmfile;
type pegasus_conf_t, file_type, sysadmfile;
typealias sbin_t alias pegasus_conf_exec_t;
type pegasus_mof_t, file_type, sysadmfile;
allow pegasus_t self:capability { dac_override net_bind_service audit_write }; 

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow pegasus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow pegasus_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow pegasus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow pegasus_t node_type:node { tcp_send rawip_send };
#line 16
allow pegasus_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow pegasus_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow pegasus_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow pegasus_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow pegasus_t self:tcp_socket { listen accept };
#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow pegasus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow pegasus_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow pegasus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow pegasus_t node_type:node { tcp_send rawip_send };
#line 16
allow pegasus_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow pegasus_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow pegasus_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow pegasus_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow pegasus_t self:tcp_socket { connect };
#line 16

#line 16

#line 16
;

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the domain to create and use tcp sockets.
#line 17
# Other kinds of sockets must be separately authorized for use.
#line 17
allow pegasus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 17

#line 17
allow pegasus_t unlabeled_t:association { sendto recvfrom };
#line 17

#line 17
#
#line 17
# Allow the domain to send or receive using any network interface.
#line 17
# netif_type is a type attribute for all network interface types.
#line 17
#
#line 17
allow pegasus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 17
#
#line 17
# Allow the domain to send to or receive from any node.
#line 17
# node_type is a type attribute for all node types.
#line 17
#
#line 17
allow pegasus_t node_type:node { tcp_send rawip_send };
#line 17
allow pegasus_t node_type:node { tcp_recv rawip_recv };
#line 17

#line 17
#
#line 17
# Allow the domain to send to or receive from any port.
#line 17
# port_type is a type attribute for all port types.
#line 17
#
#line 17

#line 17
allow pegasus_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 17

#line 17

#line 17
# XXX Allow binding to any node type.  Remove once
#line 17
# individual rules have been added to all domains that 
#line 17
# bind sockets. 
#line 17
allow pegasus_t node_type:tcp_socket node_bind;
#line 17
#
#line 17
# Allow access to network files including /etc/resolv.conf
#line 17
#
#line 17
allow pegasus_t net_conf_t:file { read getattr lock ioctl };
#line 17

#line 17
allow pegasus_t self:tcp_socket { connect };
#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the domain to create and use udp sockets.
#line 17
# Other kinds of sockets must be separately authorized for use.
#line 17
allow pegasus_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 17

#line 17
allow pegasus_t unlabeled_t:association { sendto recvfrom };
#line 17

#line 17
#
#line 17
# Allow the domain to send or receive using any network interface.
#line 17
# netif_type is a type attribute for all network interface types.
#line 17
#
#line 17
allow pegasus_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 17
#
#line 17
# Allow the domain to send to or receive from any node.
#line 17
# node_type is a type attribute for all node types.
#line 17
#
#line 17
allow pegasus_t node_type:node { udp_send rawip_send };
#line 17
allow pegasus_t node_type:node { udp_recv rawip_recv };
#line 17

#line 17
#
#line 17
# Allow the domain to send to or receive from any port.
#line 17
# port_type is a type attribute for all port types.
#line 17
#
#line 17

#line 17
allow pegasus_t dns_port_t:udp_socket { send_msg recv_msg };
#line 17

#line 17

#line 17
# XXX Allow binding to any node type.  Remove once
#line 17
# individual rules have been added to all domains that 
#line 17
# bind sockets. 
#line 17
allow pegasus_t node_type:udp_socket node_bind;
#line 17
#
#line 17
# Allow access to network files including /etc/resolv.conf
#line 17
#
#line 17
allow pegasus_t net_conf_t:file { read getattr lock ioctl };
#line 17

#line 17
allow pegasus_t self:udp_socket { connect };
#line 17

#line 17

#line 17

#line 17
allow pegasus_t dns_port_t:tcp_socket name_connect;
#line 17

#line 17

#line 17

#line 17
if (allow_ypbind) {
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the domain to create and use tcp sockets.
#line 17
# Other kinds of sockets must be separately authorized for use.
#line 17
allow pegasus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 17

#line 17
allow pegasus_t unlabeled_t:association { sendto recvfrom };
#line 17

#line 17
#
#line 17
# Allow the domain to send or receive using any network interface.
#line 17
# netif_type is a type attribute for all network interface types.
#line 17
#
#line 17
allow pegasus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 17
#
#line 17
# Allow the domain to send to or receive from any node.
#line 17
# node_type is a type attribute for all node types.
#line 17
#
#line 17
allow pegasus_t node_type:node { tcp_send rawip_send };
#line 17
allow pegasus_t node_type:node { tcp_recv rawip_recv };
#line 17

#line 17
#
#line 17
# Allow the domain to send to or receive from any port.
#line 17
# port_type is a type attribute for all port types.
#line 17
#
#line 17

#line 17
allow pegasus_t port_type:tcp_socket { send_msg recv_msg };
#line 17

#line 17

#line 17
# XXX Allow binding to any node type.  Remove once
#line 17
# individual rules have been added to all domains that 
#line 17
# bind sockets. 
#line 17
allow pegasus_t node_type:tcp_socket node_bind;
#line 17
#
#line 17
# Allow access to network files including /etc/resolv.conf
#line 17
#
#line 17
allow pegasus_t net_conf_t:file { read getattr lock ioctl };
#line 17

#line 17
allow pegasus_t self:tcp_socket { listen accept };
#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the domain to create and use tcp sockets.
#line 17
# Other kinds of sockets must be separately authorized for use.
#line 17
allow pegasus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 17

#line 17
allow pegasus_t unlabeled_t:association { sendto recvfrom };
#line 17

#line 17
#
#line 17
# Allow the domain to send or receive using any network interface.
#line 17
# netif_type is a type attribute for all network interface types.
#line 17
#
#line 17
allow pegasus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 17
#
#line 17
# Allow the domain to send to or receive from any node.
#line 17
# node_type is a type attribute for all node types.
#line 17
#
#line 17
allow pegasus_t node_type:node { tcp_send rawip_send };
#line 17
allow pegasus_t node_type:node { tcp_recv rawip_recv };
#line 17

#line 17
#
#line 17
# Allow the domain to send to or receive from any port.
#line 17
# port_type is a type attribute for all port types.
#line 17
#
#line 17

#line 17
allow pegasus_t port_type:tcp_socket { send_msg recv_msg };
#line 17

#line 17

#line 17
# XXX Allow binding to any node type.  Remove once
#line 17
# individual rules have been added to all domains that 
#line 17
# bind sockets. 
#line 17
allow pegasus_t node_type:tcp_socket node_bind;
#line 17
#
#line 17
# Allow access to network files including /etc/resolv.conf
#line 17
#
#line 17
allow pegasus_t net_conf_t:file { read getattr lock ioctl };
#line 17

#line 17
allow pegasus_t self:tcp_socket { connect };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the domain to create and use udp sockets.
#line 17
# Other kinds of sockets must be separately authorized for use.
#line 17
allow pegasus_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 17

#line 17
allow pegasus_t unlabeled_t:association { sendto recvfrom };
#line 17

#line 17
#
#line 17
# Allow the domain to send or receive using any network interface.
#line 17
# netif_type is a type attribute for all network interface types.
#line 17
#
#line 17
allow pegasus_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 17
#
#line 17
# Allow the domain to send to or receive from any node.
#line 17
# node_type is a type attribute for all node types.
#line 17
#
#line 17
allow pegasus_t node_type:node { udp_send rawip_send };
#line 17
allow pegasus_t node_type:node { udp_recv rawip_recv };
#line 17

#line 17
#
#line 17
# Allow the domain to send to or receive from any port.
#line 17
# port_type is a type attribute for all port types.
#line 17
#
#line 17

#line 17
allow pegasus_t port_type:udp_socket { send_msg recv_msg };
#line 17

#line 17

#line 17
# XXX Allow binding to any node type.  Remove once
#line 17
# individual rules have been added to all domains that 
#line 17
# bind sockets. 
#line 17
allow pegasus_t node_type:udp_socket node_bind;
#line 17
#
#line 17
# Allow access to network files including /etc/resolv.conf
#line 17
#
#line 17
allow pegasus_t net_conf_t:file { read getattr lock ioctl };
#line 17

#line 17
allow pegasus_t self:udp_socket { connect };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow pegasus_t var_yp_t:dir { read getattr lock search ioctl };
#line 17
allow pegasus_t var_yp_t:file { read getattr lock ioctl };
#line 17
allow pegasus_t var_yp_t:lnk_file { getattr read };
#line 17

#line 17
allow pegasus_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 17
allow pegasus_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 17
dontaudit pegasus_t self:capability net_bind_service;
#line 17
dontaudit pegasus_t reserved_port_type:tcp_socket name_connect;
#line 17
dontaudit pegasus_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 17

#line 17
} else {
#line 17
dontaudit pegasus_t var_yp_t:dir search;
#line 17
}
#line 17
 
#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the domain to create and use tcp sockets.
#line 17
# Other kinds of sockets must be separately authorized for use.
#line 17
allow pegasus_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 17

#line 17
allow pegasus_t unlabeled_t:association { sendto recvfrom };
#line 17

#line 17
#
#line 17
# Allow the domain to send or receive using any network interface.
#line 17
# netif_type is a type attribute for all network interface types.
#line 17
#
#line 17
allow pegasus_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 17
#
#line 17
# Allow the domain to send to or receive from any node.
#line 17
# node_type is a type attribute for all node types.
#line 17
#
#line 17
allow pegasus_t node_type:node { tcp_send rawip_send };
#line 17
allow pegasus_t node_type:node { tcp_recv rawip_recv };
#line 17

#line 17
#
#line 17
# Allow the domain to send to or receive from any port.
#line 17
# port_type is a type attribute for all port types.
#line 17
#
#line 17

#line 17
allow pegasus_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 17

#line 17

#line 17
# XXX Allow binding to any node type.  Remove once
#line 17
# individual rules have been added to all domains that 
#line 17
# bind sockets. 
#line 17
allow pegasus_t node_type:tcp_socket node_bind;
#line 17
#
#line 17
# Allow access to network files including /etc/resolv.conf
#line 17
#
#line 17
allow pegasus_t net_conf_t:file { read getattr lock ioctl };
#line 17

#line 17
allow pegasus_t self:tcp_socket { connect };
#line 17

#line 17
allow pegasus_t ldap_port_t:tcp_socket name_connect;
#line 17

#line 17

#line 17

#line 17
allow pegasus_t winbind_var_run_t:dir { getattr search };
#line 17
allow pegasus_t winbind_t:unix_stream_socket connectto;
#line 17
allow pegasus_t winbind_var_run_t:sock_file { getattr read write };
#line 17

#line 17

#line 17
;
allow pegasus_t pegasus_var_run_t:sock_file { create setattr };
allow pegasus_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow pegasus_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow pegasus_t self:file { read getattr };
allow pegasus_t self:fifo_file { ioctl read getattr lock write append };
allow pegasus_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };
allow pegasus_t { pegasus_http_port_t pegasus_https_port_t }:tcp_socket { name_bind name_connect };
allow pegasus_t proc_t:file { getattr read };
allow pegasus_t sysctl_vm_t:dir search;
allow pegasus_t initrc_var_run_t:file { read write lock };
allow pegasus_t urandom_device_t:chr_file { getattr read };

#line 29
allow pegasus_t etc_t:dir { read getattr lock search ioctl };
#line 29
allow pegasus_t etc_t:file { read getattr lock ioctl };
#line 29
allow pegasus_t etc_t:lnk_file { getattr read };
#line 29


#line 30
allow pegasus_t var_lib_t:dir { read getattr lock search ioctl };
#line 30
allow pegasus_t var_lib_t:file { read getattr lock ioctl };
#line 30
allow pegasus_t var_lib_t:lnk_file { getattr read };
#line 30


#line 31
allow pegasus_t pegasus_mof_t:dir { read getattr lock search ioctl };
#line 31
allow pegasus_t pegasus_mof_t:file { read getattr lock ioctl };
#line 31
allow pegasus_t pegasus_mof_t:lnk_file { getattr read };
#line 31

allow pegasus_t pegasus_conf_t:file { link unlink };

#line 33
allow pegasus_t pegasus_conf_t:dir { read getattr lock search ioctl };
#line 33
allow pegasus_t pegasus_conf_t:file { read getattr lock ioctl };
#line 33
allow pegasus_t pegasus_conf_t:lnk_file { getattr read };
#line 33


#line 34

#line 34

#line 34

#line 34
#
#line 34
# Allow the process to modify the directory.
#line 34
#
#line 34
allow pegasus_t pegasus_conf_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 34

#line 34
#
#line 34
# Allow the process to create the file.
#line 34
#
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
allow pegasus_t pegasus_data_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
allow pegasus_t pegasus_data_t:lnk_file { create read getattr setattr link unlink rename };
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
allow pegasus_t pegasus_data_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
allow pegasus_t pegasus_data_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
allow pegasus_t pegasus_data_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
type_transition pegasus_t pegasus_conf_t:dir pegasus_data_t;
#line 34
type_transition pegasus_t pegasus_conf_t:{ file lnk_file sock_file fifo_file } pegasus_data_t;
#line 34

#line 34


#line 35
allow pegasus_t pegasus_data_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 35
allow pegasus_t pegasus_data_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 35
allow pegasus_t pegasus_data_t:lnk_file { create read getattr setattr link unlink rename };
#line 35

dontaudit pegasus_t selinux_config_t:dir search;
#line 1 "domains/program/ping.te"
#DESC Ping - Send ICMP messages to network hosts
#
# Author:  David A. Wheeler <dwheeler@ida.org>
# X-Debian-Packages: iputils-ping netkit-ping iputils-arping arping hping2
#

#################################
#
# Rules for the ping_t domain.
#
# ping_t is the domain for the ping program.
# ping_exec_t is the type of the corresponding program.
#
type ping_t, domain, privlog, nscd_client_domain;
role sysadm_r types ping_t;
role system_r types ping_t;

#line 17
role user_r types ping_t;
#line 17
role staff_r types ping_t;
#line 17

type ping_exec_t, file_type, sysadmfile, exec_type;

#line 31

#line 31
	allow ping_t { devpts_t ttyfile ptyfile }:chr_file { ioctl read getattr lock write append };
#line 31


# Transition into this domain when you run this program.

#line 34

#line 34

#line 34
#
#line 34
# Allow the process to transition to the new domain.
#line 34
#
#line 34
allow sysadm_t ping_t:process transition;
#line 34

#line 34
#
#line 34
# Do not audit when glibc secure mode is enabled upon the transition.
#line 34
#
#line 34
dontaudit sysadm_t ping_t:process noatsecure;
#line 34

#line 34
#
#line 34
# Do not audit when signal-related state is cleared upon the transition.
#line 34
#
#line 34
dontaudit sysadm_t ping_t:process siginh;
#line 34

#line 34
#
#line 34
# Do not audit when resource limits are reset upon the transition.
#line 34
#
#line 34
dontaudit sysadm_t ping_t:process rlimitinh;
#line 34

#line 34
#
#line 34
# Allow the process to execute the program.
#line 34
# 
#line 34
allow sysadm_t ping_exec_t:file { read { getattr execute } };
#line 34

#line 34
#
#line 34
# Allow the process to reap the new domain.
#line 34
#
#line 34
allow ping_t sysadm_t:process sigchld;
#line 34

#line 34
#
#line 34
# Allow the new domain to inherit and use file 
#line 34
# descriptions from the creating process and vice versa.
#line 34
#
#line 34
allow ping_t sysadm_t:fd use;
#line 34
allow sysadm_t ping_t:fd use;
#line 34

#line 34
#
#line 34
# Allow the new domain to write back to the old domain via a pipe.
#line 34
#
#line 34
allow ping_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 34

#line 34
#
#line 34
# Allow the new domain to read and execute the program.
#line 34
#
#line 34
allow ping_t ping_exec_t:file { read getattr lock execute ioctl };
#line 34

#line 34
#
#line 34
# Allow the new domain to be entered via the program.
#line 34
#
#line 34
allow ping_t ping_exec_t:file entrypoint;
#line 34

#line 34
type_transition sysadm_t ping_exec_t:process ping_t;
#line 34


#line 35

#line 35

#line 35
#
#line 35
# Allow the process to transition to the new domain.
#line 35
#
#line 35
allow initrc_t ping_t:process transition;
#line 35

#line 35
#
#line 35
# Do not audit when glibc secure mode is enabled upon the transition.
#line 35
#
#line 35
dontaudit initrc_t ping_t:process noatsecure;
#line 35

#line 35
#
#line 35
# Do not audit when signal-related state is cleared upon the transition.
#line 35
#
#line 35
dontaudit initrc_t ping_t:process siginh;
#line 35

#line 35
#
#line 35
# Do not audit when resource limits are reset upon the transition.
#line 35
#
#line 35
dontaudit initrc_t ping_t:process rlimitinh;
#line 35

#line 35
#
#line 35
# Allow the process to execute the program.
#line 35
# 
#line 35
allow initrc_t ping_exec_t:file { read { getattr execute } };
#line 35

#line 35
#
#line 35
# Allow the process to reap the new domain.
#line 35
#
#line 35
allow ping_t initrc_t:process sigchld;
#line 35

#line 35
#
#line 35
# Allow the new domain to inherit and use file 
#line 35
# descriptions from the creating process and vice versa.
#line 35
#
#line 35
allow ping_t initrc_t:fd use;
#line 35
allow initrc_t ping_t:fd use;
#line 35

#line 35
#
#line 35
# Allow the new domain to write back to the old domain via a pipe.
#line 35
#
#line 35
allow ping_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 35

#line 35
#
#line 35
# Allow the new domain to read and execute the program.
#line 35
#
#line 35
allow ping_t ping_exec_t:file { read getattr lock execute ioctl };
#line 35

#line 35
#
#line 35
# Allow the new domain to be entered via the program.
#line 35
#
#line 35
allow ping_t ping_exec_t:file entrypoint;
#line 35

#line 35
type_transition initrc_t ping_exec_t:process ping_t;
#line 35



#line 37
allow ping_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 37
allow ping_t lib_t:lnk_file { read getattr lock ioctl };
#line 37
allow ping_t ld_so_t:file { read getattr lock execute ioctl };
#line 37
#allow ping_t ld_so_t:file execute_no_trans;
#line 37
allow ping_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 37
allow ping_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 37
allow ping_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 37
allow ping_t texrel_shlib_t:file execmod;
#line 37
allow ping_t ld_so_cache_t:file { read getattr lock ioctl };
#line 37
allow ping_t device_t:dir search;
#line 37
allow ping_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 37


#line 38

#line 38

#line 38

#line 38
#
#line 38
# Allow the domain to create and use tcp sockets.
#line 38
# Other kinds of sockets must be separately authorized for use.
#line 38
allow ping_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 38

#line 38
allow ping_t unlabeled_t:association { sendto recvfrom };
#line 38

#line 38
#
#line 38
# Allow the domain to send or receive using any network interface.
#line 38
# netif_type is a type attribute for all network interface types.
#line 38
#
#line 38
allow ping_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 38
#
#line 38
# Allow the domain to send to or receive from any node.
#line 38
# node_type is a type attribute for all node types.
#line 38
#
#line 38
allow ping_t node_type:node { tcp_send rawip_send };
#line 38
allow ping_t node_type:node { tcp_recv rawip_recv };
#line 38

#line 38
#
#line 38
# Allow the domain to send to or receive from any port.
#line 38
# port_type is a type attribute for all port types.
#line 38
#
#line 38

#line 38
allow ping_t port_type:tcp_socket { send_msg recv_msg };
#line 38

#line 38

#line 38
# XXX Allow binding to any node type.  Remove once
#line 38
# individual rules have been added to all domains that 
#line 38
# bind sockets. 
#line 38
allow ping_t node_type:tcp_socket node_bind;
#line 38
#
#line 38
# Allow access to network files including /etc/resolv.conf
#line 38
#
#line 38
allow ping_t net_conf_t:file { read getattr lock ioctl };
#line 38

#line 38
allow ping_t self:tcp_socket { connect };
#line 38

#line 38

#line 38

#line 38
#
#line 38
# Allow the domain to create and use udp sockets.
#line 38
# Other kinds of sockets must be separately authorized for use.
#line 38
allow ping_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 38

#line 38
allow ping_t unlabeled_t:association { sendto recvfrom };
#line 38

#line 38
#
#line 38
# Allow the domain to send or receive using any network interface.
#line 38
# netif_type is a type attribute for all network interface types.
#line 38
#
#line 38
allow ping_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 38
#
#line 38
# Allow the domain to send to or receive from any node.
#line 38
# node_type is a type attribute for all node types.
#line 38
#
#line 38
allow ping_t node_type:node { udp_send rawip_send };
#line 38
allow ping_t node_type:node { udp_recv rawip_recv };
#line 38

#line 38
#
#line 38
# Allow the domain to send to or receive from any port.
#line 38
# port_type is a type attribute for all port types.
#line 38
#
#line 38

#line 38
allow ping_t port_type:udp_socket { send_msg recv_msg };
#line 38

#line 38

#line 38
# XXX Allow binding to any node type.  Remove once
#line 38
# individual rules have been added to all domains that 
#line 38
# bind sockets. 
#line 38
allow ping_t node_type:udp_socket node_bind;
#line 38
#
#line 38
# Allow access to network files including /etc/resolv.conf
#line 38
#
#line 38
allow ping_t net_conf_t:file { read getattr lock ioctl };
#line 38

#line 38
allow ping_t self:udp_socket { connect };
#line 38

#line 38

#line 38


#line 39

#line 39

#line 39

#line 39

#line 39
#
#line 39
# Allow the domain to create and use tcp sockets.
#line 39
# Other kinds of sockets must be separately authorized for use.
#line 39
allow ping_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 39

#line 39
allow ping_t unlabeled_t:association { sendto recvfrom };
#line 39

#line 39
#
#line 39
# Allow the domain to send or receive using any network interface.
#line 39
# netif_type is a type attribute for all network interface types.
#line 39
#
#line 39
allow ping_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 39
#
#line 39
# Allow the domain to send to or receive from any node.
#line 39
# node_type is a type attribute for all node types.
#line 39
#
#line 39
allow ping_t node_type:node { tcp_send rawip_send };
#line 39
allow ping_t node_type:node { tcp_recv rawip_recv };
#line 39

#line 39
#
#line 39
# Allow the domain to send to or receive from any port.
#line 39
# port_type is a type attribute for all port types.
#line 39
#
#line 39

#line 39
allow ping_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 39

#line 39

#line 39
# XXX Allow binding to any node type.  Remove once
#line 39
# individual rules have been added to all domains that 
#line 39
# bind sockets. 
#line 39
allow ping_t node_type:tcp_socket node_bind;
#line 39
#
#line 39
# Allow access to network files including /etc/resolv.conf
#line 39
#
#line 39
allow ping_t net_conf_t:file { read getattr lock ioctl };
#line 39

#line 39
allow ping_t self:tcp_socket { connect };
#line 39

#line 39

#line 39

#line 39
#
#line 39
# Allow the domain to create and use udp sockets.
#line 39
# Other kinds of sockets must be separately authorized for use.
#line 39
allow ping_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 39

#line 39
allow ping_t unlabeled_t:association { sendto recvfrom };
#line 39

#line 39
#
#line 39
# Allow the domain to send or receive using any network interface.
#line 39
# netif_type is a type attribute for all network interface types.
#line 39
#
#line 39
allow ping_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 39
#
#line 39
# Allow the domain to send to or receive from any node.
#line 39
# node_type is a type attribute for all node types.
#line 39
#
#line 39
allow ping_t node_type:node { udp_send rawip_send };
#line 39
allow ping_t node_type:node { udp_recv rawip_recv };
#line 39

#line 39
#
#line 39
# Allow the domain to send to or receive from any port.
#line 39
# port_type is a type attribute for all port types.
#line 39
#
#line 39

#line 39
allow ping_t dns_port_t:udp_socket { send_msg recv_msg };
#line 39

#line 39

#line 39
# XXX Allow binding to any node type.  Remove once
#line 39
# individual rules have been added to all domains that 
#line 39
# bind sockets. 
#line 39
allow ping_t node_type:udp_socket node_bind;
#line 39
#
#line 39
# Allow access to network files including /etc/resolv.conf
#line 39
#
#line 39
allow ping_t net_conf_t:file { read getattr lock ioctl };
#line 39

#line 39
allow ping_t self:udp_socket { connect };
#line 39

#line 39

#line 39

#line 39
allow ping_t dns_port_t:tcp_socket name_connect;
#line 39


#line 40

#line 40
if (allow_ypbind) {
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use tcp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow ping_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow ping_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow ping_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow ping_t node_type:node { tcp_send rawip_send };
#line 40
allow ping_t node_type:node { tcp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow ping_t port_type:tcp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow ping_t node_type:tcp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow ping_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow ping_t self:tcp_socket { listen accept };
#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use tcp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow ping_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow ping_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow ping_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow ping_t node_type:node { tcp_send rawip_send };
#line 40
allow ping_t node_type:node { tcp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow ping_t port_type:tcp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow ping_t node_type:tcp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow ping_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow ping_t self:tcp_socket { connect };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the domain to create and use udp sockets.
#line 40
# Other kinds of sockets must be separately authorized for use.
#line 40
allow ping_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 40

#line 40
allow ping_t unlabeled_t:association { sendto recvfrom };
#line 40

#line 40
#
#line 40
# Allow the domain to send or receive using any network interface.
#line 40
# netif_type is a type attribute for all network interface types.
#line 40
#
#line 40
allow ping_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 40
#
#line 40
# Allow the domain to send to or receive from any node.
#line 40
# node_type is a type attribute for all node types.
#line 40
#
#line 40
allow ping_t node_type:node { udp_send rawip_send };
#line 40
allow ping_t node_type:node { udp_recv rawip_recv };
#line 40

#line 40
#
#line 40
# Allow the domain to send to or receive from any port.
#line 40
# port_type is a type attribute for all port types.
#line 40
#
#line 40

#line 40
allow ping_t port_type:udp_socket { send_msg recv_msg };
#line 40

#line 40

#line 40
# XXX Allow binding to any node type.  Remove once
#line 40
# individual rules have been added to all domains that 
#line 40
# bind sockets. 
#line 40
allow ping_t node_type:udp_socket node_bind;
#line 40
#
#line 40
# Allow access to network files including /etc/resolv.conf
#line 40
#
#line 40
allow ping_t net_conf_t:file { read getattr lock ioctl };
#line 40

#line 40
allow ping_t self:udp_socket { connect };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
allow ping_t var_yp_t:dir { read getattr lock search ioctl };
#line 40
allow ping_t var_yp_t:file { read getattr lock ioctl };
#line 40
allow ping_t var_yp_t:lnk_file { getattr read };
#line 40

#line 40
allow ping_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 40
allow ping_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 40
dontaudit ping_t self:capability net_bind_service;
#line 40
dontaudit ping_t reserved_port_type:tcp_socket name_connect;
#line 40
dontaudit ping_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 40

#line 40
} else {
#line 40
dontaudit ping_t var_yp_t:dir search;
#line 40
}
#line 40
 
allow ping_t etc_t:file { getattr read };
allow ping_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

# Let ping create raw ICMP packets.
allow ping_t self:rawip_socket { create ioctl read write bind getopt setopt };

# Use capabilities.
allow ping_t self:capability { net_raw setuid };

# Access the terminal.
allow ping_t admin_tty_type:chr_file { ioctl read getattr lock write append };

allow ping_t privfd:fd use;
dontaudit ping_t fs_t:filesystem getattr;

# it tries to access /var/run
dontaudit ping_t var_t:dir search;
dontaudit ping_t devtty_t:chr_file { read write };
dontaudit ping_t self:capability sys_tty_config;
#line 62

#line 62
dontaudit ping_t init_t:fd use;
#line 62


#line 1 "domains/program/portmap.te"
#DESC Portmap - Maintain RPC program number map
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#           Russell Coker <russell@coker.com.au>
# X-Debian-Packages: portmap
#



#################################
#
# Rules for the portmap_t domain.
#

#line 14

#line 14

#line 14

#line 14
type portmap_t, domain, privlog, daemon , nscd_client_domain, transitionbool;
#line 14
type portmap_exec_t, file_type, sysadmfile, exec_type;
#line 14
dontaudit portmap_t self:capability sys_tty_config;
#line 14

#line 14
role system_r types portmap_t;
#line 14

#line 14
# Inherit and use descriptors from init.
#line 14
allow portmap_t init_t:fd use;
#line 14
allow portmap_t init_t:process sigchld;
#line 14
allow portmap_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 14

#line 14

#line 14
allow portmap_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow portmap_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow portmap_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow portmap_t ld_so_t:file execute_no_trans;
#line 14
allow portmap_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow portmap_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow portmap_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow portmap_t texrel_shlib_t:file execmod;
#line 14
allow portmap_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow portmap_t device_t:dir search;
#line 14
allow portmap_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
allow portmap_t { self proc_t }:dir { read getattr lock search ioctl };
#line 14
allow portmap_t { self proc_t }:lnk_file { getattr read };
#line 14

#line 14
allow portmap_t device_t:dir { read getattr lock search ioctl };
#line 14

#line 14
allow portmap_t udev_tdb_t:file { read getattr lock ioctl };
#line 14
allow portmap_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit portmap_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit portmap_t unpriv_userdomain:fd use;
#line 14

#line 14

#line 14
allow portmap_t sysfs_t:dir { read getattr lock search ioctl };
#line 14
allow portmap_t sysfs_t:file { read getattr lock ioctl };
#line 14
allow portmap_t sysfs_t:lnk_file { getattr read };
#line 14
 
#line 14

#line 14
allow portmap_t autofs_t:dir { search getattr };
#line 14

#line 14
dontaudit portmap_t { tty_device_t devpts_t }:chr_file { read write };
#line 14
dontaudit portmap_t root_t:file { getattr read };
#line 14
 
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow portmap_t sysctl_t:dir search;
#line 14
allow portmap_t sysctl_kernel_t:dir search;
#line 14
allow portmap_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14

#line 14
bool portmap_disable_trans false;
#line 14
if (portmap_disable_trans) {
#line 14

#line 14
allow initrc_t portmap_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t portmap_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14
 
#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow initrc_t portmap_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit initrc_t portmap_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit initrc_t portmap_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit initrc_t portmap_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow initrc_t portmap_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow portmap_t initrc_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow portmap_t initrc_t:fd use;
#line 14
allow initrc_t portmap_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow portmap_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow portmap_t portmap_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow portmap_t portmap_exec_t:file entrypoint;
#line 14

#line 14
type_transition initrc_t portmap_exec_t:process portmap_t;
#line 14

#line 14

#line 14
allow initrc_t portmap_t:process { noatsecure siginh rlimitinh };
#line 14

#line 14
}
#line 14
 
#line 14
allow portmap_t privfd:fd use;
#line 14

#line 14
allow portmap_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
# Create pid file.
#line 14
allow portmap_t var_t:dir { getattr search };
#line 14

#line 14
type portmap_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow portmap_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow portmap_t portmap_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition portmap_t var_run_t:file portmap_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow portmap_t var_t:dir search;
#line 14
allow portmap_t portmap_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
allow portmap_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
# for daemons that look at /root on startup
#line 14
dontaudit portmap_t sysadm_home_dir_t:dir search;
#line 14

#line 14
# for df
#line 14
allow portmap_t fs_type:filesystem getattr;
#line 14
allow portmap_t removable_t:filesystem getattr;
#line 14

#line 14

#line 14
allow portmap_t etc_t:lnk_file read;
#line 14
allow portmap_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow portmap_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow portmap_t locale_t:file { read getattr lock ioctl };
#line 14
allow portmap_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14

#line 14
# for localization
#line 14
allow portmap_t lib_t:file { getattr read };
#line 14



#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow portmap_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow portmap_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow portmap_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow portmap_t node_type:node { tcp_send rawip_send };
#line 16
allow portmap_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow portmap_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow portmap_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow portmap_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow portmap_t self:tcp_socket { listen accept };
#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow portmap_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow portmap_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow portmap_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow portmap_t node_type:node { tcp_send rawip_send };
#line 16
allow portmap_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow portmap_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow portmap_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow portmap_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow portmap_t self:tcp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use udp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow portmap_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow portmap_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow portmap_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow portmap_t node_type:node { udp_send rawip_send };
#line 16
allow portmap_t node_type:node { udp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow portmap_t port_type:udp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow portmap_t node_type:udp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow portmap_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow portmap_t self:udp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

allow portmap_t port_type:tcp_socket name_connect;

#line 18

#line 18
if (allow_ypbind) {
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow portmap_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow portmap_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow portmap_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow portmap_t node_type:node { tcp_send rawip_send };
#line 18
allow portmap_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow portmap_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow portmap_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow portmap_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow portmap_t self:tcp_socket { listen accept };
#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow portmap_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow portmap_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow portmap_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow portmap_t node_type:node { tcp_send rawip_send };
#line 18
allow portmap_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow portmap_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow portmap_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow portmap_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow portmap_t self:tcp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use udp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow portmap_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow portmap_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow portmap_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow portmap_t node_type:node { udp_send rawip_send };
#line 18
allow portmap_t node_type:node { udp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow portmap_t port_type:udp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow portmap_t node_type:udp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow portmap_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow portmap_t self:udp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
allow portmap_t var_yp_t:dir { read getattr lock search ioctl };
#line 18
allow portmap_t var_yp_t:file { read getattr lock ioctl };
#line 18
allow portmap_t var_yp_t:lnk_file { getattr read };
#line 18

#line 18
allow portmap_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 18
allow portmap_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 18
dontaudit portmap_t self:capability net_bind_service;
#line 18
dontaudit portmap_t reserved_port_type:tcp_socket name_connect;
#line 18
dontaudit portmap_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 18

#line 18
} else {
#line 18
dontaudit portmap_t var_yp_t:dir search;
#line 18
}
#line 18
 
allow portmap_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow portmap_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };


#line 22
type portmap_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 22

#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the process to modify the directory.
#line 22
#
#line 22
allow portmap_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 22

#line 22
#
#line 22
# Allow the process to create the file.
#line 22
#
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
allow portmap_t portmap_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
allow portmap_t portmap_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
type_transition portmap_t tmp_t:{ file dir } portmap_tmp_t;
#line 22

#line 22

#line 22


allow portmap_t portmap_port_t:{ udp_socket tcp_socket } name_bind;
dontaudit portmap_t reserved_port_type:{ udp_socket tcp_socket } name_bind;

# portmap binds to arbitary ports
allow portmap_t port_t:{ udp_socket tcp_socket } name_bind;
allow portmap_t reserved_port_t:{ udp_socket tcp_socket } name_bind;

allow portmap_t etc_t:file { getattr read };

# Send to ypbind, initrc, rpc.statd, xinetd.
#line 35

#line 35
#allow portmap_t ypbind_t:udp_socket sendto;
#line 35
#allow ypbind_t portmap_t:udp_socket recvfrom;
#line 35


#line 36
#allow portmap_t { initrc_t init_t }:udp_socket sendto;
#line 36
#allow { initrc_t init_t } portmap_t:udp_socket recvfrom;
#line 36


#line 37
#allow init_t portmap_t:udp_socket sendto;
#line 37
#allow portmap_t init_t:udp_socket recvfrom;
#line 37

#line 39

#line 39
#allow portmap_t rpcd_t:udp_socket sendto;
#line 39
#allow rpcd_t portmap_t:udp_socket recvfrom;
#line 39

#line 41

#line 41
#allow portmap_t inetd_t:udp_socket sendto;
#line 41
#allow inetd_t portmap_t:udp_socket recvfrom;
#line 41

#line 43

#line 43
#allow portmap_t lpd_t:udp_socket sendto;
#line 43
#allow lpd_t portmap_t:udp_socket recvfrom;
#line 43

#line 46


#line 47
#allow portmap_t kernel_t:udp_socket sendto;
#line 47
#allow kernel_t portmap_t:udp_socket recvfrom;
#line 47


#line 48
#allow kernel_t portmap_t:udp_socket sendto;
#line 48
#allow portmap_t kernel_t:udp_socket recvfrom;
#line 48


#line 49
#allow sysadm_t portmap_t:udp_socket sendto;
#line 49
#allow portmap_t sysadm_t:udp_socket recvfrom;
#line 49


#line 50
#allow portmap_t sysadm_t:udp_socket sendto;
#line 50
#allow sysadm_t portmap_t:udp_socket recvfrom;
#line 50


# Use capabilities
allow portmap_t self:capability { net_bind_service setuid setgid };
allow portmap_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };


#line 56
type portmap_helper_t, domain, privlog ;
#line 56
type portmap_helper_exec_t, file_type, sysadmfile, exec_type;
#line 56
role sysadm_r types portmap_helper_t;
#line 56

#line 56
role system_r types portmap_helper_t;
#line 56

#line 56

#line 56

#line 56

#line 56
#
#line 56
# Allow the process to transition to the new domain.
#line 56
#
#line 56
allow sysadm_t portmap_helper_t:process transition;
#line 56

#line 56
#
#line 56
# Do not audit when glibc secure mode is enabled upon the transition.
#line 56
#
#line 56
dontaudit sysadm_t portmap_helper_t:process noatsecure;
#line 56

#line 56
#
#line 56
# Do not audit when signal-related state is cleared upon the transition.
#line 56
#
#line 56
dontaudit sysadm_t portmap_helper_t:process siginh;
#line 56

#line 56
#
#line 56
# Do not audit when resource limits are reset upon the transition.
#line 56
#
#line 56
dontaudit sysadm_t portmap_helper_t:process rlimitinh;
#line 56

#line 56
#
#line 56
# Allow the process to execute the program.
#line 56
# 
#line 56
allow sysadm_t portmap_helper_exec_t:file { read { getattr execute } };
#line 56

#line 56
#
#line 56
# Allow the process to reap the new domain.
#line 56
#
#line 56
allow portmap_helper_t sysadm_t:process sigchld;
#line 56

#line 56
#
#line 56
# Allow the new domain to inherit and use file 
#line 56
# descriptions from the creating process and vice versa.
#line 56
#
#line 56
allow portmap_helper_t sysadm_t:fd use;
#line 56
allow sysadm_t portmap_helper_t:fd use;
#line 56

#line 56
#
#line 56
# Allow the new domain to write back to the old domain via a pipe.
#line 56
#
#line 56
allow portmap_helper_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 56

#line 56
#
#line 56
# Allow the new domain to read and execute the program.
#line 56
#
#line 56
allow portmap_helper_t portmap_helper_exec_t:file { read getattr lock execute ioctl };
#line 56

#line 56
#
#line 56
# Allow the new domain to be entered via the program.
#line 56
#
#line 56
allow portmap_helper_t portmap_helper_exec_t:file entrypoint;
#line 56

#line 56
type_transition sysadm_t portmap_helper_exec_t:process portmap_helper_t;
#line 56

#line 56

#line 56
allow portmap_helper_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 56
allow portmap_helper_t lib_t:lnk_file { read getattr lock ioctl };
#line 56
allow portmap_helper_t ld_so_t:file { read getattr lock execute ioctl };
#line 56
#allow portmap_helper_t ld_so_t:file execute_no_trans;
#line 56
allow portmap_helper_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 56
allow portmap_helper_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 56
allow portmap_helper_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 56
allow portmap_helper_t texrel_shlib_t:file execmod;
#line 56
allow portmap_helper_t ld_so_cache_t:file { read getattr lock ioctl };
#line 56
allow portmap_helper_t device_t:dir search;
#line 56
allow portmap_helper_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 56

#line 56

role system_r types portmap_helper_t;

#line 58

#line 58

#line 58
#
#line 58
# Allow the process to transition to the new domain.
#line 58
#
#line 58
allow initrc_t portmap_helper_t:process transition;
#line 58

#line 58
#
#line 58
# Do not audit when glibc secure mode is enabled upon the transition.
#line 58
#
#line 58
dontaudit initrc_t portmap_helper_t:process noatsecure;
#line 58

#line 58
#
#line 58
# Do not audit when signal-related state is cleared upon the transition.
#line 58
#
#line 58
dontaudit initrc_t portmap_helper_t:process siginh;
#line 58

#line 58
#
#line 58
# Do not audit when resource limits are reset upon the transition.
#line 58
#
#line 58
dontaudit initrc_t portmap_helper_t:process rlimitinh;
#line 58

#line 58
#
#line 58
# Allow the process to execute the program.
#line 58
# 
#line 58
allow initrc_t portmap_helper_exec_t:file { read { getattr execute } };
#line 58

#line 58
#
#line 58
# Allow the process to reap the new domain.
#line 58
#
#line 58
allow portmap_helper_t initrc_t:process sigchld;
#line 58

#line 58
#
#line 58
# Allow the new domain to inherit and use file 
#line 58
# descriptions from the creating process and vice versa.
#line 58
#
#line 58
allow portmap_helper_t initrc_t:fd use;
#line 58
allow initrc_t portmap_helper_t:fd use;
#line 58

#line 58
#
#line 58
# Allow the new domain to write back to the old domain via a pipe.
#line 58
#
#line 58
allow portmap_helper_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 58

#line 58
#
#line 58
# Allow the new domain to read and execute the program.
#line 58
#
#line 58
allow portmap_helper_t portmap_helper_exec_t:file { read getattr lock execute ioctl };
#line 58

#line 58
#
#line 58
# Allow the new domain to be entered via the program.
#line 58
#
#line 58
allow portmap_helper_t portmap_helper_exec_t:file entrypoint;
#line 58

#line 58
type_transition initrc_t portmap_helper_exec_t:process portmap_helper_t;
#line 58

dontaudit portmap_helper_t self:capability { net_admin };
allow portmap_helper_t self:capability { net_bind_service };
allow portmap_helper_t initrc_var_run_t:file { ioctl read getattr lock write append };

#line 62

#line 62

#line 62

#line 62
#
#line 62
# Allow the process to modify the directory.
#line 62
#
#line 62
allow portmap_helper_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 62

#line 62
#
#line 62
# Allow the process to create the file.
#line 62
#
#line 62

#line 62

#line 62

#line 62

#line 62

#line 62
allow portmap_helper_t portmap_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 62

#line 62

#line 62

#line 62

#line 62

#line 62

#line 62

#line 62

#line 62

#line 62
type_transition portmap_helper_t var_run_t:file portmap_var_run_t;
#line 62

#line 62

allow portmap_helper_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };

#line 64

#line 64

#line 64

#line 64

#line 64

#line 64
#
#line 64
# Allow the domain to create and use tcp sockets.
#line 64
# Other kinds of sockets must be separately authorized for use.
#line 64
allow portmap_helper_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 64

#line 64
allow portmap_helper_t unlabeled_t:association { sendto recvfrom };
#line 64

#line 64
#
#line 64
# Allow the domain to send or receive using any network interface.
#line 64
# netif_type is a type attribute for all network interface types.
#line 64
#
#line 64
allow portmap_helper_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 64
#
#line 64
# Allow the domain to send to or receive from any node.
#line 64
# node_type is a type attribute for all node types.
#line 64
#
#line 64
allow portmap_helper_t node_type:node { tcp_send rawip_send };
#line 64
allow portmap_helper_t node_type:node { tcp_recv rawip_recv };
#line 64

#line 64
#
#line 64
# Allow the domain to send to or receive from any port.
#line 64
# port_type is a type attribute for all port types.
#line 64
#
#line 64

#line 64
allow portmap_helper_t port_type:tcp_socket { send_msg recv_msg };
#line 64

#line 64

#line 64
# XXX Allow binding to any node type.  Remove once
#line 64
# individual rules have been added to all domains that 
#line 64
# bind sockets. 
#line 64
allow portmap_helper_t node_type:tcp_socket node_bind;
#line 64
#
#line 64
# Allow access to network files including /etc/resolv.conf
#line 64
#
#line 64
allow portmap_helper_t net_conf_t:file { read getattr lock ioctl };
#line 64

#line 64
allow portmap_helper_t self:tcp_socket { listen accept };
#line 64

#line 64

#line 64

#line 64
#
#line 64
# Allow the domain to create and use tcp sockets.
#line 64
# Other kinds of sockets must be separately authorized for use.
#line 64
allow portmap_helper_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 64

#line 64
allow portmap_helper_t unlabeled_t:association { sendto recvfrom };
#line 64

#line 64
#
#line 64
# Allow the domain to send or receive using any network interface.
#line 64
# netif_type is a type attribute for all network interface types.
#line 64
#
#line 64
allow portmap_helper_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 64
#
#line 64
# Allow the domain to send to or receive from any node.
#line 64
# node_type is a type attribute for all node types.
#line 64
#
#line 64
allow portmap_helper_t node_type:node { tcp_send rawip_send };
#line 64
allow portmap_helper_t node_type:node { tcp_recv rawip_recv };
#line 64

#line 64
#
#line 64
# Allow the domain to send to or receive from any port.
#line 64
# port_type is a type attribute for all port types.
#line 64
#
#line 64

#line 64
allow portmap_helper_t port_type:tcp_socket { send_msg recv_msg };
#line 64

#line 64

#line 64
# XXX Allow binding to any node type.  Remove once
#line 64
# individual rules have been added to all domains that 
#line 64
# bind sockets. 
#line 64
allow portmap_helper_t node_type:tcp_socket node_bind;
#line 64
#
#line 64
# Allow access to network files including /etc/resolv.conf
#line 64
#
#line 64
allow portmap_helper_t net_conf_t:file { read getattr lock ioctl };
#line 64

#line 64
allow portmap_helper_t self:tcp_socket { connect };
#line 64

#line 64

#line 64

#line 64

#line 64

#line 64
#
#line 64
# Allow the domain to create and use udp sockets.
#line 64
# Other kinds of sockets must be separately authorized for use.
#line 64
allow portmap_helper_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 64

#line 64
allow portmap_helper_t unlabeled_t:association { sendto recvfrom };
#line 64

#line 64
#
#line 64
# Allow the domain to send or receive using any network interface.
#line 64
# netif_type is a type attribute for all network interface types.
#line 64
#
#line 64
allow portmap_helper_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 64
#
#line 64
# Allow the domain to send to or receive from any node.
#line 64
# node_type is a type attribute for all node types.
#line 64
#
#line 64
allow portmap_helper_t node_type:node { udp_send rawip_send };
#line 64
allow portmap_helper_t node_type:node { udp_recv rawip_recv };
#line 64

#line 64
#
#line 64
# Allow the domain to send to or receive from any port.
#line 64
# port_type is a type attribute for all port types.
#line 64
#
#line 64

#line 64
allow portmap_helper_t port_type:udp_socket { send_msg recv_msg };
#line 64

#line 64

#line 64
# XXX Allow binding to any node type.  Remove once
#line 64
# individual rules have been added to all domains that 
#line 64
# bind sockets. 
#line 64
allow portmap_helper_t node_type:udp_socket node_bind;
#line 64
#
#line 64
# Allow access to network files including /etc/resolv.conf
#line 64
#
#line 64
allow portmap_helper_t net_conf_t:file { read getattr lock ioctl };
#line 64

#line 64
allow portmap_helper_t self:udp_socket { connect };
#line 64

#line 64

#line 64

#line 64

#line 64

allow portmap_helper_t port_type:tcp_socket name_connect;

#line 66

#line 66
if (allow_ypbind) {
#line 66

#line 66

#line 66

#line 66

#line 66

#line 66

#line 66

#line 66
#
#line 66
# Allow the domain to create and use tcp sockets.
#line 66
# Other kinds of sockets must be separately authorized for use.
#line 66
allow portmap_helper_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 66

#line 66
allow portmap_helper_t unlabeled_t:association { sendto recvfrom };
#line 66

#line 66
#
#line 66
# Allow the domain to send or receive using any network interface.
#line 66
# netif_type is a type attribute for all network interface types.
#line 66
#
#line 66
allow portmap_helper_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 66
#
#line 66
# Allow the domain to send to or receive from any node.
#line 66
# node_type is a type attribute for all node types.
#line 66
#
#line 66
allow portmap_helper_t node_type:node { tcp_send rawip_send };
#line 66
allow portmap_helper_t node_type:node { tcp_recv rawip_recv };
#line 66

#line 66
#
#line 66
# Allow the domain to send to or receive from any port.
#line 66
# port_type is a type attribute for all port types.
#line 66
#
#line 66

#line 66
allow portmap_helper_t port_type:tcp_socket { send_msg recv_msg };
#line 66

#line 66

#line 66
# XXX Allow binding to any node type.  Remove once
#line 66
# individual rules have been added to all domains that 
#line 66
# bind sockets. 
#line 66
allow portmap_helper_t node_type:tcp_socket node_bind;
#line 66
#
#line 66
# Allow access to network files including /etc/resolv.conf
#line 66
#
#line 66
allow portmap_helper_t net_conf_t:file { read getattr lock ioctl };
#line 66

#line 66
allow portmap_helper_t self:tcp_socket { listen accept };
#line 66

#line 66

#line 66

#line 66
#
#line 66
# Allow the domain to create and use tcp sockets.
#line 66
# Other kinds of sockets must be separately authorized for use.
#line 66
allow portmap_helper_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 66

#line 66
allow portmap_helper_t unlabeled_t:association { sendto recvfrom };
#line 66

#line 66
#
#line 66
# Allow the domain to send or receive using any network interface.
#line 66
# netif_type is a type attribute for all network interface types.
#line 66
#
#line 66
allow portmap_helper_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 66
#
#line 66
# Allow the domain to send to or receive from any node.
#line 66
# node_type is a type attribute for all node types.
#line 66
#
#line 66
allow portmap_helper_t node_type:node { tcp_send rawip_send };
#line 66
allow portmap_helper_t node_type:node { tcp_recv rawip_recv };
#line 66

#line 66
#
#line 66
# Allow the domain to send to or receive from any port.
#line 66
# port_type is a type attribute for all port types.
#line 66
#
#line 66

#line 66
allow portmap_helper_t port_type:tcp_socket { send_msg recv_msg };
#line 66

#line 66

#line 66
# XXX Allow binding to any node type.  Remove once
#line 66
# individual rules have been added to all domains that 
#line 66
# bind sockets. 
#line 66
allow portmap_helper_t node_type:tcp_socket node_bind;
#line 66
#
#line 66
# Allow access to network files including /etc/resolv.conf
#line 66
#
#line 66
allow portmap_helper_t net_conf_t:file { read getattr lock ioctl };
#line 66

#line 66
allow portmap_helper_t self:tcp_socket { connect };
#line 66

#line 66

#line 66

#line 66

#line 66

#line 66
#
#line 66
# Allow the domain to create and use udp sockets.
#line 66
# Other kinds of sockets must be separately authorized for use.
#line 66
allow portmap_helper_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 66

#line 66
allow portmap_helper_t unlabeled_t:association { sendto recvfrom };
#line 66

#line 66
#
#line 66
# Allow the domain to send or receive using any network interface.
#line 66
# netif_type is a type attribute for all network interface types.
#line 66
#
#line 66
allow portmap_helper_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 66
#
#line 66
# Allow the domain to send to or receive from any node.
#line 66
# node_type is a type attribute for all node types.
#line 66
#
#line 66
allow portmap_helper_t node_type:node { udp_send rawip_send };
#line 66
allow portmap_helper_t node_type:node { udp_recv rawip_recv };
#line 66

#line 66
#
#line 66
# Allow the domain to send to or receive from any port.
#line 66
# port_type is a type attribute for all port types.
#line 66
#
#line 66

#line 66
allow portmap_helper_t port_type:udp_socket { send_msg recv_msg };
#line 66

#line 66

#line 66
# XXX Allow binding to any node type.  Remove once
#line 66
# individual rules have been added to all domains that 
#line 66
# bind sockets. 
#line 66
allow portmap_helper_t node_type:udp_socket node_bind;
#line 66
#
#line 66
# Allow access to network files including /etc/resolv.conf
#line 66
#
#line 66
allow portmap_helper_t net_conf_t:file { read getattr lock ioctl };
#line 66

#line 66
allow portmap_helper_t self:udp_socket { connect };
#line 66

#line 66

#line 66

#line 66

#line 66

#line 66

#line 66
allow portmap_helper_t var_yp_t:dir { read getattr lock search ioctl };
#line 66
allow portmap_helper_t var_yp_t:file { read getattr lock ioctl };
#line 66
allow portmap_helper_t var_yp_t:lnk_file { getattr read };
#line 66

#line 66
allow portmap_helper_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 66
allow portmap_helper_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 66
dontaudit portmap_helper_t self:capability net_bind_service;
#line 66
dontaudit portmap_helper_t reserved_port_type:tcp_socket name_connect;
#line 66
dontaudit portmap_helper_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 66

#line 66
} else {
#line 66
dontaudit portmap_helper_t var_yp_t:dir search;
#line 66
}
#line 66
 
dontaudit portmap_helper_t admin_tty_type:chr_file { ioctl read getattr lock write append };
allow portmap_helper_t etc_t:file { getattr read };
dontaudit portmap_helper_t { userdomain privfd }:fd use;
allow portmap_helper_t reserved_port_t:{ tcp_socket udp_socket } name_bind;
dontaudit portmap_helper_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 1 "domains/program/postfix.te"
#DESC Postfix - Mail server
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: postfix
# Depends: mta.te
#

# Type for files created during execution of postfix.
type postfix_var_run_t, file_type, sysadmfile, pidfile;

type postfix_etc_t, file_type, sysadmfile;
type postfix_exec_t, file_type, sysadmfile, exec_type;
type postfix_public_t, file_type, sysadmfile;
type postfix_private_t, file_type, sysadmfile;
type postfix_spool_t, file_type, sysadmfile;
type postfix_spool_maildrop_t, file_type, sysadmfile;
type postfix_spool_flush_t, file_type, sysadmfile;
type postfix_prng_t, file_type, sysadmfile;

# postfix needs this for newaliases
allow { system_mail_t sysadm_mail_t } tmp_t:dir getattr;

#################################
#
# Rules for the postfix_$1_t domain.
#
# postfix_$1_exec_t is the type of the postfix_$1 executables.
#
#line 67

#line 69
allow system_mail_t crond_t:tcp_socket { read write create };


#line 71

#line 71
type postfix_master_t, domain, privlog, daemon , mail_server_domain;
#line 71
type postfix_master_exec_t, file_type, sysadmfile, exec_type;
#line 71
dontaudit postfix_master_t self:capability sys_tty_config;
#line 71

#line 71
role system_r types postfix_master_t;
#line 71

#line 71
# Inherit and use descriptors from init.
#line 71
allow postfix_master_t init_t:fd use;
#line 71
allow postfix_master_t init_t:process sigchld;
#line 71
allow postfix_master_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 71

#line 71

#line 71
allow postfix_master_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 71
allow postfix_master_t lib_t:lnk_file { read getattr lock ioctl };
#line 71
allow postfix_master_t ld_so_t:file { read getattr lock execute ioctl };
#line 71
#allow postfix_master_t ld_so_t:file execute_no_trans;
#line 71
allow postfix_master_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 71
allow postfix_master_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 71
allow postfix_master_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 71
allow postfix_master_t texrel_shlib_t:file execmod;
#line 71
allow postfix_master_t ld_so_cache_t:file { read getattr lock ioctl };
#line 71
allow postfix_master_t device_t:dir search;
#line 71
allow postfix_master_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 71

#line 71

#line 71
allow postfix_master_t { self proc_t }:dir { read getattr lock search ioctl };
#line 71
allow postfix_master_t { self proc_t }:lnk_file { getattr read };
#line 71

#line 71
allow postfix_master_t device_t:dir { read getattr lock search ioctl };
#line 71

#line 71
allow postfix_master_t udev_tdb_t:file { read getattr lock ioctl };
#line 71
allow postfix_master_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 71
dontaudit postfix_master_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 71
dontaudit postfix_master_t unpriv_userdomain:fd use;
#line 71

#line 71

#line 71
allow postfix_master_t sysfs_t:dir { read getattr lock search ioctl };
#line 71
allow postfix_master_t sysfs_t:file { read getattr lock ioctl };
#line 71
allow postfix_master_t sysfs_t:lnk_file { getattr read };
#line 71
 
#line 71

#line 71
allow postfix_master_t autofs_t:dir { search getattr };
#line 71

#line 71
dontaudit postfix_master_t { tty_device_t devpts_t }:chr_file { read write };
#line 71
dontaudit postfix_master_t root_t:file { getattr read };
#line 71
 
#line 71

#line 71
allow postfix_master_t self:process setpgid;
#line 71
allow postfix_master_t postfix_master_t:process sigchld;
#line 71
allow postfix_master_t postfix_master_t:process signal;
#line 71

#line 71
allow postfix_master_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 71
allow postfix_master_t postfix_etc_t:file { read getattr lock ioctl };
#line 71

#line 71
allow postfix_master_t etc_t:lnk_file read;
#line 71
allow postfix_master_t lib_t:file { read getattr lock ioctl };
#line 71

#line 71
allow postfix_master_t locale_t:dir { read getattr lock search ioctl };
#line 71
allow postfix_master_t locale_t:file { read getattr lock ioctl };
#line 71
allow postfix_master_t locale_t:lnk_file { getattr read };
#line 71

#line 71

#line 71
allow postfix_master_t etc_t:file { getattr read };
#line 71
allow postfix_master_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 71
allow postfix_master_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 71
allow postfix_master_t self:unix_stream_socket connectto;
#line 71

#line 71
allow postfix_master_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 71
allow postfix_master_t { bin_t usr_t }:lnk_file { getattr read };
#line 71
allow postfix_master_t shell_exec_t:file { read getattr lock execute ioctl };
#line 71
allow postfix_master_t { var_t var_spool_t }:dir { search getattr };
#line 71
allow postfix_master_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 71
allow postfix_master_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 71
allow postfix_master_t etc_runtime_t:file { read getattr lock ioctl };
#line 71
allow postfix_master_t proc_t:dir { read getattr lock search ioctl };
#line 71
allow postfix_master_t proc_t:file { read getattr lock ioctl };
#line 71
allow postfix_master_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 71
allow postfix_master_t fs_t:filesystem getattr;
#line 71
allow postfix_master_t proc_net_t:dir search;
#line 71
allow postfix_master_t proc_net_t:file { getattr read };
#line 71

#line 71
allow postfix_master_t postfix_master_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 71

#line 71

#line 71
allow postfix_master_t cert_t:dir { read getattr lock search ioctl };
#line 71
allow postfix_master_t cert_t:file { read getattr lock ioctl };
#line 71
allow postfix_master_t cert_t:lnk_file { getattr read };
#line 71

#line 71
allow postfix_master_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 71

#line 71
allow postfix_master_t tmp_t:dir getattr;
#line 71

#line 71

#line 71

#line 71

#line 71

#line 71
#
#line 71
# Allow the process to modify the directory.
#line 71
#
#line 71
allow postfix_master_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 71

#line 71
#
#line 71
# Allow the process to create the file.
#line 71
#
#line 71

#line 71

#line 71

#line 71

#line 71

#line 71
allow postfix_master_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 71

#line 71

#line 71

#line 71

#line 71

#line 71

#line 71

#line 71

#line 71

#line 71
type_transition postfix_master_t var_run_t:file postfix_var_run_t;
#line 71

#line 71

#line 71

#line 71

#line 71
# Read system variables in /sys.
#line 71

#line 71
allow postfix_master_t sysctl_t:dir search;
#line 71
allow postfix_master_t sysctl_kernel_t:dir search;
#line 71
allow postfix_master_t sysctl_kernel_t:file { getattr read };
#line 71

#line 71

#line 71

#line 71

#line 71


#line 72


# for a find command
dontaudit postfix_master_t security_t:dir search;


#line 77
# Read system variables in /sys.
#line 77

#line 77
allow postfix_master_t sysctl_t:dir search;
#line 77
allow postfix_master_t sysctl_kernel_t:dir search;
#line 77
allow postfix_master_t sysctl_kernel_t:file { getattr read };
#line 77

#line 77

#line 77


#line 82

#line 82
bool postfix_disable_trans false;
#line 82
if (!postfix_disable_trans) {
#line 82


#line 83

#line 83

#line 83
#
#line 83
# Allow the process to transition to the new domain.
#line 83
#
#line 83
allow initrc_t postfix_master_t:process transition;
#line 83

#line 83
#
#line 83
# Do not audit when glibc secure mode is enabled upon the transition.
#line 83
#
#line 83
dontaudit initrc_t postfix_master_t:process noatsecure;
#line 83

#line 83
#
#line 83
# Do not audit when signal-related state is cleared upon the transition.
#line 83
#
#line 83
dontaudit initrc_t postfix_master_t:process siginh;
#line 83

#line 83
#
#line 83
# Do not audit when resource limits are reset upon the transition.
#line 83
#
#line 83
dontaudit initrc_t postfix_master_t:process rlimitinh;
#line 83

#line 83
#
#line 83
# Allow the process to execute the program.
#line 83
# 
#line 83
allow initrc_t postfix_master_exec_t:file { read { getattr execute } };
#line 83

#line 83
#
#line 83
# Allow the process to reap the new domain.
#line 83
#
#line 83
allow postfix_master_t initrc_t:process sigchld;
#line 83

#line 83
#
#line 83
# Allow the new domain to inherit and use file 
#line 83
# descriptions from the creating process and vice versa.
#line 83
#
#line 83
allow postfix_master_t initrc_t:fd use;
#line 83
allow initrc_t postfix_master_t:fd use;
#line 83

#line 83
#
#line 83
# Allow the new domain to write back to the old domain via a pipe.
#line 83
#
#line 83
allow postfix_master_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 83

#line 83
#
#line 83
# Allow the new domain to read and execute the program.
#line 83
#
#line 83
allow postfix_master_t postfix_master_exec_t:file { read getattr lock execute ioctl };
#line 83

#line 83
#
#line 83
# Allow the new domain to be entered via the program.
#line 83
#
#line 83
allow postfix_master_t postfix_master_exec_t:file entrypoint;
#line 83

#line 83
type_transition initrc_t postfix_master_exec_t:process postfix_master_t;
#line 83

allow initrc_t postfix_master_t:process { noatsecure siginh rlimitinh };


#line 86

#line 86

#line 86
#
#line 86
# Allow the process to transition to the new domain.
#line 86
#
#line 86
allow sysadm_t postfix_master_t:process transition;
#line 86

#line 86
#
#line 86
# Do not audit when glibc secure mode is enabled upon the transition.
#line 86
#
#line 86
dontaudit sysadm_t postfix_master_t:process noatsecure;
#line 86

#line 86
#
#line 86
# Do not audit when signal-related state is cleared upon the transition.
#line 86
#
#line 86
dontaudit sysadm_t postfix_master_t:process siginh;
#line 86

#line 86
#
#line 86
# Do not audit when resource limits are reset upon the transition.
#line 86
#
#line 86
dontaudit sysadm_t postfix_master_t:process rlimitinh;
#line 86

#line 86
#
#line 86
# Allow the process to execute the program.
#line 86
# 
#line 86
allow sysadm_t postfix_master_exec_t:file { read { getattr execute } };
#line 86

#line 86
#
#line 86
# Allow the process to reap the new domain.
#line 86
#
#line 86
allow postfix_master_t sysadm_t:process sigchld;
#line 86

#line 86
#
#line 86
# Allow the new domain to inherit and use file 
#line 86
# descriptions from the creating process and vice versa.
#line 86
#
#line 86
allow postfix_master_t sysadm_t:fd use;
#line 86
allow sysadm_t postfix_master_t:fd use;
#line 86

#line 86
#
#line 86
# Allow the new domain to write back to the old domain via a pipe.
#line 86
#
#line 86
allow postfix_master_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 86

#line 86
#
#line 86
# Allow the new domain to read and execute the program.
#line 86
#
#line 86
allow postfix_master_t postfix_master_exec_t:file { read getattr lock execute ioctl };
#line 86

#line 86
#
#line 86
# Allow the new domain to be entered via the program.
#line 86
#
#line 86
allow postfix_master_t postfix_master_exec_t:file entrypoint;
#line 86

#line 86
type_transition sysadm_t postfix_master_exec_t:process postfix_master_t;
#line 86

allow sysadm_t postfix_master_t:process { noatsecure siginh rlimitinh };
#line 90

allow postfix_master_t postfix_etc_t:file { ioctl read getattr lock write append };
dontaudit postfix_master_t admin_tty_type:chr_file { read write };
allow postfix_master_t devpts_t:dir search;


#line 95

#line 95

#line 95
#
#line 95
# Allow the process to transition to the new domain.
#line 95
#
#line 95
allow sysadm_mail_t system_mail_t:process transition;
#line 95

#line 95
#
#line 95
# Do not audit when glibc secure mode is enabled upon the transition.
#line 95
#
#line 95
dontaudit sysadm_mail_t system_mail_t:process noatsecure;
#line 95

#line 95
#
#line 95
# Do not audit when signal-related state is cleared upon the transition.
#line 95
#
#line 95
dontaudit sysadm_mail_t system_mail_t:process siginh;
#line 95

#line 95
#
#line 95
# Do not audit when resource limits are reset upon the transition.
#line 95
#
#line 95
dontaudit sysadm_mail_t system_mail_t:process rlimitinh;
#line 95

#line 95
#
#line 95
# Allow the process to execute the program.
#line 95
# 
#line 95
allow sysadm_mail_t postfix_master_exec_t:file { read { getattr execute } };
#line 95

#line 95
#
#line 95
# Allow the process to reap the new domain.
#line 95
#
#line 95
allow system_mail_t sysadm_mail_t:process sigchld;
#line 95

#line 95
#
#line 95
# Allow the new domain to inherit and use file 
#line 95
# descriptions from the creating process and vice versa.
#line 95
#
#line 95
allow system_mail_t sysadm_mail_t:fd use;
#line 95
allow sysadm_mail_t system_mail_t:fd use;
#line 95

#line 95
#
#line 95
# Allow the new domain to write back to the old domain via a pipe.
#line 95
#
#line 95
allow system_mail_t sysadm_mail_t:fifo_file { ioctl read getattr lock write append };
#line 95

#line 95
#
#line 95
# Allow the new domain to read and execute the program.
#line 95
#
#line 95
allow system_mail_t postfix_master_exec_t:file { read getattr lock execute ioctl };
#line 95

#line 95
#
#line 95
# Allow the new domain to be entered via the program.
#line 95
#
#line 95
allow system_mail_t postfix_master_exec_t:file entrypoint;
#line 95

#line 95
type_transition sysadm_mail_t postfix_master_exec_t:process system_mail_t;
#line 95

allow system_mail_t sysadm_t:process sigchld;
allow system_mail_t privfd:fd use;

#line 101

#line 101

#line 101

#line 101

#line 101
#
#line 101
# Allow the process to transition to the new domain.
#line 101
#
#line 101
allow pppd_t postfix_master_t:process transition;
#line 101

#line 101
#
#line 101
# Do not audit when glibc secure mode is enabled upon the transition.
#line 101
#
#line 101
dontaudit pppd_t postfix_master_t:process noatsecure;
#line 101

#line 101
#
#line 101
# Do not audit when signal-related state is cleared upon the transition.
#line 101
#
#line 101
dontaudit pppd_t postfix_master_t:process siginh;
#line 101

#line 101
#
#line 101
# Do not audit when resource limits are reset upon the transition.
#line 101
#
#line 101
dontaudit pppd_t postfix_master_t:process rlimitinh;
#line 101

#line 101
#
#line 101
# Allow the process to execute the program.
#line 101
# 
#line 101
allow pppd_t postfix_master_exec_t:file { read { getattr execute } };
#line 101

#line 101
#
#line 101
# Allow the process to reap the new domain.
#line 101
#
#line 101
allow postfix_master_t pppd_t:process sigchld;
#line 101

#line 101
#
#line 101
# Allow the new domain to inherit and use file 
#line 101
# descriptions from the creating process and vice versa.
#line 101
#
#line 101
allow postfix_master_t pppd_t:fd use;
#line 101
allow pppd_t postfix_master_t:fd use;
#line 101

#line 101
#
#line 101
# Allow the new domain to write back to the old domain via a pipe.
#line 101
#
#line 101
allow postfix_master_t pppd_t:fifo_file { ioctl read getattr lock write append };
#line 101

#line 101
#
#line 101
# Allow the new domain to read and execute the program.
#line 101
#
#line 101
allow postfix_master_t postfix_master_exec_t:file { read getattr lock execute ioctl };
#line 101

#line 101
#
#line 101
# Allow the new domain to be entered via the program.
#line 101
#
#line 101
allow postfix_master_t postfix_master_exec_t:file entrypoint;
#line 101

#line 101
type_transition pppd_t postfix_master_exec_t:process postfix_master_t;
#line 101

#line 101


#line 105

#line 105
}
#line 105


allow postfix_master_t privfd:fd use;

allow postfix_master_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };

# postfix does a "find" on startup for some reason - keep it quiet
dontaudit postfix_master_t selinux_config_t:dir search;

#line 113
allow { sysadm_mail_t system_mail_t } postfix_master_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 113

#line 119

#line 119
# compatability for old default main.cf
#line 119

#line 119

#line 119

#line 119

#line 119
#
#line 119
# Allow the process to modify the directory.
#line 119
#
#line 119
allow { sysadm_mail_t system_mail_t postfix_master_t } postfix_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 119

#line 119
#
#line 119
# Allow the process to create the file.
#line 119
#
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow { sysadm_mail_t system_mail_t postfix_master_t } etc_aliases_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow { sysadm_mail_t system_mail_t postfix_master_t } etc_aliases_t:lnk_file { create read getattr setattr link unlink rename };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow { sysadm_mail_t system_mail_t postfix_master_t } etc_aliases_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow { sysadm_mail_t system_mail_t postfix_master_t } etc_aliases_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow { sysadm_mail_t system_mail_t postfix_master_t } etc_aliases_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
type_transition { sysadm_mail_t system_mail_t postfix_master_t } postfix_etc_t:dir etc_aliases_t;
#line 119
type_transition { sysadm_mail_t system_mail_t postfix_master_t } postfix_etc_t:{ file lnk_file sock_file fifo_file } etc_aliases_t;
#line 119

#line 119

#line 119
# for newer main.cf that uses /etc/aliases
#line 119

#line 119

#line 119

#line 119

#line 119
#
#line 119
# Allow the process to modify the directory.
#line 119
#
#line 119
allow postfix_master_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 119

#line 119
#
#line 119
# Allow the process to create the file.
#line 119
#
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow postfix_master_t etc_aliases_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow postfix_master_t etc_aliases_t:lnk_file { create read getattr setattr link unlink rename };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow postfix_master_t etc_aliases_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow postfix_master_t etc_aliases_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
allow postfix_master_t etc_aliases_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119

#line 119
type_transition postfix_master_t etc_t:dir etc_aliases_t;
#line 119
type_transition postfix_master_t etc_t:{ file lnk_file sock_file fifo_file } etc_aliases_t;
#line 119

#line 119

#line 119


#line 120

#line 120

#line 120

#line 120
#
#line 120
# Allow the process to modify the directory.
#line 120
#
#line 120
allow { sysadm_mail_t system_mail_t } etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 120

#line 120
#
#line 120
# Allow the process to create the file.
#line 120
#
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
allow { sysadm_mail_t system_mail_t } etc_aliases_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
allow { sysadm_mail_t system_mail_t } etc_aliases_t:lnk_file { create read getattr setattr link unlink rename };
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
allow { sysadm_mail_t system_mail_t } etc_aliases_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
allow { sysadm_mail_t system_mail_t } etc_aliases_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
allow { sysadm_mail_t system_mail_t } etc_aliases_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
type_transition { sysadm_mail_t system_mail_t } etc_t:dir etc_aliases_t;
#line 120
type_transition { sysadm_mail_t system_mail_t } etc_t:{ file lnk_file sock_file fifo_file } etc_aliases_t;
#line 120

#line 120

allow postfix_master_t sendmail_exec_t:file { read getattr lock ioctl };
allow postfix_master_t sbin_t:lnk_file { getattr read };


#line 124
allow postfix_master_t { ls_exec_t sbin_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 124

allow postfix_master_t self:fifo_file { ioctl read getattr lock write append };
allow postfix_master_t usr_t:file { read getattr lock ioctl };

#line 127
allow postfix_master_t { shell_exec_t bin_t postfix_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 127

# chown is to set the correct ownership of queue dirs
allow postfix_master_t self:capability { chown dac_override kill setgid setuid net_bind_service sys_tty_config };
allow postfix_master_t postfix_public_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
allow postfix_master_t postfix_public_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
allow postfix_master_t postfix_public_t:dir { read getattr lock search ioctl add_name remove_name write };
allow postfix_master_t postfix_private_t:dir { read getattr lock search ioctl add_name remove_name write };
allow postfix_master_t postfix_private_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
allow postfix_master_t postfix_private_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };

#line 136

#line 136

#line 136

#line 136

#line 136

#line 136
#
#line 136
# Allow the domain to create and use tcp sockets.
#line 136
# Other kinds of sockets must be separately authorized for use.
#line 136
allow postfix_master_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 136

#line 136
allow postfix_master_t unlabeled_t:association { sendto recvfrom };
#line 136

#line 136
#
#line 136
# Allow the domain to send or receive using any network interface.
#line 136
# netif_type is a type attribute for all network interface types.
#line 136
#
#line 136
allow postfix_master_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 136
#
#line 136
# Allow the domain to send to or receive from any node.
#line 136
# node_type is a type attribute for all node types.
#line 136
#
#line 136
allow postfix_master_t node_type:node { tcp_send rawip_send };
#line 136
allow postfix_master_t node_type:node { tcp_recv rawip_recv };
#line 136

#line 136
#
#line 136
# Allow the domain to send to or receive from any port.
#line 136
# port_type is a type attribute for all port types.
#line 136
#
#line 136

#line 136
allow postfix_master_t port_type:tcp_socket { send_msg recv_msg };
#line 136

#line 136

#line 136
# XXX Allow binding to any node type.  Remove once
#line 136
# individual rules have been added to all domains that 
#line 136
# bind sockets. 
#line 136
allow postfix_master_t node_type:tcp_socket node_bind;
#line 136
#
#line 136
# Allow access to network files including /etc/resolv.conf
#line 136
#
#line 136
allow postfix_master_t net_conf_t:file { read getattr lock ioctl };
#line 136

#line 136
allow postfix_master_t self:tcp_socket { listen accept };
#line 136

#line 136

#line 136

#line 136
#
#line 136
# Allow the domain to create and use tcp sockets.
#line 136
# Other kinds of sockets must be separately authorized for use.
#line 136
allow postfix_master_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 136

#line 136
allow postfix_master_t unlabeled_t:association { sendto recvfrom };
#line 136

#line 136
#
#line 136
# Allow the domain to send or receive using any network interface.
#line 136
# netif_type is a type attribute for all network interface types.
#line 136
#
#line 136
allow postfix_master_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 136
#
#line 136
# Allow the domain to send to or receive from any node.
#line 136
# node_type is a type attribute for all node types.
#line 136
#
#line 136
allow postfix_master_t node_type:node { tcp_send rawip_send };
#line 136
allow postfix_master_t node_type:node { tcp_recv rawip_recv };
#line 136

#line 136
#
#line 136
# Allow the domain to send to or receive from any port.
#line 136
# port_type is a type attribute for all port types.
#line 136
#
#line 136

#line 136
allow postfix_master_t port_type:tcp_socket { send_msg recv_msg };
#line 136

#line 136

#line 136
# XXX Allow binding to any node type.  Remove once
#line 136
# individual rules have been added to all domains that 
#line 136
# bind sockets. 
#line 136
allow postfix_master_t node_type:tcp_socket node_bind;
#line 136
#
#line 136
# Allow access to network files including /etc/resolv.conf
#line 136
#
#line 136
allow postfix_master_t net_conf_t:file { read getattr lock ioctl };
#line 136

#line 136
allow postfix_master_t self:tcp_socket { connect };
#line 136

#line 136

#line 136

#line 136

#line 136

#line 136
#
#line 136
# Allow the domain to create and use udp sockets.
#line 136
# Other kinds of sockets must be separately authorized for use.
#line 136
allow postfix_master_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 136

#line 136
allow postfix_master_t unlabeled_t:association { sendto recvfrom };
#line 136

#line 136
#
#line 136
# Allow the domain to send or receive using any network interface.
#line 136
# netif_type is a type attribute for all network interface types.
#line 136
#
#line 136
allow postfix_master_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 136
#
#line 136
# Allow the domain to send to or receive from any node.
#line 136
# node_type is a type attribute for all node types.
#line 136
#
#line 136
allow postfix_master_t node_type:node { udp_send rawip_send };
#line 136
allow postfix_master_t node_type:node { udp_recv rawip_recv };
#line 136

#line 136
#
#line 136
# Allow the domain to send to or receive from any port.
#line 136
# port_type is a type attribute for all port types.
#line 136
#
#line 136

#line 136
allow postfix_master_t port_type:udp_socket { send_msg recv_msg };
#line 136

#line 136

#line 136
# XXX Allow binding to any node type.  Remove once
#line 136
# individual rules have been added to all domains that 
#line 136
# bind sockets. 
#line 136
allow postfix_master_t node_type:udp_socket node_bind;
#line 136
#
#line 136
# Allow access to network files including /etc/resolv.conf
#line 136
#
#line 136
allow postfix_master_t net_conf_t:file { read getattr lock ioctl };
#line 136

#line 136
allow postfix_master_t self:udp_socket { connect };
#line 136

#line 136

#line 136

#line 136

#line 136

allow postfix_master_t port_type:tcp_socket name_connect;

#line 138

#line 138
if (allow_ypbind) {
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postfix_master_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postfix_master_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postfix_master_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postfix_master_t node_type:node { tcp_send rawip_send };
#line 138
allow postfix_master_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postfix_master_t port_type:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postfix_master_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postfix_master_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postfix_master_t self:tcp_socket { listen accept };
#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postfix_master_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postfix_master_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postfix_master_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postfix_master_t node_type:node { tcp_send rawip_send };
#line 138
allow postfix_master_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postfix_master_t port_type:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postfix_master_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postfix_master_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postfix_master_t self:tcp_socket { connect };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use udp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postfix_master_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postfix_master_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postfix_master_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postfix_master_t node_type:node { udp_send rawip_send };
#line 138
allow postfix_master_t node_type:node { udp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postfix_master_t port_type:udp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postfix_master_t node_type:udp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postfix_master_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postfix_master_t self:udp_socket { connect };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
allow postfix_master_t var_yp_t:dir { read getattr lock search ioctl };
#line 138
allow postfix_master_t var_yp_t:file { read getattr lock ioctl };
#line 138
allow postfix_master_t var_yp_t:lnk_file { getattr read };
#line 138

#line 138
allow postfix_master_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 138
allow postfix_master_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 138
dontaudit postfix_master_t self:capability net_bind_service;
#line 138
dontaudit postfix_master_t reserved_port_type:tcp_socket name_connect;
#line 138
dontaudit postfix_master_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 138

#line 138
} else {
#line 138
dontaudit postfix_master_t var_yp_t:dir search;
#line 138
}
#line 138
 
allow postfix_master_t { amavisd_send_port_t smtp_port_t }:tcp_socket name_bind;
allow postfix_master_t postfix_spool_maildrop_t:dir { read getattr lock search ioctl add_name remove_name write };
allow postfix_master_t postfix_spool_maildrop_t:file { unlink rename getattr };
allow postfix_master_t postfix_prng_t:file getattr;
allow postfix_master_t privfd:fd use;
allow postfix_master_t etc_aliases_t:file { ioctl read getattr lock write append };
allow postfix_master_t var_lib_t:dir search;

#line 151

#line 151
allow postfix_smtpd_t saslauthd_var_run_t:dir { search getattr };
#line 151
allow postfix_smtpd_t saslauthd_var_run_t:sock_file { read write };
#line 151

#line 151
allow postfix_smtpd_t saslauthd_t:unix_stream_socket connectto;
#line 151

#line 151



#line 153
allow postfix_master_t postfix_spool_flush_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 153
allow postfix_master_t postfix_spool_flush_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 153
allow postfix_master_t postfix_spool_flush_t:lnk_file { create read getattr setattr link unlink rename };
#line 153

allow postfix_master_t postfix_prng_t:file { ioctl read getattr lock write append };
# for ls to get the current context
allow postfix_master_t self:file { getattr read };

# allow access to deferred queue and allow removing bogus incoming entries
allow postfix_master_t postfix_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
allow postfix_master_t postfix_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };

dontaudit postfix_master_t man_t:dir search;

#line 172



#line 174

#line 174

#line 174
type postfix_smtp_t, domain, privlog, daemon , mail_server_sender;
#line 174
type postfix_smtp_exec_t, file_type, sysadmfile, exec_type;
#line 174
dontaudit postfix_smtp_t self:capability sys_tty_config;
#line 174

#line 174
role system_r types postfix_smtp_t;
#line 174

#line 174
# Inherit and use descriptors from init.
#line 174
allow postfix_smtp_t init_t:fd use;
#line 174
allow postfix_smtp_t init_t:process sigchld;
#line 174
allow postfix_smtp_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 174

#line 174

#line 174
allow postfix_smtp_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t lib_t:lnk_file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t ld_so_t:file { read getattr lock execute ioctl };
#line 174
#allow postfix_smtp_t ld_so_t:file execute_no_trans;
#line 174
allow postfix_smtp_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 174
allow postfix_smtp_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t texrel_shlib_t:file execmod;
#line 174
allow postfix_smtp_t ld_so_cache_t:file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t device_t:dir search;
#line 174
allow postfix_smtp_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 174

#line 174

#line 174
allow postfix_smtp_t { self proc_t }:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t { self proc_t }:lnk_file { getattr read };
#line 174

#line 174
allow postfix_smtp_t device_t:dir { read getattr lock search ioctl };
#line 174

#line 174
allow postfix_smtp_t udev_tdb_t:file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 174
dontaudit postfix_smtp_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 174
dontaudit postfix_smtp_t unpriv_userdomain:fd use;
#line 174

#line 174

#line 174
allow postfix_smtp_t sysfs_t:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t sysfs_t:file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t sysfs_t:lnk_file { getattr read };
#line 174
 
#line 174

#line 174
allow postfix_smtp_t autofs_t:dir { search getattr };
#line 174

#line 174
dontaudit postfix_smtp_t { tty_device_t devpts_t }:chr_file { read write };
#line 174
dontaudit postfix_smtp_t root_t:file { getattr read };
#line 174
 
#line 174

#line 174
allow postfix_smtp_t self:process setpgid;
#line 174
allow postfix_smtp_t postfix_master_t:process sigchld;
#line 174
allow postfix_master_t postfix_smtp_t:process signal;
#line 174

#line 174
allow postfix_smtp_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t postfix_etc_t:file { read getattr lock ioctl };
#line 174

#line 174
allow postfix_smtp_t etc_t:lnk_file read;
#line 174
allow postfix_smtp_t lib_t:file { read getattr lock ioctl };
#line 174

#line 174
allow postfix_smtp_t locale_t:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t locale_t:file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t locale_t:lnk_file { getattr read };
#line 174

#line 174

#line 174
allow postfix_smtp_t etc_t:file { getattr read };
#line 174
allow postfix_smtp_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 174
allow postfix_smtp_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 174
allow postfix_smtp_t self:unix_stream_socket connectto;
#line 174

#line 174
allow postfix_smtp_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t { bin_t usr_t }:lnk_file { getattr read };
#line 174
allow postfix_smtp_t shell_exec_t:file { read getattr lock execute ioctl };
#line 174
allow postfix_smtp_t { var_t var_spool_t }:dir { search getattr };
#line 174
allow postfix_smtp_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 174
allow postfix_smtp_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 174
allow postfix_smtp_t etc_runtime_t:file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t proc_t:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t proc_t:file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t fs_t:filesystem getattr;
#line 174
allow postfix_smtp_t proc_net_t:dir search;
#line 174
allow postfix_smtp_t proc_net_t:file { getattr read };
#line 174

#line 174
allow postfix_smtp_t postfix_smtp_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 174

#line 174

#line 174
allow postfix_smtp_t cert_t:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t cert_t:file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t cert_t:lnk_file { getattr read };
#line 174

#line 174
allow postfix_smtp_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 174

#line 174
allow postfix_smtp_t tmp_t:dir getattr;
#line 174

#line 174

#line 174

#line 174

#line 174

#line 174
#
#line 174
# Allow the process to modify the directory.
#line 174
#
#line 174
allow postfix_smtp_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 174

#line 174
#
#line 174
# Allow the process to create the file.
#line 174
#
#line 174

#line 174

#line 174

#line 174

#line 174

#line 174
allow postfix_smtp_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174
type_transition postfix_smtp_t var_run_t:file postfix_var_run_t;
#line 174

#line 174

#line 174

#line 174

#line 174
# Read system variables in /sys.
#line 174

#line 174
allow postfix_smtp_t sysctl_t:dir search;
#line 174
allow postfix_smtp_t sysctl_kernel_t:dir search;
#line 174
allow postfix_smtp_t sysctl_kernel_t:file { getattr read };
#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174
#
#line 174
# Allow the process to transition to the new domain.
#line 174
#
#line 174
allow postfix_master_t postfix_smtp_t:process transition;
#line 174

#line 174
#
#line 174
# Do not audit when glibc secure mode is enabled upon the transition.
#line 174
#
#line 174
dontaudit postfix_master_t postfix_smtp_t:process noatsecure;
#line 174

#line 174
#
#line 174
# Do not audit when signal-related state is cleared upon the transition.
#line 174
#
#line 174
dontaudit postfix_master_t postfix_smtp_t:process siginh;
#line 174

#line 174
#
#line 174
# Do not audit when resource limits are reset upon the transition.
#line 174
#
#line 174
dontaudit postfix_master_t postfix_smtp_t:process rlimitinh;
#line 174

#line 174
#
#line 174
# Allow the process to execute the program.
#line 174
# 
#line 174
allow postfix_master_t postfix_smtp_exec_t:file { read { getattr execute } };
#line 174

#line 174
#
#line 174
# Allow the process to reap the new domain.
#line 174
#
#line 174
allow postfix_smtp_t postfix_master_t:process sigchld;
#line 174

#line 174
#
#line 174
# Allow the new domain to inherit and use file 
#line 174
# descriptions from the creating process and vice versa.
#line 174
#
#line 174
allow postfix_smtp_t postfix_master_t:fd use;
#line 174
allow postfix_master_t postfix_smtp_t:fd use;
#line 174

#line 174
#
#line 174
# Allow the new domain to write back to the old domain via a pipe.
#line 174
#
#line 174
allow postfix_smtp_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 174

#line 174
#
#line 174
# Allow the new domain to read and execute the program.
#line 174
#
#line 174
allow postfix_smtp_t postfix_smtp_exec_t:file { read getattr lock execute ioctl };
#line 174

#line 174
#
#line 174
# Allow the new domain to be entered via the program.
#line 174
#
#line 174
allow postfix_smtp_t postfix_smtp_exec_t:file entrypoint;
#line 174

#line 174
type_transition postfix_master_t postfix_smtp_exec_t:process postfix_smtp_t;
#line 174

#line 174
allow postfix_smtp_t postfix_master_t:unix_stream_socket { connectto { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept } };
#line 174
allow postfix_smtp_t self:capability { setuid setgid dac_override };
#line 174

#line 174

#line 174

#line 174

#line 174
#
#line 174
# Allow the domain to create and use tcp sockets.
#line 174
# Other kinds of sockets must be separately authorized for use.
#line 174
allow postfix_smtp_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 174

#line 174
allow postfix_smtp_t unlabeled_t:association { sendto recvfrom };
#line 174

#line 174
#
#line 174
# Allow the domain to send or receive using any network interface.
#line 174
# netif_type is a type attribute for all network interface types.
#line 174
#
#line 174
allow postfix_smtp_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 174
#
#line 174
# Allow the domain to send to or receive from any node.
#line 174
# node_type is a type attribute for all node types.
#line 174
#
#line 174
allow postfix_smtp_t node_type:node { tcp_send rawip_send };
#line 174
allow postfix_smtp_t node_type:node { tcp_recv rawip_recv };
#line 174

#line 174
#
#line 174
# Allow the domain to send to or receive from any port.
#line 174
# port_type is a type attribute for all port types.
#line 174
#
#line 174

#line 174
allow postfix_smtp_t port_type:tcp_socket { send_msg recv_msg };
#line 174

#line 174

#line 174
# XXX Allow binding to any node type.  Remove once
#line 174
# individual rules have been added to all domains that 
#line 174
# bind sockets. 
#line 174
allow postfix_smtp_t node_type:tcp_socket node_bind;
#line 174
#
#line 174
# Allow access to network files including /etc/resolv.conf
#line 174
#
#line 174
allow postfix_smtp_t net_conf_t:file { read getattr lock ioctl };
#line 174

#line 174
allow postfix_smtp_t self:tcp_socket { connect };
#line 174

#line 174

#line 174

#line 174
#
#line 174
# Allow the domain to create and use udp sockets.
#line 174
# Other kinds of sockets must be separately authorized for use.
#line 174
allow postfix_smtp_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 174

#line 174
allow postfix_smtp_t unlabeled_t:association { sendto recvfrom };
#line 174

#line 174
#
#line 174
# Allow the domain to send or receive using any network interface.
#line 174
# netif_type is a type attribute for all network interface types.
#line 174
#
#line 174
allow postfix_smtp_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 174
#
#line 174
# Allow the domain to send to or receive from any node.
#line 174
# node_type is a type attribute for all node types.
#line 174
#
#line 174
allow postfix_smtp_t node_type:node { udp_send rawip_send };
#line 174
allow postfix_smtp_t node_type:node { udp_recv rawip_recv };
#line 174

#line 174
#
#line 174
# Allow the domain to send to or receive from any port.
#line 174
# port_type is a type attribute for all port types.
#line 174
#
#line 174

#line 174
allow postfix_smtp_t port_type:udp_socket { send_msg recv_msg };
#line 174

#line 174

#line 174
# XXX Allow binding to any node type.  Remove once
#line 174
# individual rules have been added to all domains that 
#line 174
# bind sockets. 
#line 174
allow postfix_smtp_t node_type:udp_socket node_bind;
#line 174
#
#line 174
# Allow access to network files including /etc/resolv.conf
#line 174
#
#line 174
allow postfix_smtp_t net_conf_t:file { read getattr lock ioctl };
#line 174

#line 174
allow postfix_smtp_t self:udp_socket { connect };
#line 174

#line 174

#line 174

#line 174
allow postfix_smtp_t port_type:tcp_socket name_connect;
#line 174

#line 174

#line 174
if (allow_ypbind) {
#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174
#
#line 174
# Allow the domain to create and use tcp sockets.
#line 174
# Other kinds of sockets must be separately authorized for use.
#line 174
allow postfix_smtp_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 174

#line 174
allow postfix_smtp_t unlabeled_t:association { sendto recvfrom };
#line 174

#line 174
#
#line 174
# Allow the domain to send or receive using any network interface.
#line 174
# netif_type is a type attribute for all network interface types.
#line 174
#
#line 174
allow postfix_smtp_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 174
#
#line 174
# Allow the domain to send to or receive from any node.
#line 174
# node_type is a type attribute for all node types.
#line 174
#
#line 174
allow postfix_smtp_t node_type:node { tcp_send rawip_send };
#line 174
allow postfix_smtp_t node_type:node { tcp_recv rawip_recv };
#line 174

#line 174
#
#line 174
# Allow the domain to send to or receive from any port.
#line 174
# port_type is a type attribute for all port types.
#line 174
#
#line 174

#line 174
allow postfix_smtp_t port_type:tcp_socket { send_msg recv_msg };
#line 174

#line 174

#line 174
# XXX Allow binding to any node type.  Remove once
#line 174
# individual rules have been added to all domains that 
#line 174
# bind sockets. 
#line 174
allow postfix_smtp_t node_type:tcp_socket node_bind;
#line 174
#
#line 174
# Allow access to network files including /etc/resolv.conf
#line 174
#
#line 174
allow postfix_smtp_t net_conf_t:file { read getattr lock ioctl };
#line 174

#line 174
allow postfix_smtp_t self:tcp_socket { listen accept };
#line 174

#line 174

#line 174

#line 174
#
#line 174
# Allow the domain to create and use tcp sockets.
#line 174
# Other kinds of sockets must be separately authorized for use.
#line 174
allow postfix_smtp_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 174

#line 174
allow postfix_smtp_t unlabeled_t:association { sendto recvfrom };
#line 174

#line 174
#
#line 174
# Allow the domain to send or receive using any network interface.
#line 174
# netif_type is a type attribute for all network interface types.
#line 174
#
#line 174
allow postfix_smtp_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 174
#
#line 174
# Allow the domain to send to or receive from any node.
#line 174
# node_type is a type attribute for all node types.
#line 174
#
#line 174
allow postfix_smtp_t node_type:node { tcp_send rawip_send };
#line 174
allow postfix_smtp_t node_type:node { tcp_recv rawip_recv };
#line 174

#line 174
#
#line 174
# Allow the domain to send to or receive from any port.
#line 174
# port_type is a type attribute for all port types.
#line 174
#
#line 174

#line 174
allow postfix_smtp_t port_type:tcp_socket { send_msg recv_msg };
#line 174

#line 174

#line 174
# XXX Allow binding to any node type.  Remove once
#line 174
# individual rules have been added to all domains that 
#line 174
# bind sockets. 
#line 174
allow postfix_smtp_t node_type:tcp_socket node_bind;
#line 174
#
#line 174
# Allow access to network files including /etc/resolv.conf
#line 174
#
#line 174
allow postfix_smtp_t net_conf_t:file { read getattr lock ioctl };
#line 174

#line 174
allow postfix_smtp_t self:tcp_socket { connect };
#line 174

#line 174

#line 174

#line 174

#line 174

#line 174
#
#line 174
# Allow the domain to create and use udp sockets.
#line 174
# Other kinds of sockets must be separately authorized for use.
#line 174
allow postfix_smtp_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 174

#line 174
allow postfix_smtp_t unlabeled_t:association { sendto recvfrom };
#line 174

#line 174
#
#line 174
# Allow the domain to send or receive using any network interface.
#line 174
# netif_type is a type attribute for all network interface types.
#line 174
#
#line 174
allow postfix_smtp_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 174
#
#line 174
# Allow the domain to send to or receive from any node.
#line 174
# node_type is a type attribute for all node types.
#line 174
#
#line 174
allow postfix_smtp_t node_type:node { udp_send rawip_send };
#line 174
allow postfix_smtp_t node_type:node { udp_recv rawip_recv };
#line 174

#line 174
#
#line 174
# Allow the domain to send to or receive from any port.
#line 174
# port_type is a type attribute for all port types.
#line 174
#
#line 174

#line 174
allow postfix_smtp_t port_type:udp_socket { send_msg recv_msg };
#line 174

#line 174

#line 174
# XXX Allow binding to any node type.  Remove once
#line 174
# individual rules have been added to all domains that 
#line 174
# bind sockets. 
#line 174
allow postfix_smtp_t node_type:udp_socket node_bind;
#line 174
#
#line 174
# Allow access to network files including /etc/resolv.conf
#line 174
#
#line 174
allow postfix_smtp_t net_conf_t:file { read getattr lock ioctl };
#line 174

#line 174
allow postfix_smtp_t self:udp_socket { connect };
#line 174

#line 174

#line 174

#line 174

#line 174

#line 174

#line 174
allow postfix_smtp_t var_yp_t:dir { read getattr lock search ioctl };
#line 174
allow postfix_smtp_t var_yp_t:file { read getattr lock ioctl };
#line 174
allow postfix_smtp_t var_yp_t:lnk_file { getattr read };
#line 174

#line 174
allow postfix_smtp_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 174
allow postfix_smtp_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 174
dontaudit postfix_smtp_t self:capability net_bind_service;
#line 174
dontaudit postfix_smtp_t reserved_port_type:tcp_socket name_connect;
#line 174
dontaudit postfix_smtp_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 174

#line 174
} else {
#line 174
dontaudit postfix_smtp_t var_yp_t:dir search;
#line 174
}
#line 174
 
#line 174

allow postfix_smtp_t postfix_spool_t:file { ioctl read getattr lock write append };
allow postfix_smtp_t { postfix_private_t postfix_public_t }:dir search;
allow postfix_smtp_t { postfix_private_t postfix_public_t }:sock_file write;
allow postfix_smtp_t postfix_master_t:unix_stream_socket connectto;
# if you have two different mail servers on the same host let them talk via
# SMTP, also if one mail server wants to talk to itself then allow it and let
# the SMTP protocol sort it out (SE Linux is not to prevent mail server
# misconfiguration)

#line 183
#allow postfix_smtp_t mail_server_domain:tcp_socket { connectto recvfrom };
#line 183
#allow mail_server_domain postfix_smtp_t:tcp_socket { acceptfrom recvfrom };
#line 183
#allow mail_server_domain kernel_t:tcp_socket recvfrom;
#line 183
#allow postfix_smtp_t kernel_t:tcp_socket recvfrom;
#line 183



#line 185

#line 185

#line 185
type postfix_smtpd_t, domain, privlog, daemon ;
#line 185
type postfix_smtpd_exec_t, file_type, sysadmfile, exec_type;
#line 185
dontaudit postfix_smtpd_t self:capability sys_tty_config;
#line 185

#line 185
role system_r types postfix_smtpd_t;
#line 185

#line 185
# Inherit and use descriptors from init.
#line 185
allow postfix_smtpd_t init_t:fd use;
#line 185
allow postfix_smtpd_t init_t:process sigchld;
#line 185
allow postfix_smtpd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 185

#line 185

#line 185
allow postfix_smtpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 185
#allow postfix_smtpd_t ld_so_t:file execute_no_trans;
#line 185
allow postfix_smtpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 185
allow postfix_smtpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t texrel_shlib_t:file execmod;
#line 185
allow postfix_smtpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t device_t:dir search;
#line 185
allow postfix_smtpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 185

#line 185

#line 185
allow postfix_smtpd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t { self proc_t }:lnk_file { getattr read };
#line 185

#line 185
allow postfix_smtpd_t device_t:dir { read getattr lock search ioctl };
#line 185

#line 185
allow postfix_smtpd_t udev_tdb_t:file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 185
dontaudit postfix_smtpd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 185
dontaudit postfix_smtpd_t unpriv_userdomain:fd use;
#line 185

#line 185

#line 185
allow postfix_smtpd_t sysfs_t:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t sysfs_t:file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t sysfs_t:lnk_file { getattr read };
#line 185
 
#line 185

#line 185
allow postfix_smtpd_t autofs_t:dir { search getattr };
#line 185

#line 185
dontaudit postfix_smtpd_t { tty_device_t devpts_t }:chr_file { read write };
#line 185
dontaudit postfix_smtpd_t root_t:file { getattr read };
#line 185
 
#line 185

#line 185
allow postfix_smtpd_t self:process setpgid;
#line 185
allow postfix_smtpd_t postfix_master_t:process sigchld;
#line 185
allow postfix_master_t postfix_smtpd_t:process signal;
#line 185

#line 185
allow postfix_smtpd_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t postfix_etc_t:file { read getattr lock ioctl };
#line 185

#line 185
allow postfix_smtpd_t etc_t:lnk_file read;
#line 185
allow postfix_smtpd_t lib_t:file { read getattr lock ioctl };
#line 185

#line 185
allow postfix_smtpd_t locale_t:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t locale_t:file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t locale_t:lnk_file { getattr read };
#line 185

#line 185

#line 185
allow postfix_smtpd_t etc_t:file { getattr read };
#line 185
allow postfix_smtpd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 185
allow postfix_smtpd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 185
allow postfix_smtpd_t self:unix_stream_socket connectto;
#line 185

#line 185
allow postfix_smtpd_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t { bin_t usr_t }:lnk_file { getattr read };
#line 185
allow postfix_smtpd_t shell_exec_t:file { read getattr lock execute ioctl };
#line 185
allow postfix_smtpd_t { var_t var_spool_t }:dir { search getattr };
#line 185
allow postfix_smtpd_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 185
allow postfix_smtpd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 185
allow postfix_smtpd_t etc_runtime_t:file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t proc_t:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t proc_t:file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t fs_t:filesystem getattr;
#line 185
allow postfix_smtpd_t proc_net_t:dir search;
#line 185
allow postfix_smtpd_t proc_net_t:file { getattr read };
#line 185

#line 185
allow postfix_smtpd_t postfix_smtpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 185

#line 185

#line 185
allow postfix_smtpd_t cert_t:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t cert_t:file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t cert_t:lnk_file { getattr read };
#line 185

#line 185
allow postfix_smtpd_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 185

#line 185
allow postfix_smtpd_t tmp_t:dir getattr;
#line 185

#line 185

#line 185

#line 185

#line 185

#line 185
#
#line 185
# Allow the process to modify the directory.
#line 185
#
#line 185
allow postfix_smtpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 185

#line 185
#
#line 185
# Allow the process to create the file.
#line 185
#
#line 185

#line 185

#line 185

#line 185

#line 185

#line 185
allow postfix_smtpd_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185
type_transition postfix_smtpd_t var_run_t:file postfix_var_run_t;
#line 185

#line 185

#line 185

#line 185

#line 185
# Read system variables in /sys.
#line 185

#line 185
allow postfix_smtpd_t sysctl_t:dir search;
#line 185
allow postfix_smtpd_t sysctl_kernel_t:dir search;
#line 185
allow postfix_smtpd_t sysctl_kernel_t:file { getattr read };
#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185
#
#line 185
# Allow the process to transition to the new domain.
#line 185
#
#line 185
allow postfix_master_t postfix_smtpd_t:process transition;
#line 185

#line 185
#
#line 185
# Do not audit when glibc secure mode is enabled upon the transition.
#line 185
#
#line 185
dontaudit postfix_master_t postfix_smtpd_t:process noatsecure;
#line 185

#line 185
#
#line 185
# Do not audit when signal-related state is cleared upon the transition.
#line 185
#
#line 185
dontaudit postfix_master_t postfix_smtpd_t:process siginh;
#line 185

#line 185
#
#line 185
# Do not audit when resource limits are reset upon the transition.
#line 185
#
#line 185
dontaudit postfix_master_t postfix_smtpd_t:process rlimitinh;
#line 185

#line 185
#
#line 185
# Allow the process to execute the program.
#line 185
# 
#line 185
allow postfix_master_t postfix_smtpd_exec_t:file { read { getattr execute } };
#line 185

#line 185
#
#line 185
# Allow the process to reap the new domain.
#line 185
#
#line 185
allow postfix_smtpd_t postfix_master_t:process sigchld;
#line 185

#line 185
#
#line 185
# Allow the new domain to inherit and use file 
#line 185
# descriptions from the creating process and vice versa.
#line 185
#
#line 185
allow postfix_smtpd_t postfix_master_t:fd use;
#line 185
allow postfix_master_t postfix_smtpd_t:fd use;
#line 185

#line 185
#
#line 185
# Allow the new domain to write back to the old domain via a pipe.
#line 185
#
#line 185
allow postfix_smtpd_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 185

#line 185
#
#line 185
# Allow the new domain to read and execute the program.
#line 185
#
#line 185
allow postfix_smtpd_t postfix_smtpd_exec_t:file { read getattr lock execute ioctl };
#line 185

#line 185
#
#line 185
# Allow the new domain to be entered via the program.
#line 185
#
#line 185
allow postfix_smtpd_t postfix_smtpd_exec_t:file entrypoint;
#line 185

#line 185
type_transition postfix_master_t postfix_smtpd_exec_t:process postfix_smtpd_t;
#line 185

#line 185
allow postfix_smtpd_t postfix_master_t:unix_stream_socket { connectto { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept } };
#line 185
allow postfix_smtpd_t self:capability { setuid setgid dac_override };
#line 185

#line 185

#line 185

#line 185

#line 185
#
#line 185
# Allow the domain to create and use tcp sockets.
#line 185
# Other kinds of sockets must be separately authorized for use.
#line 185
allow postfix_smtpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 185

#line 185
allow postfix_smtpd_t unlabeled_t:association { sendto recvfrom };
#line 185

#line 185
#
#line 185
# Allow the domain to send or receive using any network interface.
#line 185
# netif_type is a type attribute for all network interface types.
#line 185
#
#line 185
allow postfix_smtpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 185
#
#line 185
# Allow the domain to send to or receive from any node.
#line 185
# node_type is a type attribute for all node types.
#line 185
#
#line 185
allow postfix_smtpd_t node_type:node { tcp_send rawip_send };
#line 185
allow postfix_smtpd_t node_type:node { tcp_recv rawip_recv };
#line 185

#line 185
#
#line 185
# Allow the domain to send to or receive from any port.
#line 185
# port_type is a type attribute for all port types.
#line 185
#
#line 185

#line 185
allow postfix_smtpd_t port_type:tcp_socket { send_msg recv_msg };
#line 185

#line 185

#line 185
# XXX Allow binding to any node type.  Remove once
#line 185
# individual rules have been added to all domains that 
#line 185
# bind sockets. 
#line 185
allow postfix_smtpd_t node_type:tcp_socket node_bind;
#line 185
#
#line 185
# Allow access to network files including /etc/resolv.conf
#line 185
#
#line 185
allow postfix_smtpd_t net_conf_t:file { read getattr lock ioctl };
#line 185

#line 185
allow postfix_smtpd_t self:tcp_socket { connect };
#line 185

#line 185

#line 185

#line 185
#
#line 185
# Allow the domain to create and use udp sockets.
#line 185
# Other kinds of sockets must be separately authorized for use.
#line 185
allow postfix_smtpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 185

#line 185
allow postfix_smtpd_t unlabeled_t:association { sendto recvfrom };
#line 185

#line 185
#
#line 185
# Allow the domain to send or receive using any network interface.
#line 185
# netif_type is a type attribute for all network interface types.
#line 185
#
#line 185
allow postfix_smtpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 185
#
#line 185
# Allow the domain to send to or receive from any node.
#line 185
# node_type is a type attribute for all node types.
#line 185
#
#line 185
allow postfix_smtpd_t node_type:node { udp_send rawip_send };
#line 185
allow postfix_smtpd_t node_type:node { udp_recv rawip_recv };
#line 185

#line 185
#
#line 185
# Allow the domain to send to or receive from any port.
#line 185
# port_type is a type attribute for all port types.
#line 185
#
#line 185

#line 185
allow postfix_smtpd_t port_type:udp_socket { send_msg recv_msg };
#line 185

#line 185

#line 185
# XXX Allow binding to any node type.  Remove once
#line 185
# individual rules have been added to all domains that 
#line 185
# bind sockets. 
#line 185
allow postfix_smtpd_t node_type:udp_socket node_bind;
#line 185
#
#line 185
# Allow access to network files including /etc/resolv.conf
#line 185
#
#line 185
allow postfix_smtpd_t net_conf_t:file { read getattr lock ioctl };
#line 185

#line 185
allow postfix_smtpd_t self:udp_socket { connect };
#line 185

#line 185

#line 185

#line 185
allow postfix_smtpd_t port_type:tcp_socket name_connect;
#line 185

#line 185

#line 185
if (allow_ypbind) {
#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185
#
#line 185
# Allow the domain to create and use tcp sockets.
#line 185
# Other kinds of sockets must be separately authorized for use.
#line 185
allow postfix_smtpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 185

#line 185
allow postfix_smtpd_t unlabeled_t:association { sendto recvfrom };
#line 185

#line 185
#
#line 185
# Allow the domain to send or receive using any network interface.
#line 185
# netif_type is a type attribute for all network interface types.
#line 185
#
#line 185
allow postfix_smtpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 185
#
#line 185
# Allow the domain to send to or receive from any node.
#line 185
# node_type is a type attribute for all node types.
#line 185
#
#line 185
allow postfix_smtpd_t node_type:node { tcp_send rawip_send };
#line 185
allow postfix_smtpd_t node_type:node { tcp_recv rawip_recv };
#line 185

#line 185
#
#line 185
# Allow the domain to send to or receive from any port.
#line 185
# port_type is a type attribute for all port types.
#line 185
#
#line 185

#line 185
allow postfix_smtpd_t port_type:tcp_socket { send_msg recv_msg };
#line 185

#line 185

#line 185
# XXX Allow binding to any node type.  Remove once
#line 185
# individual rules have been added to all domains that 
#line 185
# bind sockets. 
#line 185
allow postfix_smtpd_t node_type:tcp_socket node_bind;
#line 185
#
#line 185
# Allow access to network files including /etc/resolv.conf
#line 185
#
#line 185
allow postfix_smtpd_t net_conf_t:file { read getattr lock ioctl };
#line 185

#line 185
allow postfix_smtpd_t self:tcp_socket { listen accept };
#line 185

#line 185

#line 185

#line 185
#
#line 185
# Allow the domain to create and use tcp sockets.
#line 185
# Other kinds of sockets must be separately authorized for use.
#line 185
allow postfix_smtpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 185

#line 185
allow postfix_smtpd_t unlabeled_t:association { sendto recvfrom };
#line 185

#line 185
#
#line 185
# Allow the domain to send or receive using any network interface.
#line 185
# netif_type is a type attribute for all network interface types.
#line 185
#
#line 185
allow postfix_smtpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 185
#
#line 185
# Allow the domain to send to or receive from any node.
#line 185
# node_type is a type attribute for all node types.
#line 185
#
#line 185
allow postfix_smtpd_t node_type:node { tcp_send rawip_send };
#line 185
allow postfix_smtpd_t node_type:node { tcp_recv rawip_recv };
#line 185

#line 185
#
#line 185
# Allow the domain to send to or receive from any port.
#line 185
# port_type is a type attribute for all port types.
#line 185
#
#line 185

#line 185
allow postfix_smtpd_t port_type:tcp_socket { send_msg recv_msg };
#line 185

#line 185

#line 185
# XXX Allow binding to any node type.  Remove once
#line 185
# individual rules have been added to all domains that 
#line 185
# bind sockets. 
#line 185
allow postfix_smtpd_t node_type:tcp_socket node_bind;
#line 185
#
#line 185
# Allow access to network files including /etc/resolv.conf
#line 185
#
#line 185
allow postfix_smtpd_t net_conf_t:file { read getattr lock ioctl };
#line 185

#line 185
allow postfix_smtpd_t self:tcp_socket { connect };
#line 185

#line 185

#line 185

#line 185

#line 185

#line 185
#
#line 185
# Allow the domain to create and use udp sockets.
#line 185
# Other kinds of sockets must be separately authorized for use.
#line 185
allow postfix_smtpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 185

#line 185
allow postfix_smtpd_t unlabeled_t:association { sendto recvfrom };
#line 185

#line 185
#
#line 185
# Allow the domain to send or receive using any network interface.
#line 185
# netif_type is a type attribute for all network interface types.
#line 185
#
#line 185
allow postfix_smtpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 185
#
#line 185
# Allow the domain to send to or receive from any node.
#line 185
# node_type is a type attribute for all node types.
#line 185
#
#line 185
allow postfix_smtpd_t node_type:node { udp_send rawip_send };
#line 185
allow postfix_smtpd_t node_type:node { udp_recv rawip_recv };
#line 185

#line 185
#
#line 185
# Allow the domain to send to or receive from any port.
#line 185
# port_type is a type attribute for all port types.
#line 185
#
#line 185

#line 185
allow postfix_smtpd_t port_type:udp_socket { send_msg recv_msg };
#line 185

#line 185

#line 185
# XXX Allow binding to any node type.  Remove once
#line 185
# individual rules have been added to all domains that 
#line 185
# bind sockets. 
#line 185
allow postfix_smtpd_t node_type:udp_socket node_bind;
#line 185
#
#line 185
# Allow access to network files including /etc/resolv.conf
#line 185
#
#line 185
allow postfix_smtpd_t net_conf_t:file { read getattr lock ioctl };
#line 185

#line 185
allow postfix_smtpd_t self:udp_socket { connect };
#line 185

#line 185

#line 185

#line 185

#line 185

#line 185

#line 185
allow postfix_smtpd_t var_yp_t:dir { read getattr lock search ioctl };
#line 185
allow postfix_smtpd_t var_yp_t:file { read getattr lock ioctl };
#line 185
allow postfix_smtpd_t var_yp_t:lnk_file { getattr read };
#line 185

#line 185
allow postfix_smtpd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 185
allow postfix_smtpd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 185
dontaudit postfix_smtpd_t self:capability net_bind_service;
#line 185
dontaudit postfix_smtpd_t reserved_port_type:tcp_socket name_connect;
#line 185
dontaudit postfix_smtpd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 185

#line 185
} else {
#line 185
dontaudit postfix_smtpd_t var_yp_t:dir search;
#line 185
}
#line 185
 
#line 185

allow postfix_smtpd_t postfix_master_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
allow postfix_smtpd_t { postfix_private_t postfix_public_t }:dir search;
allow postfix_smtpd_t { postfix_private_t postfix_public_t }:sock_file { ioctl read getattr lock write append };
allow postfix_smtpd_t postfix_master_t:unix_stream_socket connectto;
# for OpenSSL certificates

#line 191
allow postfix_smtpd_t usr_t:dir { read getattr lock search ioctl };
#line 191
allow postfix_smtpd_t usr_t:file { read getattr lock ioctl };
#line 191
allow postfix_smtpd_t usr_t:lnk_file { getattr read };
#line 191

allow postfix_smtpd_t etc_aliases_t:file { read getattr lock ioctl };
allow postfix_smtpd_t self:file { getattr read };

# for prng_exch
allow postfix_smtpd_t postfix_spool_t:file { ioctl read getattr lock write append };

allow { postfix_smtp_t postfix_smtpd_t } postfix_prng_t:file { ioctl read getattr lock write append };


#line 200

#line 200

#line 200
type postfix_local_t, domain, privlog, daemon , mta_delivery_agent;
#line 200
type postfix_local_exec_t, file_type, sysadmfile, exec_type;
#line 200
dontaudit postfix_local_t self:capability sys_tty_config;
#line 200

#line 200
role system_r types postfix_local_t;
#line 200

#line 200
# Inherit and use descriptors from init.
#line 200
allow postfix_local_t init_t:fd use;
#line 200
allow postfix_local_t init_t:process sigchld;
#line 200
allow postfix_local_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 200

#line 200

#line 200
allow postfix_local_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t lib_t:lnk_file { read getattr lock ioctl };
#line 200
allow postfix_local_t ld_so_t:file { read getattr lock execute ioctl };
#line 200
#allow postfix_local_t ld_so_t:file execute_no_trans;
#line 200
allow postfix_local_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 200
allow postfix_local_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 200
allow postfix_local_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 200
allow postfix_local_t texrel_shlib_t:file execmod;
#line 200
allow postfix_local_t ld_so_cache_t:file { read getattr lock ioctl };
#line 200
allow postfix_local_t device_t:dir search;
#line 200
allow postfix_local_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 200

#line 200

#line 200
allow postfix_local_t { self proc_t }:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t { self proc_t }:lnk_file { getattr read };
#line 200

#line 200
allow postfix_local_t device_t:dir { read getattr lock search ioctl };
#line 200

#line 200
allow postfix_local_t udev_tdb_t:file { read getattr lock ioctl };
#line 200
allow postfix_local_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 200
dontaudit postfix_local_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 200
dontaudit postfix_local_t unpriv_userdomain:fd use;
#line 200

#line 200

#line 200
allow postfix_local_t sysfs_t:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t sysfs_t:file { read getattr lock ioctl };
#line 200
allow postfix_local_t sysfs_t:lnk_file { getattr read };
#line 200
 
#line 200

#line 200
allow postfix_local_t autofs_t:dir { search getattr };
#line 200

#line 200
dontaudit postfix_local_t { tty_device_t devpts_t }:chr_file { read write };
#line 200
dontaudit postfix_local_t root_t:file { getattr read };
#line 200
 
#line 200

#line 200
allow postfix_local_t self:process setpgid;
#line 200
allow postfix_local_t postfix_master_t:process sigchld;
#line 200
allow postfix_master_t postfix_local_t:process signal;
#line 200

#line 200
allow postfix_local_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t postfix_etc_t:file { read getattr lock ioctl };
#line 200

#line 200
allow postfix_local_t etc_t:lnk_file read;
#line 200
allow postfix_local_t lib_t:file { read getattr lock ioctl };
#line 200

#line 200
allow postfix_local_t locale_t:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t locale_t:file { read getattr lock ioctl };
#line 200
allow postfix_local_t locale_t:lnk_file { getattr read };
#line 200

#line 200

#line 200
allow postfix_local_t etc_t:file { getattr read };
#line 200
allow postfix_local_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 200
allow postfix_local_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 200
allow postfix_local_t self:unix_stream_socket connectto;
#line 200

#line 200
allow postfix_local_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t { bin_t usr_t }:lnk_file { getattr read };
#line 200
allow postfix_local_t shell_exec_t:file { read getattr lock execute ioctl };
#line 200
allow postfix_local_t { var_t var_spool_t }:dir { search getattr };
#line 200
allow postfix_local_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 200
allow postfix_local_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 200
allow postfix_local_t etc_runtime_t:file { read getattr lock ioctl };
#line 200
allow postfix_local_t proc_t:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t proc_t:file { read getattr lock ioctl };
#line 200
allow postfix_local_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t fs_t:filesystem getattr;
#line 200
allow postfix_local_t proc_net_t:dir search;
#line 200
allow postfix_local_t proc_net_t:file { getattr read };
#line 200

#line 200
allow postfix_local_t postfix_local_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 200

#line 200

#line 200
allow postfix_local_t cert_t:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t cert_t:file { read getattr lock ioctl };
#line 200
allow postfix_local_t cert_t:lnk_file { getattr read };
#line 200

#line 200
allow postfix_local_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 200

#line 200
allow postfix_local_t tmp_t:dir getattr;
#line 200

#line 200

#line 200

#line 200

#line 200

#line 200
#
#line 200
# Allow the process to modify the directory.
#line 200
#
#line 200
allow postfix_local_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 200

#line 200
#
#line 200
# Allow the process to create the file.
#line 200
#
#line 200

#line 200

#line 200

#line 200

#line 200

#line 200
allow postfix_local_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200
type_transition postfix_local_t var_run_t:file postfix_var_run_t;
#line 200

#line 200

#line 200

#line 200

#line 200
# Read system variables in /sys.
#line 200

#line 200
allow postfix_local_t sysctl_t:dir search;
#line 200
allow postfix_local_t sysctl_kernel_t:dir search;
#line 200
allow postfix_local_t sysctl_kernel_t:file { getattr read };
#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200
#
#line 200
# Allow the process to transition to the new domain.
#line 200
#
#line 200
allow postfix_master_t postfix_local_t:process transition;
#line 200

#line 200
#
#line 200
# Do not audit when glibc secure mode is enabled upon the transition.
#line 200
#
#line 200
dontaudit postfix_master_t postfix_local_t:process noatsecure;
#line 200

#line 200
#
#line 200
# Do not audit when signal-related state is cleared upon the transition.
#line 200
#
#line 200
dontaudit postfix_master_t postfix_local_t:process siginh;
#line 200

#line 200
#
#line 200
# Do not audit when resource limits are reset upon the transition.
#line 200
#
#line 200
dontaudit postfix_master_t postfix_local_t:process rlimitinh;
#line 200

#line 200
#
#line 200
# Allow the process to execute the program.
#line 200
# 
#line 200
allow postfix_master_t postfix_local_exec_t:file { read { getattr execute } };
#line 200

#line 200
#
#line 200
# Allow the process to reap the new domain.
#line 200
#
#line 200
allow postfix_local_t postfix_master_t:process sigchld;
#line 200

#line 200
#
#line 200
# Allow the new domain to inherit and use file 
#line 200
# descriptions from the creating process and vice versa.
#line 200
#
#line 200
allow postfix_local_t postfix_master_t:fd use;
#line 200
allow postfix_master_t postfix_local_t:fd use;
#line 200

#line 200
#
#line 200
# Allow the new domain to write back to the old domain via a pipe.
#line 200
#
#line 200
allow postfix_local_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 200

#line 200
#
#line 200
# Allow the new domain to read and execute the program.
#line 200
#
#line 200
allow postfix_local_t postfix_local_exec_t:file { read getattr lock execute ioctl };
#line 200

#line 200
#
#line 200
# Allow the new domain to be entered via the program.
#line 200
#
#line 200
allow postfix_local_t postfix_local_exec_t:file entrypoint;
#line 200

#line 200
type_transition postfix_master_t postfix_local_exec_t:process postfix_local_t;
#line 200

#line 200
allow postfix_local_t postfix_master_t:unix_stream_socket { connectto { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept } };
#line 200
allow postfix_local_t self:capability { setuid setgid dac_override };
#line 200

#line 200

#line 200

#line 200

#line 200
#
#line 200
# Allow the domain to create and use tcp sockets.
#line 200
# Other kinds of sockets must be separately authorized for use.
#line 200
allow postfix_local_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 200

#line 200
allow postfix_local_t unlabeled_t:association { sendto recvfrom };
#line 200

#line 200
#
#line 200
# Allow the domain to send or receive using any network interface.
#line 200
# netif_type is a type attribute for all network interface types.
#line 200
#
#line 200
allow postfix_local_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 200
#
#line 200
# Allow the domain to send to or receive from any node.
#line 200
# node_type is a type attribute for all node types.
#line 200
#
#line 200
allow postfix_local_t node_type:node { tcp_send rawip_send };
#line 200
allow postfix_local_t node_type:node { tcp_recv rawip_recv };
#line 200

#line 200
#
#line 200
# Allow the domain to send to or receive from any port.
#line 200
# port_type is a type attribute for all port types.
#line 200
#
#line 200

#line 200
allow postfix_local_t port_type:tcp_socket { send_msg recv_msg };
#line 200

#line 200

#line 200
# XXX Allow binding to any node type.  Remove once
#line 200
# individual rules have been added to all domains that 
#line 200
# bind sockets. 
#line 200
allow postfix_local_t node_type:tcp_socket node_bind;
#line 200
#
#line 200
# Allow access to network files including /etc/resolv.conf
#line 200
#
#line 200
allow postfix_local_t net_conf_t:file { read getattr lock ioctl };
#line 200

#line 200
allow postfix_local_t self:tcp_socket { connect };
#line 200

#line 200

#line 200

#line 200
#
#line 200
# Allow the domain to create and use udp sockets.
#line 200
# Other kinds of sockets must be separately authorized for use.
#line 200
allow postfix_local_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 200

#line 200
allow postfix_local_t unlabeled_t:association { sendto recvfrom };
#line 200

#line 200
#
#line 200
# Allow the domain to send or receive using any network interface.
#line 200
# netif_type is a type attribute for all network interface types.
#line 200
#
#line 200
allow postfix_local_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 200
#
#line 200
# Allow the domain to send to or receive from any node.
#line 200
# node_type is a type attribute for all node types.
#line 200
#
#line 200
allow postfix_local_t node_type:node { udp_send rawip_send };
#line 200
allow postfix_local_t node_type:node { udp_recv rawip_recv };
#line 200

#line 200
#
#line 200
# Allow the domain to send to or receive from any port.
#line 200
# port_type is a type attribute for all port types.
#line 200
#
#line 200

#line 200
allow postfix_local_t port_type:udp_socket { send_msg recv_msg };
#line 200

#line 200

#line 200
# XXX Allow binding to any node type.  Remove once
#line 200
# individual rules have been added to all domains that 
#line 200
# bind sockets. 
#line 200
allow postfix_local_t node_type:udp_socket node_bind;
#line 200
#
#line 200
# Allow access to network files including /etc/resolv.conf
#line 200
#
#line 200
allow postfix_local_t net_conf_t:file { read getattr lock ioctl };
#line 200

#line 200
allow postfix_local_t self:udp_socket { connect };
#line 200

#line 200

#line 200

#line 200
allow postfix_local_t port_type:tcp_socket name_connect;
#line 200

#line 200

#line 200
if (allow_ypbind) {
#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200
#
#line 200
# Allow the domain to create and use tcp sockets.
#line 200
# Other kinds of sockets must be separately authorized for use.
#line 200
allow postfix_local_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 200

#line 200
allow postfix_local_t unlabeled_t:association { sendto recvfrom };
#line 200

#line 200
#
#line 200
# Allow the domain to send or receive using any network interface.
#line 200
# netif_type is a type attribute for all network interface types.
#line 200
#
#line 200
allow postfix_local_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 200
#
#line 200
# Allow the domain to send to or receive from any node.
#line 200
# node_type is a type attribute for all node types.
#line 200
#
#line 200
allow postfix_local_t node_type:node { tcp_send rawip_send };
#line 200
allow postfix_local_t node_type:node { tcp_recv rawip_recv };
#line 200

#line 200
#
#line 200
# Allow the domain to send to or receive from any port.
#line 200
# port_type is a type attribute for all port types.
#line 200
#
#line 200

#line 200
allow postfix_local_t port_type:tcp_socket { send_msg recv_msg };
#line 200

#line 200

#line 200
# XXX Allow binding to any node type.  Remove once
#line 200
# individual rules have been added to all domains that 
#line 200
# bind sockets. 
#line 200
allow postfix_local_t node_type:tcp_socket node_bind;
#line 200
#
#line 200
# Allow access to network files including /etc/resolv.conf
#line 200
#
#line 200
allow postfix_local_t net_conf_t:file { read getattr lock ioctl };
#line 200

#line 200
allow postfix_local_t self:tcp_socket { listen accept };
#line 200

#line 200

#line 200

#line 200
#
#line 200
# Allow the domain to create and use tcp sockets.
#line 200
# Other kinds of sockets must be separately authorized for use.
#line 200
allow postfix_local_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 200

#line 200
allow postfix_local_t unlabeled_t:association { sendto recvfrom };
#line 200

#line 200
#
#line 200
# Allow the domain to send or receive using any network interface.
#line 200
# netif_type is a type attribute for all network interface types.
#line 200
#
#line 200
allow postfix_local_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 200
#
#line 200
# Allow the domain to send to or receive from any node.
#line 200
# node_type is a type attribute for all node types.
#line 200
#
#line 200
allow postfix_local_t node_type:node { tcp_send rawip_send };
#line 200
allow postfix_local_t node_type:node { tcp_recv rawip_recv };
#line 200

#line 200
#
#line 200
# Allow the domain to send to or receive from any port.
#line 200
# port_type is a type attribute for all port types.
#line 200
#
#line 200

#line 200
allow postfix_local_t port_type:tcp_socket { send_msg recv_msg };
#line 200

#line 200

#line 200
# XXX Allow binding to any node type.  Remove once
#line 200
# individual rules have been added to all domains that 
#line 200
# bind sockets. 
#line 200
allow postfix_local_t node_type:tcp_socket node_bind;
#line 200
#
#line 200
# Allow access to network files including /etc/resolv.conf
#line 200
#
#line 200
allow postfix_local_t net_conf_t:file { read getattr lock ioctl };
#line 200

#line 200
allow postfix_local_t self:tcp_socket { connect };
#line 200

#line 200

#line 200

#line 200

#line 200

#line 200
#
#line 200
# Allow the domain to create and use udp sockets.
#line 200
# Other kinds of sockets must be separately authorized for use.
#line 200
allow postfix_local_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 200

#line 200
allow postfix_local_t unlabeled_t:association { sendto recvfrom };
#line 200

#line 200
#
#line 200
# Allow the domain to send or receive using any network interface.
#line 200
# netif_type is a type attribute for all network interface types.
#line 200
#
#line 200
allow postfix_local_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 200
#
#line 200
# Allow the domain to send to or receive from any node.
#line 200
# node_type is a type attribute for all node types.
#line 200
#
#line 200
allow postfix_local_t node_type:node { udp_send rawip_send };
#line 200
allow postfix_local_t node_type:node { udp_recv rawip_recv };
#line 200

#line 200
#
#line 200
# Allow the domain to send to or receive from any port.
#line 200
# port_type is a type attribute for all port types.
#line 200
#
#line 200

#line 200
allow postfix_local_t port_type:udp_socket { send_msg recv_msg };
#line 200

#line 200

#line 200
# XXX Allow binding to any node type.  Remove once
#line 200
# individual rules have been added to all domains that 
#line 200
# bind sockets. 
#line 200
allow postfix_local_t node_type:udp_socket node_bind;
#line 200
#
#line 200
# Allow access to network files including /etc/resolv.conf
#line 200
#
#line 200
allow postfix_local_t net_conf_t:file { read getattr lock ioctl };
#line 200

#line 200
allow postfix_local_t self:udp_socket { connect };
#line 200

#line 200

#line 200

#line 200

#line 200

#line 200

#line 200
allow postfix_local_t var_yp_t:dir { read getattr lock search ioctl };
#line 200
allow postfix_local_t var_yp_t:file { read getattr lock ioctl };
#line 200
allow postfix_local_t var_yp_t:lnk_file { getattr read };
#line 200

#line 200
allow postfix_local_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 200
allow postfix_local_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 200
dontaudit postfix_local_t self:capability net_bind_service;
#line 200
dontaudit postfix_local_t reserved_port_type:tcp_socket name_connect;
#line 200
dontaudit postfix_local_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 200

#line 200
} else {
#line 200
dontaudit postfix_local_t var_yp_t:dir search;
#line 200
}
#line 200
 
#line 200

#line 206

allow postfix_local_t etc_aliases_t:file { read getattr lock ioctl };
allow postfix_local_t self:fifo_file { ioctl read getattr lock write append };
allow postfix_local_t self:process { setsched setrlimit };
allow postfix_local_t postfix_spool_t:file { ioctl read getattr lock write append };
# for .forward - maybe we need a new type for it?
allow postfix_local_t postfix_private_t:dir search;
allow postfix_local_t postfix_private_t:sock_file { ioctl read getattr lock write append };
allow postfix_local_t postfix_master_t:unix_stream_socket connectto;
allow postfix_local_t postfix_public_t:dir search;
allow postfix_local_t postfix_public_t:sock_file write;

#line 217
type postfix_local_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 217

#line 217

#line 217

#line 217

#line 217
#
#line 217
# Allow the process to modify the directory.
#line 217
#
#line 217
allow postfix_local_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 217

#line 217
#
#line 217
# Allow the process to create the file.
#line 217
#
#line 217

#line 217

#line 217

#line 217

#line 217

#line 217
allow postfix_local_t postfix_local_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 217

#line 217

#line 217

#line 217

#line 217

#line 217

#line 217
allow postfix_local_t postfix_local_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 217

#line 217

#line 217

#line 217

#line 217

#line 217

#line 217

#line 217

#line 217

#line 217

#line 217

#line 217
type_transition postfix_local_t tmp_t:{ file dir } postfix_local_tmp_t;
#line 217

#line 217

#line 217


#line 218
allow postfix_local_t { shell_exec_t bin_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 218

#line 221

allow postfix_local_t mail_spool_t:dir { remove_name };
allow postfix_local_t mail_spool_t:file { unlink };
# For reading spamassasin

#line 225
allow postfix_local_t etc_mail_t:dir { read getattr lock search ioctl };
#line 225
allow postfix_local_t etc_mail_t:file { read getattr lock ioctl };
#line 225
allow postfix_local_t etc_mail_t:lnk_file { getattr read };
#line 225


#line 230



#line 232

#line 232

#line 232

#line 232
type postfix_cleanup_t, domain, privlog, daemon ;
#line 232
type postfix_cleanup_exec_t, file_type, sysadmfile, exec_type;
#line 232
dontaudit postfix_cleanup_t self:capability sys_tty_config;
#line 232

#line 232
role system_r types postfix_cleanup_t;
#line 232

#line 232
# Inherit and use descriptors from init.
#line 232
allow postfix_cleanup_t init_t:fd use;
#line 232
allow postfix_cleanup_t init_t:process sigchld;
#line 232
allow postfix_cleanup_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 232

#line 232

#line 232
allow postfix_cleanup_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t lib_t:lnk_file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t ld_so_t:file { read getattr lock execute ioctl };
#line 232
#allow postfix_cleanup_t ld_so_t:file execute_no_trans;
#line 232
allow postfix_cleanup_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 232
allow postfix_cleanup_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t texrel_shlib_t:file execmod;
#line 232
allow postfix_cleanup_t ld_so_cache_t:file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t device_t:dir search;
#line 232
allow postfix_cleanup_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 232

#line 232

#line 232
allow postfix_cleanup_t { self proc_t }:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t { self proc_t }:lnk_file { getattr read };
#line 232

#line 232
allow postfix_cleanup_t device_t:dir { read getattr lock search ioctl };
#line 232

#line 232
allow postfix_cleanup_t udev_tdb_t:file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 232
dontaudit postfix_cleanup_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 232
dontaudit postfix_cleanup_t unpriv_userdomain:fd use;
#line 232

#line 232

#line 232
allow postfix_cleanup_t sysfs_t:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t sysfs_t:file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t sysfs_t:lnk_file { getattr read };
#line 232
 
#line 232

#line 232
allow postfix_cleanup_t autofs_t:dir { search getattr };
#line 232

#line 232
dontaudit postfix_cleanup_t { tty_device_t devpts_t }:chr_file { read write };
#line 232
dontaudit postfix_cleanup_t root_t:file { getattr read };
#line 232
 
#line 232

#line 232
allow postfix_cleanup_t self:process setpgid;
#line 232
allow postfix_cleanup_t postfix_master_t:process sigchld;
#line 232
allow postfix_master_t postfix_cleanup_t:process signal;
#line 232

#line 232
allow postfix_cleanup_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t postfix_etc_t:file { read getattr lock ioctl };
#line 232

#line 232
allow postfix_cleanup_t etc_t:lnk_file read;
#line 232
allow postfix_cleanup_t lib_t:file { read getattr lock ioctl };
#line 232

#line 232
allow postfix_cleanup_t locale_t:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t locale_t:file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t locale_t:lnk_file { getattr read };
#line 232

#line 232

#line 232
allow postfix_cleanup_t etc_t:file { getattr read };
#line 232
allow postfix_cleanup_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 232
allow postfix_cleanup_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 232
allow postfix_cleanup_t self:unix_stream_socket connectto;
#line 232

#line 232
allow postfix_cleanup_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t { bin_t usr_t }:lnk_file { getattr read };
#line 232
allow postfix_cleanup_t shell_exec_t:file { read getattr lock execute ioctl };
#line 232
allow postfix_cleanup_t { var_t var_spool_t }:dir { search getattr };
#line 232
allow postfix_cleanup_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 232
allow postfix_cleanup_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 232
allow postfix_cleanup_t etc_runtime_t:file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t proc_t:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t proc_t:file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t fs_t:filesystem getattr;
#line 232
allow postfix_cleanup_t proc_net_t:dir search;
#line 232
allow postfix_cleanup_t proc_net_t:file { getattr read };
#line 232

#line 232
allow postfix_cleanup_t postfix_cleanup_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 232

#line 232

#line 232
allow postfix_cleanup_t cert_t:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t cert_t:file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t cert_t:lnk_file { getattr read };
#line 232

#line 232
allow postfix_cleanup_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 232

#line 232
allow postfix_cleanup_t tmp_t:dir getattr;
#line 232

#line 232

#line 232

#line 232

#line 232

#line 232
#
#line 232
# Allow the process to modify the directory.
#line 232
#
#line 232
allow postfix_cleanup_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 232

#line 232
#
#line 232
# Allow the process to create the file.
#line 232
#
#line 232

#line 232

#line 232

#line 232

#line 232

#line 232
allow postfix_cleanup_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232
type_transition postfix_cleanup_t var_run_t:file postfix_var_run_t;
#line 232

#line 232

#line 232

#line 232

#line 232
# Read system variables in /sys.
#line 232

#line 232
allow postfix_cleanup_t sysctl_t:dir search;
#line 232
allow postfix_cleanup_t sysctl_kernel_t:dir search;
#line 232
allow postfix_cleanup_t sysctl_kernel_t:file { getattr read };
#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232
#
#line 232
# Allow the process to transition to the new domain.
#line 232
#
#line 232
allow postfix_master_t postfix_cleanup_t:process transition;
#line 232

#line 232
#
#line 232
# Do not audit when glibc secure mode is enabled upon the transition.
#line 232
#
#line 232
dontaudit postfix_master_t postfix_cleanup_t:process noatsecure;
#line 232

#line 232
#
#line 232
# Do not audit when signal-related state is cleared upon the transition.
#line 232
#
#line 232
dontaudit postfix_master_t postfix_cleanup_t:process siginh;
#line 232

#line 232
#
#line 232
# Do not audit when resource limits are reset upon the transition.
#line 232
#
#line 232
dontaudit postfix_master_t postfix_cleanup_t:process rlimitinh;
#line 232

#line 232
#
#line 232
# Allow the process to execute the program.
#line 232
# 
#line 232
allow postfix_master_t postfix_cleanup_exec_t:file { read { getattr execute } };
#line 232

#line 232
#
#line 232
# Allow the process to reap the new domain.
#line 232
#
#line 232
allow postfix_cleanup_t postfix_master_t:process sigchld;
#line 232

#line 232
#
#line 232
# Allow the new domain to inherit and use file 
#line 232
# descriptions from the creating process and vice versa.
#line 232
#
#line 232
allow postfix_cleanup_t postfix_master_t:fd use;
#line 232
allow postfix_master_t postfix_cleanup_t:fd use;
#line 232

#line 232
#
#line 232
# Allow the new domain to write back to the old domain via a pipe.
#line 232
#
#line 232
allow postfix_cleanup_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 232

#line 232
#
#line 232
# Allow the new domain to read and execute the program.
#line 232
#
#line 232
allow postfix_cleanup_t postfix_cleanup_exec_t:file { read getattr lock execute ioctl };
#line 232

#line 232
#
#line 232
# Allow the new domain to be entered via the program.
#line 232
#
#line 232
allow postfix_cleanup_t postfix_cleanup_exec_t:file entrypoint;
#line 232

#line 232
type_transition postfix_master_t postfix_cleanup_exec_t:process postfix_cleanup_t;
#line 232

#line 232
allow postfix_cleanup_t postfix_master_t:unix_stream_socket { connectto { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept } };
#line 232
allow postfix_cleanup_t self:capability { setuid setgid dac_override };
#line 232

#line 232

#line 232

#line 232

#line 232
#
#line 232
# Allow the domain to create and use tcp sockets.
#line 232
# Other kinds of sockets must be separately authorized for use.
#line 232
allow postfix_cleanup_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 232

#line 232
allow postfix_cleanup_t unlabeled_t:association { sendto recvfrom };
#line 232

#line 232
#
#line 232
# Allow the domain to send or receive using any network interface.
#line 232
# netif_type is a type attribute for all network interface types.
#line 232
#
#line 232
allow postfix_cleanup_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 232
#
#line 232
# Allow the domain to send to or receive from any node.
#line 232
# node_type is a type attribute for all node types.
#line 232
#
#line 232
allow postfix_cleanup_t node_type:node { tcp_send rawip_send };
#line 232
allow postfix_cleanup_t node_type:node { tcp_recv rawip_recv };
#line 232

#line 232
#
#line 232
# Allow the domain to send to or receive from any port.
#line 232
# port_type is a type attribute for all port types.
#line 232
#
#line 232

#line 232
allow postfix_cleanup_t port_type:tcp_socket { send_msg recv_msg };
#line 232

#line 232

#line 232
# XXX Allow binding to any node type.  Remove once
#line 232
# individual rules have been added to all domains that 
#line 232
# bind sockets. 
#line 232
allow postfix_cleanup_t node_type:tcp_socket node_bind;
#line 232
#
#line 232
# Allow access to network files including /etc/resolv.conf
#line 232
#
#line 232
allow postfix_cleanup_t net_conf_t:file { read getattr lock ioctl };
#line 232

#line 232
allow postfix_cleanup_t self:tcp_socket { connect };
#line 232

#line 232

#line 232

#line 232
#
#line 232
# Allow the domain to create and use udp sockets.
#line 232
# Other kinds of sockets must be separately authorized for use.
#line 232
allow postfix_cleanup_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 232

#line 232
allow postfix_cleanup_t unlabeled_t:association { sendto recvfrom };
#line 232

#line 232
#
#line 232
# Allow the domain to send or receive using any network interface.
#line 232
# netif_type is a type attribute for all network interface types.
#line 232
#
#line 232
allow postfix_cleanup_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 232
#
#line 232
# Allow the domain to send to or receive from any node.
#line 232
# node_type is a type attribute for all node types.
#line 232
#
#line 232
allow postfix_cleanup_t node_type:node { udp_send rawip_send };
#line 232
allow postfix_cleanup_t node_type:node { udp_recv rawip_recv };
#line 232

#line 232
#
#line 232
# Allow the domain to send to or receive from any port.
#line 232
# port_type is a type attribute for all port types.
#line 232
#
#line 232

#line 232
allow postfix_cleanup_t port_type:udp_socket { send_msg recv_msg };
#line 232

#line 232

#line 232
# XXX Allow binding to any node type.  Remove once
#line 232
# individual rules have been added to all domains that 
#line 232
# bind sockets. 
#line 232
allow postfix_cleanup_t node_type:udp_socket node_bind;
#line 232
#
#line 232
# Allow access to network files including /etc/resolv.conf
#line 232
#
#line 232
allow postfix_cleanup_t net_conf_t:file { read getattr lock ioctl };
#line 232

#line 232
allow postfix_cleanup_t self:udp_socket { connect };
#line 232

#line 232

#line 232

#line 232
allow postfix_cleanup_t port_type:tcp_socket name_connect;
#line 232

#line 232

#line 232
if (allow_ypbind) {
#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232
#
#line 232
# Allow the domain to create and use tcp sockets.
#line 232
# Other kinds of sockets must be separately authorized for use.
#line 232
allow postfix_cleanup_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 232

#line 232
allow postfix_cleanup_t unlabeled_t:association { sendto recvfrom };
#line 232

#line 232
#
#line 232
# Allow the domain to send or receive using any network interface.
#line 232
# netif_type is a type attribute for all network interface types.
#line 232
#
#line 232
allow postfix_cleanup_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 232
#
#line 232
# Allow the domain to send to or receive from any node.
#line 232
# node_type is a type attribute for all node types.
#line 232
#
#line 232
allow postfix_cleanup_t node_type:node { tcp_send rawip_send };
#line 232
allow postfix_cleanup_t node_type:node { tcp_recv rawip_recv };
#line 232

#line 232
#
#line 232
# Allow the domain to send to or receive from any port.
#line 232
# port_type is a type attribute for all port types.
#line 232
#
#line 232

#line 232
allow postfix_cleanup_t port_type:tcp_socket { send_msg recv_msg };
#line 232

#line 232

#line 232
# XXX Allow binding to any node type.  Remove once
#line 232
# individual rules have been added to all domains that 
#line 232
# bind sockets. 
#line 232
allow postfix_cleanup_t node_type:tcp_socket node_bind;
#line 232
#
#line 232
# Allow access to network files including /etc/resolv.conf
#line 232
#
#line 232
allow postfix_cleanup_t net_conf_t:file { read getattr lock ioctl };
#line 232

#line 232
allow postfix_cleanup_t self:tcp_socket { listen accept };
#line 232

#line 232

#line 232

#line 232
#
#line 232
# Allow the domain to create and use tcp sockets.
#line 232
# Other kinds of sockets must be separately authorized for use.
#line 232
allow postfix_cleanup_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 232

#line 232
allow postfix_cleanup_t unlabeled_t:association { sendto recvfrom };
#line 232

#line 232
#
#line 232
# Allow the domain to send or receive using any network interface.
#line 232
# netif_type is a type attribute for all network interface types.
#line 232
#
#line 232
allow postfix_cleanup_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 232
#
#line 232
# Allow the domain to send to or receive from any node.
#line 232
# node_type is a type attribute for all node types.
#line 232
#
#line 232
allow postfix_cleanup_t node_type:node { tcp_send rawip_send };
#line 232
allow postfix_cleanup_t node_type:node { tcp_recv rawip_recv };
#line 232

#line 232
#
#line 232
# Allow the domain to send to or receive from any port.
#line 232
# port_type is a type attribute for all port types.
#line 232
#
#line 232

#line 232
allow postfix_cleanup_t port_type:tcp_socket { send_msg recv_msg };
#line 232

#line 232

#line 232
# XXX Allow binding to any node type.  Remove once
#line 232
# individual rules have been added to all domains that 
#line 232
# bind sockets. 
#line 232
allow postfix_cleanup_t node_type:tcp_socket node_bind;
#line 232
#
#line 232
# Allow access to network files including /etc/resolv.conf
#line 232
#
#line 232
allow postfix_cleanup_t net_conf_t:file { read getattr lock ioctl };
#line 232

#line 232
allow postfix_cleanup_t self:tcp_socket { connect };
#line 232

#line 232

#line 232

#line 232

#line 232

#line 232
#
#line 232
# Allow the domain to create and use udp sockets.
#line 232
# Other kinds of sockets must be separately authorized for use.
#line 232
allow postfix_cleanup_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 232

#line 232
allow postfix_cleanup_t unlabeled_t:association { sendto recvfrom };
#line 232

#line 232
#
#line 232
# Allow the domain to send or receive using any network interface.
#line 232
# netif_type is a type attribute for all network interface types.
#line 232
#
#line 232
allow postfix_cleanup_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 232
#
#line 232
# Allow the domain to send to or receive from any node.
#line 232
# node_type is a type attribute for all node types.
#line 232
#
#line 232
allow postfix_cleanup_t node_type:node { udp_send rawip_send };
#line 232
allow postfix_cleanup_t node_type:node { udp_recv rawip_recv };
#line 232

#line 232
#
#line 232
# Allow the domain to send to or receive from any port.
#line 232
# port_type is a type attribute for all port types.
#line 232
#
#line 232

#line 232
allow postfix_cleanup_t port_type:udp_socket { send_msg recv_msg };
#line 232

#line 232

#line 232
# XXX Allow binding to any node type.  Remove once
#line 232
# individual rules have been added to all domains that 
#line 232
# bind sockets. 
#line 232
allow postfix_cleanup_t node_type:udp_socket node_bind;
#line 232
#
#line 232
# Allow access to network files including /etc/resolv.conf
#line 232
#
#line 232
allow postfix_cleanup_t net_conf_t:file { read getattr lock ioctl };
#line 232

#line 232
allow postfix_cleanup_t self:udp_socket { connect };
#line 232

#line 232

#line 232

#line 232

#line 232

#line 232

#line 232
allow postfix_cleanup_t var_yp_t:dir { read getattr lock search ioctl };
#line 232
allow postfix_cleanup_t var_yp_t:file { read getattr lock ioctl };
#line 232
allow postfix_cleanup_t var_yp_t:lnk_file { getattr read };
#line 232

#line 232
allow postfix_cleanup_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 232
allow postfix_cleanup_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 232
dontaudit postfix_cleanup_t self:capability net_bind_service;
#line 232
dontaudit postfix_cleanup_t reserved_port_type:tcp_socket name_connect;
#line 232
dontaudit postfix_cleanup_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 232

#line 232
} else {
#line 232
dontaudit postfix_cleanup_t var_yp_t:dir search;
#line 232
}
#line 232
 
#line 232

#line 232
allow postfix_cleanup_t postfix_public_t:dir search;
#line 232


#line 233
allow postfix_cleanup_t postfix_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 233
allow postfix_cleanup_t postfix_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 233
allow postfix_cleanup_t postfix_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 233

allow postfix_cleanup_t postfix_public_t:fifo_file { ioctl read getattr lock write append };
allow postfix_cleanup_t postfix_public_t:sock_file { getattr write };
allow postfix_cleanup_t postfix_private_t:dir search;
allow postfix_cleanup_t postfix_private_t:sock_file { ioctl read getattr lock write append };
allow postfix_cleanup_t postfix_master_t:unix_stream_socket connectto;
allow postfix_cleanup_t postfix_spool_bounce_t:dir { read getattr lock search ioctl };
allow postfix_cleanup_t self:process setrlimit;

allow user_mail_domain postfix_spool_t:dir { read getattr lock search ioctl };
allow user_mail_domain postfix_etc_t:dir { read getattr lock search ioctl };
allow { user_mail_domain initrc_t } postfix_etc_t:file { read getattr lock ioctl };
allow user_mail_domain self:capability dac_override;

#line 256



#line 258

#line 258

#line 258
type postfix_postqueue_t, domain, privlog, daemon ;
#line 258
type postfix_postqueue_exec_t, file_type, sysadmfile, exec_type;
#line 258
dontaudit postfix_postqueue_t self:capability sys_tty_config;
#line 258

#line 258
role system_r types postfix_postqueue_t;
#line 258

#line 258
# Inherit and use descriptors from init.
#line 258
allow postfix_postqueue_t init_t:fd use;
#line 258
allow postfix_postqueue_t init_t:process sigchld;
#line 258
allow postfix_postqueue_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 258

#line 258

#line 258
allow postfix_postqueue_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 258
allow postfix_postqueue_t lib_t:lnk_file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t ld_so_t:file { read getattr lock execute ioctl };
#line 258
#allow postfix_postqueue_t ld_so_t:file execute_no_trans;
#line 258
allow postfix_postqueue_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 258
allow postfix_postqueue_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t texrel_shlib_t:file execmod;
#line 258
allow postfix_postqueue_t ld_so_cache_t:file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t device_t:dir search;
#line 258
allow postfix_postqueue_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 258

#line 258

#line 258
allow postfix_postqueue_t { self proc_t }:dir { read getattr lock search ioctl };
#line 258
allow postfix_postqueue_t { self proc_t }:lnk_file { getattr read };
#line 258

#line 258
allow postfix_postqueue_t device_t:dir { read getattr lock search ioctl };
#line 258

#line 258
allow postfix_postqueue_t udev_tdb_t:file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 258
dontaudit postfix_postqueue_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 258
dontaudit postfix_postqueue_t unpriv_userdomain:fd use;
#line 258

#line 258

#line 258
allow postfix_postqueue_t sysfs_t:dir { read getattr lock search ioctl };
#line 258
allow postfix_postqueue_t sysfs_t:file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t sysfs_t:lnk_file { getattr read };
#line 258
 
#line 258

#line 258
allow postfix_postqueue_t autofs_t:dir { search getattr };
#line 258

#line 258
dontaudit postfix_postqueue_t { tty_device_t devpts_t }:chr_file { read write };
#line 258
dontaudit postfix_postqueue_t root_t:file { getattr read };
#line 258
 
#line 258

#line 258
allow postfix_postqueue_t self:process setpgid;
#line 258
allow postfix_postqueue_t postfix_master_t:process sigchld;
#line 258
allow postfix_master_t postfix_postqueue_t:process signal;
#line 258

#line 258
allow postfix_postqueue_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 258
allow postfix_postqueue_t postfix_etc_t:file { read getattr lock ioctl };
#line 258

#line 258
allow postfix_postqueue_t etc_t:lnk_file read;
#line 258
allow postfix_postqueue_t lib_t:file { read getattr lock ioctl };
#line 258

#line 258
allow postfix_postqueue_t locale_t:dir { read getattr lock search ioctl };
#line 258
allow postfix_postqueue_t locale_t:file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t locale_t:lnk_file { getattr read };
#line 258

#line 258

#line 258
allow postfix_postqueue_t etc_t:file { getattr read };
#line 258
allow postfix_postqueue_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 258
allow postfix_postqueue_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 258
allow postfix_postqueue_t self:unix_stream_socket connectto;
#line 258

#line 258
allow postfix_postqueue_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 258
allow postfix_postqueue_t { bin_t usr_t }:lnk_file { getattr read };
#line 258
allow postfix_postqueue_t shell_exec_t:file { read getattr lock execute ioctl };
#line 258
allow postfix_postqueue_t { var_t var_spool_t }:dir { search getattr };
#line 258
allow postfix_postqueue_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 258
allow postfix_postqueue_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 258
allow postfix_postqueue_t etc_runtime_t:file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t proc_t:dir { read getattr lock search ioctl };
#line 258
allow postfix_postqueue_t proc_t:file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 258
allow postfix_postqueue_t fs_t:filesystem getattr;
#line 258
allow postfix_postqueue_t proc_net_t:dir search;
#line 258
allow postfix_postqueue_t proc_net_t:file { getattr read };
#line 258

#line 258
allow postfix_postqueue_t postfix_postqueue_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 258

#line 258

#line 258
allow postfix_postqueue_t cert_t:dir { read getattr lock search ioctl };
#line 258
allow postfix_postqueue_t cert_t:file { read getattr lock ioctl };
#line 258
allow postfix_postqueue_t cert_t:lnk_file { getattr read };
#line 258

#line 258
allow postfix_postqueue_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 258

#line 258
allow postfix_postqueue_t tmp_t:dir getattr;
#line 258

#line 258

#line 258

#line 258

#line 258

#line 258
#
#line 258
# Allow the process to modify the directory.
#line 258
#
#line 258
allow postfix_postqueue_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 258

#line 258
#
#line 258
# Allow the process to create the file.
#line 258
#
#line 258

#line 258

#line 258

#line 258

#line 258

#line 258
allow postfix_postqueue_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 258

#line 258

#line 258

#line 258

#line 258

#line 258

#line 258

#line 258

#line 258

#line 258
type_transition postfix_postqueue_t var_run_t:file postfix_var_run_t;
#line 258

#line 258

#line 258

#line 258

#line 258
# Read system variables in /sys.
#line 258

#line 258
allow postfix_postqueue_t sysctl_t:dir search;
#line 258
allow postfix_postqueue_t sysctl_kernel_t:dir search;
#line 258
allow postfix_postqueue_t sysctl_kernel_t:file { getattr read };
#line 258

#line 258

#line 258

#line 258

#line 258

#line 258

#line 258

#line 258

#line 258
#
#line 258
# Allow the process to transition to the new domain.
#line 258
#
#line 258
allow user_mail_domain postfix_postqueue_t:process transition;
#line 258

#line 258
#
#line 258
# Do not audit when glibc secure mode is enabled upon the transition.
#line 258
#
#line 258
dontaudit user_mail_domain postfix_postqueue_t:process noatsecure;
#line 258

#line 258
#
#line 258
# Do not audit when signal-related state is cleared upon the transition.
#line 258
#
#line 258
dontaudit user_mail_domain postfix_postqueue_t:process siginh;
#line 258

#line 258
#
#line 258
# Do not audit when resource limits are reset upon the transition.
#line 258
#
#line 258
dontaudit user_mail_domain postfix_postqueue_t:process rlimitinh;
#line 258

#line 258
#
#line 258
# Allow the process to execute the program.
#line 258
# 
#line 258
allow user_mail_domain postfix_postqueue_exec_t:file { read { getattr execute } };
#line 258

#line 258
#
#line 258
# Allow the process to reap the new domain.
#line 258
#
#line 258
allow postfix_postqueue_t user_mail_domain:process sigchld;
#line 258

#line 258
#
#line 258
# Allow the new domain to inherit and use file 
#line 258
# descriptions from the creating process and vice versa.
#line 258
#
#line 258
allow postfix_postqueue_t user_mail_domain:fd use;
#line 258
allow user_mail_domain postfix_postqueue_t:fd use;
#line 258

#line 258
#
#line 258
# Allow the new domain to write back to the old domain via a pipe.
#line 258
#
#line 258
allow postfix_postqueue_t user_mail_domain:fifo_file { ioctl read getattr lock write append };
#line 258

#line 258
#
#line 258
# Allow the new domain to read and execute the program.
#line 258
#
#line 258
allow postfix_postqueue_t postfix_postqueue_exec_t:file { read getattr lock execute ioctl };
#line 258

#line 258
#
#line 258
# Allow the new domain to be entered via the program.
#line 258
#
#line 258
allow postfix_postqueue_t postfix_postqueue_exec_t:file entrypoint;
#line 258

#line 258
type_transition user_mail_domain postfix_postqueue_exec_t:process postfix_postqueue_t;
#line 258

#line 258

#line 258
role user_r types postfix_postqueue_t;
#line 258
role staff_r types postfix_postqueue_t;
#line 258

#line 258
role sysadm_r types postfix_postqueue_t;
#line 258
allow postfix_postqueue_t userdomain:process sigchld;
#line 258
allow postfix_postqueue_t userdomain:fifo_file { write getattr };
#line 258
allow postfix_postqueue_t { userdomain privfd }:fd use;
#line 258
allow postfix_postqueue_t self:capability dac_override;
#line 258

allow postfix_postqueue_t postfix_public_t:dir search;
allow postfix_postqueue_t postfix_public_t:fifo_file getattr;
allow postfix_postqueue_t self:udp_socket { create ioctl };
allow postfix_postqueue_t self:tcp_socket create;
allow postfix_master_t postfix_postqueue_exec_t:file getattr;

#line 264

#line 264

#line 264
#
#line 264
# Allow the process to transition to the new domain.
#line 264
#
#line 264
allow postfix_master_t postfix_postqueue_t:process transition;
#line 264

#line 264
#
#line 264
# Do not audit when glibc secure mode is enabled upon the transition.
#line 264
#
#line 264
dontaudit postfix_master_t postfix_postqueue_t:process noatsecure;
#line 264

#line 264
#
#line 264
# Do not audit when signal-related state is cleared upon the transition.
#line 264
#
#line 264
dontaudit postfix_master_t postfix_postqueue_t:process siginh;
#line 264

#line 264
#
#line 264
# Do not audit when resource limits are reset upon the transition.
#line 264
#
#line 264
dontaudit postfix_master_t postfix_postqueue_t:process rlimitinh;
#line 264

#line 264
#
#line 264
# Allow the process to execute the program.
#line 264
# 
#line 264
allow postfix_master_t postfix_postqueue_exec_t:file { read { getattr execute } };
#line 264

#line 264
#
#line 264
# Allow the process to reap the new domain.
#line 264
#
#line 264
allow postfix_postqueue_t postfix_master_t:process sigchld;
#line 264

#line 264
#
#line 264
# Allow the new domain to inherit and use file 
#line 264
# descriptions from the creating process and vice versa.
#line 264
#
#line 264
allow postfix_postqueue_t postfix_master_t:fd use;
#line 264
allow postfix_master_t postfix_postqueue_t:fd use;
#line 264

#line 264
#
#line 264
# Allow the new domain to write back to the old domain via a pipe.
#line 264
#
#line 264
allow postfix_postqueue_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 264

#line 264
#
#line 264
# Allow the new domain to read and execute the program.
#line 264
#
#line 264
allow postfix_postqueue_t postfix_postqueue_exec_t:file { read getattr lock execute ioctl };
#line 264

#line 264
#
#line 264
# Allow the new domain to be entered via the program.
#line 264
#
#line 264
allow postfix_postqueue_t postfix_postqueue_exec_t:file entrypoint;
#line 264

#line 264
type_transition postfix_master_t postfix_postqueue_exec_t:process postfix_postqueue_t;
#line 264

allow postfix_postqueue_t initrc_t:process sigchld;
allow postfix_postqueue_t initrc_t:fd use;

# to write the mailq output, it really should not need read access!
allow postfix_postqueue_t { ptyfile ttyfile }:chr_file { read write getattr };


# wants to write to /var/spool/postfix/public/showq
allow postfix_postqueue_t postfix_public_t:sock_file { ioctl read getattr lock write append };
allow postfix_postqueue_t postfix_master_t:unix_stream_socket connectto;
# write to /var/spool/postfix/public/qmgr
allow postfix_postqueue_t postfix_public_t:fifo_file write;
dontaudit postfix_postqueue_t net_conf_t:file { read getattr lock ioctl };


#line 279

#line 279

#line 279
type postfix_showq_t, domain, privlog, daemon ;
#line 279
type postfix_showq_exec_t, file_type, sysadmfile, exec_type;
#line 279
dontaudit postfix_showq_t self:capability sys_tty_config;
#line 279

#line 279
role system_r types postfix_showq_t;
#line 279

#line 279
# Inherit and use descriptors from init.
#line 279
allow postfix_showq_t init_t:fd use;
#line 279
allow postfix_showq_t init_t:process sigchld;
#line 279
allow postfix_showq_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 279

#line 279

#line 279
allow postfix_showq_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 279
allow postfix_showq_t lib_t:lnk_file { read getattr lock ioctl };
#line 279
allow postfix_showq_t ld_so_t:file { read getattr lock execute ioctl };
#line 279
#allow postfix_showq_t ld_so_t:file execute_no_trans;
#line 279
allow postfix_showq_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 279
allow postfix_showq_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 279
allow postfix_showq_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 279
allow postfix_showq_t texrel_shlib_t:file execmod;
#line 279
allow postfix_showq_t ld_so_cache_t:file { read getattr lock ioctl };
#line 279
allow postfix_showq_t device_t:dir search;
#line 279
allow postfix_showq_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 279

#line 279

#line 279
allow postfix_showq_t { self proc_t }:dir { read getattr lock search ioctl };
#line 279
allow postfix_showq_t { self proc_t }:lnk_file { getattr read };
#line 279

#line 279
allow postfix_showq_t device_t:dir { read getattr lock search ioctl };
#line 279

#line 279
allow postfix_showq_t udev_tdb_t:file { read getattr lock ioctl };
#line 279
allow postfix_showq_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 279
dontaudit postfix_showq_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 279
dontaudit postfix_showq_t unpriv_userdomain:fd use;
#line 279

#line 279

#line 279
allow postfix_showq_t sysfs_t:dir { read getattr lock search ioctl };
#line 279
allow postfix_showq_t sysfs_t:file { read getattr lock ioctl };
#line 279
allow postfix_showq_t sysfs_t:lnk_file { getattr read };
#line 279
 
#line 279

#line 279
allow postfix_showq_t autofs_t:dir { search getattr };
#line 279

#line 279
dontaudit postfix_showq_t { tty_device_t devpts_t }:chr_file { read write };
#line 279
dontaudit postfix_showq_t root_t:file { getattr read };
#line 279
 
#line 279

#line 279
allow postfix_showq_t self:process setpgid;
#line 279
allow postfix_showq_t postfix_master_t:process sigchld;
#line 279
allow postfix_master_t postfix_showq_t:process signal;
#line 279

#line 279
allow postfix_showq_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 279
allow postfix_showq_t postfix_etc_t:file { read getattr lock ioctl };
#line 279

#line 279
allow postfix_showq_t etc_t:lnk_file read;
#line 279
allow postfix_showq_t lib_t:file { read getattr lock ioctl };
#line 279

#line 279
allow postfix_showq_t locale_t:dir { read getattr lock search ioctl };
#line 279
allow postfix_showq_t locale_t:file { read getattr lock ioctl };
#line 279
allow postfix_showq_t locale_t:lnk_file { getattr read };
#line 279

#line 279

#line 279
allow postfix_showq_t etc_t:file { getattr read };
#line 279
allow postfix_showq_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 279
allow postfix_showq_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 279
allow postfix_showq_t self:unix_stream_socket connectto;
#line 279

#line 279
allow postfix_showq_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 279
allow postfix_showq_t { bin_t usr_t }:lnk_file { getattr read };
#line 279
allow postfix_showq_t shell_exec_t:file { read getattr lock execute ioctl };
#line 279
allow postfix_showq_t { var_t var_spool_t }:dir { search getattr };
#line 279
allow postfix_showq_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 279
allow postfix_showq_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 279
allow postfix_showq_t etc_runtime_t:file { read getattr lock ioctl };
#line 279
allow postfix_showq_t proc_t:dir { read getattr lock search ioctl };
#line 279
allow postfix_showq_t proc_t:file { read getattr lock ioctl };
#line 279
allow postfix_showq_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 279
allow postfix_showq_t fs_t:filesystem getattr;
#line 279
allow postfix_showq_t proc_net_t:dir search;
#line 279
allow postfix_showq_t proc_net_t:file { getattr read };
#line 279

#line 279
allow postfix_showq_t postfix_showq_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 279

#line 279

#line 279
allow postfix_showq_t cert_t:dir { read getattr lock search ioctl };
#line 279
allow postfix_showq_t cert_t:file { read getattr lock ioctl };
#line 279
allow postfix_showq_t cert_t:lnk_file { getattr read };
#line 279

#line 279
allow postfix_showq_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 279

#line 279
allow postfix_showq_t tmp_t:dir getattr;
#line 279

#line 279

#line 279

#line 279

#line 279

#line 279
#
#line 279
# Allow the process to modify the directory.
#line 279
#
#line 279
allow postfix_showq_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 279

#line 279
#
#line 279
# Allow the process to create the file.
#line 279
#
#line 279

#line 279

#line 279

#line 279

#line 279

#line 279
allow postfix_showq_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279
type_transition postfix_showq_t var_run_t:file postfix_var_run_t;
#line 279

#line 279

#line 279

#line 279

#line 279
# Read system variables in /sys.
#line 279

#line 279
allow postfix_showq_t sysctl_t:dir search;
#line 279
allow postfix_showq_t sysctl_kernel_t:dir search;
#line 279
allow postfix_showq_t sysctl_kernel_t:file { getattr read };
#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279

#line 279
#
#line 279
# Allow the process to transition to the new domain.
#line 279
#
#line 279
allow user_mail_domain postfix_showq_t:process transition;
#line 279

#line 279
#
#line 279
# Do not audit when glibc secure mode is enabled upon the transition.
#line 279
#
#line 279
dontaudit user_mail_domain postfix_showq_t:process noatsecure;
#line 279

#line 279
#
#line 279
# Do not audit when signal-related state is cleared upon the transition.
#line 279
#
#line 279
dontaudit user_mail_domain postfix_showq_t:process siginh;
#line 279

#line 279
#
#line 279
# Do not audit when resource limits are reset upon the transition.
#line 279
#
#line 279
dontaudit user_mail_domain postfix_showq_t:process rlimitinh;
#line 279

#line 279
#
#line 279
# Allow the process to execute the program.
#line 279
# 
#line 279
allow user_mail_domain postfix_showq_exec_t:file { read { getattr execute } };
#line 279

#line 279
#
#line 279
# Allow the process to reap the new domain.
#line 279
#
#line 279
allow postfix_showq_t user_mail_domain:process sigchld;
#line 279

#line 279
#
#line 279
# Allow the new domain to inherit and use file 
#line 279
# descriptions from the creating process and vice versa.
#line 279
#
#line 279
allow postfix_showq_t user_mail_domain:fd use;
#line 279
allow user_mail_domain postfix_showq_t:fd use;
#line 279

#line 279
#
#line 279
# Allow the new domain to write back to the old domain via a pipe.
#line 279
#
#line 279
allow postfix_showq_t user_mail_domain:fifo_file { ioctl read getattr lock write append };
#line 279

#line 279
#
#line 279
# Allow the new domain to read and execute the program.
#line 279
#
#line 279
allow postfix_showq_t postfix_showq_exec_t:file { read getattr lock execute ioctl };
#line 279

#line 279
#
#line 279
# Allow the new domain to be entered via the program.
#line 279
#
#line 279
allow postfix_showq_t postfix_showq_exec_t:file entrypoint;
#line 279

#line 279
type_transition user_mail_domain postfix_showq_exec_t:process postfix_showq_t;
#line 279

#line 279

#line 279
role user_r types postfix_showq_t;
#line 279
role staff_r types postfix_showq_t;
#line 279

#line 279
role sysadm_r types postfix_showq_t;
#line 279
allow postfix_showq_t userdomain:process sigchld;
#line 279
allow postfix_showq_t userdomain:fifo_file { write getattr };
#line 279
allow postfix_showq_t { userdomain privfd }:fd use;
#line 279
allow postfix_showq_t self:capability dac_override;
#line 279

# the following auto_trans is usually in postfix server domain

#line 281

#line 281

#line 281
#
#line 281
# Allow the process to transition to the new domain.
#line 281
#
#line 281
allow postfix_master_t postfix_showq_t:process transition;
#line 281

#line 281
#
#line 281
# Do not audit when glibc secure mode is enabled upon the transition.
#line 281
#
#line 281
dontaudit postfix_master_t postfix_showq_t:process noatsecure;
#line 281

#line 281
#
#line 281
# Do not audit when signal-related state is cleared upon the transition.
#line 281
#
#line 281
dontaudit postfix_master_t postfix_showq_t:process siginh;
#line 281

#line 281
#
#line 281
# Do not audit when resource limits are reset upon the transition.
#line 281
#
#line 281
dontaudit postfix_master_t postfix_showq_t:process rlimitinh;
#line 281

#line 281
#
#line 281
# Allow the process to execute the program.
#line 281
# 
#line 281
allow postfix_master_t postfix_showq_exec_t:file { read { getattr execute } };
#line 281

#line 281
#
#line 281
# Allow the process to reap the new domain.
#line 281
#
#line 281
allow postfix_showq_t postfix_master_t:process sigchld;
#line 281

#line 281
#
#line 281
# Allow the new domain to inherit and use file 
#line 281
# descriptions from the creating process and vice versa.
#line 281
#
#line 281
allow postfix_showq_t postfix_master_t:fd use;
#line 281
allow postfix_master_t postfix_showq_t:fd use;
#line 281

#line 281
#
#line 281
# Allow the new domain to write back to the old domain via a pipe.
#line 281
#
#line 281
allow postfix_showq_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 281

#line 281
#
#line 281
# Allow the new domain to read and execute the program.
#line 281
#
#line 281
allow postfix_showq_t postfix_showq_exec_t:file { read getattr lock execute ioctl };
#line 281

#line 281
#
#line 281
# Allow the new domain to be entered via the program.
#line 281
#
#line 281
allow postfix_showq_t postfix_showq_exec_t:file entrypoint;
#line 281

#line 281
type_transition postfix_master_t postfix_showq_exec_t:process postfix_showq_t;
#line 281


#line 282

#line 282

#line 282

#line 282

#line 282
#
#line 282
# Allow the domain to create and use tcp sockets.
#line 282
# Other kinds of sockets must be separately authorized for use.
#line 282
allow postfix_showq_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 282

#line 282
allow postfix_showq_t unlabeled_t:association { sendto recvfrom };
#line 282

#line 282
#
#line 282
# Allow the domain to send or receive using any network interface.
#line 282
# netif_type is a type attribute for all network interface types.
#line 282
#
#line 282
allow postfix_showq_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 282
#
#line 282
# Allow the domain to send to or receive from any node.
#line 282
# node_type is a type attribute for all node types.
#line 282
#
#line 282
allow postfix_showq_t node_type:node { tcp_send rawip_send };
#line 282
allow postfix_showq_t node_type:node { tcp_recv rawip_recv };
#line 282

#line 282
#
#line 282
# Allow the domain to send to or receive from any port.
#line 282
# port_type is a type attribute for all port types.
#line 282
#
#line 282

#line 282
allow postfix_showq_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 282

#line 282

#line 282
# XXX Allow binding to any node type.  Remove once
#line 282
# individual rules have been added to all domains that 
#line 282
# bind sockets. 
#line 282
allow postfix_showq_t node_type:tcp_socket node_bind;
#line 282
#
#line 282
# Allow access to network files including /etc/resolv.conf
#line 282
#
#line 282
allow postfix_showq_t net_conf_t:file { read getattr lock ioctl };
#line 282

#line 282
allow postfix_showq_t self:tcp_socket { connect };
#line 282

#line 282

#line 282

#line 282
#
#line 282
# Allow the domain to create and use udp sockets.
#line 282
# Other kinds of sockets must be separately authorized for use.
#line 282
allow postfix_showq_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 282

#line 282
allow postfix_showq_t unlabeled_t:association { sendto recvfrom };
#line 282

#line 282
#
#line 282
# Allow the domain to send or receive using any network interface.
#line 282
# netif_type is a type attribute for all network interface types.
#line 282
#
#line 282
allow postfix_showq_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 282
#
#line 282
# Allow the domain to send to or receive from any node.
#line 282
# node_type is a type attribute for all node types.
#line 282
#
#line 282
allow postfix_showq_t node_type:node { udp_send rawip_send };
#line 282
allow postfix_showq_t node_type:node { udp_recv rawip_recv };
#line 282

#line 282
#
#line 282
# Allow the domain to send to or receive from any port.
#line 282
# port_type is a type attribute for all port types.
#line 282
#
#line 282

#line 282
allow postfix_showq_t dns_port_t:udp_socket { send_msg recv_msg };
#line 282

#line 282

#line 282
# XXX Allow binding to any node type.  Remove once
#line 282
# individual rules have been added to all domains that 
#line 282
# bind sockets. 
#line 282
allow postfix_showq_t node_type:udp_socket node_bind;
#line 282
#
#line 282
# Allow access to network files including /etc/resolv.conf
#line 282
#
#line 282
allow postfix_showq_t net_conf_t:file { read getattr lock ioctl };
#line 282

#line 282
allow postfix_showq_t self:udp_socket { connect };
#line 282

#line 282

#line 282

#line 282
allow postfix_showq_t dns_port_t:tcp_socket name_connect;
#line 282


#line 283
allow postfix_showq_t postfix_spool_maildrop_t:dir { read getattr lock search ioctl };
#line 283
allow postfix_showq_t postfix_spool_maildrop_t:file { read getattr lock ioctl };
#line 283
allow postfix_showq_t postfix_spool_maildrop_t:lnk_file { getattr read };
#line 283


#line 284

#line 284

#line 284
#
#line 284
# Allow the process to transition to the new domain.
#line 284
#
#line 284
allow postfix_postqueue_t postfix_showq_t:process transition;
#line 284

#line 284
#
#line 284
# Do not audit when glibc secure mode is enabled upon the transition.
#line 284
#
#line 284
dontaudit postfix_postqueue_t postfix_showq_t:process noatsecure;
#line 284

#line 284
#
#line 284
# Do not audit when signal-related state is cleared upon the transition.
#line 284
#
#line 284
dontaudit postfix_postqueue_t postfix_showq_t:process siginh;
#line 284

#line 284
#
#line 284
# Do not audit when resource limits are reset upon the transition.
#line 284
#
#line 284
dontaudit postfix_postqueue_t postfix_showq_t:process rlimitinh;
#line 284

#line 284
#
#line 284
# Allow the process to execute the program.
#line 284
# 
#line 284
allow postfix_postqueue_t postfix_showq_exec_t:file { read { getattr execute } };
#line 284

#line 284
#
#line 284
# Allow the process to reap the new domain.
#line 284
#
#line 284
allow postfix_showq_t postfix_postqueue_t:process sigchld;
#line 284

#line 284
#
#line 284
# Allow the new domain to inherit and use file 
#line 284
# descriptions from the creating process and vice versa.
#line 284
#
#line 284
allow postfix_showq_t postfix_postqueue_t:fd use;
#line 284
allow postfix_postqueue_t postfix_showq_t:fd use;
#line 284

#line 284
#
#line 284
# Allow the new domain to write back to the old domain via a pipe.
#line 284
#
#line 284
allow postfix_showq_t postfix_postqueue_t:fifo_file { ioctl read getattr lock write append };
#line 284

#line 284
#
#line 284
# Allow the new domain to read and execute the program.
#line 284
#
#line 284
allow postfix_showq_t postfix_showq_exec_t:file { read getattr lock execute ioctl };
#line 284

#line 284
#
#line 284
# Allow the new domain to be entered via the program.
#line 284
#
#line 284
allow postfix_showq_t postfix_showq_exec_t:file entrypoint;
#line 284

#line 284
type_transition postfix_postqueue_t postfix_showq_exec_t:process postfix_showq_t;
#line 284

allow postfix_showq_t self:capability { setuid setgid };
allow postfix_showq_t postfix_master_t:unix_stream_socket { accept { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow postfix_showq_t postfix_spool_t:file { read getattr lock ioctl };
allow postfix_showq_t self:tcp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow postfix_showq_t { ttyfile ptyfile }:chr_file { read write };
dontaudit postfix_showq_t net_conf_t:file { read getattr lock ioctl };


#line 292

#line 292

#line 292
type postfix_postdrop_t, domain, privlog, daemon , mta_user_agent;
#line 292
type postfix_postdrop_exec_t, file_type, sysadmfile, exec_type;
#line 292
dontaudit postfix_postdrop_t self:capability sys_tty_config;
#line 292

#line 292
role system_r types postfix_postdrop_t;
#line 292

#line 292
# Inherit and use descriptors from init.
#line 292
allow postfix_postdrop_t init_t:fd use;
#line 292
allow postfix_postdrop_t init_t:process sigchld;
#line 292
allow postfix_postdrop_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 292

#line 292

#line 292
allow postfix_postdrop_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 292
allow postfix_postdrop_t lib_t:lnk_file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t ld_so_t:file { read getattr lock execute ioctl };
#line 292
#allow postfix_postdrop_t ld_so_t:file execute_no_trans;
#line 292
allow postfix_postdrop_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 292
allow postfix_postdrop_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t texrel_shlib_t:file execmod;
#line 292
allow postfix_postdrop_t ld_so_cache_t:file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t device_t:dir search;
#line 292
allow postfix_postdrop_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 292

#line 292

#line 292
allow postfix_postdrop_t { self proc_t }:dir { read getattr lock search ioctl };
#line 292
allow postfix_postdrop_t { self proc_t }:lnk_file { getattr read };
#line 292

#line 292
allow postfix_postdrop_t device_t:dir { read getattr lock search ioctl };
#line 292

#line 292
allow postfix_postdrop_t udev_tdb_t:file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 292
dontaudit postfix_postdrop_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 292
dontaudit postfix_postdrop_t unpriv_userdomain:fd use;
#line 292

#line 292

#line 292
allow postfix_postdrop_t sysfs_t:dir { read getattr lock search ioctl };
#line 292
allow postfix_postdrop_t sysfs_t:file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t sysfs_t:lnk_file { getattr read };
#line 292
 
#line 292

#line 292
allow postfix_postdrop_t autofs_t:dir { search getattr };
#line 292

#line 292
dontaudit postfix_postdrop_t { tty_device_t devpts_t }:chr_file { read write };
#line 292
dontaudit postfix_postdrop_t root_t:file { getattr read };
#line 292
 
#line 292

#line 292
allow postfix_postdrop_t self:process setpgid;
#line 292
allow postfix_postdrop_t postfix_master_t:process sigchld;
#line 292
allow postfix_master_t postfix_postdrop_t:process signal;
#line 292

#line 292
allow postfix_postdrop_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 292
allow postfix_postdrop_t postfix_etc_t:file { read getattr lock ioctl };
#line 292

#line 292
allow postfix_postdrop_t etc_t:lnk_file read;
#line 292
allow postfix_postdrop_t lib_t:file { read getattr lock ioctl };
#line 292

#line 292
allow postfix_postdrop_t locale_t:dir { read getattr lock search ioctl };
#line 292
allow postfix_postdrop_t locale_t:file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t locale_t:lnk_file { getattr read };
#line 292

#line 292

#line 292
allow postfix_postdrop_t etc_t:file { getattr read };
#line 292
allow postfix_postdrop_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 292
allow postfix_postdrop_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 292
allow postfix_postdrop_t self:unix_stream_socket connectto;
#line 292

#line 292
allow postfix_postdrop_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 292
allow postfix_postdrop_t { bin_t usr_t }:lnk_file { getattr read };
#line 292
allow postfix_postdrop_t shell_exec_t:file { read getattr lock execute ioctl };
#line 292
allow postfix_postdrop_t { var_t var_spool_t }:dir { search getattr };
#line 292
allow postfix_postdrop_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 292
allow postfix_postdrop_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 292
allow postfix_postdrop_t etc_runtime_t:file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t proc_t:dir { read getattr lock search ioctl };
#line 292
allow postfix_postdrop_t proc_t:file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 292
allow postfix_postdrop_t fs_t:filesystem getattr;
#line 292
allow postfix_postdrop_t proc_net_t:dir search;
#line 292
allow postfix_postdrop_t proc_net_t:file { getattr read };
#line 292

#line 292
allow postfix_postdrop_t postfix_postdrop_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 292

#line 292

#line 292
allow postfix_postdrop_t cert_t:dir { read getattr lock search ioctl };
#line 292
allow postfix_postdrop_t cert_t:file { read getattr lock ioctl };
#line 292
allow postfix_postdrop_t cert_t:lnk_file { getattr read };
#line 292

#line 292
allow postfix_postdrop_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 292

#line 292
allow postfix_postdrop_t tmp_t:dir getattr;
#line 292

#line 292

#line 292

#line 292

#line 292

#line 292
#
#line 292
# Allow the process to modify the directory.
#line 292
#
#line 292
allow postfix_postdrop_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 292

#line 292
#
#line 292
# Allow the process to create the file.
#line 292
#
#line 292

#line 292

#line 292

#line 292

#line 292

#line 292
allow postfix_postdrop_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 292

#line 292

#line 292

#line 292

#line 292

#line 292

#line 292

#line 292

#line 292

#line 292
type_transition postfix_postdrop_t var_run_t:file postfix_var_run_t;
#line 292

#line 292

#line 292

#line 292

#line 292
# Read system variables in /sys.
#line 292

#line 292
allow postfix_postdrop_t sysctl_t:dir search;
#line 292
allow postfix_postdrop_t sysctl_kernel_t:dir search;
#line 292
allow postfix_postdrop_t sysctl_kernel_t:file { getattr read };
#line 292

#line 292

#line 292

#line 292

#line 292

#line 292

#line 292

#line 292

#line 292
#
#line 292
# Allow the process to transition to the new domain.
#line 292
#
#line 292
allow user_mail_domain postfix_postdrop_t:process transition;
#line 292

#line 292
#
#line 292
# Do not audit when glibc secure mode is enabled upon the transition.
#line 292
#
#line 292
dontaudit user_mail_domain postfix_postdrop_t:process noatsecure;
#line 292

#line 292
#
#line 292
# Do not audit when signal-related state is cleared upon the transition.
#line 292
#
#line 292
dontaudit user_mail_domain postfix_postdrop_t:process siginh;
#line 292

#line 292
#
#line 292
# Do not audit when resource limits are reset upon the transition.
#line 292
#
#line 292
dontaudit user_mail_domain postfix_postdrop_t:process rlimitinh;
#line 292

#line 292
#
#line 292
# Allow the process to execute the program.
#line 292
# 
#line 292
allow user_mail_domain postfix_postdrop_exec_t:file { read { getattr execute } };
#line 292

#line 292
#
#line 292
# Allow the process to reap the new domain.
#line 292
#
#line 292
allow postfix_postdrop_t user_mail_domain:process sigchld;
#line 292

#line 292
#
#line 292
# Allow the new domain to inherit and use file 
#line 292
# descriptions from the creating process and vice versa.
#line 292
#
#line 292
allow postfix_postdrop_t user_mail_domain:fd use;
#line 292
allow user_mail_domain postfix_postdrop_t:fd use;
#line 292

#line 292
#
#line 292
# Allow the new domain to write back to the old domain via a pipe.
#line 292
#
#line 292
allow postfix_postdrop_t user_mail_domain:fifo_file { ioctl read getattr lock write append };
#line 292

#line 292
#
#line 292
# Allow the new domain to read and execute the program.
#line 292
#
#line 292
allow postfix_postdrop_t postfix_postdrop_exec_t:file { read getattr lock execute ioctl };
#line 292

#line 292
#
#line 292
# Allow the new domain to be entered via the program.
#line 292
#
#line 292
allow postfix_postdrop_t postfix_postdrop_exec_t:file entrypoint;
#line 292

#line 292
type_transition user_mail_domain postfix_postdrop_exec_t:process postfix_postdrop_t;
#line 292

#line 292

#line 292
role user_r types postfix_postdrop_t;
#line 292
role staff_r types postfix_postdrop_t;
#line 292

#line 292
role sysadm_r types postfix_postdrop_t;
#line 292
allow postfix_postdrop_t userdomain:process sigchld;
#line 292
allow postfix_postdrop_t userdomain:fifo_file { write getattr };
#line 292
allow postfix_postdrop_t { userdomain privfd }:fd use;
#line 292
allow postfix_postdrop_t self:capability dac_override;
#line 292


#line 293

#line 293

#line 293

#line 293

#line 293
#
#line 293
# Allow the domain to create and use tcp sockets.
#line 293
# Other kinds of sockets must be separately authorized for use.
#line 293
allow postfix_postdrop_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 293

#line 293
allow postfix_postdrop_t unlabeled_t:association { sendto recvfrom };
#line 293

#line 293
#
#line 293
# Allow the domain to send or receive using any network interface.
#line 293
# netif_type is a type attribute for all network interface types.
#line 293
#
#line 293
allow postfix_postdrop_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 293
#
#line 293
# Allow the domain to send to or receive from any node.
#line 293
# node_type is a type attribute for all node types.
#line 293
#
#line 293
allow postfix_postdrop_t node_type:node { tcp_send rawip_send };
#line 293
allow postfix_postdrop_t node_type:node { tcp_recv rawip_recv };
#line 293

#line 293
#
#line 293
# Allow the domain to send to or receive from any port.
#line 293
# port_type is a type attribute for all port types.
#line 293
#
#line 293

#line 293
allow postfix_postdrop_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 293

#line 293

#line 293
# XXX Allow binding to any node type.  Remove once
#line 293
# individual rules have been added to all domains that 
#line 293
# bind sockets. 
#line 293
allow postfix_postdrop_t node_type:tcp_socket node_bind;
#line 293
#
#line 293
# Allow access to network files including /etc/resolv.conf
#line 293
#
#line 293
allow postfix_postdrop_t net_conf_t:file { read getattr lock ioctl };
#line 293

#line 293
allow postfix_postdrop_t self:tcp_socket { connect };
#line 293

#line 293

#line 293

#line 293
#
#line 293
# Allow the domain to create and use udp sockets.
#line 293
# Other kinds of sockets must be separately authorized for use.
#line 293
allow postfix_postdrop_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 293

#line 293
allow postfix_postdrop_t unlabeled_t:association { sendto recvfrom };
#line 293

#line 293
#
#line 293
# Allow the domain to send or receive using any network interface.
#line 293
# netif_type is a type attribute for all network interface types.
#line 293
#
#line 293
allow postfix_postdrop_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 293
#
#line 293
# Allow the domain to send to or receive from any node.
#line 293
# node_type is a type attribute for all node types.
#line 293
#
#line 293
allow postfix_postdrop_t node_type:node { udp_send rawip_send };
#line 293
allow postfix_postdrop_t node_type:node { udp_recv rawip_recv };
#line 293

#line 293
#
#line 293
# Allow the domain to send to or receive from any port.
#line 293
# port_type is a type attribute for all port types.
#line 293
#
#line 293

#line 293
allow postfix_postdrop_t dns_port_t:udp_socket { send_msg recv_msg };
#line 293

#line 293

#line 293
# XXX Allow binding to any node type.  Remove once
#line 293
# individual rules have been added to all domains that 
#line 293
# bind sockets. 
#line 293
allow postfix_postdrop_t node_type:udp_socket node_bind;
#line 293
#
#line 293
# Allow access to network files including /etc/resolv.conf
#line 293
#
#line 293
allow postfix_postdrop_t net_conf_t:file { read getattr lock ioctl };
#line 293

#line 293
allow postfix_postdrop_t self:udp_socket { connect };
#line 293

#line 293

#line 293

#line 293
allow postfix_postdrop_t dns_port_t:tcp_socket name_connect;
#line 293

allow postfix_postdrop_t postfix_spool_maildrop_t:dir { read getattr lock search ioctl add_name remove_name write };
allow postfix_postdrop_t postfix_spool_maildrop_t:file { create ioctl read getattr lock write setattr append link unlink rename };
allow postfix_postdrop_t user_mail_domain:unix_stream_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
allow postfix_postdrop_t postfix_public_t:dir search;
allow postfix_postdrop_t postfix_public_t:fifo_file { ioctl read getattr lock write append };
dontaudit postfix_postdrop_t { ptyfile ttyfile }:chr_file { read write };
dontaudit postfix_postdrop_t net_conf_t:file { read getattr lock ioctl };
allow postfix_master_t postfix_postdrop_exec_t:file getattr;
#line 304
allow postfix_postdrop_t { crond_t system_crond_t }:fd use;
#line 304
allow postfix_postdrop_t { crond_t system_crond_t }:fifo_file { ioctl read getattr lock write append };
# usually it does not need a UDP socket
allow postfix_postdrop_t self:udp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow postfix_postdrop_t self:tcp_socket create;
allow postfix_postdrop_t self:capability sys_resource;
allow postfix_postdrop_t self:tcp_socket create;


#line 311

#line 311

#line 311

#line 311
type postfix_pickup_t, domain, privlog, daemon ;
#line 311
type postfix_pickup_exec_t, file_type, sysadmfile, exec_type;
#line 311
dontaudit postfix_pickup_t self:capability sys_tty_config;
#line 311

#line 311
role system_r types postfix_pickup_t;
#line 311

#line 311
# Inherit and use descriptors from init.
#line 311
allow postfix_pickup_t init_t:fd use;
#line 311
allow postfix_pickup_t init_t:process sigchld;
#line 311
allow postfix_pickup_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 311

#line 311

#line 311
allow postfix_pickup_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t lib_t:lnk_file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t ld_so_t:file { read getattr lock execute ioctl };
#line 311
#allow postfix_pickup_t ld_so_t:file execute_no_trans;
#line 311
allow postfix_pickup_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 311
allow postfix_pickup_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t texrel_shlib_t:file execmod;
#line 311
allow postfix_pickup_t ld_so_cache_t:file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t device_t:dir search;
#line 311
allow postfix_pickup_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 311

#line 311

#line 311
allow postfix_pickup_t { self proc_t }:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t { self proc_t }:lnk_file { getattr read };
#line 311

#line 311
allow postfix_pickup_t device_t:dir { read getattr lock search ioctl };
#line 311

#line 311
allow postfix_pickup_t udev_tdb_t:file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 311
dontaudit postfix_pickup_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 311
dontaudit postfix_pickup_t unpriv_userdomain:fd use;
#line 311

#line 311

#line 311
allow postfix_pickup_t sysfs_t:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t sysfs_t:file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t sysfs_t:lnk_file { getattr read };
#line 311
 
#line 311

#line 311
allow postfix_pickup_t autofs_t:dir { search getattr };
#line 311

#line 311
dontaudit postfix_pickup_t { tty_device_t devpts_t }:chr_file { read write };
#line 311
dontaudit postfix_pickup_t root_t:file { getattr read };
#line 311
 
#line 311

#line 311
allow postfix_pickup_t self:process setpgid;
#line 311
allow postfix_pickup_t postfix_master_t:process sigchld;
#line 311
allow postfix_master_t postfix_pickup_t:process signal;
#line 311

#line 311
allow postfix_pickup_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t postfix_etc_t:file { read getattr lock ioctl };
#line 311

#line 311
allow postfix_pickup_t etc_t:lnk_file read;
#line 311
allow postfix_pickup_t lib_t:file { read getattr lock ioctl };
#line 311

#line 311
allow postfix_pickup_t locale_t:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t locale_t:file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t locale_t:lnk_file { getattr read };
#line 311

#line 311

#line 311
allow postfix_pickup_t etc_t:file { getattr read };
#line 311
allow postfix_pickup_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 311
allow postfix_pickup_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 311
allow postfix_pickup_t self:unix_stream_socket connectto;
#line 311

#line 311
allow postfix_pickup_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t { bin_t usr_t }:lnk_file { getattr read };
#line 311
allow postfix_pickup_t shell_exec_t:file { read getattr lock execute ioctl };
#line 311
allow postfix_pickup_t { var_t var_spool_t }:dir { search getattr };
#line 311
allow postfix_pickup_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 311
allow postfix_pickup_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 311
allow postfix_pickup_t etc_runtime_t:file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t proc_t:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t proc_t:file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t fs_t:filesystem getattr;
#line 311
allow postfix_pickup_t proc_net_t:dir search;
#line 311
allow postfix_pickup_t proc_net_t:file { getattr read };
#line 311

#line 311
allow postfix_pickup_t postfix_pickup_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 311

#line 311

#line 311
allow postfix_pickup_t cert_t:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t cert_t:file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t cert_t:lnk_file { getattr read };
#line 311

#line 311
allow postfix_pickup_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 311

#line 311
allow postfix_pickup_t tmp_t:dir getattr;
#line 311

#line 311

#line 311

#line 311

#line 311

#line 311
#
#line 311
# Allow the process to modify the directory.
#line 311
#
#line 311
allow postfix_pickup_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 311

#line 311
#
#line 311
# Allow the process to create the file.
#line 311
#
#line 311

#line 311

#line 311

#line 311

#line 311

#line 311
allow postfix_pickup_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311
type_transition postfix_pickup_t var_run_t:file postfix_var_run_t;
#line 311

#line 311

#line 311

#line 311

#line 311
# Read system variables in /sys.
#line 311

#line 311
allow postfix_pickup_t sysctl_t:dir search;
#line 311
allow postfix_pickup_t sysctl_kernel_t:dir search;
#line 311
allow postfix_pickup_t sysctl_kernel_t:file { getattr read };
#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311
#
#line 311
# Allow the process to transition to the new domain.
#line 311
#
#line 311
allow postfix_master_t postfix_pickup_t:process transition;
#line 311

#line 311
#
#line 311
# Do not audit when glibc secure mode is enabled upon the transition.
#line 311
#
#line 311
dontaudit postfix_master_t postfix_pickup_t:process noatsecure;
#line 311

#line 311
#
#line 311
# Do not audit when signal-related state is cleared upon the transition.
#line 311
#
#line 311
dontaudit postfix_master_t postfix_pickup_t:process siginh;
#line 311

#line 311
#
#line 311
# Do not audit when resource limits are reset upon the transition.
#line 311
#
#line 311
dontaudit postfix_master_t postfix_pickup_t:process rlimitinh;
#line 311

#line 311
#
#line 311
# Allow the process to execute the program.
#line 311
# 
#line 311
allow postfix_master_t postfix_pickup_exec_t:file { read { getattr execute } };
#line 311

#line 311
#
#line 311
# Allow the process to reap the new domain.
#line 311
#
#line 311
allow postfix_pickup_t postfix_master_t:process sigchld;
#line 311

#line 311
#
#line 311
# Allow the new domain to inherit and use file 
#line 311
# descriptions from the creating process and vice versa.
#line 311
#
#line 311
allow postfix_pickup_t postfix_master_t:fd use;
#line 311
allow postfix_master_t postfix_pickup_t:fd use;
#line 311

#line 311
#
#line 311
# Allow the new domain to write back to the old domain via a pipe.
#line 311
#
#line 311
allow postfix_pickup_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 311

#line 311
#
#line 311
# Allow the new domain to read and execute the program.
#line 311
#
#line 311
allow postfix_pickup_t postfix_pickup_exec_t:file { read getattr lock execute ioctl };
#line 311

#line 311
#
#line 311
# Allow the new domain to be entered via the program.
#line 311
#
#line 311
allow postfix_pickup_t postfix_pickup_exec_t:file entrypoint;
#line 311

#line 311
type_transition postfix_master_t postfix_pickup_exec_t:process postfix_pickup_t;
#line 311

#line 311
allow postfix_pickup_t postfix_master_t:unix_stream_socket { connectto { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept } };
#line 311
allow postfix_pickup_t self:capability { setuid setgid dac_override };
#line 311

#line 311

#line 311

#line 311

#line 311
#
#line 311
# Allow the domain to create and use tcp sockets.
#line 311
# Other kinds of sockets must be separately authorized for use.
#line 311
allow postfix_pickup_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 311

#line 311
allow postfix_pickup_t unlabeled_t:association { sendto recvfrom };
#line 311

#line 311
#
#line 311
# Allow the domain to send or receive using any network interface.
#line 311
# netif_type is a type attribute for all network interface types.
#line 311
#
#line 311
allow postfix_pickup_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 311
#
#line 311
# Allow the domain to send to or receive from any node.
#line 311
# node_type is a type attribute for all node types.
#line 311
#
#line 311
allow postfix_pickup_t node_type:node { tcp_send rawip_send };
#line 311
allow postfix_pickup_t node_type:node { tcp_recv rawip_recv };
#line 311

#line 311
#
#line 311
# Allow the domain to send to or receive from any port.
#line 311
# port_type is a type attribute for all port types.
#line 311
#
#line 311

#line 311
allow postfix_pickup_t port_type:tcp_socket { send_msg recv_msg };
#line 311

#line 311

#line 311
# XXX Allow binding to any node type.  Remove once
#line 311
# individual rules have been added to all domains that 
#line 311
# bind sockets. 
#line 311
allow postfix_pickup_t node_type:tcp_socket node_bind;
#line 311
#
#line 311
# Allow access to network files including /etc/resolv.conf
#line 311
#
#line 311
allow postfix_pickup_t net_conf_t:file { read getattr lock ioctl };
#line 311

#line 311
allow postfix_pickup_t self:tcp_socket { connect };
#line 311

#line 311

#line 311

#line 311
#
#line 311
# Allow the domain to create and use udp sockets.
#line 311
# Other kinds of sockets must be separately authorized for use.
#line 311
allow postfix_pickup_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 311

#line 311
allow postfix_pickup_t unlabeled_t:association { sendto recvfrom };
#line 311

#line 311
#
#line 311
# Allow the domain to send or receive using any network interface.
#line 311
# netif_type is a type attribute for all network interface types.
#line 311
#
#line 311
allow postfix_pickup_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 311
#
#line 311
# Allow the domain to send to or receive from any node.
#line 311
# node_type is a type attribute for all node types.
#line 311
#
#line 311
allow postfix_pickup_t node_type:node { udp_send rawip_send };
#line 311
allow postfix_pickup_t node_type:node { udp_recv rawip_recv };
#line 311

#line 311
#
#line 311
# Allow the domain to send to or receive from any port.
#line 311
# port_type is a type attribute for all port types.
#line 311
#
#line 311

#line 311
allow postfix_pickup_t port_type:udp_socket { send_msg recv_msg };
#line 311

#line 311

#line 311
# XXX Allow binding to any node type.  Remove once
#line 311
# individual rules have been added to all domains that 
#line 311
# bind sockets. 
#line 311
allow postfix_pickup_t node_type:udp_socket node_bind;
#line 311
#
#line 311
# Allow access to network files including /etc/resolv.conf
#line 311
#
#line 311
allow postfix_pickup_t net_conf_t:file { read getattr lock ioctl };
#line 311

#line 311
allow postfix_pickup_t self:udp_socket { connect };
#line 311

#line 311

#line 311

#line 311
allow postfix_pickup_t port_type:tcp_socket name_connect;
#line 311

#line 311

#line 311
if (allow_ypbind) {
#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311
#
#line 311
# Allow the domain to create and use tcp sockets.
#line 311
# Other kinds of sockets must be separately authorized for use.
#line 311
allow postfix_pickup_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 311

#line 311
allow postfix_pickup_t unlabeled_t:association { sendto recvfrom };
#line 311

#line 311
#
#line 311
# Allow the domain to send or receive using any network interface.
#line 311
# netif_type is a type attribute for all network interface types.
#line 311
#
#line 311
allow postfix_pickup_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 311
#
#line 311
# Allow the domain to send to or receive from any node.
#line 311
# node_type is a type attribute for all node types.
#line 311
#
#line 311
allow postfix_pickup_t node_type:node { tcp_send rawip_send };
#line 311
allow postfix_pickup_t node_type:node { tcp_recv rawip_recv };
#line 311

#line 311
#
#line 311
# Allow the domain to send to or receive from any port.
#line 311
# port_type is a type attribute for all port types.
#line 311
#
#line 311

#line 311
allow postfix_pickup_t port_type:tcp_socket { send_msg recv_msg };
#line 311

#line 311

#line 311
# XXX Allow binding to any node type.  Remove once
#line 311
# individual rules have been added to all domains that 
#line 311
# bind sockets. 
#line 311
allow postfix_pickup_t node_type:tcp_socket node_bind;
#line 311
#
#line 311
# Allow access to network files including /etc/resolv.conf
#line 311
#
#line 311
allow postfix_pickup_t net_conf_t:file { read getattr lock ioctl };
#line 311

#line 311
allow postfix_pickup_t self:tcp_socket { listen accept };
#line 311

#line 311

#line 311

#line 311
#
#line 311
# Allow the domain to create and use tcp sockets.
#line 311
# Other kinds of sockets must be separately authorized for use.
#line 311
allow postfix_pickup_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 311

#line 311
allow postfix_pickup_t unlabeled_t:association { sendto recvfrom };
#line 311

#line 311
#
#line 311
# Allow the domain to send or receive using any network interface.
#line 311
# netif_type is a type attribute for all network interface types.
#line 311
#
#line 311
allow postfix_pickup_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 311
#
#line 311
# Allow the domain to send to or receive from any node.
#line 311
# node_type is a type attribute for all node types.
#line 311
#
#line 311
allow postfix_pickup_t node_type:node { tcp_send rawip_send };
#line 311
allow postfix_pickup_t node_type:node { tcp_recv rawip_recv };
#line 311

#line 311
#
#line 311
# Allow the domain to send to or receive from any port.
#line 311
# port_type is a type attribute for all port types.
#line 311
#
#line 311

#line 311
allow postfix_pickup_t port_type:tcp_socket { send_msg recv_msg };
#line 311

#line 311

#line 311
# XXX Allow binding to any node type.  Remove once
#line 311
# individual rules have been added to all domains that 
#line 311
# bind sockets. 
#line 311
allow postfix_pickup_t node_type:tcp_socket node_bind;
#line 311
#
#line 311
# Allow access to network files including /etc/resolv.conf
#line 311
#
#line 311
allow postfix_pickup_t net_conf_t:file { read getattr lock ioctl };
#line 311

#line 311
allow postfix_pickup_t self:tcp_socket { connect };
#line 311

#line 311

#line 311

#line 311

#line 311

#line 311
#
#line 311
# Allow the domain to create and use udp sockets.
#line 311
# Other kinds of sockets must be separately authorized for use.
#line 311
allow postfix_pickup_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 311

#line 311
allow postfix_pickup_t unlabeled_t:association { sendto recvfrom };
#line 311

#line 311
#
#line 311
# Allow the domain to send or receive using any network interface.
#line 311
# netif_type is a type attribute for all network interface types.
#line 311
#
#line 311
allow postfix_pickup_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 311
#
#line 311
# Allow the domain to send to or receive from any node.
#line 311
# node_type is a type attribute for all node types.
#line 311
#
#line 311
allow postfix_pickup_t node_type:node { udp_send rawip_send };
#line 311
allow postfix_pickup_t node_type:node { udp_recv rawip_recv };
#line 311

#line 311
#
#line 311
# Allow the domain to send to or receive from any port.
#line 311
# port_type is a type attribute for all port types.
#line 311
#
#line 311

#line 311
allow postfix_pickup_t port_type:udp_socket { send_msg recv_msg };
#line 311

#line 311

#line 311
# XXX Allow binding to any node type.  Remove once
#line 311
# individual rules have been added to all domains that 
#line 311
# bind sockets. 
#line 311
allow postfix_pickup_t node_type:udp_socket node_bind;
#line 311
#
#line 311
# Allow access to network files including /etc/resolv.conf
#line 311
#
#line 311
allow postfix_pickup_t net_conf_t:file { read getattr lock ioctl };
#line 311

#line 311
allow postfix_pickup_t self:udp_socket { connect };
#line 311

#line 311

#line 311

#line 311

#line 311

#line 311

#line 311
allow postfix_pickup_t var_yp_t:dir { read getattr lock search ioctl };
#line 311
allow postfix_pickup_t var_yp_t:file { read getattr lock ioctl };
#line 311
allow postfix_pickup_t var_yp_t:lnk_file { getattr read };
#line 311

#line 311
allow postfix_pickup_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 311
allow postfix_pickup_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 311
dontaudit postfix_pickup_t self:capability net_bind_service;
#line 311
dontaudit postfix_pickup_t reserved_port_type:tcp_socket name_connect;
#line 311
dontaudit postfix_pickup_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 311

#line 311
} else {
#line 311
dontaudit postfix_pickup_t var_yp_t:dir search;
#line 311
}
#line 311
 
#line 311

#line 311
allow postfix_pickup_t postfix_public_t:dir search;
#line 311

allow postfix_pickup_t postfix_public_t:fifo_file { ioctl read getattr lock write append };
allow postfix_pickup_t postfix_public_t:sock_file { ioctl read getattr lock write append };
allow postfix_pickup_t postfix_private_t:dir search;
allow postfix_pickup_t postfix_private_t:sock_file write;
allow postfix_pickup_t postfix_master_t:unix_stream_socket connectto;
allow postfix_pickup_t postfix_spool_maildrop_t:dir { read getattr lock search ioctl add_name remove_name write };
allow postfix_pickup_t postfix_spool_maildrop_t:file { read getattr lock ioctl };
allow postfix_pickup_t postfix_spool_maildrop_t:file unlink;
allow postfix_pickup_t self:tcp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };


#line 322

#line 322

#line 322

#line 322
type postfix_qmgr_t, domain, privlog, daemon ;
#line 322
type postfix_qmgr_exec_t, file_type, sysadmfile, exec_type;
#line 322
dontaudit postfix_qmgr_t self:capability sys_tty_config;
#line 322

#line 322
role system_r types postfix_qmgr_t;
#line 322

#line 322
# Inherit and use descriptors from init.
#line 322
allow postfix_qmgr_t init_t:fd use;
#line 322
allow postfix_qmgr_t init_t:process sigchld;
#line 322
allow postfix_qmgr_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 322

#line 322

#line 322
allow postfix_qmgr_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t lib_t:lnk_file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t ld_so_t:file { read getattr lock execute ioctl };
#line 322
#allow postfix_qmgr_t ld_so_t:file execute_no_trans;
#line 322
allow postfix_qmgr_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 322
allow postfix_qmgr_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t texrel_shlib_t:file execmod;
#line 322
allow postfix_qmgr_t ld_so_cache_t:file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t device_t:dir search;
#line 322
allow postfix_qmgr_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 322

#line 322

#line 322
allow postfix_qmgr_t { self proc_t }:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t { self proc_t }:lnk_file { getattr read };
#line 322

#line 322
allow postfix_qmgr_t device_t:dir { read getattr lock search ioctl };
#line 322

#line 322
allow postfix_qmgr_t udev_tdb_t:file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 322
dontaudit postfix_qmgr_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 322
dontaudit postfix_qmgr_t unpriv_userdomain:fd use;
#line 322

#line 322

#line 322
allow postfix_qmgr_t sysfs_t:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t sysfs_t:file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t sysfs_t:lnk_file { getattr read };
#line 322
 
#line 322

#line 322
allow postfix_qmgr_t autofs_t:dir { search getattr };
#line 322

#line 322
dontaudit postfix_qmgr_t { tty_device_t devpts_t }:chr_file { read write };
#line 322
dontaudit postfix_qmgr_t root_t:file { getattr read };
#line 322
 
#line 322

#line 322
allow postfix_qmgr_t self:process setpgid;
#line 322
allow postfix_qmgr_t postfix_master_t:process sigchld;
#line 322
allow postfix_master_t postfix_qmgr_t:process signal;
#line 322

#line 322
allow postfix_qmgr_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t postfix_etc_t:file { read getattr lock ioctl };
#line 322

#line 322
allow postfix_qmgr_t etc_t:lnk_file read;
#line 322
allow postfix_qmgr_t lib_t:file { read getattr lock ioctl };
#line 322

#line 322
allow postfix_qmgr_t locale_t:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t locale_t:file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t locale_t:lnk_file { getattr read };
#line 322

#line 322

#line 322
allow postfix_qmgr_t etc_t:file { getattr read };
#line 322
allow postfix_qmgr_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 322
allow postfix_qmgr_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 322
allow postfix_qmgr_t self:unix_stream_socket connectto;
#line 322

#line 322
allow postfix_qmgr_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t { bin_t usr_t }:lnk_file { getattr read };
#line 322
allow postfix_qmgr_t shell_exec_t:file { read getattr lock execute ioctl };
#line 322
allow postfix_qmgr_t { var_t var_spool_t }:dir { search getattr };
#line 322
allow postfix_qmgr_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 322
allow postfix_qmgr_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 322
allow postfix_qmgr_t etc_runtime_t:file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t proc_t:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t proc_t:file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t fs_t:filesystem getattr;
#line 322
allow postfix_qmgr_t proc_net_t:dir search;
#line 322
allow postfix_qmgr_t proc_net_t:file { getattr read };
#line 322

#line 322
allow postfix_qmgr_t postfix_qmgr_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 322

#line 322

#line 322
allow postfix_qmgr_t cert_t:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t cert_t:file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t cert_t:lnk_file { getattr read };
#line 322

#line 322
allow postfix_qmgr_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 322

#line 322
allow postfix_qmgr_t tmp_t:dir getattr;
#line 322

#line 322

#line 322

#line 322

#line 322

#line 322
#
#line 322
# Allow the process to modify the directory.
#line 322
#
#line 322
allow postfix_qmgr_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 322

#line 322
#
#line 322
# Allow the process to create the file.
#line 322
#
#line 322

#line 322

#line 322

#line 322

#line 322

#line 322
allow postfix_qmgr_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322
type_transition postfix_qmgr_t var_run_t:file postfix_var_run_t;
#line 322

#line 322

#line 322

#line 322

#line 322
# Read system variables in /sys.
#line 322

#line 322
allow postfix_qmgr_t sysctl_t:dir search;
#line 322
allow postfix_qmgr_t sysctl_kernel_t:dir search;
#line 322
allow postfix_qmgr_t sysctl_kernel_t:file { getattr read };
#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322
#
#line 322
# Allow the process to transition to the new domain.
#line 322
#
#line 322
allow postfix_master_t postfix_qmgr_t:process transition;
#line 322

#line 322
#
#line 322
# Do not audit when glibc secure mode is enabled upon the transition.
#line 322
#
#line 322
dontaudit postfix_master_t postfix_qmgr_t:process noatsecure;
#line 322

#line 322
#
#line 322
# Do not audit when signal-related state is cleared upon the transition.
#line 322
#
#line 322
dontaudit postfix_master_t postfix_qmgr_t:process siginh;
#line 322

#line 322
#
#line 322
# Do not audit when resource limits are reset upon the transition.
#line 322
#
#line 322
dontaudit postfix_master_t postfix_qmgr_t:process rlimitinh;
#line 322

#line 322
#
#line 322
# Allow the process to execute the program.
#line 322
# 
#line 322
allow postfix_master_t postfix_qmgr_exec_t:file { read { getattr execute } };
#line 322

#line 322
#
#line 322
# Allow the process to reap the new domain.
#line 322
#
#line 322
allow postfix_qmgr_t postfix_master_t:process sigchld;
#line 322

#line 322
#
#line 322
# Allow the new domain to inherit and use file 
#line 322
# descriptions from the creating process and vice versa.
#line 322
#
#line 322
allow postfix_qmgr_t postfix_master_t:fd use;
#line 322
allow postfix_master_t postfix_qmgr_t:fd use;
#line 322

#line 322
#
#line 322
# Allow the new domain to write back to the old domain via a pipe.
#line 322
#
#line 322
allow postfix_qmgr_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 322

#line 322
#
#line 322
# Allow the new domain to read and execute the program.
#line 322
#
#line 322
allow postfix_qmgr_t postfix_qmgr_exec_t:file { read getattr lock execute ioctl };
#line 322

#line 322
#
#line 322
# Allow the new domain to be entered via the program.
#line 322
#
#line 322
allow postfix_qmgr_t postfix_qmgr_exec_t:file entrypoint;
#line 322

#line 322
type_transition postfix_master_t postfix_qmgr_exec_t:process postfix_qmgr_t;
#line 322

#line 322
allow postfix_qmgr_t postfix_master_t:unix_stream_socket { connectto { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept } };
#line 322
allow postfix_qmgr_t self:capability { setuid setgid dac_override };
#line 322

#line 322

#line 322

#line 322

#line 322
#
#line 322
# Allow the domain to create and use tcp sockets.
#line 322
# Other kinds of sockets must be separately authorized for use.
#line 322
allow postfix_qmgr_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 322

#line 322
allow postfix_qmgr_t unlabeled_t:association { sendto recvfrom };
#line 322

#line 322
#
#line 322
# Allow the domain to send or receive using any network interface.
#line 322
# netif_type is a type attribute for all network interface types.
#line 322
#
#line 322
allow postfix_qmgr_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 322
#
#line 322
# Allow the domain to send to or receive from any node.
#line 322
# node_type is a type attribute for all node types.
#line 322
#
#line 322
allow postfix_qmgr_t node_type:node { tcp_send rawip_send };
#line 322
allow postfix_qmgr_t node_type:node { tcp_recv rawip_recv };
#line 322

#line 322
#
#line 322
# Allow the domain to send to or receive from any port.
#line 322
# port_type is a type attribute for all port types.
#line 322
#
#line 322

#line 322
allow postfix_qmgr_t port_type:tcp_socket { send_msg recv_msg };
#line 322

#line 322

#line 322
# XXX Allow binding to any node type.  Remove once
#line 322
# individual rules have been added to all domains that 
#line 322
# bind sockets. 
#line 322
allow postfix_qmgr_t node_type:tcp_socket node_bind;
#line 322
#
#line 322
# Allow access to network files including /etc/resolv.conf
#line 322
#
#line 322
allow postfix_qmgr_t net_conf_t:file { read getattr lock ioctl };
#line 322

#line 322
allow postfix_qmgr_t self:tcp_socket { connect };
#line 322

#line 322

#line 322

#line 322
#
#line 322
# Allow the domain to create and use udp sockets.
#line 322
# Other kinds of sockets must be separately authorized for use.
#line 322
allow postfix_qmgr_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 322

#line 322
allow postfix_qmgr_t unlabeled_t:association { sendto recvfrom };
#line 322

#line 322
#
#line 322
# Allow the domain to send or receive using any network interface.
#line 322
# netif_type is a type attribute for all network interface types.
#line 322
#
#line 322
allow postfix_qmgr_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 322
#
#line 322
# Allow the domain to send to or receive from any node.
#line 322
# node_type is a type attribute for all node types.
#line 322
#
#line 322
allow postfix_qmgr_t node_type:node { udp_send rawip_send };
#line 322
allow postfix_qmgr_t node_type:node { udp_recv rawip_recv };
#line 322

#line 322
#
#line 322
# Allow the domain to send to or receive from any port.
#line 322
# port_type is a type attribute for all port types.
#line 322
#
#line 322

#line 322
allow postfix_qmgr_t port_type:udp_socket { send_msg recv_msg };
#line 322

#line 322

#line 322
# XXX Allow binding to any node type.  Remove once
#line 322
# individual rules have been added to all domains that 
#line 322
# bind sockets. 
#line 322
allow postfix_qmgr_t node_type:udp_socket node_bind;
#line 322
#
#line 322
# Allow access to network files including /etc/resolv.conf
#line 322
#
#line 322
allow postfix_qmgr_t net_conf_t:file { read getattr lock ioctl };
#line 322

#line 322
allow postfix_qmgr_t self:udp_socket { connect };
#line 322

#line 322

#line 322

#line 322
allow postfix_qmgr_t port_type:tcp_socket name_connect;
#line 322

#line 322

#line 322
if (allow_ypbind) {
#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322
#
#line 322
# Allow the domain to create and use tcp sockets.
#line 322
# Other kinds of sockets must be separately authorized for use.
#line 322
allow postfix_qmgr_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 322

#line 322
allow postfix_qmgr_t unlabeled_t:association { sendto recvfrom };
#line 322

#line 322
#
#line 322
# Allow the domain to send or receive using any network interface.
#line 322
# netif_type is a type attribute for all network interface types.
#line 322
#
#line 322
allow postfix_qmgr_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 322
#
#line 322
# Allow the domain to send to or receive from any node.
#line 322
# node_type is a type attribute for all node types.
#line 322
#
#line 322
allow postfix_qmgr_t node_type:node { tcp_send rawip_send };
#line 322
allow postfix_qmgr_t node_type:node { tcp_recv rawip_recv };
#line 322

#line 322
#
#line 322
# Allow the domain to send to or receive from any port.
#line 322
# port_type is a type attribute for all port types.
#line 322
#
#line 322

#line 322
allow postfix_qmgr_t port_type:tcp_socket { send_msg recv_msg };
#line 322

#line 322

#line 322
# XXX Allow binding to any node type.  Remove once
#line 322
# individual rules have been added to all domains that 
#line 322
# bind sockets. 
#line 322
allow postfix_qmgr_t node_type:tcp_socket node_bind;
#line 322
#
#line 322
# Allow access to network files including /etc/resolv.conf
#line 322
#
#line 322
allow postfix_qmgr_t net_conf_t:file { read getattr lock ioctl };
#line 322

#line 322
allow postfix_qmgr_t self:tcp_socket { listen accept };
#line 322

#line 322

#line 322

#line 322
#
#line 322
# Allow the domain to create and use tcp sockets.
#line 322
# Other kinds of sockets must be separately authorized for use.
#line 322
allow postfix_qmgr_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 322

#line 322
allow postfix_qmgr_t unlabeled_t:association { sendto recvfrom };
#line 322

#line 322
#
#line 322
# Allow the domain to send or receive using any network interface.
#line 322
# netif_type is a type attribute for all network interface types.
#line 322
#
#line 322
allow postfix_qmgr_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 322
#
#line 322
# Allow the domain to send to or receive from any node.
#line 322
# node_type is a type attribute for all node types.
#line 322
#
#line 322
allow postfix_qmgr_t node_type:node { tcp_send rawip_send };
#line 322
allow postfix_qmgr_t node_type:node { tcp_recv rawip_recv };
#line 322

#line 322
#
#line 322
# Allow the domain to send to or receive from any port.
#line 322
# port_type is a type attribute for all port types.
#line 322
#
#line 322

#line 322
allow postfix_qmgr_t port_type:tcp_socket { send_msg recv_msg };
#line 322

#line 322

#line 322
# XXX Allow binding to any node type.  Remove once
#line 322
# individual rules have been added to all domains that 
#line 322
# bind sockets. 
#line 322
allow postfix_qmgr_t node_type:tcp_socket node_bind;
#line 322
#
#line 322
# Allow access to network files including /etc/resolv.conf
#line 322
#
#line 322
allow postfix_qmgr_t net_conf_t:file { read getattr lock ioctl };
#line 322

#line 322
allow postfix_qmgr_t self:tcp_socket { connect };
#line 322

#line 322

#line 322

#line 322

#line 322

#line 322
#
#line 322
# Allow the domain to create and use udp sockets.
#line 322
# Other kinds of sockets must be separately authorized for use.
#line 322
allow postfix_qmgr_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 322

#line 322
allow postfix_qmgr_t unlabeled_t:association { sendto recvfrom };
#line 322

#line 322
#
#line 322
# Allow the domain to send or receive using any network interface.
#line 322
# netif_type is a type attribute for all network interface types.
#line 322
#
#line 322
allow postfix_qmgr_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 322
#
#line 322
# Allow the domain to send to or receive from any node.
#line 322
# node_type is a type attribute for all node types.
#line 322
#
#line 322
allow postfix_qmgr_t node_type:node { udp_send rawip_send };
#line 322
allow postfix_qmgr_t node_type:node { udp_recv rawip_recv };
#line 322

#line 322
#
#line 322
# Allow the domain to send to or receive from any port.
#line 322
# port_type is a type attribute for all port types.
#line 322
#
#line 322

#line 322
allow postfix_qmgr_t port_type:udp_socket { send_msg recv_msg };
#line 322

#line 322

#line 322
# XXX Allow binding to any node type.  Remove once
#line 322
# individual rules have been added to all domains that 
#line 322
# bind sockets. 
#line 322
allow postfix_qmgr_t node_type:udp_socket node_bind;
#line 322
#
#line 322
# Allow access to network files including /etc/resolv.conf
#line 322
#
#line 322
allow postfix_qmgr_t net_conf_t:file { read getattr lock ioctl };
#line 322

#line 322
allow postfix_qmgr_t self:udp_socket { connect };
#line 322

#line 322

#line 322

#line 322

#line 322

#line 322

#line 322
allow postfix_qmgr_t var_yp_t:dir { read getattr lock search ioctl };
#line 322
allow postfix_qmgr_t var_yp_t:file { read getattr lock ioctl };
#line 322
allow postfix_qmgr_t var_yp_t:lnk_file { getattr read };
#line 322

#line 322
allow postfix_qmgr_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 322
allow postfix_qmgr_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 322
dontaudit postfix_qmgr_t self:capability net_bind_service;
#line 322
dontaudit postfix_qmgr_t reserved_port_type:tcp_socket name_connect;
#line 322
dontaudit postfix_qmgr_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 322

#line 322
} else {
#line 322
dontaudit postfix_qmgr_t var_yp_t:dir search;
#line 322
}
#line 322
 
#line 322

#line 322
allow postfix_qmgr_t postfix_public_t:dir search;
#line 322

allow postfix_qmgr_t postfix_public_t:fifo_file { ioctl read getattr lock write append };
allow postfix_qmgr_t postfix_public_t:sock_file write;
allow postfix_qmgr_t postfix_private_t:dir search;
allow postfix_qmgr_t postfix_private_t:sock_file { ioctl read getattr lock write append };
allow postfix_qmgr_t postfix_master_t:unix_stream_socket connectto;

# for /var/spool/postfix/active

#line 330
allow postfix_qmgr_t postfix_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 330
allow postfix_qmgr_t postfix_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 330
allow postfix_qmgr_t postfix_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 330



#line 332

#line 332

#line 332

#line 332
type postfix_bounce_t, domain, privlog, daemon ;
#line 332
type postfix_bounce_exec_t, file_type, sysadmfile, exec_type;
#line 332
dontaudit postfix_bounce_t self:capability sys_tty_config;
#line 332

#line 332
role system_r types postfix_bounce_t;
#line 332

#line 332
# Inherit and use descriptors from init.
#line 332
allow postfix_bounce_t init_t:fd use;
#line 332
allow postfix_bounce_t init_t:process sigchld;
#line 332
allow postfix_bounce_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 332

#line 332

#line 332
allow postfix_bounce_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t lib_t:lnk_file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t ld_so_t:file { read getattr lock execute ioctl };
#line 332
#allow postfix_bounce_t ld_so_t:file execute_no_trans;
#line 332
allow postfix_bounce_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 332
allow postfix_bounce_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t texrel_shlib_t:file execmod;
#line 332
allow postfix_bounce_t ld_so_cache_t:file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t device_t:dir search;
#line 332
allow postfix_bounce_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 332

#line 332

#line 332
allow postfix_bounce_t { self proc_t }:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t { self proc_t }:lnk_file { getattr read };
#line 332

#line 332
allow postfix_bounce_t device_t:dir { read getattr lock search ioctl };
#line 332

#line 332
allow postfix_bounce_t udev_tdb_t:file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 332
dontaudit postfix_bounce_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 332
dontaudit postfix_bounce_t unpriv_userdomain:fd use;
#line 332

#line 332

#line 332
allow postfix_bounce_t sysfs_t:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t sysfs_t:file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t sysfs_t:lnk_file { getattr read };
#line 332
 
#line 332

#line 332
allow postfix_bounce_t autofs_t:dir { search getattr };
#line 332

#line 332
dontaudit postfix_bounce_t { tty_device_t devpts_t }:chr_file { read write };
#line 332
dontaudit postfix_bounce_t root_t:file { getattr read };
#line 332
 
#line 332

#line 332
allow postfix_bounce_t self:process setpgid;
#line 332
allow postfix_bounce_t postfix_master_t:process sigchld;
#line 332
allow postfix_master_t postfix_bounce_t:process signal;
#line 332

#line 332
allow postfix_bounce_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t postfix_etc_t:file { read getattr lock ioctl };
#line 332

#line 332
allow postfix_bounce_t etc_t:lnk_file read;
#line 332
allow postfix_bounce_t lib_t:file { read getattr lock ioctl };
#line 332

#line 332
allow postfix_bounce_t locale_t:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t locale_t:file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t locale_t:lnk_file { getattr read };
#line 332

#line 332

#line 332
allow postfix_bounce_t etc_t:file { getattr read };
#line 332
allow postfix_bounce_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 332
allow postfix_bounce_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 332
allow postfix_bounce_t self:unix_stream_socket connectto;
#line 332

#line 332
allow postfix_bounce_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t { bin_t usr_t }:lnk_file { getattr read };
#line 332
allow postfix_bounce_t shell_exec_t:file { read getattr lock execute ioctl };
#line 332
allow postfix_bounce_t { var_t var_spool_t }:dir { search getattr };
#line 332
allow postfix_bounce_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 332
allow postfix_bounce_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 332
allow postfix_bounce_t etc_runtime_t:file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t proc_t:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t proc_t:file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t fs_t:filesystem getattr;
#line 332
allow postfix_bounce_t proc_net_t:dir search;
#line 332
allow postfix_bounce_t proc_net_t:file { getattr read };
#line 332

#line 332
allow postfix_bounce_t postfix_bounce_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 332

#line 332

#line 332
allow postfix_bounce_t cert_t:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t cert_t:file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t cert_t:lnk_file { getattr read };
#line 332

#line 332
allow postfix_bounce_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 332

#line 332
allow postfix_bounce_t tmp_t:dir getattr;
#line 332

#line 332

#line 332

#line 332

#line 332

#line 332
#
#line 332
# Allow the process to modify the directory.
#line 332
#
#line 332
allow postfix_bounce_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 332

#line 332
#
#line 332
# Allow the process to create the file.
#line 332
#
#line 332

#line 332

#line 332

#line 332

#line 332

#line 332
allow postfix_bounce_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332
type_transition postfix_bounce_t var_run_t:file postfix_var_run_t;
#line 332

#line 332

#line 332

#line 332

#line 332
# Read system variables in /sys.
#line 332

#line 332
allow postfix_bounce_t sysctl_t:dir search;
#line 332
allow postfix_bounce_t sysctl_kernel_t:dir search;
#line 332
allow postfix_bounce_t sysctl_kernel_t:file { getattr read };
#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332
#
#line 332
# Allow the process to transition to the new domain.
#line 332
#
#line 332
allow postfix_master_t postfix_bounce_t:process transition;
#line 332

#line 332
#
#line 332
# Do not audit when glibc secure mode is enabled upon the transition.
#line 332
#
#line 332
dontaudit postfix_master_t postfix_bounce_t:process noatsecure;
#line 332

#line 332
#
#line 332
# Do not audit when signal-related state is cleared upon the transition.
#line 332
#
#line 332
dontaudit postfix_master_t postfix_bounce_t:process siginh;
#line 332

#line 332
#
#line 332
# Do not audit when resource limits are reset upon the transition.
#line 332
#
#line 332
dontaudit postfix_master_t postfix_bounce_t:process rlimitinh;
#line 332

#line 332
#
#line 332
# Allow the process to execute the program.
#line 332
# 
#line 332
allow postfix_master_t postfix_bounce_exec_t:file { read { getattr execute } };
#line 332

#line 332
#
#line 332
# Allow the process to reap the new domain.
#line 332
#
#line 332
allow postfix_bounce_t postfix_master_t:process sigchld;
#line 332

#line 332
#
#line 332
# Allow the new domain to inherit and use file 
#line 332
# descriptions from the creating process and vice versa.
#line 332
#
#line 332
allow postfix_bounce_t postfix_master_t:fd use;
#line 332
allow postfix_master_t postfix_bounce_t:fd use;
#line 332

#line 332
#
#line 332
# Allow the new domain to write back to the old domain via a pipe.
#line 332
#
#line 332
allow postfix_bounce_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 332

#line 332
#
#line 332
# Allow the new domain to read and execute the program.
#line 332
#
#line 332
allow postfix_bounce_t postfix_bounce_exec_t:file { read getattr lock execute ioctl };
#line 332

#line 332
#
#line 332
# Allow the new domain to be entered via the program.
#line 332
#
#line 332
allow postfix_bounce_t postfix_bounce_exec_t:file entrypoint;
#line 332

#line 332
type_transition postfix_master_t postfix_bounce_exec_t:process postfix_bounce_t;
#line 332

#line 332
allow postfix_bounce_t postfix_master_t:unix_stream_socket { connectto { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept } };
#line 332
allow postfix_bounce_t self:capability { setuid setgid dac_override };
#line 332

#line 332

#line 332

#line 332

#line 332
#
#line 332
# Allow the domain to create and use tcp sockets.
#line 332
# Other kinds of sockets must be separately authorized for use.
#line 332
allow postfix_bounce_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 332

#line 332
allow postfix_bounce_t unlabeled_t:association { sendto recvfrom };
#line 332

#line 332
#
#line 332
# Allow the domain to send or receive using any network interface.
#line 332
# netif_type is a type attribute for all network interface types.
#line 332
#
#line 332
allow postfix_bounce_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 332
#
#line 332
# Allow the domain to send to or receive from any node.
#line 332
# node_type is a type attribute for all node types.
#line 332
#
#line 332
allow postfix_bounce_t node_type:node { tcp_send rawip_send };
#line 332
allow postfix_bounce_t node_type:node { tcp_recv rawip_recv };
#line 332

#line 332
#
#line 332
# Allow the domain to send to or receive from any port.
#line 332
# port_type is a type attribute for all port types.
#line 332
#
#line 332

#line 332
allow postfix_bounce_t port_type:tcp_socket { send_msg recv_msg };
#line 332

#line 332

#line 332
# XXX Allow binding to any node type.  Remove once
#line 332
# individual rules have been added to all domains that 
#line 332
# bind sockets. 
#line 332
allow postfix_bounce_t node_type:tcp_socket node_bind;
#line 332
#
#line 332
# Allow access to network files including /etc/resolv.conf
#line 332
#
#line 332
allow postfix_bounce_t net_conf_t:file { read getattr lock ioctl };
#line 332

#line 332
allow postfix_bounce_t self:tcp_socket { connect };
#line 332

#line 332

#line 332

#line 332
#
#line 332
# Allow the domain to create and use udp sockets.
#line 332
# Other kinds of sockets must be separately authorized for use.
#line 332
allow postfix_bounce_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 332

#line 332
allow postfix_bounce_t unlabeled_t:association { sendto recvfrom };
#line 332

#line 332
#
#line 332
# Allow the domain to send or receive using any network interface.
#line 332
# netif_type is a type attribute for all network interface types.
#line 332
#
#line 332
allow postfix_bounce_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 332
#
#line 332
# Allow the domain to send to or receive from any node.
#line 332
# node_type is a type attribute for all node types.
#line 332
#
#line 332
allow postfix_bounce_t node_type:node { udp_send rawip_send };
#line 332
allow postfix_bounce_t node_type:node { udp_recv rawip_recv };
#line 332

#line 332
#
#line 332
# Allow the domain to send to or receive from any port.
#line 332
# port_type is a type attribute for all port types.
#line 332
#
#line 332

#line 332
allow postfix_bounce_t port_type:udp_socket { send_msg recv_msg };
#line 332

#line 332

#line 332
# XXX Allow binding to any node type.  Remove once
#line 332
# individual rules have been added to all domains that 
#line 332
# bind sockets. 
#line 332
allow postfix_bounce_t node_type:udp_socket node_bind;
#line 332
#
#line 332
# Allow access to network files including /etc/resolv.conf
#line 332
#
#line 332
allow postfix_bounce_t net_conf_t:file { read getattr lock ioctl };
#line 332

#line 332
allow postfix_bounce_t self:udp_socket { connect };
#line 332

#line 332

#line 332

#line 332
allow postfix_bounce_t port_type:tcp_socket name_connect;
#line 332

#line 332

#line 332
if (allow_ypbind) {
#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332
#
#line 332
# Allow the domain to create and use tcp sockets.
#line 332
# Other kinds of sockets must be separately authorized for use.
#line 332
allow postfix_bounce_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 332

#line 332
allow postfix_bounce_t unlabeled_t:association { sendto recvfrom };
#line 332

#line 332
#
#line 332
# Allow the domain to send or receive using any network interface.
#line 332
# netif_type is a type attribute for all network interface types.
#line 332
#
#line 332
allow postfix_bounce_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 332
#
#line 332
# Allow the domain to send to or receive from any node.
#line 332
# node_type is a type attribute for all node types.
#line 332
#
#line 332
allow postfix_bounce_t node_type:node { tcp_send rawip_send };
#line 332
allow postfix_bounce_t node_type:node { tcp_recv rawip_recv };
#line 332

#line 332
#
#line 332
# Allow the domain to send to or receive from any port.
#line 332
# port_type is a type attribute for all port types.
#line 332
#
#line 332

#line 332
allow postfix_bounce_t port_type:tcp_socket { send_msg recv_msg };
#line 332

#line 332

#line 332
# XXX Allow binding to any node type.  Remove once
#line 332
# individual rules have been added to all domains that 
#line 332
# bind sockets. 
#line 332
allow postfix_bounce_t node_type:tcp_socket node_bind;
#line 332
#
#line 332
# Allow access to network files including /etc/resolv.conf
#line 332
#
#line 332
allow postfix_bounce_t net_conf_t:file { read getattr lock ioctl };
#line 332

#line 332
allow postfix_bounce_t self:tcp_socket { listen accept };
#line 332

#line 332

#line 332

#line 332
#
#line 332
# Allow the domain to create and use tcp sockets.
#line 332
# Other kinds of sockets must be separately authorized for use.
#line 332
allow postfix_bounce_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 332

#line 332
allow postfix_bounce_t unlabeled_t:association { sendto recvfrom };
#line 332

#line 332
#
#line 332
# Allow the domain to send or receive using any network interface.
#line 332
# netif_type is a type attribute for all network interface types.
#line 332
#
#line 332
allow postfix_bounce_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 332
#
#line 332
# Allow the domain to send to or receive from any node.
#line 332
# node_type is a type attribute for all node types.
#line 332
#
#line 332
allow postfix_bounce_t node_type:node { tcp_send rawip_send };
#line 332
allow postfix_bounce_t node_type:node { tcp_recv rawip_recv };
#line 332

#line 332
#
#line 332
# Allow the domain to send to or receive from any port.
#line 332
# port_type is a type attribute for all port types.
#line 332
#
#line 332

#line 332
allow postfix_bounce_t port_type:tcp_socket { send_msg recv_msg };
#line 332

#line 332

#line 332
# XXX Allow binding to any node type.  Remove once
#line 332
# individual rules have been added to all domains that 
#line 332
# bind sockets. 
#line 332
allow postfix_bounce_t node_type:tcp_socket node_bind;
#line 332
#
#line 332
# Allow access to network files including /etc/resolv.conf
#line 332
#
#line 332
allow postfix_bounce_t net_conf_t:file { read getattr lock ioctl };
#line 332

#line 332
allow postfix_bounce_t self:tcp_socket { connect };
#line 332

#line 332

#line 332

#line 332

#line 332

#line 332
#
#line 332
# Allow the domain to create and use udp sockets.
#line 332
# Other kinds of sockets must be separately authorized for use.
#line 332
allow postfix_bounce_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 332

#line 332
allow postfix_bounce_t unlabeled_t:association { sendto recvfrom };
#line 332

#line 332
#
#line 332
# Allow the domain to send or receive using any network interface.
#line 332
# netif_type is a type attribute for all network interface types.
#line 332
#
#line 332
allow postfix_bounce_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 332
#
#line 332
# Allow the domain to send to or receive from any node.
#line 332
# node_type is a type attribute for all node types.
#line 332
#
#line 332
allow postfix_bounce_t node_type:node { udp_send rawip_send };
#line 332
allow postfix_bounce_t node_type:node { udp_recv rawip_recv };
#line 332

#line 332
#
#line 332
# Allow the domain to send to or receive from any port.
#line 332
# port_type is a type attribute for all port types.
#line 332
#
#line 332

#line 332
allow postfix_bounce_t port_type:udp_socket { send_msg recv_msg };
#line 332

#line 332

#line 332
# XXX Allow binding to any node type.  Remove once
#line 332
# individual rules have been added to all domains that 
#line 332
# bind sockets. 
#line 332
allow postfix_bounce_t node_type:udp_socket node_bind;
#line 332
#
#line 332
# Allow access to network files including /etc/resolv.conf
#line 332
#
#line 332
allow postfix_bounce_t net_conf_t:file { read getattr lock ioctl };
#line 332

#line 332
allow postfix_bounce_t self:udp_socket { connect };
#line 332

#line 332

#line 332

#line 332

#line 332

#line 332

#line 332
allow postfix_bounce_t var_yp_t:dir { read getattr lock search ioctl };
#line 332
allow postfix_bounce_t var_yp_t:file { read getattr lock ioctl };
#line 332
allow postfix_bounce_t var_yp_t:lnk_file { getattr read };
#line 332

#line 332
allow postfix_bounce_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 332
allow postfix_bounce_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 332
dontaudit postfix_bounce_t self:capability net_bind_service;
#line 332
dontaudit postfix_bounce_t reserved_port_type:tcp_socket name_connect;
#line 332
dontaudit postfix_bounce_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 332

#line 332
} else {
#line 332
dontaudit postfix_bounce_t var_yp_t:dir search;
#line 332
}
#line 332
 
#line 332

#line 332
allow postfix_bounce_t postfix_public_t:dir search;
#line 332

type postfix_spool_bounce_t, file_type, sysadmfile;

#line 334
allow postfix_bounce_t postfix_spool_bounce_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 334
allow postfix_bounce_t postfix_spool_bounce_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 334
allow postfix_bounce_t postfix_spool_bounce_t:lnk_file { create read getattr setattr link unlink rename };
#line 334


#line 335
allow postfix_bounce_t postfix_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 335
allow postfix_bounce_t postfix_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 335
allow postfix_bounce_t postfix_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 335

allow postfix_master_t postfix_spool_bounce_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
allow postfix_master_t postfix_spool_bounce_t:file getattr;
allow postfix_bounce_t self:capability dac_read_search;
allow postfix_bounce_t postfix_public_t:sock_file write;
allow postfix_bounce_t self:tcp_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };


#line 342
allow postfix_qmgr_t postfix_spool_bounce_t:dir { read getattr lock search ioctl };
#line 342
allow postfix_qmgr_t postfix_spool_bounce_t:file { read getattr lock ioctl };
#line 342
allow postfix_qmgr_t postfix_spool_bounce_t:lnk_file { getattr read };
#line 342



#line 344

#line 344

#line 344

#line 344
type postfix_pipe_t, domain, privlog, daemon ;
#line 344
type postfix_pipe_exec_t, file_type, sysadmfile, exec_type;
#line 344
dontaudit postfix_pipe_t self:capability sys_tty_config;
#line 344

#line 344
role system_r types postfix_pipe_t;
#line 344

#line 344
# Inherit and use descriptors from init.
#line 344
allow postfix_pipe_t init_t:fd use;
#line 344
allow postfix_pipe_t init_t:process sigchld;
#line 344
allow postfix_pipe_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 344

#line 344

#line 344
allow postfix_pipe_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t lib_t:lnk_file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t ld_so_t:file { read getattr lock execute ioctl };
#line 344
#allow postfix_pipe_t ld_so_t:file execute_no_trans;
#line 344
allow postfix_pipe_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 344
allow postfix_pipe_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t texrel_shlib_t:file execmod;
#line 344
allow postfix_pipe_t ld_so_cache_t:file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t device_t:dir search;
#line 344
allow postfix_pipe_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 344

#line 344

#line 344
allow postfix_pipe_t { self proc_t }:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t { self proc_t }:lnk_file { getattr read };
#line 344

#line 344
allow postfix_pipe_t device_t:dir { read getattr lock search ioctl };
#line 344

#line 344
allow postfix_pipe_t udev_tdb_t:file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 344
dontaudit postfix_pipe_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 344
dontaudit postfix_pipe_t unpriv_userdomain:fd use;
#line 344

#line 344

#line 344
allow postfix_pipe_t sysfs_t:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t sysfs_t:file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t sysfs_t:lnk_file { getattr read };
#line 344
 
#line 344

#line 344
allow postfix_pipe_t autofs_t:dir { search getattr };
#line 344

#line 344
dontaudit postfix_pipe_t { tty_device_t devpts_t }:chr_file { read write };
#line 344
dontaudit postfix_pipe_t root_t:file { getattr read };
#line 344
 
#line 344

#line 344
allow postfix_pipe_t self:process setpgid;
#line 344
allow postfix_pipe_t postfix_master_t:process sigchld;
#line 344
allow postfix_master_t postfix_pipe_t:process signal;
#line 344

#line 344
allow postfix_pipe_t { etc_t postfix_etc_t postfix_spool_t }:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t postfix_etc_t:file { read getattr lock ioctl };
#line 344

#line 344
allow postfix_pipe_t etc_t:lnk_file read;
#line 344
allow postfix_pipe_t lib_t:file { read getattr lock ioctl };
#line 344

#line 344
allow postfix_pipe_t locale_t:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t locale_t:file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t locale_t:lnk_file { getattr read };
#line 344

#line 344

#line 344
allow postfix_pipe_t etc_t:file { getattr read };
#line 344
allow postfix_pipe_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 344
allow postfix_pipe_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 344
allow postfix_pipe_t self:unix_stream_socket connectto;
#line 344

#line 344
allow postfix_pipe_t { sbin_t bin_t }:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t { bin_t usr_t }:lnk_file { getattr read };
#line 344
allow postfix_pipe_t shell_exec_t:file { read getattr lock execute ioctl };
#line 344
allow postfix_pipe_t { var_t var_spool_t }:dir { search getattr };
#line 344
allow postfix_pipe_t postfix_exec_t:file { read getattr lock execute ioctl };
#line 344
allow postfix_pipe_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 344
allow postfix_pipe_t etc_runtime_t:file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t proc_t:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t proc_t:file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t postfix_exec_t:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t fs_t:filesystem getattr;
#line 344
allow postfix_pipe_t proc_net_t:dir search;
#line 344
allow postfix_pipe_t proc_net_t:file { getattr read };
#line 344

#line 344
allow postfix_pipe_t postfix_pipe_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 344

#line 344

#line 344
allow postfix_pipe_t cert_t:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t cert_t:file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t cert_t:lnk_file { getattr read };
#line 344

#line 344
allow postfix_pipe_t { urandom_device_t random_device_t }:chr_file { read getattr };
#line 344

#line 344
allow postfix_pipe_t tmp_t:dir getattr;
#line 344

#line 344

#line 344

#line 344

#line 344

#line 344
#
#line 344
# Allow the process to modify the directory.
#line 344
#
#line 344
allow postfix_pipe_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 344

#line 344
#
#line 344
# Allow the process to create the file.
#line 344
#
#line 344

#line 344

#line 344

#line 344

#line 344

#line 344
allow postfix_pipe_t postfix_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344
type_transition postfix_pipe_t var_run_t:file postfix_var_run_t;
#line 344

#line 344

#line 344

#line 344

#line 344
# Read system variables in /sys.
#line 344

#line 344
allow postfix_pipe_t sysctl_t:dir search;
#line 344
allow postfix_pipe_t sysctl_kernel_t:dir search;
#line 344
allow postfix_pipe_t sysctl_kernel_t:file { getattr read };
#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344
#
#line 344
# Allow the process to transition to the new domain.
#line 344
#
#line 344
allow postfix_master_t postfix_pipe_t:process transition;
#line 344

#line 344
#
#line 344
# Do not audit when glibc secure mode is enabled upon the transition.
#line 344
#
#line 344
dontaudit postfix_master_t postfix_pipe_t:process noatsecure;
#line 344

#line 344
#
#line 344
# Do not audit when signal-related state is cleared upon the transition.
#line 344
#
#line 344
dontaudit postfix_master_t postfix_pipe_t:process siginh;
#line 344

#line 344
#
#line 344
# Do not audit when resource limits are reset upon the transition.
#line 344
#
#line 344
dontaudit postfix_master_t postfix_pipe_t:process rlimitinh;
#line 344

#line 344
#
#line 344
# Allow the process to execute the program.
#line 344
# 
#line 344
allow postfix_master_t postfix_pipe_exec_t:file { read { getattr execute } };
#line 344

#line 344
#
#line 344
# Allow the process to reap the new domain.
#line 344
#
#line 344
allow postfix_pipe_t postfix_master_t:process sigchld;
#line 344

#line 344
#
#line 344
# Allow the new domain to inherit and use file 
#line 344
# descriptions from the creating process and vice versa.
#line 344
#
#line 344
allow postfix_pipe_t postfix_master_t:fd use;
#line 344
allow postfix_master_t postfix_pipe_t:fd use;
#line 344

#line 344
#
#line 344
# Allow the new domain to write back to the old domain via a pipe.
#line 344
#
#line 344
allow postfix_pipe_t postfix_master_t:fifo_file { ioctl read getattr lock write append };
#line 344

#line 344
#
#line 344
# Allow the new domain to read and execute the program.
#line 344
#
#line 344
allow postfix_pipe_t postfix_pipe_exec_t:file { read getattr lock execute ioctl };
#line 344

#line 344
#
#line 344
# Allow the new domain to be entered via the program.
#line 344
#
#line 344
allow postfix_pipe_t postfix_pipe_exec_t:file entrypoint;
#line 344

#line 344
type_transition postfix_master_t postfix_pipe_exec_t:process postfix_pipe_t;
#line 344

#line 344
allow postfix_pipe_t postfix_master_t:unix_stream_socket { connectto { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept } };
#line 344
allow postfix_pipe_t self:capability { setuid setgid dac_override };
#line 344

#line 344

#line 344

#line 344

#line 344
#
#line 344
# Allow the domain to create and use tcp sockets.
#line 344
# Other kinds of sockets must be separately authorized for use.
#line 344
allow postfix_pipe_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 344

#line 344
allow postfix_pipe_t unlabeled_t:association { sendto recvfrom };
#line 344

#line 344
#
#line 344
# Allow the domain to send or receive using any network interface.
#line 344
# netif_type is a type attribute for all network interface types.
#line 344
#
#line 344
allow postfix_pipe_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 344
#
#line 344
# Allow the domain to send to or receive from any node.
#line 344
# node_type is a type attribute for all node types.
#line 344
#
#line 344
allow postfix_pipe_t node_type:node { tcp_send rawip_send };
#line 344
allow postfix_pipe_t node_type:node { tcp_recv rawip_recv };
#line 344

#line 344
#
#line 344
# Allow the domain to send to or receive from any port.
#line 344
# port_type is a type attribute for all port types.
#line 344
#
#line 344

#line 344
allow postfix_pipe_t port_type:tcp_socket { send_msg recv_msg };
#line 344

#line 344

#line 344
# XXX Allow binding to any node type.  Remove once
#line 344
# individual rules have been added to all domains that 
#line 344
# bind sockets. 
#line 344
allow postfix_pipe_t node_type:tcp_socket node_bind;
#line 344
#
#line 344
# Allow access to network files including /etc/resolv.conf
#line 344
#
#line 344
allow postfix_pipe_t net_conf_t:file { read getattr lock ioctl };
#line 344

#line 344
allow postfix_pipe_t self:tcp_socket { connect };
#line 344

#line 344

#line 344

#line 344
#
#line 344
# Allow the domain to create and use udp sockets.
#line 344
# Other kinds of sockets must be separately authorized for use.
#line 344
allow postfix_pipe_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 344

#line 344
allow postfix_pipe_t unlabeled_t:association { sendto recvfrom };
#line 344

#line 344
#
#line 344
# Allow the domain to send or receive using any network interface.
#line 344
# netif_type is a type attribute for all network interface types.
#line 344
#
#line 344
allow postfix_pipe_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 344
#
#line 344
# Allow the domain to send to or receive from any node.
#line 344
# node_type is a type attribute for all node types.
#line 344
#
#line 344
allow postfix_pipe_t node_type:node { udp_send rawip_send };
#line 344
allow postfix_pipe_t node_type:node { udp_recv rawip_recv };
#line 344

#line 344
#
#line 344
# Allow the domain to send to or receive from any port.
#line 344
# port_type is a type attribute for all port types.
#line 344
#
#line 344

#line 344
allow postfix_pipe_t port_type:udp_socket { send_msg recv_msg };
#line 344

#line 344

#line 344
# XXX Allow binding to any node type.  Remove once
#line 344
# individual rules have been added to all domains that 
#line 344
# bind sockets. 
#line 344
allow postfix_pipe_t node_type:udp_socket node_bind;
#line 344
#
#line 344
# Allow access to network files including /etc/resolv.conf
#line 344
#
#line 344
allow postfix_pipe_t net_conf_t:file { read getattr lock ioctl };
#line 344

#line 344
allow postfix_pipe_t self:udp_socket { connect };
#line 344

#line 344

#line 344

#line 344
allow postfix_pipe_t port_type:tcp_socket name_connect;
#line 344

#line 344

#line 344
if (allow_ypbind) {
#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344
#
#line 344
# Allow the domain to create and use tcp sockets.
#line 344
# Other kinds of sockets must be separately authorized for use.
#line 344
allow postfix_pipe_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 344

#line 344
allow postfix_pipe_t unlabeled_t:association { sendto recvfrom };
#line 344

#line 344
#
#line 344
# Allow the domain to send or receive using any network interface.
#line 344
# netif_type is a type attribute for all network interface types.
#line 344
#
#line 344
allow postfix_pipe_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 344
#
#line 344
# Allow the domain to send to or receive from any node.
#line 344
# node_type is a type attribute for all node types.
#line 344
#
#line 344
allow postfix_pipe_t node_type:node { tcp_send rawip_send };
#line 344
allow postfix_pipe_t node_type:node { tcp_recv rawip_recv };
#line 344

#line 344
#
#line 344
# Allow the domain to send to or receive from any port.
#line 344
# port_type is a type attribute for all port types.
#line 344
#
#line 344

#line 344
allow postfix_pipe_t port_type:tcp_socket { send_msg recv_msg };
#line 344

#line 344

#line 344
# XXX Allow binding to any node type.  Remove once
#line 344
# individual rules have been added to all domains that 
#line 344
# bind sockets. 
#line 344
allow postfix_pipe_t node_type:tcp_socket node_bind;
#line 344
#
#line 344
# Allow access to network files including /etc/resolv.conf
#line 344
#
#line 344
allow postfix_pipe_t net_conf_t:file { read getattr lock ioctl };
#line 344

#line 344
allow postfix_pipe_t self:tcp_socket { listen accept };
#line 344

#line 344

#line 344

#line 344
#
#line 344
# Allow the domain to create and use tcp sockets.
#line 344
# Other kinds of sockets must be separately authorized for use.
#line 344
allow postfix_pipe_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 344

#line 344
allow postfix_pipe_t unlabeled_t:association { sendto recvfrom };
#line 344

#line 344
#
#line 344
# Allow the domain to send or receive using any network interface.
#line 344
# netif_type is a type attribute for all network interface types.
#line 344
#
#line 344
allow postfix_pipe_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 344
#
#line 344
# Allow the domain to send to or receive from any node.
#line 344
# node_type is a type attribute for all node types.
#line 344
#
#line 344
allow postfix_pipe_t node_type:node { tcp_send rawip_send };
#line 344
allow postfix_pipe_t node_type:node { tcp_recv rawip_recv };
#line 344

#line 344
#
#line 344
# Allow the domain to send to or receive from any port.
#line 344
# port_type is a type attribute for all port types.
#line 344
#
#line 344

#line 344
allow postfix_pipe_t port_type:tcp_socket { send_msg recv_msg };
#line 344

#line 344

#line 344
# XXX Allow binding to any node type.  Remove once
#line 344
# individual rules have been added to all domains that 
#line 344
# bind sockets. 
#line 344
allow postfix_pipe_t node_type:tcp_socket node_bind;
#line 344
#
#line 344
# Allow access to network files including /etc/resolv.conf
#line 344
#
#line 344
allow postfix_pipe_t net_conf_t:file { read getattr lock ioctl };
#line 344

#line 344
allow postfix_pipe_t self:tcp_socket { connect };
#line 344

#line 344

#line 344

#line 344

#line 344

#line 344
#
#line 344
# Allow the domain to create and use udp sockets.
#line 344
# Other kinds of sockets must be separately authorized for use.
#line 344
allow postfix_pipe_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 344

#line 344
allow postfix_pipe_t unlabeled_t:association { sendto recvfrom };
#line 344

#line 344
#
#line 344
# Allow the domain to send or receive using any network interface.
#line 344
# netif_type is a type attribute for all network interface types.
#line 344
#
#line 344
allow postfix_pipe_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 344
#
#line 344
# Allow the domain to send to or receive from any node.
#line 344
# node_type is a type attribute for all node types.
#line 344
#
#line 344
allow postfix_pipe_t node_type:node { udp_send rawip_send };
#line 344
allow postfix_pipe_t node_type:node { udp_recv rawip_recv };
#line 344

#line 344
#
#line 344
# Allow the domain to send to or receive from any port.
#line 344
# port_type is a type attribute for all port types.
#line 344
#
#line 344

#line 344
allow postfix_pipe_t port_type:udp_socket { send_msg recv_msg };
#line 344

#line 344

#line 344
# XXX Allow binding to any node type.  Remove once
#line 344
# individual rules have been added to all domains that 
#line 344
# bind sockets. 
#line 344
allow postfix_pipe_t node_type:udp_socket node_bind;
#line 344
#
#line 344
# Allow access to network files including /etc/resolv.conf
#line 344
#
#line 344
allow postfix_pipe_t net_conf_t:file { read getattr lock ioctl };
#line 344

#line 344
allow postfix_pipe_t self:udp_socket { connect };
#line 344

#line 344

#line 344

#line 344

#line 344

#line 344

#line 344
allow postfix_pipe_t var_yp_t:dir { read getattr lock search ioctl };
#line 344
allow postfix_pipe_t var_yp_t:file { read getattr lock ioctl };
#line 344
allow postfix_pipe_t var_yp_t:lnk_file { getattr read };
#line 344

#line 344
allow postfix_pipe_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 344
allow postfix_pipe_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 344
dontaudit postfix_pipe_t self:capability net_bind_service;
#line 344
dontaudit postfix_pipe_t reserved_port_type:tcp_socket name_connect;
#line 344
dontaudit postfix_pipe_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 344

#line 344
} else {
#line 344
dontaudit postfix_pipe_t var_yp_t:dir search;
#line 344
}
#line 344
 
#line 344

#line 344
allow postfix_pipe_t postfix_public_t:dir search;
#line 344

allow postfix_pipe_t postfix_spool_t:dir search;
allow postfix_pipe_t postfix_spool_t:file { ioctl read getattr lock write append };
allow postfix_pipe_t self:fifo_file { read write };
allow postfix_pipe_t postfix_private_t:dir search;
allow postfix_pipe_t postfix_private_t:sock_file write;
#line 352

#line 356

#line 356

#line 356
allow sendmail_t postfix_etc_t:dir { read getattr lock search ioctl };
#line 356
allow sendmail_t postfix_etc_t:file { read getattr lock ioctl };
#line 356
allow sendmail_t postfix_etc_t:lnk_file { getattr read };
#line 356

#line 356
allow sendmail_t postfix_spool_t:dir search;
#line 356


# Program for creating database files

#line 359
type postfix_map_t, domain, privlog ;
#line 359
type postfix_map_exec_t, file_type, sysadmfile, exec_type;
#line 359
role sysadm_r types postfix_map_t;
#line 359

#line 359
role system_r types postfix_map_t;
#line 359

#line 359

#line 359

#line 359

#line 359
#
#line 359
# Allow the process to transition to the new domain.
#line 359
#
#line 359
allow sysadm_t postfix_map_t:process transition;
#line 359

#line 359
#
#line 359
# Do not audit when glibc secure mode is enabled upon the transition.
#line 359
#
#line 359
dontaudit sysadm_t postfix_map_t:process noatsecure;
#line 359

#line 359
#
#line 359
# Do not audit when signal-related state is cleared upon the transition.
#line 359
#
#line 359
dontaudit sysadm_t postfix_map_t:process siginh;
#line 359

#line 359
#
#line 359
# Do not audit when resource limits are reset upon the transition.
#line 359
#
#line 359
dontaudit sysadm_t postfix_map_t:process rlimitinh;
#line 359

#line 359
#
#line 359
# Allow the process to execute the program.
#line 359
# 
#line 359
allow sysadm_t postfix_map_exec_t:file { read { getattr execute } };
#line 359

#line 359
#
#line 359
# Allow the process to reap the new domain.
#line 359
#
#line 359
allow postfix_map_t sysadm_t:process sigchld;
#line 359

#line 359
#
#line 359
# Allow the new domain to inherit and use file 
#line 359
# descriptions from the creating process and vice versa.
#line 359
#
#line 359
allow postfix_map_t sysadm_t:fd use;
#line 359
allow sysadm_t postfix_map_t:fd use;
#line 359

#line 359
#
#line 359
# Allow the new domain to write back to the old domain via a pipe.
#line 359
#
#line 359
allow postfix_map_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 359

#line 359
#
#line 359
# Allow the new domain to read and execute the program.
#line 359
#
#line 359
allow postfix_map_t postfix_map_exec_t:file { read getattr lock execute ioctl };
#line 359

#line 359
#
#line 359
# Allow the new domain to be entered via the program.
#line 359
#
#line 359
allow postfix_map_t postfix_map_exec_t:file entrypoint;
#line 359

#line 359
type_transition sysadm_t postfix_map_exec_t:process postfix_map_t;
#line 359

#line 359

#line 359
allow postfix_map_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 359
allow postfix_map_t lib_t:lnk_file { read getattr lock ioctl };
#line 359
allow postfix_map_t ld_so_t:file { read getattr lock execute ioctl };
#line 359
#allow postfix_map_t ld_so_t:file execute_no_trans;
#line 359
allow postfix_map_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 359
allow postfix_map_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 359
allow postfix_map_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 359
allow postfix_map_t texrel_shlib_t:file execmod;
#line 359
allow postfix_map_t ld_so_cache_t:file { read getattr lock ioctl };
#line 359
allow postfix_map_t device_t:dir search;
#line 359
allow postfix_map_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 359

#line 359


#line 360
# Read /.
#line 360
allow postfix_map_t root_t:dir { read getattr lock search ioctl };
#line 360
allow postfix_map_t root_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 360

#line 360
# Read /home.
#line 360
allow postfix_map_t home_root_t:dir { read getattr lock search ioctl };
#line 360

#line 360
# Read /usr.
#line 360
allow postfix_map_t usr_t:dir { read getattr lock search ioctl };
#line 360
allow postfix_map_t usr_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 360

#line 360
# Read bin and sbin directories.
#line 360
allow postfix_map_t bin_t:dir { read getattr lock search ioctl };
#line 360
allow postfix_map_t bin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 360
allow postfix_map_t sbin_t:dir { read getattr lock search ioctl };
#line 360
allow postfix_map_t sbin_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 360

#line 360
# Read system variables in /sys.
#line 360

#line 360
allow postfix_map_t sysctl_t:dir search;
#line 360
allow postfix_map_t sysctl_kernel_t:dir search;
#line 360
allow postfix_map_t sysctl_kernel_t:file { getattr read };
#line 360

#line 360

#line 360

#line 360

#line 360

#line 360
allow postfix_map_t selinux_config_t:dir { read getattr lock search ioctl };
#line 360
allow postfix_map_t selinux_config_t:file { read getattr lock ioctl };
#line 360
allow postfix_map_t selinux_config_t:lnk_file { getattr read };
#line 360

#line 360

#line 360
if (read_default_t) {
#line 360
#
#line 360
# Read default_t
#line 360
#.
#line 360
allow postfix_map_t default_t:dir { read getattr lock search ioctl };
#line 360
allow postfix_map_t default_t:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 360
}
#line 360

#line 360

allow postfix_map_t { etc_t etc_runtime_t }:{ file lnk_file } { getattr read };

#line 362
type postfix_map_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 362

#line 362

#line 362

#line 362

#line 362
#
#line 362
# Allow the process to modify the directory.
#line 362
#
#line 362
allow postfix_map_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 362

#line 362
#
#line 362
# Allow the process to create the file.
#line 362
#
#line 362

#line 362

#line 362

#line 362

#line 362

#line 362
allow postfix_map_t postfix_map_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 362

#line 362

#line 362

#line 362

#line 362

#line 362

#line 362
allow postfix_map_t postfix_map_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 362

#line 362

#line 362

#line 362

#line 362

#line 362

#line 362

#line 362

#line 362

#line 362

#line 362

#line 362
type_transition postfix_map_t tmp_t:{ file dir } postfix_map_tmp_t;
#line 362

#line 362

#line 362


#line 363
allow postfix_map_t postfix_etc_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 363
allow postfix_map_t postfix_etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 363
allow postfix_map_t postfix_etc_t:lnk_file { create read getattr setattr link unlink rename };
#line 363

allow postfix_map_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
dontaudit postfix_map_t proc_t:dir { getattr read search };
dontaudit postfix_map_t local_login_t:fd use;
allow postfix_master_t postfix_map_exec_t:file { read getattr lock execute ioctl };

#line 368
allow postfix_map_t etc_t:lnk_file read;
#line 368
allow postfix_map_t lib_t:file { read getattr lock ioctl };
#line 368

#line 368
allow postfix_map_t locale_t:dir { read getattr lock search ioctl };
#line 368
allow postfix_map_t locale_t:file { read getattr lock ioctl };
#line 368
allow postfix_map_t locale_t:lnk_file { getattr read };
#line 368

#line 368

allow postfix_map_t self:capability setgid;
allow postfix_map_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
dontaudit postfix_map_t var_t:dir search;

#line 372

#line 372

#line 372

#line 372
#
#line 372
# Allow the domain to create and use tcp sockets.
#line 372
# Other kinds of sockets must be separately authorized for use.
#line 372
allow postfix_map_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 372

#line 372
allow postfix_map_t unlabeled_t:association { sendto recvfrom };
#line 372

#line 372
#
#line 372
# Allow the domain to send or receive using any network interface.
#line 372
# netif_type is a type attribute for all network interface types.
#line 372
#
#line 372
allow postfix_map_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 372
#
#line 372
# Allow the domain to send to or receive from any node.
#line 372
# node_type is a type attribute for all node types.
#line 372
#
#line 372
allow postfix_map_t node_type:node { tcp_send rawip_send };
#line 372
allow postfix_map_t node_type:node { tcp_recv rawip_recv };
#line 372

#line 372
#
#line 372
# Allow the domain to send to or receive from any port.
#line 372
# port_type is a type attribute for all port types.
#line 372
#
#line 372

#line 372
allow postfix_map_t port_type:tcp_socket { send_msg recv_msg };
#line 372

#line 372

#line 372
# XXX Allow binding to any node type.  Remove once
#line 372
# individual rules have been added to all domains that 
#line 372
# bind sockets. 
#line 372
allow postfix_map_t node_type:tcp_socket node_bind;
#line 372
#
#line 372
# Allow access to network files including /etc/resolv.conf
#line 372
#
#line 372
allow postfix_map_t net_conf_t:file { read getattr lock ioctl };
#line 372

#line 372
allow postfix_map_t self:tcp_socket { listen accept };
#line 372

#line 372

#line 372

#line 372
#
#line 372
# Allow the domain to create and use udp sockets.
#line 372
# Other kinds of sockets must be separately authorized for use.
#line 372
allow postfix_map_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 372

#line 372
allow postfix_map_t unlabeled_t:association { sendto recvfrom };
#line 372

#line 372
#
#line 372
# Allow the domain to send or receive using any network interface.
#line 372
# netif_type is a type attribute for all network interface types.
#line 372
#
#line 372
allow postfix_map_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 372
#
#line 372
# Allow the domain to send to or receive from any node.
#line 372
# node_type is a type attribute for all node types.
#line 372
#
#line 372
allow postfix_map_t node_type:node { udp_send rawip_send };
#line 372
allow postfix_map_t node_type:node { udp_recv rawip_recv };
#line 372

#line 372
#
#line 372
# Allow the domain to send to or receive from any port.
#line 372
# port_type is a type attribute for all port types.
#line 372
#
#line 372

#line 372
allow postfix_map_t port_type:udp_socket { send_msg recv_msg };
#line 372

#line 372

#line 372
# XXX Allow binding to any node type.  Remove once
#line 372
# individual rules have been added to all domains that 
#line 372
# bind sockets. 
#line 372
allow postfix_map_t node_type:udp_socket node_bind;
#line 372
#
#line 372
# Allow access to network files including /etc/resolv.conf
#line 372
#
#line 372
allow postfix_map_t net_conf_t:file { read getattr lock ioctl };
#line 372

#line 372
allow postfix_map_t self:udp_socket { connect };
#line 372

#line 372

#line 372

allow postfix_map_t port_type:tcp_socket name_connect;
#line 1 "domains/program/postgresql.te"
#DESC Postgresql - Database server
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: postgresql
#

#################################
#
# Rules for the postgresql_t domain.
#
# postgresql_exec_t is the type of the postgresql executable.
#

#line 13

#line 13

#line 13

#line 13
type postgresql_t, domain, privlog, daemon , transitionbool;
#line 13
type postgresql_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit postgresql_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types postgresql_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow postgresql_t init_t:fd use;
#line 13
allow postgresql_t init_t:process sigchld;
#line 13
allow postgresql_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow postgresql_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow postgresql_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow postgresql_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow postgresql_t ld_so_t:file execute_no_trans;
#line 13
allow postgresql_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow postgresql_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow postgresql_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow postgresql_t texrel_shlib_t:file execmod;
#line 13
allow postgresql_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow postgresql_t device_t:dir search;
#line 13
allow postgresql_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow postgresql_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow postgresql_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow postgresql_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow postgresql_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow postgresql_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit postgresql_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit postgresql_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow postgresql_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow postgresql_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow postgresql_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow postgresql_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit postgresql_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit postgresql_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow postgresql_t sysctl_t:dir search;
#line 13
allow postgresql_t sysctl_kernel_t:dir search;
#line 13
allow postgresql_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13

#line 13
bool postgresql_disable_trans false;
#line 13
if (postgresql_disable_trans) {
#line 13

#line 13
allow initrc_t postgresql_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13

#line 13
allow sysadm_t postgresql_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13
} else {
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t postgresql_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t postgresql_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t postgresql_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t postgresql_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t postgresql_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow postgresql_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow postgresql_t initrc_t:fd use;
#line 13
allow initrc_t postgresql_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow postgresql_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow postgresql_t postgresql_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow postgresql_t postgresql_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t postgresql_exec_t:process postgresql_t;
#line 13

#line 13

#line 13
allow initrc_t postgresql_t:process { noatsecure siginh rlimitinh };
#line 13

#line 13
}
#line 13
 
#line 13
allow postgresql_t privfd:fd use;
#line 13

#line 13
allow postgresql_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
# Create pid file.
#line 13
allow postgresql_t var_t:dir { getattr search };
#line 13

#line 13
type postgresql_var_run_t, file_type, sysadmfile, pidfile;
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow postgresql_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow postgresql_t postgresql_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition postgresql_t var_run_t:file postgresql_var_run_t;
#line 13

#line 13

#line 13

#line 13
allow postgresql_t var_t:dir search;
#line 13
allow postgresql_t postgresql_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13

#line 13
allow postgresql_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13
# for daemons that look at /root on startup
#line 13
dontaudit postgresql_t sysadm_home_dir_t:dir search;
#line 13

#line 13
# for df
#line 13
allow postgresql_t fs_type:filesystem getattr;
#line 13
allow postgresql_t removable_t:filesystem getattr;
#line 13

#line 13

#line 13
allow postgresql_t etc_t:lnk_file read;
#line 13
allow postgresql_t lib_t:file { read getattr lock ioctl };
#line 13

#line 13
allow postgresql_t locale_t:dir { read getattr lock search ioctl };
#line 13
allow postgresql_t locale_t:file { read getattr lock ioctl };
#line 13
allow postgresql_t locale_t:lnk_file { getattr read };
#line 13

#line 13

#line 13

#line 13
# for localization
#line 13
allow postgresql_t lib_t:file { getattr read };
#line 13

allow initrc_t postgresql_exec_t:lnk_file read;
allow postgresql_t usr_t:file { getattr read };

allow postgresql_t postgresql_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };

#line 24


dontaudit postgresql_t sysadm_home_dir_t:dir search;

# quiet ps and killall
dontaudit postgresql_t domain:dir { getattr search };

# for currect directory of scripts
allow postgresql_t { var_spool_t cron_spool_t }:dir search;

# capability kill is for shutdown script
allow postgresql_t self:capability { kill dac_override dac_read_search chown fowner fsetid setuid setgid sys_nice sys_tty_config };
dontaudit postgresql_t self:capability sys_admin;


#line 38

#line 38
type postgresql_etc_t, file_type, sysadmfile, usercanread;
#line 38
allow postgresql_t postgresql_etc_t:file { read getattr lock ioctl };
#line 38

#line 38
allow postgresql_t postgresql_etc_t:dir { read getattr lock search ioctl };
#line 38
allow postgresql_t postgresql_etc_t:lnk_file { getattr read };
#line 38

type postgresql_db_t, file_type, sysadmfile;


#line 41

#line 41
type postgresql_log_t, file_type, sysadmfile, logfile;
#line 41

#line 41

#line 41

#line 41

#line 41
#
#line 41
# Allow the process to modify the directory.
#line 41
#
#line 41
allow postgresql_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 41

#line 41
#
#line 41
# Allow the process to create the file.
#line 41
#
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
allow postgresql_t postgresql_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41

#line 41
type_transition postgresql_t var_log_t:file postgresql_log_t;
#line 41

#line 41

#line 41

#line 41
allow postgresql_t postgresql_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 41


#line 47

#line 47
# allow crond to find /usr/lib/postgresql/bin/do.maintenance
#line 47
allow crond_t postgresql_db_t:dir search;
#line 47

#line 47

#line 47

#line 47

#line 47

#line 47
#
#line 47
# Allow the process to transition to the new domain.
#line 47
#
#line 47
allow system_crond_t postgresql_t:process transition;
#line 47

#line 47
#
#line 47
# Do not audit when glibc secure mode is enabled upon the transition.
#line 47
#
#line 47
dontaudit system_crond_t postgresql_t:process noatsecure;
#line 47

#line 47
#
#line 47
# Do not audit when signal-related state is cleared upon the transition.
#line 47
#
#line 47
dontaudit system_crond_t postgresql_t:process siginh;
#line 47

#line 47
#
#line 47
# Do not audit when resource limits are reset upon the transition.
#line 47
#
#line 47
dontaudit system_crond_t postgresql_t:process rlimitinh;
#line 47

#line 47
#
#line 47
# Allow the process to execute the program.
#line 47
# 
#line 47
allow system_crond_t postgresql_exec_t:file { read { getattr execute } };
#line 47

#line 47
#
#line 47
# Allow the process to reap the new domain.
#line 47
#
#line 47
allow postgresql_t system_crond_t:process sigchld;
#line 47

#line 47
#
#line 47
# Allow the new domain to inherit and use file 
#line 47
# descriptions from the creating process and vice versa.
#line 47
#
#line 47
allow postgresql_t system_crond_t:fd use;
#line 47
allow system_crond_t postgresql_t:fd use;
#line 47

#line 47
#
#line 47
# Allow the new domain to write back to the old domain via a pipe.
#line 47
#
#line 47
allow postgresql_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 47

#line 47
#
#line 47
# Allow the new domain to read and execute the program.
#line 47
#
#line 47
allow postgresql_t postgresql_exec_t:file { read getattr lock execute ioctl };
#line 47

#line 47
#
#line 47
# Allow the new domain to be entered via the program.
#line 47
#
#line 47
allow postgresql_t postgresql_exec_t:file entrypoint;
#line 47

#line 47
type_transition system_crond_t postgresql_exec_t:process postgresql_t;
#line 47

#line 47
allow postgresql_t crond_t:fifo_file { getattr read write ioctl };
#line 47
# a rule for privfd may make this obsolete
#line 47
allow postgresql_t crond_t:fd use;
#line 47
allow postgresql_t crond_t:process sigchld;
#line 47

#line 47



#line 49
type postgresql_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the process to modify the directory.
#line 49
#
#line 49
allow postgresql_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 49

#line 49
#
#line 49
# Allow the process to create the file.
#line 49
#
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow postgresql_t postgresql_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow postgresql_t postgresql_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow postgresql_t postgresql_tmp_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
type_transition postgresql_t tmp_t:{ dir file sock_file } postgresql_tmp_t;
#line 49

#line 49

#line 49


#line 50

#line 50

#line 50

#line 50
#
#line 50
# Allow the process to modify the directory.
#line 50
#
#line 50
allow postgresql_t tmpfs_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 50

#line 50
#
#line 50
# Allow the process to create the file.
#line 50
#
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow postgresql_t postgresql_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow postgresql_t postgresql_tmp_t:lnk_file { create read getattr setattr link unlink rename };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow postgresql_t postgresql_tmp_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow postgresql_t postgresql_tmp_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow postgresql_t postgresql_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
type_transition postgresql_t tmpfs_t:dir postgresql_tmp_t;
#line 50
type_transition postgresql_t tmpfs_t:{ file lnk_file sock_file fifo_file } postgresql_tmp_t;
#line 50

#line 50


# Use the network.

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow postgresql_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow postgresql_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow postgresql_t node_type:node { tcp_send rawip_send };
#line 53
allow postgresql_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow postgresql_t port_type:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow postgresql_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow postgresql_t self:tcp_socket { listen accept };
#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow postgresql_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow postgresql_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow postgresql_t node_type:node { tcp_send rawip_send };
#line 53
allow postgresql_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow postgresql_t port_type:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow postgresql_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow postgresql_t self:tcp_socket { connect };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use udp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow postgresql_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow postgresql_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow postgresql_t node_type:node { udp_send rawip_send };
#line 53
allow postgresql_t node_type:node { udp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow postgresql_t port_type:udp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow postgresql_t node_type:udp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow postgresql_t self:udp_socket { connect };
#line 53

#line 53

#line 53

#line 53

#line 53

allow postgresql_t self:fifo_file { getattr read write ioctl };
allow postgresql_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

#line 56
allow postgresql_t self:unix_stream_socket connectto;
#line 56

allow postgresql_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

allow postgresql_t self:shm { associate getattr setattr create destroy read write lock unix_read unix_write };

#line 71

#line 74

#line 74

#line 74
allow postgresql_t consoletype_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 74

#line 74


#line 78

#line 78

#line 78
allow postgresql_t hostname_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 78

#line 78


allow postgresql_t postgresql_port_t:tcp_socket name_bind;
allow postgresql_t auth_port_t:tcp_socket name_connect;

allow postgresql_t { proc_t self }:file { getattr read };

# Allow access to the postgresql databases

#line 86
allow postgresql_t postgresql_db_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 86
allow postgresql_t postgresql_db_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 86
allow postgresql_t postgresql_db_t:lnk_file { create read getattr setattr link unlink rename };
#line 86


#line 87

#line 87

#line 87

#line 87
#
#line 87
# Allow the process to modify the directory.
#line 87
#
#line 87
allow postgresql_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 87

#line 87
#
#line 87
# Allow the process to create the file.
#line 87
#
#line 87

#line 87

#line 87

#line 87

#line 87

#line 87
allow postgresql_t postgresql_db_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87
allow postgresql_t postgresql_db_t:lnk_file { create read getattr setattr link unlink rename };
#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87
allow postgresql_t postgresql_db_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87
allow postgresql_t postgresql_db_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87
allow postgresql_t postgresql_db_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87

#line 87
type_transition postgresql_t var_lib_t:dir postgresql_db_t;
#line 87
type_transition postgresql_t var_lib_t:{ file lnk_file sock_file fifo_file } postgresql_db_t;
#line 87

#line 87

allow postgresql_t var_lib_t:dir { getattr search };

# because postgresql start scripts are broken and put the pid file in the DB
# directory

#line 92
allow initrc_t postgresql_db_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 92
allow initrc_t postgresql_db_t:file { ioctl read getattr lock write append };
#line 92
allow initrc_t postgresql_db_t:lnk_file { getattr read };
#line 92


# read config files
allow postgresql_t { etc_t etc_runtime_t }:{ file lnk_file } { read getattr };

#line 96
allow initrc_t postgresql_etc_t:dir { read getattr lock search ioctl };
#line 96
allow initrc_t postgresql_etc_t:file { read getattr lock ioctl };
#line 96
allow initrc_t postgresql_etc_t:lnk_file { getattr read };
#line 96


allow postgresql_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };


#line 100
# Read system variables in /sys.
#line 100

#line 100
allow postgresql_t sysctl_t:dir search;
#line 100
allow postgresql_t sysctl_kernel_t:dir search;
#line 100
allow postgresql_t sysctl_kernel_t:file { getattr read };
#line 100

#line 100

#line 100


allow postgresql_t devtty_t:chr_file { read write };
allow postgresql_t devpts_t:dir search;

allow postgresql_t { bin_t sbin_t }:dir search;
allow postgresql_t { bin_t sbin_t }:lnk_file { getattr read };
allow postgresql_t postgresql_exec_t:lnk_file { getattr read };

allow postgresql_t self:sem { associate getattr setattr create destroy read write unix_read unix_write };

allow postgresql_t initrc_var_run_t:file { getattr read lock };
dontaudit postgresql_t selinux_config_t:dir search;
allow postgresql_t mail_spool_t:dir search;

#line 114
type postgresql_lock_t, file_type, sysadmfile, lockfile;
#line 114

#line 114

#line 114

#line 114

#line 114
#
#line 114
# Allow the process to modify the directory.
#line 114
#
#line 114
allow postgresql_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 114

#line 114
#
#line 114
# Allow the process to create the file.
#line 114
#
#line 114

#line 114

#line 114

#line 114

#line 114

#line 114
allow postgresql_t postgresql_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 114

#line 114

#line 114

#line 114

#line 114

#line 114

#line 114

#line 114

#line 114

#line 114
type_transition postgresql_t var_lock_t:file postgresql_lock_t;
#line 114

#line 114

#line 114


#line 115
allow postgresql_t { shell_exec_t bin_t postgresql_exec_t ls_exec_t } :file { { read getattr lock execute ioctl } execute_no_trans };
#line 115

#line 122

#line 122
# 
#line 122
# Allow httpd to work with postgresql
#line 122
#
#line 122
allow httpd_t postgresql_tmp_t:sock_file { ioctl read getattr lock write append };
#line 122

#line 122
allow httpd_t postgresql_t:unix_stream_socket connectto;
#line 122

#line 122


#line 129


dontaudit postgresql_t home_root_t:dir search;
allow postgresql_t urandom_device_t:chr_file { getattr read };

if (allow_execmem) {
allow postgresql_t self:process execmem;
}


#line 138

#line 138

#line 138
if (allow_ypbind) {
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { tcp_send rawip_send };
#line 138
allow postgresql_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t port_type:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:tcp_socket { listen accept };
#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { tcp_send rawip_send };
#line 138
allow postgresql_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t port_type:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:tcp_socket { connect };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use udp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { udp_send rawip_send };
#line 138
allow postgresql_t node_type:node { udp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t port_type:udp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:udp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:udp_socket { connect };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
allow postgresql_t var_yp_t:dir { read getattr lock search ioctl };
#line 138
allow postgresql_t var_yp_t:file { read getattr lock ioctl };
#line 138
allow postgresql_t var_yp_t:lnk_file { getattr read };
#line 138

#line 138
allow postgresql_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 138
allow postgresql_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 138
dontaudit postgresql_t self:capability net_bind_service;
#line 138
dontaudit postgresql_t reserved_port_type:tcp_socket name_connect;
#line 138
dontaudit postgresql_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 138

#line 138
} else {
#line 138
dontaudit postgresql_t var_yp_t:dir search;
#line 138
}
#line 138
 
#line 138

#line 138

#line 138
if (allow_kerberos) {
#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { tcp_send rawip_send };
#line 138
allow postgresql_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:tcp_socket { connect };
#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use udp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { udp_send rawip_send };
#line 138
allow postgresql_t node_type:node { udp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:udp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:udp_socket { connect };
#line 138

#line 138

#line 138

#line 138
allow postgresql_t kerberos_port_t:tcp_socket name_connect;
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { tcp_send rawip_send };
#line 138
allow postgresql_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:tcp_socket { connect };
#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use udp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { udp_send rawip_send };
#line 138
allow postgresql_t node_type:node { udp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t dns_port_t:udp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:udp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:udp_socket { connect };
#line 138

#line 138

#line 138

#line 138
allow postgresql_t dns_port_t:tcp_socket name_connect;
#line 138

#line 138
}
#line 138
 dontaudit postgresql_t krb5_conf_t:file write;
#line 138
allow postgresql_t krb5_conf_t:file { getattr read };
#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { tcp_send rawip_send };
#line 138
allow postgresql_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:tcp_socket { connect };
#line 138

#line 138
allow postgresql_t ldap_port_t:tcp_socket name_connect;
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { tcp_send rawip_send };
#line 138
allow postgresql_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:tcp_socket { connect };
#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use udp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow postgresql_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow postgresql_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow postgresql_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow postgresql_t node_type:node { udp_send rawip_send };
#line 138
allow postgresql_t node_type:node { udp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow postgresql_t dns_port_t:udp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow postgresql_t node_type:udp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow postgresql_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow postgresql_t self:udp_socket { connect };
#line 138

#line 138

#line 138

#line 138
allow postgresql_t dns_port_t:tcp_socket name_connect;
#line 138

#line 138

#line 138

#line 138
allow postgresql_t winbind_var_run_t:dir { getattr search };
#line 138
allow postgresql_t winbind_t:unix_stream_socket connectto;
#line 138
allow postgresql_t winbind_var_run_t:sock_file { getattr read write };
#line 138

#line 138

#line 138

#line 138
allow postgresql_t cert_t:dir { read getattr lock search ioctl };
#line 138
allow postgresql_t cert_t:file { read getattr lock ioctl };
#line 138
allow postgresql_t cert_t:lnk_file { getattr read };
#line 138

#line 138
allow postgresql_t { random_device_t urandom_device_t }:chr_file { getattr read };
#line 138
allow postgresql_t self:capability { audit_write audit_control };
#line 138
dontaudit postgresql_t shadow_t:file { getattr read };
#line 138
allow postgresql_t sbin_t:dir search;
#line 138
allow postgresql_t self:netlink_audit_socket { { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write } nlmsg_relay };
#line 138
allow postgresql_t var_lib_t:dir { read getattr lock search ioctl };
#line 138

#line 138
allow postgresql_t var_auth_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 138
allow postgresql_t var_auth_t:file { ioctl read getattr lock write append };
#line 138
allow postgresql_t var_auth_t:lnk_file { getattr read };
#line 138

#line 138

#
# postgresql has pam support
#
bool allow_postgresql_use_pam false;
if (allow_postgresql_use_pam) {

#line 144

#line 144

#line 144
#
#line 144
# Allow the process to transition to the new domain.
#line 144
#
#line 144
allow postgresql_t system_chkpwd_t:process transition;
#line 144

#line 144
#
#line 144
# Do not audit when glibc secure mode is enabled upon the transition.
#line 144
#
#line 144
dontaudit postgresql_t system_chkpwd_t:process noatsecure;
#line 144

#line 144
#
#line 144
# Do not audit when signal-related state is cleared upon the transition.
#line 144
#
#line 144
dontaudit postgresql_t system_chkpwd_t:process siginh;
#line 144

#line 144
#
#line 144
# Do not audit when resource limits are reset upon the transition.
#line 144
#
#line 144
dontaudit postgresql_t system_chkpwd_t:process rlimitinh;
#line 144

#line 144
#
#line 144
# Allow the process to execute the program.
#line 144
# 
#line 144
allow postgresql_t chkpwd_exec_t:file { read { getattr execute } };
#line 144

#line 144
#
#line 144
# Allow the process to reap the new domain.
#line 144
#
#line 144
allow system_chkpwd_t postgresql_t:process sigchld;
#line 144

#line 144
#
#line 144
# Allow the new domain to inherit and use file 
#line 144
# descriptions from the creating process and vice versa.
#line 144
#
#line 144
allow system_chkpwd_t postgresql_t:fd use;
#line 144
allow postgresql_t system_chkpwd_t:fd use;
#line 144

#line 144
#
#line 144
# Allow the new domain to write back to the old domain via a pipe.
#line 144
#
#line 144
allow system_chkpwd_t postgresql_t:fifo_file { ioctl read getattr lock write append };
#line 144

#line 144
#
#line 144
# Allow the new domain to read and execute the program.
#line 144
#
#line 144
allow system_chkpwd_t chkpwd_exec_t:file { read getattr lock execute ioctl };
#line 144

#line 144
#
#line 144
# Allow the new domain to be entered via the program.
#line 144
#
#line 144
allow system_chkpwd_t chkpwd_exec_t:file entrypoint;
#line 144

#line 144
type_transition postgresql_t chkpwd_exec_t:process system_chkpwd_t;
#line 144

}
#line 1 "domains/program/pppd.te"
#DESC PPPD - PPP daemon
#
# Author:  Russell Coker
# X-Debian-Packages: ppp
#

#################################
#
# Rules for the pppd_t domain, et al.
#
# pppd_t is the domain for the pppd program.
# pppd_exec_t is the type of the pppd executable.
# pppd_secret_t is the type of the pap and chap password files
#
bool pppd_for_user false;


#line 17

#line 17

#line 17

#line 17
type pppd_t, domain, privlog, daemon , privmail, privsysmod, nscd_client_domain, transitionbool;
#line 17
type pppd_exec_t, file_type, sysadmfile, exec_type;
#line 17
dontaudit pppd_t self:capability sys_tty_config;
#line 17

#line 17
role system_r types pppd_t;
#line 17

#line 17
# Inherit and use descriptors from init.
#line 17
allow pppd_t init_t:fd use;
#line 17
allow pppd_t init_t:process sigchld;
#line 17
allow pppd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 17

#line 17

#line 17
allow pppd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 17
allow pppd_t lib_t:lnk_file { read getattr lock ioctl };
#line 17
allow pppd_t ld_so_t:file { read getattr lock execute ioctl };
#line 17
#allow pppd_t ld_so_t:file execute_no_trans;
#line 17
allow pppd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 17
allow pppd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 17
allow pppd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 17
allow pppd_t texrel_shlib_t:file execmod;
#line 17
allow pppd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 17
allow pppd_t device_t:dir search;
#line 17
allow pppd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 17

#line 17

#line 17
allow pppd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 17
allow pppd_t { self proc_t }:lnk_file { getattr read };
#line 17

#line 17
allow pppd_t device_t:dir { read getattr lock search ioctl };
#line 17

#line 17
allow pppd_t udev_tdb_t:file { read getattr lock ioctl };
#line 17
allow pppd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 17
dontaudit pppd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 17
dontaudit pppd_t unpriv_userdomain:fd use;
#line 17

#line 17

#line 17
allow pppd_t sysfs_t:dir { read getattr lock search ioctl };
#line 17
allow pppd_t sysfs_t:file { read getattr lock ioctl };
#line 17
allow pppd_t sysfs_t:lnk_file { getattr read };
#line 17
 
#line 17

#line 17
allow pppd_t autofs_t:dir { search getattr };
#line 17

#line 17
dontaudit pppd_t { tty_device_t devpts_t }:chr_file { read write };
#line 17
dontaudit pppd_t root_t:file { getattr read };
#line 17
 
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
# Read system variables in /sys.
#line 17

#line 17
allow pppd_t sysctl_t:dir search;
#line 17
allow pppd_t sysctl_kernel_t:dir search;
#line 17
allow pppd_t sysctl_kernel_t:file { getattr read };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allows user to define a tunable to disable domain transition
#line 17
#
#line 17

#line 17
bool pppd_disable_trans false;
#line 17
if (pppd_disable_trans) {
#line 17

#line 17
allow initrc_t pppd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 17

#line 17

#line 17
allow sysadm_t pppd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 17

#line 17
} else {
#line 17
 
#line 17

#line 17

#line 17
#
#line 17
# Allow the process to transition to the new domain.
#line 17
#
#line 17
allow initrc_t pppd_t:process transition;
#line 17

#line 17
#
#line 17
# Do not audit when glibc secure mode is enabled upon the transition.
#line 17
#
#line 17
dontaudit initrc_t pppd_t:process noatsecure;
#line 17

#line 17
#
#line 17
# Do not audit when signal-related state is cleared upon the transition.
#line 17
#
#line 17
dontaudit initrc_t pppd_t:process siginh;
#line 17

#line 17
#
#line 17
# Do not audit when resource limits are reset upon the transition.
#line 17
#
#line 17
dontaudit initrc_t pppd_t:process rlimitinh;
#line 17

#line 17
#
#line 17
# Allow the process to execute the program.
#line 17
# 
#line 17
allow initrc_t pppd_exec_t:file { read { getattr execute } };
#line 17

#line 17
#
#line 17
# Allow the process to reap the new domain.
#line 17
#
#line 17
allow pppd_t initrc_t:process sigchld;
#line 17

#line 17
#
#line 17
# Allow the new domain to inherit and use file 
#line 17
# descriptions from the creating process and vice versa.
#line 17
#
#line 17
allow pppd_t initrc_t:fd use;
#line 17
allow initrc_t pppd_t:fd use;
#line 17

#line 17
#
#line 17
# Allow the new domain to write back to the old domain via a pipe.
#line 17
#
#line 17
allow pppd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 17

#line 17
#
#line 17
# Allow the new domain to read and execute the program.
#line 17
#
#line 17
allow pppd_t pppd_exec_t:file { read getattr lock execute ioctl };
#line 17

#line 17
#
#line 17
# Allow the new domain to be entered via the program.
#line 17
#
#line 17
allow pppd_t pppd_exec_t:file entrypoint;
#line 17

#line 17
type_transition initrc_t pppd_exec_t:process pppd_t;
#line 17

#line 17

#line 17
allow initrc_t pppd_t:process { noatsecure siginh rlimitinh };
#line 17

#line 17
}
#line 17
 
#line 17
allow pppd_t privfd:fd use;
#line 17

#line 17
allow pppd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 17

#line 17

#line 17
# Create pid file.
#line 17
allow pppd_t var_t:dir { getattr search };
#line 17

#line 17
type pppd_var_run_t, file_type, sysadmfile, pidfile;
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the process to modify the directory.
#line 17
#
#line 17
allow pppd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17

#line 17
#
#line 17
# Allow the process to create the file.
#line 17
#
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow pppd_t pppd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
type_transition pppd_t var_run_t:file pppd_var_run_t;
#line 17

#line 17

#line 17

#line 17
allow pppd_t var_t:dir search;
#line 17
allow pppd_t pppd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17

#line 17

#line 17
allow pppd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 17

#line 17
# for daemons that look at /root on startup
#line 17
dontaudit pppd_t sysadm_home_dir_t:dir search;
#line 17

#line 17
# for df
#line 17
allow pppd_t fs_type:filesystem getattr;
#line 17
allow pppd_t removable_t:filesystem getattr;
#line 17

#line 17

#line 17
allow pppd_t etc_t:lnk_file read;
#line 17
allow pppd_t lib_t:file { read getattr lock ioctl };
#line 17

#line 17
allow pppd_t locale_t:dir { read getattr lock search ioctl };
#line 17
allow pppd_t locale_t:file { read getattr lock ioctl };
#line 17
allow pppd_t locale_t:lnk_file { getattr read };
#line 17

#line 17

#line 17

#line 17
# for localization
#line 17
allow pppd_t lib_t:file { getattr read };
#line 17

type pppd_secret_t, file_type, sysadmfile;

# Define a separate type for /etc/ppp

#line 21

#line 21
type pppd_etc_t, file_type, sysadmfile, usercanread;
#line 21
allow pppd_t pppd_etc_t:file { read getattr lock ioctl };
#line 21

#line 21
allow pppd_t pppd_etc_t:dir { read getattr lock search ioctl };
#line 21
allow pppd_t pppd_etc_t:lnk_file { getattr read };
#line 21

# Define a separate type for writable files under /etc/ppp
type pppd_etc_rw_t, file_type, sysadmfile;
# Automatically label newly created files under /etc/ppp with this type

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the process to modify the directory.
#line 25
#
#line 25
allow pppd_t pppd_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 25

#line 25
#
#line 25
# Allow the process to create the file.
#line 25
#
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow pppd_t pppd_etc_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
type_transition pppd_t pppd_etc_t:file pppd_etc_rw_t;
#line 25

#line 25


# for SSP
allow pppd_t urandom_device_t:chr_file read;

allow pppd_t sysfs_t:dir search;


#line 32
type pppd_log_t, file_type, sysadmfile, logfile;
#line 32

#line 32

#line 32

#line 32

#line 32
#
#line 32
# Allow the process to modify the directory.
#line 32
#
#line 32
allow pppd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 32

#line 32
#
#line 32
# Allow the process to create the file.
#line 32
#
#line 32

#line 32

#line 32

#line 32

#line 32

#line 32
allow pppd_t pppd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32

#line 32
type_transition pppd_t var_log_t:file pppd_log_t;
#line 32

#line 32

#line 32


# Use the network.

#line 35

#line 35

#line 35

#line 35
#
#line 35
# Allow the domain to create and use tcp sockets.
#line 35
# Other kinds of sockets must be separately authorized for use.
#line 35
allow pppd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 35

#line 35
allow pppd_t unlabeled_t:association { sendto recvfrom };
#line 35

#line 35
#
#line 35
# Allow the domain to send or receive using any network interface.
#line 35
# netif_type is a type attribute for all network interface types.
#line 35
#
#line 35
allow pppd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 35
#
#line 35
# Allow the domain to send to or receive from any node.
#line 35
# node_type is a type attribute for all node types.
#line 35
#
#line 35
allow pppd_t node_type:node { tcp_send rawip_send };
#line 35
allow pppd_t node_type:node { tcp_recv rawip_recv };
#line 35

#line 35
#
#line 35
# Allow the domain to send to or receive from any port.
#line 35
# port_type is a type attribute for all port types.
#line 35
#
#line 35

#line 35
allow pppd_t port_type:tcp_socket { send_msg recv_msg };
#line 35

#line 35

#line 35
# XXX Allow binding to any node type.  Remove once
#line 35
# individual rules have been added to all domains that 
#line 35
# bind sockets. 
#line 35
allow pppd_t node_type:tcp_socket node_bind;
#line 35
#
#line 35
# Allow access to network files including /etc/resolv.conf
#line 35
#
#line 35
allow pppd_t net_conf_t:file { read getattr lock ioctl };
#line 35

#line 35
allow pppd_t self:tcp_socket { listen accept };
#line 35

#line 35

#line 35

#line 35
#
#line 35
# Allow the domain to create and use udp sockets.
#line 35
# Other kinds of sockets must be separately authorized for use.
#line 35
allow pppd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 35

#line 35
allow pppd_t unlabeled_t:association { sendto recvfrom };
#line 35

#line 35
#
#line 35
# Allow the domain to send or receive using any network interface.
#line 35
# netif_type is a type attribute for all network interface types.
#line 35
#
#line 35
allow pppd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 35
#
#line 35
# Allow the domain to send to or receive from any node.
#line 35
# node_type is a type attribute for all node types.
#line 35
#
#line 35
allow pppd_t node_type:node { udp_send rawip_send };
#line 35
allow pppd_t node_type:node { udp_recv rawip_recv };
#line 35

#line 35
#
#line 35
# Allow the domain to send to or receive from any port.
#line 35
# port_type is a type attribute for all port types.
#line 35
#
#line 35

#line 35
allow pppd_t port_type:udp_socket { send_msg recv_msg };
#line 35

#line 35

#line 35
# XXX Allow binding to any node type.  Remove once
#line 35
# individual rules have been added to all domains that 
#line 35
# bind sockets. 
#line 35
allow pppd_t node_type:udp_socket node_bind;
#line 35
#
#line 35
# Allow access to network files including /etc/resolv.conf
#line 35
#
#line 35
allow pppd_t net_conf_t:file { read getattr lock ioctl };
#line 35

#line 35
allow pppd_t self:udp_socket { connect };
#line 35

#line 35

#line 35


#line 36

#line 36
if (allow_ypbind) {
#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36
#
#line 36
# Allow the domain to create and use tcp sockets.
#line 36
# Other kinds of sockets must be separately authorized for use.
#line 36
allow pppd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 36

#line 36
allow pppd_t unlabeled_t:association { sendto recvfrom };
#line 36

#line 36
#
#line 36
# Allow the domain to send or receive using any network interface.
#line 36
# netif_type is a type attribute for all network interface types.
#line 36
#
#line 36
allow pppd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 36
#
#line 36
# Allow the domain to send to or receive from any node.
#line 36
# node_type is a type attribute for all node types.
#line 36
#
#line 36
allow pppd_t node_type:node { tcp_send rawip_send };
#line 36
allow pppd_t node_type:node { tcp_recv rawip_recv };
#line 36

#line 36
#
#line 36
# Allow the domain to send to or receive from any port.
#line 36
# port_type is a type attribute for all port types.
#line 36
#
#line 36

#line 36
allow pppd_t port_type:tcp_socket { send_msg recv_msg };
#line 36

#line 36

#line 36
# XXX Allow binding to any node type.  Remove once
#line 36
# individual rules have been added to all domains that 
#line 36
# bind sockets. 
#line 36
allow pppd_t node_type:tcp_socket node_bind;
#line 36
#
#line 36
# Allow access to network files including /etc/resolv.conf
#line 36
#
#line 36
allow pppd_t net_conf_t:file { read getattr lock ioctl };
#line 36

#line 36
allow pppd_t self:tcp_socket { listen accept };
#line 36

#line 36

#line 36

#line 36
#
#line 36
# Allow the domain to create and use tcp sockets.
#line 36
# Other kinds of sockets must be separately authorized for use.
#line 36
allow pppd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 36

#line 36
allow pppd_t unlabeled_t:association { sendto recvfrom };
#line 36

#line 36
#
#line 36
# Allow the domain to send or receive using any network interface.
#line 36
# netif_type is a type attribute for all network interface types.
#line 36
#
#line 36
allow pppd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 36
#
#line 36
# Allow the domain to send to or receive from any node.
#line 36
# node_type is a type attribute for all node types.
#line 36
#
#line 36
allow pppd_t node_type:node { tcp_send rawip_send };
#line 36
allow pppd_t node_type:node { tcp_recv rawip_recv };
#line 36

#line 36
#
#line 36
# Allow the domain to send to or receive from any port.
#line 36
# port_type is a type attribute for all port types.
#line 36
#
#line 36

#line 36
allow pppd_t port_type:tcp_socket { send_msg recv_msg };
#line 36

#line 36

#line 36
# XXX Allow binding to any node type.  Remove once
#line 36
# individual rules have been added to all domains that 
#line 36
# bind sockets. 
#line 36
allow pppd_t node_type:tcp_socket node_bind;
#line 36
#
#line 36
# Allow access to network files including /etc/resolv.conf
#line 36
#
#line 36
allow pppd_t net_conf_t:file { read getattr lock ioctl };
#line 36

#line 36
allow pppd_t self:tcp_socket { connect };
#line 36

#line 36

#line 36

#line 36

#line 36

#line 36
#
#line 36
# Allow the domain to create and use udp sockets.
#line 36
# Other kinds of sockets must be separately authorized for use.
#line 36
allow pppd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 36

#line 36
allow pppd_t unlabeled_t:association { sendto recvfrom };
#line 36

#line 36
#
#line 36
# Allow the domain to send or receive using any network interface.
#line 36
# netif_type is a type attribute for all network interface types.
#line 36
#
#line 36
allow pppd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 36
#
#line 36
# Allow the domain to send to or receive from any node.
#line 36
# node_type is a type attribute for all node types.
#line 36
#
#line 36
allow pppd_t node_type:node { udp_send rawip_send };
#line 36
allow pppd_t node_type:node { udp_recv rawip_recv };
#line 36

#line 36
#
#line 36
# Allow the domain to send to or receive from any port.
#line 36
# port_type is a type attribute for all port types.
#line 36
#
#line 36

#line 36
allow pppd_t port_type:udp_socket { send_msg recv_msg };
#line 36

#line 36

#line 36
# XXX Allow binding to any node type.  Remove once
#line 36
# individual rules have been added to all domains that 
#line 36
# bind sockets. 
#line 36
allow pppd_t node_type:udp_socket node_bind;
#line 36
#
#line 36
# Allow access to network files including /etc/resolv.conf
#line 36
#
#line 36
allow pppd_t net_conf_t:file { read getattr lock ioctl };
#line 36

#line 36
allow pppd_t self:udp_socket { connect };
#line 36

#line 36

#line 36

#line 36

#line 36

#line 36

#line 36
allow pppd_t var_yp_t:dir { read getattr lock search ioctl };
#line 36
allow pppd_t var_yp_t:file { read getattr lock ioctl };
#line 36
allow pppd_t var_yp_t:lnk_file { getattr read };
#line 36

#line 36
allow pppd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 36
allow pppd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 36
dontaudit pppd_t self:capability net_bind_service;
#line 36
dontaudit pppd_t reserved_port_type:tcp_socket name_connect;
#line 36
dontaudit pppd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 36

#line 36
} else {
#line 36
dontaudit pppd_t var_yp_t:dir search;
#line 36
}
#line 36
 

# Use capabilities.
allow pppd_t self:capability { net_admin setuid setgid fsetid fowner net_raw dac_override sys_module };

#line 40
type pppd_lock_t, file_type, sysadmfile, lockfile;
#line 40

#line 40

#line 40

#line 40

#line 40
#
#line 40
# Allow the process to modify the directory.
#line 40
#
#line 40
allow pppd_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 40

#line 40
#
#line 40
# Allow the process to create the file.
#line 40
#
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
allow pppd_t pppd_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40

#line 40
type_transition pppd_t var_lock_t:file pppd_lock_t;
#line 40

#line 40

#line 40


# Access secret files
allow pppd_t pppd_secret_t:file { read getattr lock ioctl };

#line 51

#line 51
allow pppd_t postfix_etc_t:dir search;
#line 51
allow pppd_t postfix_etc_t:file { read getattr lock ioctl };
#line 51
allow pppd_t postfix_master_exec_t:file { getattr read };
#line 51
allow postfix_postqueue_t pppd_t:fd use;
#line 51
allow postfix_postqueue_t pppd_t:process sigchld;
#line 51


# allow running ip-up and ip-down scripts and running chat.

#line 54
allow pppd_t { shell_exec_t bin_t sbin_t etc_t ifconfig_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 54

allow pppd_t { bin_t sbin_t }:dir search;
allow pppd_t { sbin_t bin_t }:lnk_file read;
allow ifconfig_t pppd_t:fd use;

# Access /dev/ppp.
allow pppd_t ppp_device_t:chr_file { ioctl read getattr lock write append };
allow pppd_t devtty_t:chr_file { read write };

allow pppd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow pppd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

allow pppd_t proc_t:dir search;
allow pppd_t proc_t:{ file lnk_file } { read getattr lock ioctl };
allow pppd_t proc_net_t:dir { read search };
allow pppd_t proc_net_t:file { read getattr lock ioctl };

allow pppd_t etc_runtime_t:file { read getattr lock ioctl };

allow pppd_t self:socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

allow pppd_t tty_device_t:chr_file { setattr { ioctl read getattr lock write append } };

allow pppd_t devpts_t:dir search;
allow pppd_t devpts_t:chr_file ioctl;

# for scripts
allow pppd_t self:fifo_file { ioctl read getattr lock write append };
allow pppd_t etc_t:lnk_file read;

# for ~/.ppprc - if it actually exists then you need some policy to read it
allow pppd_t { sysadm_home_dir_t home_root_t user_home_dir_type }:dir search;


#line 87
role user_r types pppd_t;
#line 87
role staff_r types pppd_t;
#line 87

if (pppd_for_user)  {
# Run pppd in pppd_t by default for user

#line 90

#line 90

#line 90
#
#line 90
# Allow the process to transition to the new domain.
#line 90
#
#line 90
allow unpriv_userdomain pppd_t:process transition;
#line 90

#line 90
#
#line 90
# Do not audit when glibc secure mode is enabled upon the transition.
#line 90
#
#line 90
dontaudit unpriv_userdomain pppd_t:process noatsecure;
#line 90

#line 90
#
#line 90
# Do not audit when signal-related state is cleared upon the transition.
#line 90
#
#line 90
dontaudit unpriv_userdomain pppd_t:process siginh;
#line 90

#line 90
#
#line 90
# Do not audit when resource limits are reset upon the transition.
#line 90
#
#line 90
dontaudit unpriv_userdomain pppd_t:process rlimitinh;
#line 90

#line 90
#
#line 90
# Allow the process to execute the program.
#line 90
# 
#line 90
allow unpriv_userdomain pppd_exec_t:file { read { getattr execute } };
#line 90

#line 90
#
#line 90
# Allow the process to reap the new domain.
#line 90
#
#line 90
allow pppd_t unpriv_userdomain:process sigchld;
#line 90

#line 90
#
#line 90
# Allow the new domain to inherit and use file 
#line 90
# descriptions from the creating process and vice versa.
#line 90
#
#line 90
allow pppd_t unpriv_userdomain:fd use;
#line 90
allow unpriv_userdomain pppd_t:fd use;
#line 90

#line 90
#
#line 90
# Allow the new domain to write back to the old domain via a pipe.
#line 90
#
#line 90
allow pppd_t unpriv_userdomain:fifo_file { ioctl read getattr lock write append };
#line 90

#line 90
#
#line 90
# Allow the new domain to read and execute the program.
#line 90
#
#line 90
allow pppd_t pppd_exec_t:file { read getattr lock execute ioctl };
#line 90

#line 90
#
#line 90
# Allow the new domain to be entered via the program.
#line 90
#
#line 90
allow pppd_t pppd_exec_t:file entrypoint;
#line 90

#line 90
type_transition unpriv_userdomain pppd_exec_t:process pppd_t;
#line 90

allow unpriv_userdomain pppd_t:process signal;
}

# for pppoe

#line 95

#line 95
# Access the pty master multiplexer.
#line 95
allow pppd_t ptmx_t:chr_file { ioctl read getattr lock write append };
#line 95

#line 95
allow pppd_t devpts_t:filesystem getattr;
#line 95

#line 95
# allow searching /dev/pts
#line 95
allow pppd_t devpts_t:dir { getattr read search };
#line 95

#line 95
# ignore old BSD pty devices
#line 95
dontaudit pppd_t bsdpty_device_t:chr_file { getattr read write };
#line 95

#line 95

#line 95
type pppd_devpts_t, file_type, sysadmfile, ptyfile ;
#line 95

#line 95
# Allow the pty to be associated with the file system.
#line 95
allow pppd_devpts_t devpts_t:filesystem associate;
#line 95

#line 95
# Label pty files with a derived type.
#line 95
type_transition pppd_t devpts_t:chr_file pppd_devpts_t;
#line 95

#line 95
# allow searching /dev/pts
#line 95
allow pppd_t devpts_t:dir { getattr read search };
#line 95

#line 95
# Read and write my pty files.
#line 95
allow pppd_t pppd_devpts_t:chr_file { setattr { ioctl read getattr lock write append } };
#line 95

#line 95

allow pppd_t self:file { read getattr };

allow pppd_t self:packet_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };


#line 100

#line 100

#line 100

#line 100
#
#line 100
# Allow the process to modify the directory.
#line 100
#
#line 100
allow pppd_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 100

#line 100
#
#line 100
# Allow the process to create the file.
#line 100
#
#line 100

#line 100

#line 100

#line 100

#line 100

#line 100
allow pppd_t net_conf_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 100

#line 100

#line 100

#line 100

#line 100

#line 100

#line 100

#line 100

#line 100

#line 100
type_transition pppd_t etc_t:file net_conf_t;
#line 100

#line 100


#line 101
type pppd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 101

#line 101

#line 101

#line 101

#line 101
#
#line 101
# Allow the process to modify the directory.
#line 101
#
#line 101
allow pppd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 101

#line 101
#
#line 101
# Allow the process to create the file.
#line 101
#
#line 101

#line 101

#line 101

#line 101

#line 101

#line 101
allow pppd_t pppd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 101

#line 101

#line 101

#line 101

#line 101

#line 101

#line 101
allow pppd_t pppd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 101

#line 101

#line 101

#line 101

#line 101

#line 101

#line 101

#line 101

#line 101

#line 101

#line 101

#line 101
type_transition pppd_t tmp_t:{ file dir } pppd_tmp_t;
#line 101

#line 101

#line 101

allow pppd_t sysctl_net_t:dir search;
allow pppd_t sysctl_net_t:file { read getattr lock ioctl };
allow pppd_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
allow pppd_t initrc_var_run_t:file { read getattr lock ioctl };
dontaudit pppd_t initrc_var_run_t:file { lock write };

# pppd needs to load kernel modules for certain modems
#line 118

#line 118
bool pppd_can_insmod false;
#line 118
typeattribute ifconfig_t privsysmod;
#line 118

#line 118
if (pppd_can_insmod && !secure_mode_insmod) {
#line 118

#line 118

#line 118

#line 118
#
#line 118
# Allow the process to transition to the new domain.
#line 118
#
#line 118
allow pppd_t insmod_t:process transition;
#line 118

#line 118
#
#line 118
# Do not audit when glibc secure mode is enabled upon the transition.
#line 118
#
#line 118
dontaudit pppd_t insmod_t:process noatsecure;
#line 118

#line 118
#
#line 118
# Do not audit when signal-related state is cleared upon the transition.
#line 118
#
#line 118
dontaudit pppd_t insmod_t:process siginh;
#line 118

#line 118
#
#line 118
# Do not audit when resource limits are reset upon the transition.
#line 118
#
#line 118
dontaudit pppd_t insmod_t:process rlimitinh;
#line 118

#line 118
#
#line 118
# Allow the process to execute the program.
#line 118
# 
#line 118
allow pppd_t insmod_exec_t:file { read { getattr execute } };
#line 118

#line 118
#
#line 118
# Allow the process to reap the new domain.
#line 118
#
#line 118
allow insmod_t pppd_t:process sigchld;
#line 118

#line 118
#
#line 118
# Allow the new domain to inherit and use file 
#line 118
# descriptions from the creating process and vice versa.
#line 118
#
#line 118
allow insmod_t pppd_t:fd use;
#line 118
allow pppd_t insmod_t:fd use;
#line 118

#line 118
#
#line 118
# Allow the new domain to write back to the old domain via a pipe.
#line 118
#
#line 118
allow insmod_t pppd_t:fifo_file { ioctl read getattr lock write append };
#line 118

#line 118
#
#line 118
# Allow the new domain to read and execute the program.
#line 118
#
#line 118
allow insmod_t insmod_exec_t:file { read getattr lock execute ioctl };
#line 118

#line 118
#
#line 118
# Allow the new domain to be entered via the program.
#line 118
#
#line 118
allow insmod_t insmod_exec_t:file entrypoint;
#line 118

#line 118
type_transition pppd_t insmod_exec_t:process insmod_t;
#line 118

#line 118
allow ifconfig_t self:capability sys_module;
#line 118
}
#line 118

#line 118



#line 120

#line 120

#line 120

#line 120
type pptp_t, domain, privlog, daemon , nscd_client_domain, transitionbool;
#line 120
type pptp_exec_t, file_type, sysadmfile, exec_type;
#line 120
dontaudit pptp_t self:capability sys_tty_config;
#line 120

#line 120
role system_r types pptp_t;
#line 120

#line 120
# Inherit and use descriptors from init.
#line 120
allow pptp_t init_t:fd use;
#line 120
allow pptp_t init_t:process sigchld;
#line 120
allow pptp_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 120

#line 120

#line 120
allow pptp_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 120
allow pptp_t lib_t:lnk_file { read getattr lock ioctl };
#line 120
allow pptp_t ld_so_t:file { read getattr lock execute ioctl };
#line 120
#allow pptp_t ld_so_t:file execute_no_trans;
#line 120
allow pptp_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 120
allow pptp_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 120
allow pptp_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 120
allow pptp_t texrel_shlib_t:file execmod;
#line 120
allow pptp_t ld_so_cache_t:file { read getattr lock ioctl };
#line 120
allow pptp_t device_t:dir search;
#line 120
allow pptp_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 120

#line 120

#line 120
allow pptp_t { self proc_t }:dir { read getattr lock search ioctl };
#line 120
allow pptp_t { self proc_t }:lnk_file { getattr read };
#line 120

#line 120
allow pptp_t device_t:dir { read getattr lock search ioctl };
#line 120

#line 120
allow pptp_t udev_tdb_t:file { read getattr lock ioctl };
#line 120
allow pptp_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 120
dontaudit pptp_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 120
dontaudit pptp_t unpriv_userdomain:fd use;
#line 120

#line 120

#line 120
allow pptp_t sysfs_t:dir { read getattr lock search ioctl };
#line 120
allow pptp_t sysfs_t:file { read getattr lock ioctl };
#line 120
allow pptp_t sysfs_t:lnk_file { getattr read };
#line 120
 
#line 120

#line 120
allow pptp_t autofs_t:dir { search getattr };
#line 120

#line 120
dontaudit pptp_t { tty_device_t devpts_t }:chr_file { read write };
#line 120
dontaudit pptp_t root_t:file { getattr read };
#line 120
 
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
# Read system variables in /sys.
#line 120

#line 120
allow pptp_t sysctl_t:dir search;
#line 120
allow pptp_t sysctl_kernel_t:dir search;
#line 120
allow pptp_t sysctl_kernel_t:file { getattr read };
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
#
#line 120
# Allows user to define a tunable to disable domain transition
#line 120
#
#line 120

#line 120
bool pptp_disable_trans false;
#line 120
if (pptp_disable_trans) {
#line 120

#line 120
allow initrc_t pptp_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 120

#line 120

#line 120
allow sysadm_t pptp_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 120

#line 120
} else {
#line 120
 
#line 120

#line 120

#line 120
#
#line 120
# Allow the process to transition to the new domain.
#line 120
#
#line 120
allow initrc_t pptp_t:process transition;
#line 120

#line 120
#
#line 120
# Do not audit when glibc secure mode is enabled upon the transition.
#line 120
#
#line 120
dontaudit initrc_t pptp_t:process noatsecure;
#line 120

#line 120
#
#line 120
# Do not audit when signal-related state is cleared upon the transition.
#line 120
#
#line 120
dontaudit initrc_t pptp_t:process siginh;
#line 120

#line 120
#
#line 120
# Do not audit when resource limits are reset upon the transition.
#line 120
#
#line 120
dontaudit initrc_t pptp_t:process rlimitinh;
#line 120

#line 120
#
#line 120
# Allow the process to execute the program.
#line 120
# 
#line 120
allow initrc_t pptp_exec_t:file { read { getattr execute } };
#line 120

#line 120
#
#line 120
# Allow the process to reap the new domain.
#line 120
#
#line 120
allow pptp_t initrc_t:process sigchld;
#line 120

#line 120
#
#line 120
# Allow the new domain to inherit and use file 
#line 120
# descriptions from the creating process and vice versa.
#line 120
#
#line 120
allow pptp_t initrc_t:fd use;
#line 120
allow initrc_t pptp_t:fd use;
#line 120

#line 120
#
#line 120
# Allow the new domain to write back to the old domain via a pipe.
#line 120
#
#line 120
allow pptp_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 120

#line 120
#
#line 120
# Allow the new domain to read and execute the program.
#line 120
#
#line 120
allow pptp_t pptp_exec_t:file { read getattr lock execute ioctl };
#line 120

#line 120
#
#line 120
# Allow the new domain to be entered via the program.
#line 120
#
#line 120
allow pptp_t pptp_exec_t:file entrypoint;
#line 120

#line 120
type_transition initrc_t pptp_exec_t:process pptp_t;
#line 120

#line 120

#line 120
allow initrc_t pptp_t:process { noatsecure siginh rlimitinh };
#line 120

#line 120
}
#line 120
 
#line 120
allow pptp_t privfd:fd use;
#line 120

#line 120
allow pptp_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 120

#line 120

#line 120
# Create pid file.
#line 120
allow pptp_t var_t:dir { getattr search };
#line 120

#line 120
type pptp_var_run_t, file_type, sysadmfile, pidfile;
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
#
#line 120
# Allow the process to modify the directory.
#line 120
#
#line 120
allow pptp_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 120

#line 120
#
#line 120
# Allow the process to create the file.
#line 120
#
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
allow pptp_t pptp_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120

#line 120
type_transition pptp_t var_run_t:file pptp_var_run_t;
#line 120

#line 120

#line 120

#line 120
allow pptp_t var_t:dir search;
#line 120
allow pptp_t pptp_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 120

#line 120

#line 120
allow pptp_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 120

#line 120
# for daemons that look at /root on startup
#line 120
dontaudit pptp_t sysadm_home_dir_t:dir search;
#line 120

#line 120
# for df
#line 120
allow pptp_t fs_type:filesystem getattr;
#line 120
allow pptp_t removable_t:filesystem getattr;
#line 120

#line 120

#line 120
allow pptp_t etc_t:lnk_file read;
#line 120
allow pptp_t lib_t:file { read getattr lock ioctl };
#line 120

#line 120
allow pptp_t locale_t:dir { read getattr lock search ioctl };
#line 120
allow pptp_t locale_t:file { read getattr lock ioctl };
#line 120
allow pptp_t locale_t:lnk_file { getattr read };
#line 120

#line 120

#line 120

#line 120
# for localization
#line 120
allow pptp_t lib_t:file { getattr read };
#line 120


#line 121

#line 121
#
#line 121
# Allow the domain to create and use tcp sockets.
#line 121
# Other kinds of sockets must be separately authorized for use.
#line 121
allow pptp_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 121

#line 121
allow pptp_t unlabeled_t:association { sendto recvfrom };
#line 121

#line 121
#
#line 121
# Allow the domain to send or receive using any network interface.
#line 121
# netif_type is a type attribute for all network interface types.
#line 121
#
#line 121
allow pptp_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 121
#
#line 121
# Allow the domain to send to or receive from any node.
#line 121
# node_type is a type attribute for all node types.
#line 121
#
#line 121
allow pptp_t node_type:node { tcp_send rawip_send };
#line 121
allow pptp_t node_type:node { tcp_recv rawip_recv };
#line 121

#line 121
#
#line 121
# Allow the domain to send to or receive from any port.
#line 121
# port_type is a type attribute for all port types.
#line 121
#
#line 121

#line 121
allow pptp_t port_type:tcp_socket { send_msg recv_msg };
#line 121

#line 121

#line 121
# XXX Allow binding to any node type.  Remove once
#line 121
# individual rules have been added to all domains that 
#line 121
# bind sockets. 
#line 121
allow pptp_t node_type:tcp_socket node_bind;
#line 121
#
#line 121
# Allow access to network files including /etc/resolv.conf
#line 121
#
#line 121
allow pptp_t net_conf_t:file { read getattr lock ioctl };
#line 121

#line 121
allow pptp_t self:tcp_socket { connect };
#line 121

allow pptp_t { reserved_port_type port_t }:tcp_socket name_connect;

#line 123
allow pptp_t hostname_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 123


#line 124

#line 124

#line 124
#
#line 124
# Allow the process to transition to the new domain.
#line 124
#
#line 124
allow pppd_t pptp_t:process transition;
#line 124

#line 124
#
#line 124
# Do not audit when glibc secure mode is enabled upon the transition.
#line 124
#
#line 124
dontaudit pppd_t pptp_t:process noatsecure;
#line 124

#line 124
#
#line 124
# Do not audit when signal-related state is cleared upon the transition.
#line 124
#
#line 124
dontaudit pppd_t pptp_t:process siginh;
#line 124

#line 124
#
#line 124
# Do not audit when resource limits are reset upon the transition.
#line 124
#
#line 124
dontaudit pppd_t pptp_t:process rlimitinh;
#line 124

#line 124
#
#line 124
# Allow the process to execute the program.
#line 124
# 
#line 124
allow pppd_t pptp_exec_t:file { read { getattr execute } };
#line 124

#line 124
#
#line 124
# Allow the process to reap the new domain.
#line 124
#
#line 124
allow pptp_t pppd_t:process sigchld;
#line 124

#line 124
#
#line 124
# Allow the new domain to inherit and use file 
#line 124
# descriptions from the creating process and vice versa.
#line 124
#
#line 124
allow pptp_t pppd_t:fd use;
#line 124
allow pppd_t pptp_t:fd use;
#line 124

#line 124
#
#line 124
# Allow the new domain to write back to the old domain via a pipe.
#line 124
#
#line 124
allow pptp_t pppd_t:fifo_file { ioctl read getattr lock write append };
#line 124

#line 124
#
#line 124
# Allow the new domain to read and execute the program.
#line 124
#
#line 124
allow pptp_t pptp_exec_t:file { read getattr lock execute ioctl };
#line 124

#line 124
#
#line 124
# Allow the new domain to be entered via the program.
#line 124
#
#line 124
allow pptp_t pptp_exec_t:file entrypoint;
#line 124

#line 124
type_transition pppd_t pptp_exec_t:process pptp_t;
#line 124

allow pptp_t self:rawip_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow pptp_t self:unix_stream_socket { connectto { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept } };
allow pptp_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

#line 128
allow pptp_t pppd_etc_rw_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 128

allow pptp_t devpts_t:dir search;
allow pptp_t pppd_devpts_t:chr_file { ioctl read getattr lock write append };
allow pptp_t devpts_t:chr_file ioctl;

#line 132
allow pptp_t pppd_etc_rw_t:dir { read getattr lock search ioctl };
#line 132
allow pptp_t pppd_etc_rw_t:file { read getattr lock ioctl };
#line 132
allow pptp_t pppd_etc_rw_t:lnk_file { getattr read };
#line 132


#line 133
allow pptp_t pppd_etc_t:dir { read getattr lock search ioctl };
#line 133
allow pptp_t pppd_etc_t:file { read getattr lock ioctl };
#line 133
allow pptp_t pppd_etc_t:lnk_file { getattr read };
#line 133

allow pppd_t pptp_t:process signal;
allow pptp_t self:capability net_raw;
allow pptp_t self:fifo_file { read write };
allow pptp_t ptmx_t:chr_file { ioctl read getattr lock write append };

#line 138
type pptp_log_t, file_type, sysadmfile, logfile;
#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the process to modify the directory.
#line 138
#
#line 138
allow pptp_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 138

#line 138
#
#line 138
# Allow the process to create the file.
#line 138
#
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
allow pptp_t pptp_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
type_transition pptp_t var_log_t:file pptp_log_t;
#line 138

#line 138

#line 138


# Fix sockets
allow pptp_t pptp_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };

# Allow pptp to append to pppd log files
allow pptp_t pppd_log_t:file append;

#line 148

#line 148
dontaudit ndc_t pppd_t:fd use;
#line 148


# Allow /etc/ppp/ip-{up,down} to run most anything
type pppd_script_exec_t, file_type, sysadmfile;

#line 152

#line 152

#line 152
#
#line 152
# Allow the process to transition to the new domain.
#line 152
#
#line 152
allow pppd_t initrc_t:process transition;
#line 152

#line 152
#
#line 152
# Do not audit when glibc secure mode is enabled upon the transition.
#line 152
#
#line 152
dontaudit pppd_t initrc_t:process noatsecure;
#line 152

#line 152
#
#line 152
# Do not audit when signal-related state is cleared upon the transition.
#line 152
#
#line 152
dontaudit pppd_t initrc_t:process siginh;
#line 152

#line 152
#
#line 152
# Do not audit when resource limits are reset upon the transition.
#line 152
#
#line 152
dontaudit pppd_t initrc_t:process rlimitinh;
#line 152

#line 152
#
#line 152
# Allow the process to execute the program.
#line 152
# 
#line 152
allow pppd_t pppd_script_exec_t:file { read { getattr execute } };
#line 152

#line 152
#
#line 152
# Allow the process to reap the new domain.
#line 152
#
#line 152
allow initrc_t pppd_t:process sigchld;
#line 152

#line 152
#
#line 152
# Allow the new domain to inherit and use file 
#line 152
# descriptions from the creating process and vice versa.
#line 152
#
#line 152
allow initrc_t pppd_t:fd use;
#line 152
allow pppd_t initrc_t:fd use;
#line 152

#line 152
#
#line 152
# Allow the new domain to write back to the old domain via a pipe.
#line 152
#
#line 152
allow initrc_t pppd_t:fifo_file { ioctl read getattr lock write append };
#line 152

#line 152
#
#line 152
# Allow the new domain to read and execute the program.
#line 152
#
#line 152
allow initrc_t pppd_script_exec_t:file { read getattr lock execute ioctl };
#line 152

#line 152
#
#line 152
# Allow the new domain to be entered via the program.
#line 152
#
#line 152
allow initrc_t pppd_script_exec_t:file entrypoint;
#line 152

#line 152
type_transition pppd_t pppd_script_exec_t:process initrc_t;
#line 152

allow pppd_t initrc_t:process noatsecure;
#line 1 "domains/program/privoxy.te"
#DESC privoxy - privacy enhancing proxy
#
# Authors: Dan Walsh <dwalsh@redhat.com>
#
#

#################################
#
# Rules for the privoxy_t domain.
#

#line 11

#line 11

#line 11

#line 11
type privoxy_t, domain, privlog, daemon , web_client_domain, transitionbool;
#line 11
type privoxy_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit privoxy_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types privoxy_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow privoxy_t init_t:fd use;
#line 11
allow privoxy_t init_t:process sigchld;
#line 11
allow privoxy_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow privoxy_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow privoxy_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow privoxy_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow privoxy_t ld_so_t:file execute_no_trans;
#line 11
allow privoxy_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow privoxy_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow privoxy_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow privoxy_t texrel_shlib_t:file execmod;
#line 11
allow privoxy_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow privoxy_t device_t:dir search;
#line 11
allow privoxy_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow privoxy_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow privoxy_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow privoxy_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow privoxy_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow privoxy_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit privoxy_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit privoxy_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow privoxy_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow privoxy_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow privoxy_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow privoxy_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit privoxy_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit privoxy_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
# Read system variables in /sys.
#line 11

#line 11
allow privoxy_t sysctl_t:dir search;
#line 11
allow privoxy_t sysctl_kernel_t:dir search;
#line 11
allow privoxy_t sysctl_kernel_t:file { getattr read };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allows user to define a tunable to disable domain transition
#line 11
#
#line 11

#line 11
bool privoxy_disable_trans false;
#line 11
if (privoxy_disable_trans) {
#line 11

#line 11
allow initrc_t privoxy_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11

#line 11
allow sysadm_t privoxy_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11
 
#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow initrc_t privoxy_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit initrc_t privoxy_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit initrc_t privoxy_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit initrc_t privoxy_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow initrc_t privoxy_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow privoxy_t initrc_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow privoxy_t initrc_t:fd use;
#line 11
allow initrc_t privoxy_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow privoxy_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow privoxy_t privoxy_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow privoxy_t privoxy_exec_t:file entrypoint;
#line 11

#line 11
type_transition initrc_t privoxy_exec_t:process privoxy_t;
#line 11

#line 11

#line 11
allow initrc_t privoxy_t:process { noatsecure siginh rlimitinh };
#line 11

#line 11
}
#line 11
 
#line 11
allow privoxy_t privfd:fd use;
#line 11

#line 11
allow privoxy_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
# Create pid file.
#line 11
allow privoxy_t var_t:dir { getattr search };
#line 11

#line 11
type privoxy_var_run_t, file_type, sysadmfile, pidfile;
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow privoxy_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow privoxy_t privoxy_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition privoxy_t var_run_t:file privoxy_var_run_t;
#line 11

#line 11

#line 11

#line 11
allow privoxy_t var_t:dir search;
#line 11
allow privoxy_t privoxy_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11

#line 11
allow privoxy_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11
# for daemons that look at /root on startup
#line 11
dontaudit privoxy_t sysadm_home_dir_t:dir search;
#line 11

#line 11
# for df
#line 11
allow privoxy_t fs_type:filesystem getattr;
#line 11
allow privoxy_t removable_t:filesystem getattr;
#line 11

#line 11

#line 11
allow privoxy_t etc_t:lnk_file read;
#line 11
allow privoxy_t lib_t:file { read getattr lock ioctl };
#line 11

#line 11
allow privoxy_t locale_t:dir { read getattr lock search ioctl };
#line 11
allow privoxy_t locale_t:file { read getattr lock ioctl };
#line 11
allow privoxy_t locale_t:lnk_file { getattr read };
#line 11

#line 11

#line 11

#line 11
# for localization
#line 11
allow privoxy_t lib_t:file { getattr read };
#line 11



#line 13

#line 13
type privoxy_log_t, file_type, sysadmfile, logfile;
#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow privoxy_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow privoxy_t privoxy_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition privoxy_t var_log_t:file privoxy_log_t;
#line 13

#line 13

#line 13

#line 13
allow privoxy_t privoxy_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 13


# Use capabilities.
allow privoxy_t self:capability net_bind_service;

# Use the network.

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow privoxy_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow privoxy_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow privoxy_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow privoxy_t node_type:node { tcp_send rawip_send };
#line 19
allow privoxy_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow privoxy_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow privoxy_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow privoxy_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow privoxy_t self:tcp_socket { listen accept };
#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow privoxy_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow privoxy_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow privoxy_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow privoxy_t node_type:node { tcp_send rawip_send };
#line 19
allow privoxy_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow privoxy_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow privoxy_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow privoxy_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow privoxy_t self:tcp_socket { connect };
#line 19

#line 19

#line 19


#line 20

#line 20
if (allow_ypbind) {
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use tcp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow privoxy_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow privoxy_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow privoxy_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow privoxy_t node_type:node { tcp_send rawip_send };
#line 20
allow privoxy_t node_type:node { tcp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow privoxy_t port_type:tcp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow privoxy_t node_type:tcp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow privoxy_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow privoxy_t self:tcp_socket { listen accept };
#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use tcp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow privoxy_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow privoxy_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow privoxy_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow privoxy_t node_type:node { tcp_send rawip_send };
#line 20
allow privoxy_t node_type:node { tcp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow privoxy_t port_type:tcp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow privoxy_t node_type:tcp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow privoxy_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow privoxy_t self:tcp_socket { connect };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the domain to create and use udp sockets.
#line 20
# Other kinds of sockets must be separately authorized for use.
#line 20
allow privoxy_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 20

#line 20
allow privoxy_t unlabeled_t:association { sendto recvfrom };
#line 20

#line 20
#
#line 20
# Allow the domain to send or receive using any network interface.
#line 20
# netif_type is a type attribute for all network interface types.
#line 20
#
#line 20
allow privoxy_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 20
#
#line 20
# Allow the domain to send to or receive from any node.
#line 20
# node_type is a type attribute for all node types.
#line 20
#
#line 20
allow privoxy_t node_type:node { udp_send rawip_send };
#line 20
allow privoxy_t node_type:node { udp_recv rawip_recv };
#line 20

#line 20
#
#line 20
# Allow the domain to send to or receive from any port.
#line 20
# port_type is a type attribute for all port types.
#line 20
#
#line 20

#line 20
allow privoxy_t port_type:udp_socket { send_msg recv_msg };
#line 20

#line 20

#line 20
# XXX Allow binding to any node type.  Remove once
#line 20
# individual rules have been added to all domains that 
#line 20
# bind sockets. 
#line 20
allow privoxy_t node_type:udp_socket node_bind;
#line 20
#
#line 20
# Allow access to network files including /etc/resolv.conf
#line 20
#
#line 20
allow privoxy_t net_conf_t:file { read getattr lock ioctl };
#line 20

#line 20
allow privoxy_t self:udp_socket { connect };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
allow privoxy_t var_yp_t:dir { read getattr lock search ioctl };
#line 20
allow privoxy_t var_yp_t:file { read getattr lock ioctl };
#line 20
allow privoxy_t var_yp_t:lnk_file { getattr read };
#line 20

#line 20
allow privoxy_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 20
allow privoxy_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 20
dontaudit privoxy_t self:capability net_bind_service;
#line 20
dontaudit privoxy_t reserved_port_type:tcp_socket name_connect;
#line 20
dontaudit privoxy_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 20

#line 20
} else {
#line 20
dontaudit privoxy_t var_yp_t:dir search;
#line 20
}
#line 20
 

#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use tcp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow privoxy_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow privoxy_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow privoxy_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow privoxy_t node_type:node { tcp_send rawip_send };
#line 21
allow privoxy_t node_type:node { tcp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow privoxy_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow privoxy_t node_type:tcp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow privoxy_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow privoxy_t self:tcp_socket { connect };
#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the domain to create and use udp sockets.
#line 21
# Other kinds of sockets must be separately authorized for use.
#line 21
allow privoxy_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 21

#line 21
allow privoxy_t unlabeled_t:association { sendto recvfrom };
#line 21

#line 21
#
#line 21
# Allow the domain to send or receive using any network interface.
#line 21
# netif_type is a type attribute for all network interface types.
#line 21
#
#line 21
allow privoxy_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 21
#
#line 21
# Allow the domain to send to or receive from any node.
#line 21
# node_type is a type attribute for all node types.
#line 21
#
#line 21
allow privoxy_t node_type:node { udp_send rawip_send };
#line 21
allow privoxy_t node_type:node { udp_recv rawip_recv };
#line 21

#line 21
#
#line 21
# Allow the domain to send to or receive from any port.
#line 21
# port_type is a type attribute for all port types.
#line 21
#
#line 21

#line 21
allow privoxy_t dns_port_t:udp_socket { send_msg recv_msg };
#line 21

#line 21

#line 21
# XXX Allow binding to any node type.  Remove once
#line 21
# individual rules have been added to all domains that 
#line 21
# bind sockets. 
#line 21
allow privoxy_t node_type:udp_socket node_bind;
#line 21
#
#line 21
# Allow access to network files including /etc/resolv.conf
#line 21
#
#line 21
allow privoxy_t net_conf_t:file { read getattr lock ioctl };
#line 21

#line 21
allow privoxy_t self:udp_socket { connect };
#line 21

#line 21

#line 21

#line 21
allow privoxy_t dns_port_t:tcp_socket name_connect;
#line 21

allow privoxy_t http_cache_port_t:tcp_socket name_bind;
allow privoxy_t etc_t:file { getattr read };
allow privoxy_t self:capability { setgid setuid };
allow privoxy_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } ;
allow privoxy_t admin_tty_type:chr_file { read write };

type privoxy_etc_rw_t, file_type, sysadmfile;
allow privoxy_t privoxy_etc_rw_t:file { ioctl read getattr lock write append };#DESC RADIUS - Radius server
#line 2 "domains/program/radius.te"
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: radiusd-cistron radiusd-livingston xtradius yardradius radiusd-freeradius
#

#################################
#
# Rules for the radiusd_t domain.
#
# radiusd_exec_t is the type of the radiusd executable.
#

#line 13

#line 13

#line 13

#line 13
type radiusd_t, domain, privlog, daemon , auth_chkpwd, transitionbool;
#line 13
type radiusd_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit radiusd_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types radiusd_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow radiusd_t init_t:fd use;
#line 13
allow radiusd_t init_t:process sigchld;
#line 13
allow radiusd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow radiusd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow radiusd_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow radiusd_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow radiusd_t ld_so_t:file execute_no_trans;
#line 13
allow radiusd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow radiusd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow radiusd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow radiusd_t texrel_shlib_t:file execmod;
#line 13
allow radiusd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow radiusd_t device_t:dir search;
#line 13
allow radiusd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow radiusd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow radiusd_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow radiusd_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow radiusd_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow radiusd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit radiusd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit radiusd_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow radiusd_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow radiusd_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow radiusd_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow radiusd_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit radiusd_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit radiusd_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow radiusd_t sysctl_t:dir search;
#line 13
allow radiusd_t sysctl_kernel_t:dir search;
#line 13
allow radiusd_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13

#line 13
bool radiusd_disable_trans false;
#line 13
if (radiusd_disable_trans) {
#line 13

#line 13
allow initrc_t radiusd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13

#line 13
allow sysadm_t radiusd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13
} else {
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t radiusd_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t radiusd_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t radiusd_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t radiusd_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t radiusd_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow radiusd_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow radiusd_t initrc_t:fd use;
#line 13
allow initrc_t radiusd_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow radiusd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow radiusd_t radiusd_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow radiusd_t radiusd_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t radiusd_exec_t:process radiusd_t;
#line 13

#line 13

#line 13
allow initrc_t radiusd_t:process { noatsecure siginh rlimitinh };
#line 13

#line 13
}
#line 13
 
#line 13
allow radiusd_t privfd:fd use;
#line 13

#line 13
allow radiusd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
# Create pid file.
#line 13
allow radiusd_t var_t:dir { getattr search };
#line 13

#line 13
type radiusd_var_run_t, file_type, sysadmfile, pidfile;
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow radiusd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow radiusd_t radiusd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition radiusd_t var_run_t:file radiusd_var_run_t;
#line 13

#line 13

#line 13

#line 13
allow radiusd_t var_t:dir search;
#line 13
allow radiusd_t radiusd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13

#line 13
allow radiusd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13
# for daemons that look at /root on startup
#line 13
dontaudit radiusd_t sysadm_home_dir_t:dir search;
#line 13

#line 13
# for df
#line 13
allow radiusd_t fs_type:filesystem getattr;
#line 13
allow radiusd_t removable_t:filesystem getattr;
#line 13

#line 13

#line 13
allow radiusd_t etc_t:lnk_file read;
#line 13
allow radiusd_t lib_t:file { read getattr lock ioctl };
#line 13

#line 13
allow radiusd_t locale_t:dir { read getattr lock search ioctl };
#line 13
allow radiusd_t locale_t:file { read getattr lock ioctl };
#line 13
allow radiusd_t locale_t:lnk_file { getattr read };
#line 13

#line 13

#line 13

#line 13
# for localization
#line 13
allow radiusd_t lib_t:file { getattr read };
#line 13



#line 15

#line 15
type radiusd_etc_t, file_type, sysadmfile, usercanread;
#line 15
allow radiusd_t radiusd_etc_t:file { read getattr lock ioctl };
#line 15

#line 15
allow radiusd_t radiusd_etc_t:dir { read getattr lock search ioctl };
#line 15
allow radiusd_t radiusd_etc_t:lnk_file { getattr read };
#line 15



#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the process to transition to the new domain.
#line 17
#
#line 17
allow system_crond_t radiusd_t:process transition;
#line 17

#line 17
#
#line 17
# Do not audit when glibc secure mode is enabled upon the transition.
#line 17
#
#line 17
dontaudit system_crond_t radiusd_t:process noatsecure;
#line 17

#line 17
#
#line 17
# Do not audit when signal-related state is cleared upon the transition.
#line 17
#
#line 17
dontaudit system_crond_t radiusd_t:process siginh;
#line 17

#line 17
#
#line 17
# Do not audit when resource limits are reset upon the transition.
#line 17
#
#line 17
dontaudit system_crond_t radiusd_t:process rlimitinh;
#line 17

#line 17
#
#line 17
# Allow the process to execute the program.
#line 17
# 
#line 17
allow system_crond_t radiusd_exec_t:file { read { getattr execute } };
#line 17

#line 17
#
#line 17
# Allow the process to reap the new domain.
#line 17
#
#line 17
allow radiusd_t system_crond_t:process sigchld;
#line 17

#line 17
#
#line 17
# Allow the new domain to inherit and use file 
#line 17
# descriptions from the creating process and vice versa.
#line 17
#
#line 17
allow radiusd_t system_crond_t:fd use;
#line 17
allow system_crond_t radiusd_t:fd use;
#line 17

#line 17
#
#line 17
# Allow the new domain to write back to the old domain via a pipe.
#line 17
#
#line 17
allow radiusd_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 17

#line 17
#
#line 17
# Allow the new domain to read and execute the program.
#line 17
#
#line 17
allow radiusd_t radiusd_exec_t:file { read getattr lock execute ioctl };
#line 17

#line 17
#
#line 17
# Allow the new domain to be entered via the program.
#line 17
#
#line 17
allow radiusd_t radiusd_exec_t:file entrypoint;
#line 17

#line 17
type_transition system_crond_t radiusd_exec_t:process radiusd_t;
#line 17

#line 17
allow radiusd_t crond_t:fifo_file { getattr read write ioctl };
#line 17
# a rule for privfd may make this obsolete
#line 17
allow radiusd_t crond_t:fd use;
#line 17
allow radiusd_t crond_t:process sigchld;
#line 17


allow radiusd_t self:process setsched;

allow radiusd_t proc_t:file { read getattr };

dontaudit radiusd_t sysadm_home_dir_t:dir getattr;

# allow pthreads to read kernel version

#line 26
# Read system variables in /sys.
#line 26

#line 26
allow radiusd_t sysctl_t:dir search;
#line 26
allow radiusd_t sysctl_kernel_t:dir search;
#line 26
allow radiusd_t sysctl_kernel_t:file { getattr read };
#line 26

#line 26

#line 26


# read config files
allow radiusd_t etc_t:dir { read getattr lock search ioctl };
allow radiusd_t { etc_t etc_runtime_t }:file { read getattr };
allow radiusd_t etc_t:lnk_file read;

# write log files

#line 34

#line 34
type radiusd_log_t, file_type, sysadmfile, logfile;
#line 34

#line 34

#line 34

#line 34

#line 34
#
#line 34
# Allow the process to modify the directory.
#line 34
#
#line 34
allow radiusd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 34

#line 34
#
#line 34
# Allow the process to create the file.
#line 34
#
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
allow radiusd_t radiusd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
type_transition radiusd_t var_log_t:file radiusd_log_t;
#line 34

#line 34

#line 34

#line 34
allow radiusd_t radiusd_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 34

allow radiusd_t radiusd_log_t:dir create;

allow radiusd_t usr_t:file { read getattr lock ioctl };


#line 39
allow radiusd_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 39


#line 40
allow radiusd_t { bin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 40

allow radiusd_t { bin_t sbin_t }:dir search;
allow radiusd_t bin_t:lnk_file read;

allow radiusd_t devtty_t:chr_file { read write };
allow radiusd_t self:fifo_file { ioctl read getattr lock write append };
# fsetid is for gzip which needs it when run from scripts
# gzip also needs chown access to preserve GID for radwtmp files
allow radiusd_t self:capability { chown dac_override fsetid kill setgid setuid sys_resource sys_tty_config };


#line 50

#line 50

#line 50

#line 50
#
#line 50
# Allow the domain to create and use tcp sockets.
#line 50
# Other kinds of sockets must be separately authorized for use.
#line 50
allow radiusd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 50

#line 50
allow radiusd_t unlabeled_t:association { sendto recvfrom };
#line 50

#line 50
#
#line 50
# Allow the domain to send or receive using any network interface.
#line 50
# netif_type is a type attribute for all network interface types.
#line 50
#
#line 50
allow radiusd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 50
#
#line 50
# Allow the domain to send to or receive from any node.
#line 50
# node_type is a type attribute for all node types.
#line 50
#
#line 50
allow radiusd_t node_type:node { tcp_send rawip_send };
#line 50
allow radiusd_t node_type:node { tcp_recv rawip_recv };
#line 50

#line 50
#
#line 50
# Allow the domain to send to or receive from any port.
#line 50
# port_type is a type attribute for all port types.
#line 50
#
#line 50

#line 50
allow radiusd_t port_type:tcp_socket { send_msg recv_msg };
#line 50

#line 50

#line 50
# XXX Allow binding to any node type.  Remove once
#line 50
# individual rules have been added to all domains that 
#line 50
# bind sockets. 
#line 50
allow radiusd_t node_type:tcp_socket node_bind;
#line 50
#
#line 50
# Allow access to network files including /etc/resolv.conf
#line 50
#
#line 50
allow radiusd_t net_conf_t:file { read getattr lock ioctl };
#line 50

#line 50
allow radiusd_t self:tcp_socket { listen accept };
#line 50

#line 50

#line 50

#line 50
#
#line 50
# Allow the domain to create and use udp sockets.
#line 50
# Other kinds of sockets must be separately authorized for use.
#line 50
allow radiusd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 50

#line 50
allow radiusd_t unlabeled_t:association { sendto recvfrom };
#line 50

#line 50
#
#line 50
# Allow the domain to send or receive using any network interface.
#line 50
# netif_type is a type attribute for all network interface types.
#line 50
#
#line 50
allow radiusd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 50
#
#line 50
# Allow the domain to send to or receive from any node.
#line 50
# node_type is a type attribute for all node types.
#line 50
#
#line 50
allow radiusd_t node_type:node { udp_send rawip_send };
#line 50
allow radiusd_t node_type:node { udp_recv rawip_recv };
#line 50

#line 50
#
#line 50
# Allow the domain to send to or receive from any port.
#line 50
# port_type is a type attribute for all port types.
#line 50
#
#line 50

#line 50
allow radiusd_t port_type:udp_socket { send_msg recv_msg };
#line 50

#line 50

#line 50
# XXX Allow binding to any node type.  Remove once
#line 50
# individual rules have been added to all domains that 
#line 50
# bind sockets. 
#line 50
allow radiusd_t node_type:udp_socket node_bind;
#line 50
#
#line 50
# Allow access to network files including /etc/resolv.conf
#line 50
#
#line 50
allow radiusd_t net_conf_t:file { read getattr lock ioctl };
#line 50

#line 50
allow radiusd_t self:udp_socket { connect };
#line 50

#line 50

#line 50


#line 51

#line 51
if (allow_ypbind) {
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
#
#line 51
# Allow the domain to create and use tcp sockets.
#line 51
# Other kinds of sockets must be separately authorized for use.
#line 51
allow radiusd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 51

#line 51
allow radiusd_t unlabeled_t:association { sendto recvfrom };
#line 51

#line 51
#
#line 51
# Allow the domain to send or receive using any network interface.
#line 51
# netif_type is a type attribute for all network interface types.
#line 51
#
#line 51
allow radiusd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 51
#
#line 51
# Allow the domain to send to or receive from any node.
#line 51
# node_type is a type attribute for all node types.
#line 51
#
#line 51
allow radiusd_t node_type:node { tcp_send rawip_send };
#line 51
allow radiusd_t node_type:node { tcp_recv rawip_recv };
#line 51

#line 51
#
#line 51
# Allow the domain to send to or receive from any port.
#line 51
# port_type is a type attribute for all port types.
#line 51
#
#line 51

#line 51
allow radiusd_t port_type:tcp_socket { send_msg recv_msg };
#line 51

#line 51

#line 51
# XXX Allow binding to any node type.  Remove once
#line 51
# individual rules have been added to all domains that 
#line 51
# bind sockets. 
#line 51
allow radiusd_t node_type:tcp_socket node_bind;
#line 51
#
#line 51
# Allow access to network files including /etc/resolv.conf
#line 51
#
#line 51
allow radiusd_t net_conf_t:file { read getattr lock ioctl };
#line 51

#line 51
allow radiusd_t self:tcp_socket { listen accept };
#line 51

#line 51

#line 51

#line 51
#
#line 51
# Allow the domain to create and use tcp sockets.
#line 51
# Other kinds of sockets must be separately authorized for use.
#line 51
allow radiusd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 51

#line 51
allow radiusd_t unlabeled_t:association { sendto recvfrom };
#line 51

#line 51
#
#line 51
# Allow the domain to send or receive using any network interface.
#line 51
# netif_type is a type attribute for all network interface types.
#line 51
#
#line 51
allow radiusd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 51
#
#line 51
# Allow the domain to send to or receive from any node.
#line 51
# node_type is a type attribute for all node types.
#line 51
#
#line 51
allow radiusd_t node_type:node { tcp_send rawip_send };
#line 51
allow radiusd_t node_type:node { tcp_recv rawip_recv };
#line 51

#line 51
#
#line 51
# Allow the domain to send to or receive from any port.
#line 51
# port_type is a type attribute for all port types.
#line 51
#
#line 51

#line 51
allow radiusd_t port_type:tcp_socket { send_msg recv_msg };
#line 51

#line 51

#line 51
# XXX Allow binding to any node type.  Remove once
#line 51
# individual rules have been added to all domains that 
#line 51
# bind sockets. 
#line 51
allow radiusd_t node_type:tcp_socket node_bind;
#line 51
#
#line 51
# Allow access to network files including /etc/resolv.conf
#line 51
#
#line 51
allow radiusd_t net_conf_t:file { read getattr lock ioctl };
#line 51

#line 51
allow radiusd_t self:tcp_socket { connect };
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
#
#line 51
# Allow the domain to create and use udp sockets.
#line 51
# Other kinds of sockets must be separately authorized for use.
#line 51
allow radiusd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 51

#line 51
allow radiusd_t unlabeled_t:association { sendto recvfrom };
#line 51

#line 51
#
#line 51
# Allow the domain to send or receive using any network interface.
#line 51
# netif_type is a type attribute for all network interface types.
#line 51
#
#line 51
allow radiusd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 51
#
#line 51
# Allow the domain to send to or receive from any node.
#line 51
# node_type is a type attribute for all node types.
#line 51
#
#line 51
allow radiusd_t node_type:node { udp_send rawip_send };
#line 51
allow radiusd_t node_type:node { udp_recv rawip_recv };
#line 51

#line 51
#
#line 51
# Allow the domain to send to or receive from any port.
#line 51
# port_type is a type attribute for all port types.
#line 51
#
#line 51

#line 51
allow radiusd_t port_type:udp_socket { send_msg recv_msg };
#line 51

#line 51

#line 51
# XXX Allow binding to any node type.  Remove once
#line 51
# individual rules have been added to all domains that 
#line 51
# bind sockets. 
#line 51
allow radiusd_t node_type:udp_socket node_bind;
#line 51
#
#line 51
# Allow access to network files including /etc/resolv.conf
#line 51
#
#line 51
allow radiusd_t net_conf_t:file { read getattr lock ioctl };
#line 51

#line 51
allow radiusd_t self:udp_socket { connect };
#line 51

#line 51

#line 51

#line 51

#line 51

#line 51

#line 51
allow radiusd_t var_yp_t:dir { read getattr lock search ioctl };
#line 51
allow radiusd_t var_yp_t:file { read getattr lock ioctl };
#line 51
allow radiusd_t var_yp_t:lnk_file { getattr read };
#line 51

#line 51
allow radiusd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 51
allow radiusd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 51
dontaudit radiusd_t self:capability net_bind_service;
#line 51
dontaudit radiusd_t reserved_port_type:tcp_socket name_connect;
#line 51
dontaudit radiusd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 51

#line 51
} else {
#line 51
dontaudit radiusd_t var_yp_t:dir search;
#line 51
}
#line 51
 
allow radiusd_t { radius_port_t radacct_port_t }:udp_socket name_bind;

# for RADIUS proxy port
allow radiusd_t port_t:udp_socket name_bind;

#line 59

#line 59

#line 59
#allow radiusd_t snmpd_t:tcp_socket { connectto recvfrom };
#line 59
#allow snmpd_t radiusd_t:tcp_socket { acceptfrom recvfrom };
#line 59
#allow snmpd_t kernel_t:tcp_socket recvfrom;
#line 59
#allow radiusd_t kernel_t:tcp_socket recvfrom;
#line 59

#line 59

#line 62


#line 63
#allow sysadm_t radiusd_t:udp_socket sendto;
#line 63
#allow radiusd_t sysadm_t:udp_socket recvfrom;
#line 63


#line 64
#allow radiusd_t sysadm_t:udp_socket sendto;
#line 64
#allow sysadm_t radiusd_t:udp_socket recvfrom;
#line 64


allow radiusd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow radiusd_t urandom_device_t:chr_file { getattr read };
#line 1 "domains/program/radvd.te"
#DESC Radv - IPv6 route advisory daemon
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: radvd
#

#################################
#
# Rules for the radvd_t domain.
#

#line 11

#line 11

#line 11

#line 11
type radvd_t, domain, privlog, daemon , transitionbool;
#line 11
type radvd_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit radvd_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types radvd_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow radvd_t init_t:fd use;
#line 11
allow radvd_t init_t:process sigchld;
#line 11
allow radvd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow radvd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow radvd_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow radvd_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow radvd_t ld_so_t:file execute_no_trans;
#line 11
allow radvd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow radvd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow radvd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow radvd_t texrel_shlib_t:file execmod;
#line 11
allow radvd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow radvd_t device_t:dir search;
#line 11
allow radvd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow radvd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow radvd_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow radvd_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow radvd_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow radvd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit radvd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit radvd_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow radvd_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow radvd_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow radvd_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow radvd_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit radvd_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit radvd_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
# Read system variables in /sys.
#line 11

#line 11
allow radvd_t sysctl_t:dir search;
#line 11
allow radvd_t sysctl_kernel_t:dir search;
#line 11
allow radvd_t sysctl_kernel_t:file { getattr read };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allows user to define a tunable to disable domain transition
#line 11
#
#line 11

#line 11
bool radvd_disable_trans false;
#line 11
if (radvd_disable_trans) {
#line 11

#line 11
allow initrc_t radvd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11

#line 11
allow sysadm_t radvd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11
 
#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow initrc_t radvd_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit initrc_t radvd_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit initrc_t radvd_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit initrc_t radvd_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow initrc_t radvd_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow radvd_t initrc_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow radvd_t initrc_t:fd use;
#line 11
allow initrc_t radvd_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow radvd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow radvd_t radvd_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow radvd_t radvd_exec_t:file entrypoint;
#line 11

#line 11
type_transition initrc_t radvd_exec_t:process radvd_t;
#line 11

#line 11

#line 11
allow initrc_t radvd_t:process { noatsecure siginh rlimitinh };
#line 11

#line 11
}
#line 11
 
#line 11
allow radvd_t privfd:fd use;
#line 11

#line 11
allow radvd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
# Create pid file.
#line 11
allow radvd_t var_t:dir { getattr search };
#line 11

#line 11
type radvd_var_run_t, file_type, sysadmfile, pidfile;
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow radvd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow radvd_t radvd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition radvd_t var_run_t:file radvd_var_run_t;
#line 11

#line 11

#line 11

#line 11
allow radvd_t var_t:dir search;
#line 11
allow radvd_t radvd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11

#line 11
allow radvd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11
# for daemons that look at /root on startup
#line 11
dontaudit radvd_t sysadm_home_dir_t:dir search;
#line 11

#line 11
# for df
#line 11
allow radvd_t fs_type:filesystem getattr;
#line 11
allow radvd_t removable_t:filesystem getattr;
#line 11

#line 11

#line 11
allow radvd_t etc_t:lnk_file read;
#line 11
allow radvd_t lib_t:file { read getattr lock ioctl };
#line 11

#line 11
allow radvd_t locale_t:dir { read getattr lock search ioctl };
#line 11
allow radvd_t locale_t:file { read getattr lock ioctl };
#line 11
allow radvd_t locale_t:lnk_file { getattr read };
#line 11

#line 11

#line 11

#line 11
# for localization
#line 11
allow radvd_t lib_t:file { getattr read };
#line 11



#line 13
type radvd_etc_t, file_type, sysadmfile, usercanread;
#line 13
allow radvd_t radvd_etc_t:file { read getattr lock ioctl };
#line 13

allow radvd_t etc_t:file { getattr read };

allow radvd_t self:{ rawip_socket unix_dgram_socket } { ioctl read getattr write setattr append bind connect getopt setopt shutdown };

allow radvd_t self:capability { setgid setuid net_raw };
allow radvd_t self:{ unix_dgram_socket rawip_socket } create;
allow radvd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };


#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the domain to create and use tcp sockets.
#line 22
# Other kinds of sockets must be separately authorized for use.
#line 22
allow radvd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 22

#line 22
allow radvd_t unlabeled_t:association { sendto recvfrom };
#line 22

#line 22
#
#line 22
# Allow the domain to send or receive using any network interface.
#line 22
# netif_type is a type attribute for all network interface types.
#line 22
#
#line 22
allow radvd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 22
#
#line 22
# Allow the domain to send to or receive from any node.
#line 22
# node_type is a type attribute for all node types.
#line 22
#
#line 22
allow radvd_t node_type:node { tcp_send rawip_send };
#line 22
allow radvd_t node_type:node { tcp_recv rawip_recv };
#line 22

#line 22
#
#line 22
# Allow the domain to send to or receive from any port.
#line 22
# port_type is a type attribute for all port types.
#line 22
#
#line 22

#line 22
allow radvd_t port_type:tcp_socket { send_msg recv_msg };
#line 22

#line 22

#line 22
# XXX Allow binding to any node type.  Remove once
#line 22
# individual rules have been added to all domains that 
#line 22
# bind sockets. 
#line 22
allow radvd_t node_type:tcp_socket node_bind;
#line 22
#
#line 22
# Allow access to network files including /etc/resolv.conf
#line 22
#
#line 22
allow radvd_t net_conf_t:file { read getattr lock ioctl };
#line 22

#line 22
allow radvd_t self:tcp_socket { listen accept };
#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the domain to create and use udp sockets.
#line 22
# Other kinds of sockets must be separately authorized for use.
#line 22
allow radvd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 22

#line 22
allow radvd_t unlabeled_t:association { sendto recvfrom };
#line 22

#line 22
#
#line 22
# Allow the domain to send or receive using any network interface.
#line 22
# netif_type is a type attribute for all network interface types.
#line 22
#
#line 22
allow radvd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 22
#
#line 22
# Allow the domain to send to or receive from any node.
#line 22
# node_type is a type attribute for all node types.
#line 22
#
#line 22
allow radvd_t node_type:node { udp_send rawip_send };
#line 22
allow radvd_t node_type:node { udp_recv rawip_recv };
#line 22

#line 22
#
#line 22
# Allow the domain to send to or receive from any port.
#line 22
# port_type is a type attribute for all port types.
#line 22
#
#line 22

#line 22
allow radvd_t port_type:udp_socket { send_msg recv_msg };
#line 22

#line 22

#line 22
# XXX Allow binding to any node type.  Remove once
#line 22
# individual rules have been added to all domains that 
#line 22
# bind sockets. 
#line 22
allow radvd_t node_type:udp_socket node_bind;
#line 22
#
#line 22
# Allow access to network files including /etc/resolv.conf
#line 22
#
#line 22
allow radvd_t net_conf_t:file { read getattr lock ioctl };
#line 22

#line 22
allow radvd_t self:udp_socket { connect };
#line 22

#line 22

#line 22


#line 23

#line 23
if (allow_ypbind) {
#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use tcp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow radvd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow radvd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow radvd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow radvd_t node_type:node { tcp_send rawip_send };
#line 23
allow radvd_t node_type:node { tcp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow radvd_t port_type:tcp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow radvd_t node_type:tcp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow radvd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow radvd_t self:tcp_socket { listen accept };
#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use tcp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow radvd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow radvd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow radvd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow radvd_t node_type:node { tcp_send rawip_send };
#line 23
allow radvd_t node_type:node { tcp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow radvd_t port_type:tcp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow radvd_t node_type:tcp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow radvd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow radvd_t self:tcp_socket { connect };
#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use udp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow radvd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow radvd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow radvd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow radvd_t node_type:node { udp_send rawip_send };
#line 23
allow radvd_t node_type:node { udp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow radvd_t port_type:udp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow radvd_t node_type:udp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow radvd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow radvd_t self:udp_socket { connect };
#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
allow radvd_t var_yp_t:dir { read getattr lock search ioctl };
#line 23
allow radvd_t var_yp_t:file { read getattr lock ioctl };
#line 23
allow radvd_t var_yp_t:lnk_file { getattr read };
#line 23

#line 23
allow radvd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 23
allow radvd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 23
dontaudit radvd_t self:capability net_bind_service;
#line 23
dontaudit radvd_t reserved_port_type:tcp_socket name_connect;
#line 23
dontaudit radvd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 23

#line 23
} else {
#line 23
dontaudit radvd_t var_yp_t:dir search;
#line 23
}
#line 23
 

allow radvd_t { proc_t proc_net_t }:dir { read getattr lock search ioctl };
allow radvd_t { proc_t proc_net_t }:file { getattr read };
allow radvd_t etc_t:lnk_file read;

allow radvd_t sysctl_net_t:file { read getattr lock ioctl };
allow radvd_t sysctl_net_t:dir { read getattr lock search ioctl };
#line 1 "domains/program/restorecon.te"
#DESC restorecon - Restore or check the context of a file
#
# Authors:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: policycoreutils
#

#################################
#
# Rules for the restorecon_t domain.
#
# restorecon_exec_t is the type of the restorecon executable.
#
# needs auth_write attribute because it has relabelfrom/relabelto
# access to shadow_t
type restorecon_t, domain, privlog, privowner, auth_write, change_context, mlsfileread, mlsfilewrite, mlsfileupgrade, mlsfiledowngrade;
type restorecon_exec_t, file_type, sysadmfile, exec_type;

role system_r types restorecon_t;
role sysadm_r types restorecon_t;
role secadm_r types restorecon_t;


#line 22
allow restorecon_t devpts_t:dir { read getattr lock search ioctl };
#line 22
allow restorecon_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 22

allow restorecon_t { tty_device_t admin_tty_type user_tty_type devtty_t }:chr_file { read write ioctl };


#line 25

#line 25

#line 25
#
#line 25
# Allow the process to transition to the new domain.
#line 25
#
#line 25
allow { initrc_t sysadm_t secadm_t } restorecon_t:process transition;
#line 25

#line 25
#
#line 25
# Do not audit when glibc secure mode is enabled upon the transition.
#line 25
#
#line 25
dontaudit { initrc_t sysadm_t secadm_t } restorecon_t:process noatsecure;
#line 25

#line 25
#
#line 25
# Do not audit when signal-related state is cleared upon the transition.
#line 25
#
#line 25
dontaudit { initrc_t sysadm_t secadm_t } restorecon_t:process siginh;
#line 25

#line 25
#
#line 25
# Do not audit when resource limits are reset upon the transition.
#line 25
#
#line 25
dontaudit { initrc_t sysadm_t secadm_t } restorecon_t:process rlimitinh;
#line 25

#line 25
#
#line 25
# Allow the process to execute the program.
#line 25
# 
#line 25
allow { initrc_t sysadm_t secadm_t } restorecon_exec_t:file { read { getattr execute } };
#line 25

#line 25
#
#line 25
# Allow the process to reap the new domain.
#line 25
#
#line 25
allow restorecon_t { initrc_t sysadm_t secadm_t }:process sigchld;
#line 25

#line 25
#
#line 25
# Allow the new domain to inherit and use file 
#line 25
# descriptions from the creating process and vice versa.
#line 25
#
#line 25
allow restorecon_t { initrc_t sysadm_t secadm_t }:fd use;
#line 25
allow { initrc_t sysadm_t secadm_t } restorecon_t:fd use;
#line 25

#line 25
#
#line 25
# Allow the new domain to write back to the old domain via a pipe.
#line 25
#
#line 25
allow restorecon_t { initrc_t sysadm_t secadm_t }:fifo_file { ioctl read getattr lock write append };
#line 25

#line 25
#
#line 25
# Allow the new domain to read and execute the program.
#line 25
#
#line 25
allow restorecon_t restorecon_exec_t:file { read getattr lock execute ioctl };
#line 25

#line 25
#
#line 25
# Allow the new domain to be entered via the program.
#line 25
#
#line 25
allow restorecon_t restorecon_exec_t:file entrypoint;
#line 25

#line 25
type_transition { initrc_t sysadm_t secadm_t } restorecon_exec_t:process restorecon_t;
#line 25

allow restorecon_t { userdomain init_t privfd }:fd use;


#line 28
allow restorecon_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 28
allow restorecon_t lib_t:lnk_file { read getattr lock ioctl };
#line 28
allow restorecon_t ld_so_t:file { read getattr lock execute ioctl };
#line 28
#allow restorecon_t ld_so_t:file execute_no_trans;
#line 28
allow restorecon_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 28
allow restorecon_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 28
allow restorecon_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 28
allow restorecon_t texrel_shlib_t:file execmod;
#line 28
allow restorecon_t ld_so_cache_t:file { read getattr lock ioctl };
#line 28
allow restorecon_t device_t:dir search;
#line 28
allow restorecon_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 28

allow restorecon_t self:capability { dac_override dac_read_search fowner };

# for upgrading glibc and other shared objects - without this the upgrade
# scripts will put things in a state such that restorecon can not be run!
allow restorecon_t lib_t:file { read execute };

# Get security policy decisions.

#line 36
# Get the selinuxfs mount point via /proc/self/mounts.
#line 36
allow restorecon_t proc_t:dir search;
#line 36
allow restorecon_t proc_t:{ file lnk_file } { getattr read };
#line 36
allow restorecon_t self:dir search;
#line 36
allow restorecon_t self:file { getattr read };
#line 36
# Access selinuxfs.
#line 36
allow restorecon_t security_t:dir { read search getattr };
#line 36
allow restorecon_t security_t:file { getattr read write };
#line 36
allow restorecon_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 36



#line 38
allow restorecon_t policy_config_t:dir { read getattr lock search ioctl };
#line 38
allow restorecon_t policy_config_t:file { read getattr lock ioctl };
#line 38
allow restorecon_t policy_config_t:lnk_file { getattr read };
#line 38


allow restorecon_t file_type:dir { read getattr lock search ioctl };
allow restorecon_t file_type:{ dir file lnk_file sock_file fifo_file } { getattr relabelfrom relabelto };
allow restorecon_t unlabeled_t:{ dir file lnk_file sock_file fifo_file chr_file blk_file } { getattr relabelfrom };
allow restorecon_t unlabeled_t:dir read;
allow restorecon_t { device_t device_type }:{ chr_file blk_file } { getattr relabelfrom relabelto };
#line 47

#line 47
allow restorecon_t tmpfs_t:{ chr_file blk_file } { { ioctl read getattr lock write append } relabelfrom relabelto };
#line 47

#line 50


allow restorecon_t ptyfile:chr_file getattr;

allow restorecon_t fs_t:filesystem getattr;

allow restorecon_t etc_runtime_t:file { getattr read };
allow restorecon_t etc_t:file { getattr read };
allow restorecon_t proc_t:file { getattr read };
dontaudit restorecon_t proc_t:lnk_file { getattr read };

allow restorecon_t device_t:file { read write };
allow restorecon_t kernel_t:fd use;
allow restorecon_t kernel_t:fifo_file { read write };
allow restorecon_t kernel_t:unix_dgram_socket { read write };

#line 65
allow restorecon_t { selinux_config_t file_context_t default_context_t } :dir { read getattr lock search ioctl };
#line 65
allow restorecon_t { selinux_config_t file_context_t default_context_t } :file { read getattr lock ioctl };
#line 65
allow restorecon_t { selinux_config_t file_context_t default_context_t } :lnk_file { getattr read };
#line 65

allow restorecon_t autofs_t:dir { read getattr lock search ioctl };
#line 69

#line 69
allow restorecon_t devpts_t:chr_file getattr;
#line 69

#line 1 "domains/program/rlogind.te"
#DESC Rlogind - Remote login daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: rsh-client rsh-redone-client
# Depends: inetd.te
#

#################################
#
# Rules for the rlogind_t domain.
#

#line 12

#line 12
type rlogind_t, domain, privlog, nscd_client_domain;
#line 12
role system_r types rlogind_t;
#line 12

#line 12
#
#line 12
# Allows user to define a tunable to disable domain transition
#line 12
#
#line 12
bool rlogind_disable_trans false;
#line 12
if (rlogind_disable_trans) {
#line 12

#line 12
allow initrc_t rlogind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12

#line 12
allow sysadm_t rlogind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12
} else {
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow inetd_t rlogind_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit inetd_t rlogind_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit inetd_t rlogind_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit inetd_t rlogind_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow inetd_t rlogind_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow rlogind_t inetd_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow rlogind_t inetd_t:fd use;
#line 12
allow inetd_t rlogind_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow rlogind_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow rlogind_t rlogind_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow rlogind_t rlogind_exec_t:file entrypoint;
#line 12

#line 12
type_transition inetd_t rlogind_exec_t:process rlogind_t;
#line 12

#line 12
allow inetd_t rlogind_t:process sigkill;
#line 12
}
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow rlogind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow rlogind_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow rlogind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow rlogind_t node_type:node { tcp_send rawip_send };
#line 12
allow rlogind_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow rlogind_t port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow rlogind_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow rlogind_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t self:tcp_socket { listen accept };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow rlogind_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow rlogind_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow rlogind_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow rlogind_t node_type:node { udp_send rawip_send };
#line 12
allow rlogind_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow rlogind_t port_type:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow rlogind_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow rlogind_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
if (allow_ypbind) {
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow rlogind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow rlogind_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow rlogind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow rlogind_t node_type:node { tcp_send rawip_send };
#line 12
allow rlogind_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow rlogind_t port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow rlogind_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow rlogind_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t self:tcp_socket { listen accept };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow rlogind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow rlogind_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow rlogind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow rlogind_t node_type:node { tcp_send rawip_send };
#line 12
allow rlogind_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow rlogind_t port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow rlogind_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow rlogind_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow rlogind_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow rlogind_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow rlogind_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow rlogind_t node_type:node { udp_send rawip_send };
#line 12
allow rlogind_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow rlogind_t port_type:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow rlogind_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow rlogind_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow rlogind_t var_yp_t:dir { read getattr lock search ioctl };
#line 12
allow rlogind_t var_yp_t:file { read getattr lock ioctl };
#line 12
allow rlogind_t var_yp_t:lnk_file { getattr read };
#line 12

#line 12
allow rlogind_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 12
allow rlogind_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 12
dontaudit rlogind_t self:capability net_bind_service;
#line 12
dontaudit rlogind_t reserved_port_type:tcp_socket name_connect;
#line 12
dontaudit rlogind_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 12

#line 12
} else {
#line 12
dontaudit rlogind_t var_yp_t:dir search;
#line 12
}
#line 12
 
#line 12

#line 12
allow rlogind_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 12
allow rlogind_t lib_t:lnk_file { read getattr lock ioctl };
#line 12
allow rlogind_t ld_so_t:file { read getattr lock execute ioctl };
#line 12
#allow rlogind_t ld_so_t:file execute_no_trans;
#line 12
allow rlogind_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 12
allow rlogind_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 12
allow rlogind_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 12
allow rlogind_t texrel_shlib_t:file execmod;
#line 12
allow rlogind_t ld_so_cache_t:file { read getattr lock ioctl };
#line 12
allow rlogind_t device_t:dir search;
#line 12
allow rlogind_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12
allow rlogind_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 12
allow rlogind_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 12
allow rlogind_t self:fifo_file { ioctl read getattr lock write append };
#line 12
type rlogind_exec_t, file_type, sysadmfile, exec_type;
#line 12

#line 12
allow rlogind_t etc_t:lnk_file read;
#line 12
allow rlogind_t lib_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t locale_t:dir { read getattr lock search ioctl };
#line 12
allow rlogind_t locale_t:file { read getattr lock ioctl };
#line 12
allow rlogind_t locale_t:lnk_file { getattr read };
#line 12

#line 12

#line 12
allow rlogind_t device_t:dir search;
#line 12
allow rlogind_t proc_t:dir search;
#line 12
allow rlogind_t proc_t:{ file lnk_file } { getattr read };
#line 12
allow rlogind_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 12
allow rlogind_t fs_t:filesystem getattr;
#line 12

#line 12

#line 12
# Read system variables in /sys.
#line 12

#line 12
allow rlogind_t sysctl_t:dir search;
#line 12
allow rlogind_t sysctl_kernel_t:dir search;
#line 12
allow rlogind_t sysctl_kernel_t:file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12
allow rlogind_t etc_t:file { getattr read };
#line 12

#line 12

#line 12
type rlogind_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to modify the directory.
#line 12
#
#line 12
allow rlogind_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12
#
#line 12
# Allow the process to create the file.
#line 12
#
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow rlogind_t rlogind_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow rlogind_t rlogind_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
type_transition rlogind_t tmp_t:{ file dir } rlogind_tmp_t;
#line 12

#line 12

#line 12

#line 12
allow rlogind_t var_t:dir search;
#line 12

#line 12
type rlogind_var_run_t, file_type, sysadmfile, pidfile;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to modify the directory.
#line 12
#
#line 12
allow rlogind_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12
#
#line 12
# Allow the process to create the file.
#line 12
#
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow rlogind_t rlogind_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
type_transition rlogind_t var_run_t:file rlogind_var_run_t;
#line 12

#line 12

#line 12

#line 12
allow rlogind_t var_t:dir search;
#line 12
allow rlogind_t rlogind_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12

#line 12
# Inherit and use descriptors from inetd.
#line 12
allow rlogind_t inetd_t:fd use;
#line 12

#line 12
# for identd
#line 12
allow rlogind_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 12
allow rlogind_t self:capability { setuid setgid };
#line 12
allow rlogind_t home_root_t:dir search;
#line 12
allow rlogind_t self:dir search;
#line 12
allow rlogind_t self:{ lnk_file file } { getattr read };
#line 12

#line 12

#line 12
if (allow_kerberos) {
#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow rlogind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow rlogind_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow rlogind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow rlogind_t node_type:node { tcp_send rawip_send };
#line 12
allow rlogind_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow rlogind_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow rlogind_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow rlogind_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow rlogind_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow rlogind_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow rlogind_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow rlogind_t node_type:node { udp_send rawip_send };
#line 12
allow rlogind_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow rlogind_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow rlogind_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow rlogind_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12
allow rlogind_t kerberos_port_t:tcp_socket name_connect;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow rlogind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow rlogind_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow rlogind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow rlogind_t node_type:node { tcp_send rawip_send };
#line 12
allow rlogind_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow rlogind_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow rlogind_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow rlogind_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow rlogind_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow rlogind_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow rlogind_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow rlogind_t node_type:node { udp_send rawip_send };
#line 12
allow rlogind_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow rlogind_t dns_port_t:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow rlogind_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow rlogind_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow rlogind_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12
allow rlogind_t dns_port_t:tcp_socket name_connect;
#line 12

#line 12
}
#line 12
 dontaudit rlogind_t krb5_conf_t:file write;
#line 12
allow rlogind_t krb5_conf_t:file { getattr read };
#line 12

#line 12
allow rlogind_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 12
# Use sockets inherited from inetd.
#line 12

#line 12
allow inetd_t rlogind_port_t:udp_socket name_bind;
#line 12
allow rlogind_t inetd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
#line 12
allow inetd_t rlogind_port_t:tcp_socket name_bind;
#line 12
allow rlogind_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 12

#line 12

#line 12

#line 12

#line 12
allow rlogind_t proc_net_t:dir { read getattr lock search ioctl };
#line 12
allow rlogind_t proc_net_t:file { read getattr lock ioctl };
#line 12
allow rlogind_t proc_net_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12
# Execute /bin/login on a new PTY
#line 12
allow rlogind_t { bin_t sbin_t }:dir search;
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow rlogind_t remote_login_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit rlogind_t remote_login_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit rlogind_t remote_login_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit rlogind_t remote_login_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow rlogind_t login_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow remote_login_t rlogind_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow remote_login_t rlogind_t:fd use;
#line 12
allow rlogind_t remote_login_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow remote_login_t rlogind_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow remote_login_t login_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow remote_login_t login_exec_t:file entrypoint;
#line 12

#line 12
type_transition rlogind_t login_exec_t:process remote_login_t;
#line 12

#line 12

#line 12

#line 12
# Access the pty master multiplexer.
#line 12
allow rlogind_t ptmx_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12
allow rlogind_t devpts_t:filesystem getattr;
#line 12

#line 12
# allow searching /dev/pts
#line 12
allow rlogind_t devpts_t:dir { getattr read search };
#line 12

#line 12
# ignore old BSD pty devices
#line 12
dontaudit rlogind_t bsdpty_device_t:chr_file { getattr read write };
#line 12

#line 12

#line 12
type rlogind_devpts_t, file_type, sysadmfile, ptyfile , server_pty, userpty_type;
#line 12

#line 12
# Allow the pty to be associated with the file system.
#line 12
allow rlogind_devpts_t devpts_t:filesystem associate;
#line 12

#line 12
# Label pty files with a derived type.
#line 12
type_transition rlogind_t devpts_t:chr_file rlogind_devpts_t;
#line 12

#line 12
# allow searching /dev/pts
#line 12
allow rlogind_t devpts_t:dir { getattr read search };
#line 12

#line 12
# Read and write my pty files.
#line 12
allow rlogind_t rlogind_devpts_t:chr_file { setattr { ioctl read getattr lock write append } };
#line 12

#line 12

#line 12
allow rlogind_t self:capability { fsetid chown fowner sys_tty_config dac_override } ;
#line 12

#line 12
# Append to /var/log/wtmp.
#line 12
allow rlogind_t var_log_t:dir search;
#line 12
allow rlogind_t wtmp_t:file { ioctl read getattr lock write append };
#line 12
allow rlogind_t initrc_var_run_t:file { ioctl read getattr lock write append };
#line 12

#line 12
# Allow reading of /etc/issue.net
#line 12
allow rlogind_t etc_runtime_t:file { read getattr lock ioctl };
#line 12

#line 12
# Allow krb5 rlogind to use fork and open /dev/tty for use
#line 12
allow rlogind_t userpty_type:chr_file setattr;
#line 12
allow rlogind_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit rlogind_t selinux_config_t:dir search;
#line 12

typeattribute rlogind_t auth_chkpwd;

#line 17


# for /usr/lib/telnetlogin

#line 20
allow rlogind_t rlogind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 20


# Use capabilities.
allow rlogind_t self:capability { net_bind_service };

# Run login in remote_login_t.
allow remote_login_t inetd_t:fd use;
allow remote_login_t inetd_t:tcp_socket { ioctl read getattr lock write append };

# Send SIGCHLD to inetd on death.
allow rlogind_t inetd_t:process sigchld;

allow rlogind_t home_dir_type:dir search;
allow rlogind_t home_type:file { getattr read };
allow rlogind_t self:file { getattr read };
allow rlogind_t default_t:dir search;
typealias rlogind_port_t alias rlogin_port_t;

#line 37
# Read system variables in /sys.
#line 37

#line 37
allow rlogind_t sysctl_t:dir search;
#line 37
allow rlogind_t sysctl_kernel_t:dir search;
#line 37
allow rlogind_t sysctl_kernel_t:file { getattr read };
#line 37

#line 37

#line 37
;
#line 40

#line 40
allow rlogind_t krb5_keytab_t:file { getattr read };
#line 40

#line 1 "domains/program/rpcd.te"
#DESC Rpcd - RPC daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#           Russell Coker <russell@coker.com.au>
# Depends: portmap.te
# X-Debian-Packages: nfs-common
#

#################################
#
# Rules for the rpcd_t and nfsd_t domain.
#
#line 41


type exports_t, file_type, sysadmfile;
dontaudit userdomain exports_t:file getattr;

# rpcd_t is the domain of rpc daemons.
# rpcd_exec_t is the type of rpc daemon programs.
#

#line 49

#line 49

#line 49

#line 49
type rpcd_t, domain, privlog, daemon , transitionbool;
#line 49
type rpcd_exec_t, file_type, sysadmfile, exec_type;
#line 49
dontaudit rpcd_t self:capability sys_tty_config;
#line 49

#line 49
role system_r types rpcd_t;
#line 49

#line 49
# Inherit and use descriptors from init.
#line 49
allow rpcd_t init_t:fd use;
#line 49
allow rpcd_t init_t:process sigchld;
#line 49
allow rpcd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 49

#line 49

#line 49
allow rpcd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 49
allow rpcd_t lib_t:lnk_file { read getattr lock ioctl };
#line 49
allow rpcd_t ld_so_t:file { read getattr lock execute ioctl };
#line 49
#allow rpcd_t ld_so_t:file execute_no_trans;
#line 49
allow rpcd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 49
allow rpcd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 49
allow rpcd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 49
allow rpcd_t texrel_shlib_t:file execmod;
#line 49
allow rpcd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 49
allow rpcd_t device_t:dir search;
#line 49
allow rpcd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 49

#line 49

#line 49
allow rpcd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 49
allow rpcd_t { self proc_t }:lnk_file { getattr read };
#line 49

#line 49
allow rpcd_t device_t:dir { read getattr lock search ioctl };
#line 49

#line 49
allow rpcd_t udev_tdb_t:file { read getattr lock ioctl };
#line 49
allow rpcd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 49
dontaudit rpcd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 49
dontaudit rpcd_t unpriv_userdomain:fd use;
#line 49

#line 49

#line 49
allow rpcd_t sysfs_t:dir { read getattr lock search ioctl };
#line 49
allow rpcd_t sysfs_t:file { read getattr lock ioctl };
#line 49
allow rpcd_t sysfs_t:lnk_file { getattr read };
#line 49
 
#line 49

#line 49
allow rpcd_t autofs_t:dir { search getattr };
#line 49

#line 49
dontaudit rpcd_t { tty_device_t devpts_t }:chr_file { read write };
#line 49
dontaudit rpcd_t root_t:file { getattr read };
#line 49
 
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
# Read system variables in /sys.
#line 49

#line 49
allow rpcd_t sysctl_t:dir search;
#line 49
allow rpcd_t sysctl_kernel_t:dir search;
#line 49
allow rpcd_t sysctl_kernel_t:file { getattr read };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allows user to define a tunable to disable domain transition
#line 49
#
#line 49

#line 49
bool rpcd_disable_trans false;
#line 49
if (rpcd_disable_trans) {
#line 49

#line 49
allow initrc_t rpcd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 49

#line 49

#line 49
allow sysadm_t rpcd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 49

#line 49
} else {
#line 49
 
#line 49

#line 49

#line 49
#
#line 49
# Allow the process to transition to the new domain.
#line 49
#
#line 49
allow initrc_t rpcd_t:process transition;
#line 49

#line 49
#
#line 49
# Do not audit when glibc secure mode is enabled upon the transition.
#line 49
#
#line 49
dontaudit initrc_t rpcd_t:process noatsecure;
#line 49

#line 49
#
#line 49
# Do not audit when signal-related state is cleared upon the transition.
#line 49
#
#line 49
dontaudit initrc_t rpcd_t:process siginh;
#line 49

#line 49
#
#line 49
# Do not audit when resource limits are reset upon the transition.
#line 49
#
#line 49
dontaudit initrc_t rpcd_t:process rlimitinh;
#line 49

#line 49
#
#line 49
# Allow the process to execute the program.
#line 49
# 
#line 49
allow initrc_t rpcd_exec_t:file { read { getattr execute } };
#line 49

#line 49
#
#line 49
# Allow the process to reap the new domain.
#line 49
#
#line 49
allow rpcd_t initrc_t:process sigchld;
#line 49

#line 49
#
#line 49
# Allow the new domain to inherit and use file 
#line 49
# descriptions from the creating process and vice versa.
#line 49
#
#line 49
allow rpcd_t initrc_t:fd use;
#line 49
allow initrc_t rpcd_t:fd use;
#line 49

#line 49
#
#line 49
# Allow the new domain to write back to the old domain via a pipe.
#line 49
#
#line 49
allow rpcd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 49

#line 49
#
#line 49
# Allow the new domain to read and execute the program.
#line 49
#
#line 49
allow rpcd_t rpcd_exec_t:file { read getattr lock execute ioctl };
#line 49

#line 49
#
#line 49
# Allow the new domain to be entered via the program.
#line 49
#
#line 49
allow rpcd_t rpcd_exec_t:file entrypoint;
#line 49

#line 49
type_transition initrc_t rpcd_exec_t:process rpcd_t;
#line 49

#line 49

#line 49
allow initrc_t rpcd_t:process { noatsecure siginh rlimitinh };
#line 49

#line 49
}
#line 49
 
#line 49
allow rpcd_t privfd:fd use;
#line 49

#line 49
allow rpcd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use tcp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow rpcd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow rpcd_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow rpcd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow rpcd_t node_type:node { tcp_send rawip_send };
#line 49
allow rpcd_t node_type:node { tcp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow rpcd_t port_type:tcp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow rpcd_t node_type:tcp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow rpcd_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow rpcd_t self:tcp_socket { listen accept };
#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use tcp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow rpcd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow rpcd_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow rpcd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow rpcd_t node_type:node { tcp_send rawip_send };
#line 49
allow rpcd_t node_type:node { tcp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow rpcd_t port_type:tcp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow rpcd_t node_type:tcp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow rpcd_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow rpcd_t self:tcp_socket { connect };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use udp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow rpcd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow rpcd_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow rpcd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow rpcd_t node_type:node { udp_send rawip_send };
#line 49
allow rpcd_t node_type:node { udp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow rpcd_t port_type:udp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow rpcd_t node_type:udp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow rpcd_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow rpcd_t self:udp_socket { connect };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow rpcd_t port_type:tcp_socket name_connect;
#line 49

#line 49

#line 49
if (allow_ypbind) {
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use tcp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow rpcd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow rpcd_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow rpcd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow rpcd_t node_type:node { tcp_send rawip_send };
#line 49
allow rpcd_t node_type:node { tcp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow rpcd_t port_type:tcp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow rpcd_t node_type:tcp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow rpcd_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow rpcd_t self:tcp_socket { listen accept };
#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use tcp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow rpcd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow rpcd_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow rpcd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow rpcd_t node_type:node { tcp_send rawip_send };
#line 49
allow rpcd_t node_type:node { tcp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow rpcd_t port_type:tcp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow rpcd_t node_type:tcp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow rpcd_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow rpcd_t self:tcp_socket { connect };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use udp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow rpcd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow rpcd_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow rpcd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow rpcd_t node_type:node { udp_send rawip_send };
#line 49
allow rpcd_t node_type:node { udp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow rpcd_t port_type:udp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow rpcd_t node_type:udp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow rpcd_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow rpcd_t self:udp_socket { connect };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow rpcd_t var_yp_t:dir { read getattr lock search ioctl };
#line 49
allow rpcd_t var_yp_t:file { read getattr lock ioctl };
#line 49
allow rpcd_t var_yp_t:lnk_file { getattr read };
#line 49

#line 49
allow rpcd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 49
allow rpcd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 49
dontaudit rpcd_t self:capability net_bind_service;
#line 49
dontaudit rpcd_t reserved_port_type:tcp_socket name_connect;
#line 49
dontaudit rpcd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 49

#line 49
} else {
#line 49
dontaudit rpcd_t var_yp_t:dir search;
#line 49
}
#line 49
 
#line 49
allow rpcd_t { etc_runtime_t etc_t }:file { getattr read };
#line 49

#line 49
allow rpcd_t etc_t:lnk_file read;
#line 49
allow rpcd_t lib_t:file { read getattr lock ioctl };
#line 49

#line 49
allow rpcd_t locale_t:dir { read getattr lock search ioctl };
#line 49
allow rpcd_t locale_t:file { read getattr lock ioctl };
#line 49
allow rpcd_t locale_t:lnk_file { getattr read };
#line 49

#line 49

#line 49
allow rpcd_t self:capability net_bind_service;
#line 49
dontaudit rpcd_t self:capability net_admin;
#line 49

#line 49
allow rpcd_t var_t:dir { getattr search };
#line 49
allow rpcd_t var_lib_t:dir search;
#line 49
allow rpcd_t var_lib_nfs_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 49
allow rpcd_t var_lib_nfs_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 49
# do not log when it tries to bind to a port belonging to another domain
#line 49
dontaudit rpcd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 49
allow rpcd_t reserved_port_t:{ udp_socket tcp_socket } name_bind;
#line 49
allow rpcd_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 49
allow rpcd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 49
allow rpcd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 49
# bind to arbitary unused ports
#line 49
allow rpcd_t port_t:{ tcp_socket udp_socket } name_bind;
#line 49
allow rpcd_t sysctl_rpc_t:dir search;
#line 49
allow rpcd_t sysctl_rpc_t:file { ioctl read getattr lock write append };
#line 49


#line 50
type rpcd_var_run_t, file_type, sysadmfile, pidfile;
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
#
#line 50
# Allow the process to modify the directory.
#line 50
#
#line 50
allow rpcd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 50

#line 50
#
#line 50
# Allow the process to create the file.
#line 50
#
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
allow rpcd_t rpcd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50

#line 50
type_transition rpcd_t var_run_t:file rpcd_var_run_t;
#line 50

#line 50

#line 50

#line 50
allow rpcd_t var_t:dir search;
#line 50
allow rpcd_t rpcd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 50

allow rpcd_t rpcd_var_run_t:dir setattr;

# for rpc.rquotad
allow rpcd_t sysctl_t:dir { read getattr lock search ioctl };
allow rpcd_t self:fifo_file { ioctl read getattr lock write append };

# rpcd_t needs to talk to the portmap_t domain

#line 58
#allow rpcd_t portmap_t:udp_socket sendto;
#line 58
#allow portmap_t rpcd_t:udp_socket recvfrom;
#line 58


allow initrc_t exports_t:file { read getattr lock ioctl };
#line 65

#line 65
allow rpcd_t self:capability { chown dac_override setgid setuid };
#line 65
# for /etc/rc.d/init.d/nfs to create /etc/exports
#line 65
allow initrc_t exports_t:file write;
#line 65


allow rpcd_t self:file { getattr read };

# nfs kernel server needs kernel UDP access.  It is less risky and painful
# to just give it everything.

#line 71

#line 71

#line 71

#line 71
#
#line 71
# Allow the domain to create and use tcp sockets.
#line 71
# Other kinds of sockets must be separately authorized for use.
#line 71
allow kernel_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 71

#line 71
allow kernel_t unlabeled_t:association { sendto recvfrom };
#line 71

#line 71
#
#line 71
# Allow the domain to send or receive using any network interface.
#line 71
# netif_type is a type attribute for all network interface types.
#line 71
#
#line 71
allow kernel_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 71
#
#line 71
# Allow the domain to send to or receive from any node.
#line 71
# node_type is a type attribute for all node types.
#line 71
#
#line 71
allow kernel_t node_type:node { tcp_send rawip_send };
#line 71
allow kernel_t node_type:node { tcp_recv rawip_recv };
#line 71

#line 71
#
#line 71
# Allow the domain to send to or receive from any port.
#line 71
# port_type is a type attribute for all port types.
#line 71
#
#line 71

#line 71
allow kernel_t port_type:tcp_socket { send_msg recv_msg };
#line 71

#line 71

#line 71
# XXX Allow binding to any node type.  Remove once
#line 71
# individual rules have been added to all domains that 
#line 71
# bind sockets. 
#line 71
allow kernel_t node_type:tcp_socket node_bind;
#line 71
#
#line 71
# Allow access to network files including /etc/resolv.conf
#line 71
#
#line 71
allow kernel_t net_conf_t:file { read getattr lock ioctl };
#line 71

#line 71
allow kernel_t self:tcp_socket { listen accept };
#line 71

#line 71

#line 71

#line 71
#
#line 71
# Allow the domain to create and use udp sockets.
#line 71
# Other kinds of sockets must be separately authorized for use.
#line 71
allow kernel_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 71

#line 71
allow kernel_t unlabeled_t:association { sendto recvfrom };
#line 71

#line 71
#
#line 71
# Allow the domain to send or receive using any network interface.
#line 71
# netif_type is a type attribute for all network interface types.
#line 71
#
#line 71
allow kernel_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 71
#
#line 71
# Allow the domain to send to or receive from any node.
#line 71
# node_type is a type attribute for all node types.
#line 71
#
#line 71
allow kernel_t node_type:node { udp_send rawip_send };
#line 71
allow kernel_t node_type:node { udp_recv rawip_recv };
#line 71

#line 71
#
#line 71
# Allow the domain to send to or receive from any port.
#line 71
# port_type is a type attribute for all port types.
#line 71
#
#line 71

#line 71
allow kernel_t port_type:udp_socket { send_msg recv_msg };
#line 71

#line 71

#line 71
# XXX Allow binding to any node type.  Remove once
#line 71
# individual rules have been added to all domains that 
#line 71
# bind sockets. 
#line 71
allow kernel_t node_type:udp_socket node_bind;
#line 71
#
#line 71
# Allow access to network files including /etc/resolv.conf
#line 71
#
#line 71
allow kernel_t net_conf_t:file { read getattr lock ioctl };
#line 71

#line 71
allow kernel_t self:udp_socket { connect };
#line 71

#line 71

#line 71

#can_udp_send(kernel_t, rpcd_t)
#can_udp_send(rpcd_t, kernel_t)


#line 75

#line 75

#line 75

#line 75
type nfsd_t, domain, privlog, daemon , transitionbool;
#line 75
type nfsd_exec_t, file_type, sysadmfile, exec_type;
#line 75
dontaudit nfsd_t self:capability sys_tty_config;
#line 75

#line 75
role system_r types nfsd_t;
#line 75

#line 75
# Inherit and use descriptors from init.
#line 75
allow nfsd_t init_t:fd use;
#line 75
allow nfsd_t init_t:process sigchld;
#line 75
allow nfsd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 75

#line 75

#line 75
allow nfsd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 75
allow nfsd_t lib_t:lnk_file { read getattr lock ioctl };
#line 75
allow nfsd_t ld_so_t:file { read getattr lock execute ioctl };
#line 75
#allow nfsd_t ld_so_t:file execute_no_trans;
#line 75
allow nfsd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 75
allow nfsd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 75
allow nfsd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 75
allow nfsd_t texrel_shlib_t:file execmod;
#line 75
allow nfsd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 75
allow nfsd_t device_t:dir search;
#line 75
allow nfsd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 75

#line 75

#line 75
allow nfsd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 75
allow nfsd_t { self proc_t }:lnk_file { getattr read };
#line 75

#line 75
allow nfsd_t device_t:dir { read getattr lock search ioctl };
#line 75

#line 75
allow nfsd_t udev_tdb_t:file { read getattr lock ioctl };
#line 75
allow nfsd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 75
dontaudit nfsd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 75
dontaudit nfsd_t unpriv_userdomain:fd use;
#line 75

#line 75

#line 75
allow nfsd_t sysfs_t:dir { read getattr lock search ioctl };
#line 75
allow nfsd_t sysfs_t:file { read getattr lock ioctl };
#line 75
allow nfsd_t sysfs_t:lnk_file { getattr read };
#line 75
 
#line 75

#line 75
allow nfsd_t autofs_t:dir { search getattr };
#line 75

#line 75
dontaudit nfsd_t { tty_device_t devpts_t }:chr_file { read write };
#line 75
dontaudit nfsd_t root_t:file { getattr read };
#line 75
 
#line 75

#line 75

#line 75

#line 75

#line 75

#line 75

#line 75
# Read system variables in /sys.
#line 75

#line 75
allow nfsd_t sysctl_t:dir search;
#line 75
allow nfsd_t sysctl_kernel_t:dir search;
#line 75
allow nfsd_t sysctl_kernel_t:file { getattr read };
#line 75

#line 75

#line 75

#line 75

#line 75

#line 75

#line 75
#
#line 75
# Allows user to define a tunable to disable domain transition
#line 75
#
#line 75

#line 75
bool nfsd_disable_trans false;
#line 75
if (nfsd_disable_trans) {
#line 75

#line 75
allow initrc_t nfsd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 75

#line 75

#line 75
allow sysadm_t nfsd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 75

#line 75
} else {
#line 75
 
#line 75

#line 75

#line 75
#
#line 75
# Allow the process to transition to the new domain.
#line 75
#
#line 75
allow initrc_t nfsd_t:process transition;
#line 75

#line 75
#
#line 75
# Do not audit when glibc secure mode is enabled upon the transition.
#line 75
#
#line 75
dontaudit initrc_t nfsd_t:process noatsecure;
#line 75

#line 75
#
#line 75
# Do not audit when signal-related state is cleared upon the transition.
#line 75
#
#line 75
dontaudit initrc_t nfsd_t:process siginh;
#line 75

#line 75
#
#line 75
# Do not audit when resource limits are reset upon the transition.
#line 75
#
#line 75
dontaudit initrc_t nfsd_t:process rlimitinh;
#line 75

#line 75
#
#line 75
# Allow the process to execute the program.
#line 75
# 
#line 75
allow initrc_t nfsd_exec_t:file { read { getattr execute } };
#line 75

#line 75
#
#line 75
# Allow the process to reap the new domain.
#line 75
#
#line 75
allow nfsd_t initrc_t:process sigchld;
#line 75

#line 75
#
#line 75
# Allow the new domain to inherit and use file 
#line 75
# descriptions from the creating process and vice versa.
#line 75
#
#line 75
allow nfsd_t initrc_t:fd use;
#line 75
allow initrc_t nfsd_t:fd use;
#line 75

#line 75
#
#line 75
# Allow the new domain to write back to the old domain via a pipe.
#line 75
#
#line 75
allow nfsd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 75

#line 75
#
#line 75
# Allow the new domain to read and execute the program.
#line 75
#
#line 75
allow nfsd_t nfsd_exec_t:file { read getattr lock execute ioctl };
#line 75

#line 75
#
#line 75
# Allow the new domain to be entered via the program.
#line 75
#
#line 75
allow nfsd_t nfsd_exec_t:file entrypoint;
#line 75

#line 75
type_transition initrc_t nfsd_exec_t:process nfsd_t;
#line 75

#line 75

#line 75
allow initrc_t nfsd_t:process { noatsecure siginh rlimitinh };
#line 75

#line 75
}
#line 75
 
#line 75
allow nfsd_t privfd:fd use;
#line 75

#line 75
allow nfsd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 75

#line 75

#line 75

#line 75

#line 75

#line 75

#line 75

#line 75

#line 75
#
#line 75
# Allow the domain to create and use tcp sockets.
#line 75
# Other kinds of sockets must be separately authorized for use.
#line 75
allow nfsd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 75

#line 75
allow nfsd_t unlabeled_t:association { sendto recvfrom };
#line 75

#line 75
#
#line 75
# Allow the domain to send or receive using any network interface.
#line 75
# netif_type is a type attribute for all network interface types.
#line 75
#
#line 75
allow nfsd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 75
#
#line 75
# Allow the domain to send to or receive from any node.
#line 75
# node_type is a type attribute for all node types.
#line 75
#
#line 75
allow nfsd_t node_type:node { tcp_send rawip_send };
#line 75
allow nfsd_t node_type:node { tcp_recv rawip_recv };
#line 75

#line 75
#
#line 75
# Allow the domain to send to or receive from any port.
#line 75
# port_type is a type attribute for all port types.
#line 75
#
#line 75

#line 75
allow nfsd_t port_type:tcp_socket { send_msg recv_msg };
#line 75

#line 75

#line 75
# XXX Allow binding to any node type.  Remove once
#line 75
# individual rules have been added to all domains that 
#line 75
# bind sockets. 
#line 75
allow nfsd_t node_type:tcp_socket node_bind;
#line 75
#
#line 75
# Allow access to network files including /etc/resolv.conf
#line 75
#
#line 75
allow nfsd_t net_conf_t:file { read getattr lock ioctl };
#line 75

#line 75
allow nfsd_t self:tcp_socket { listen accept };
#line 75

#line 75

#line 75

#line 75
#
#line 75
# Allow the domain to create and use tcp sockets.
#line 75
# Other kinds of sockets must be separately authorized for use.
#line 75
allow nfsd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 75

#line 75
allow nfsd_t unlabeled_t:association { sendto recvfrom };
#line 75

#line 75
#
#line 75
# Allow the domain to send or receive using any network interface.
#line 75
# netif_type is a type attribute for all network interface types.
#line 75
#
#line 75
allow nfsd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 75
#
#line 75
# Allow the domain to send to or receive from any node.
#line 75
# node_type is a type attribute for all node types.
#line 75
#
#line 75
allow nfsd_t node_type:node { tcp_send rawip_send };
#line 75
allow nfsd_t node_type:node { tcp_recv rawip_recv };
#line 75

#line 75
#
#line 75
# Allow the domain to send to or receive from any port.
#line 75
# port_type is a type attribute for all port types.
#line 75
#
#line 75

#line 75
allow nfsd_t port_type:tcp_socket { send_msg recv_msg };
#line 75

#line 75

#line 75
# XXX Allow binding to any node type.  Remove once
#line 75
# individual rules have been added to all domains that 
#line 75
# bind sockets. 
#line 75
allow nfsd_t node_type:tcp_socket node_bind;
#line 75
#
#line 75
# Allow access to network files including /etc/resolv.conf
#line 75
#
#line 75
allow nfsd_t net_conf_t:file { read getattr lock ioctl };
#line 75

#line 75
allow nfsd_t self:tcp_socket { connect };
#line 75

#line 75

#line 75

#line 75

#line 75

#line 75
#
#line 75
# Allow the domain to create and use udp sockets.
#line 75
# Other kinds of sockets must be separately authorized for use.
#line 75
allow nfsd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 75

#line 75
allow nfsd_t unlabeled_t:association { sendto recvfrom };
#line 75

#line 75
#
#line 75
# Allow the domain to send or receive using any network interface.
#line 75
# netif_type is a type attribute for all network interface types.
#line 75
#
#line 75
allow nfsd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 75
#
#line 75
# Allow the domain to send to or receive from any node.
#line 75
# node_type is a type attribute for all node types.
#line 75
#
#line 75
allow nfsd_t node_type:node { udp_send rawip_send };
#line 75
allow nfsd_t node_type:node { udp_recv rawip_recv };
#line 75

#line 75
#
#line 75
# Allow the domain to send to or receive from any port.
#line 75
# port_type is a type attribute for all port types.
#line 75
#
#line 75

#line 75
allow nfsd_t port_type:udp_socket { send_msg recv_msg };
#line 75

#line 75

#line 75
# XXX Allow binding to any node type.  Remove once
#line 75
# individual rules have been added to all domains that 
#line 75
# bind sockets. 
#line 75
allow nfsd_t node_type:udp_socket node_bind;
#line 75
#
#line 75
# Allow access to network files including /etc/resolv.conf
#line 75
#
#line 75
allow nfsd_t net_conf_t:file { read getattr lock ioctl };
#line 75

#line 75
allow nfsd_t self:udp_socket { connect };
#line 75

#line 75

#line 75

#line 75

#line 75

#line 75
allow nfsd_t port_type:tcp_socket name_connect;
#line 75

#line 75

#line 75
if (allow_ypbind) {
#line 75

#line 75

#line 75

#line 75

#line 75

#line 75

#line 75

#line 75
#
#line 75
# Allow the domain to create and use tcp sockets.
#line 75
# Other kinds of sockets must be separately authorized for use.
#line 75
allow nfsd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 75

#line 75
allow nfsd_t unlabeled_t:association { sendto recvfrom };
#line 75

#line 75
#
#line 75
# Allow the domain to send or receive using any network interface.
#line 75
# netif_type is a type attribute for all network interface types.
#line 75
#
#line 75
allow nfsd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 75
#
#line 75
# Allow the domain to send to or receive from any node.
#line 75
# node_type is a type attribute for all node types.
#line 75
#
#line 75
allow nfsd_t node_type:node { tcp_send rawip_send };
#line 75
allow nfsd_t node_type:node { tcp_recv rawip_recv };
#line 75

#line 75
#
#line 75
# Allow the domain to send to or receive from any port.
#line 75
# port_type is a type attribute for all port types.
#line 75
#
#line 75

#line 75
allow nfsd_t port_type:tcp_socket { send_msg recv_msg };
#line 75

#line 75

#line 75
# XXX Allow binding to any node type.  Remove once
#line 75
# individual rules have been added to all domains that 
#line 75
# bind sockets. 
#line 75
allow nfsd_t node_type:tcp_socket node_bind;
#line 75
#
#line 75
# Allow access to network files including /etc/resolv.conf
#line 75
#
#line 75
allow nfsd_t net_conf_t:file { read getattr lock ioctl };
#line 75

#line 75
allow nfsd_t self:tcp_socket { listen accept };
#line 75

#line 75

#line 75

#line 75
#
#line 75
# Allow the domain to create and use tcp sockets.
#line 75
# Other kinds of sockets must be separately authorized for use.
#line 75
allow nfsd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 75

#line 75
allow nfsd_t unlabeled_t:association { sendto recvfrom };
#line 75

#line 75
#
#line 75
# Allow the domain to send or receive using any network interface.
#line 75
# netif_type is a type attribute for all network interface types.
#line 75
#
#line 75
allow nfsd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 75
#
#line 75
# Allow the domain to send to or receive from any node.
#line 75
# node_type is a type attribute for all node types.
#line 75
#
#line 75
allow nfsd_t node_type:node { tcp_send rawip_send };
#line 75
allow nfsd_t node_type:node { tcp_recv rawip_recv };
#line 75

#line 75
#
#line 75
# Allow the domain to send to or receive from any port.
#line 75
# port_type is a type attribute for all port types.
#line 75
#
#line 75

#line 75
allow nfsd_t port_type:tcp_socket { send_msg recv_msg };
#line 75

#line 75

#line 75
# XXX Allow binding to any node type.  Remove once
#line 75
# individual rules have been added to all domains that 
#line 75
# bind sockets. 
#line 75
allow nfsd_t node_type:tcp_socket node_bind;
#line 75
#
#line 75
# Allow access to network files including /etc/resolv.conf
#line 75
#
#line 75
allow nfsd_t net_conf_t:file { read getattr lock ioctl };
#line 75

#line 75
allow nfsd_t self:tcp_socket { connect };
#line 75

#line 75

#line 75

#line 75

#line 75

#line 75
#
#line 75
# Allow the domain to create and use udp sockets.
#line 75
# Other kinds of sockets must be separately authorized for use.
#line 75
allow nfsd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 75

#line 75
allow nfsd_t unlabeled_t:association { sendto recvfrom };
#line 75

#line 75
#
#line 75
# Allow the domain to send or receive using any network interface.
#line 75
# netif_type is a type attribute for all network interface types.
#line 75
#
#line 75
allow nfsd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 75
#
#line 75
# Allow the domain to send to or receive from any node.
#line 75
# node_type is a type attribute for all node types.
#line 75
#
#line 75
allow nfsd_t node_type:node { udp_send rawip_send };
#line 75
allow nfsd_t node_type:node { udp_recv rawip_recv };
#line 75

#line 75
#
#line 75
# Allow the domain to send to or receive from any port.
#line 75
# port_type is a type attribute for all port types.
#line 75
#
#line 75

#line 75
allow nfsd_t port_type:udp_socket { send_msg recv_msg };
#line 75

#line 75

#line 75
# XXX Allow binding to any node type.  Remove once
#line 75
# individual rules have been added to all domains that 
#line 75
# bind sockets. 
#line 75
allow nfsd_t node_type:udp_socket node_bind;
#line 75
#
#line 75
# Allow access to network files including /etc/resolv.conf
#line 75
#
#line 75
allow nfsd_t net_conf_t:file { read getattr lock ioctl };
#line 75

#line 75
allow nfsd_t self:udp_socket { connect };
#line 75

#line 75

#line 75

#line 75

#line 75

#line 75

#line 75
allow nfsd_t var_yp_t:dir { read getattr lock search ioctl };
#line 75
allow nfsd_t var_yp_t:file { read getattr lock ioctl };
#line 75
allow nfsd_t var_yp_t:lnk_file { getattr read };
#line 75

#line 75
allow nfsd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 75
allow nfsd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 75
dontaudit nfsd_t self:capability net_bind_service;
#line 75
dontaudit nfsd_t reserved_port_type:tcp_socket name_connect;
#line 75
dontaudit nfsd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 75

#line 75
} else {
#line 75
dontaudit nfsd_t var_yp_t:dir search;
#line 75
}
#line 75
 
#line 75
allow nfsd_t { etc_runtime_t etc_t }:file { getattr read };
#line 75

#line 75
allow nfsd_t etc_t:lnk_file read;
#line 75
allow nfsd_t lib_t:file { read getattr lock ioctl };
#line 75

#line 75
allow nfsd_t locale_t:dir { read getattr lock search ioctl };
#line 75
allow nfsd_t locale_t:file { read getattr lock ioctl };
#line 75
allow nfsd_t locale_t:lnk_file { getattr read };
#line 75

#line 75

#line 75
allow nfsd_t self:capability net_bind_service;
#line 75
dontaudit nfsd_t self:capability net_admin;
#line 75

#line 75
allow nfsd_t var_t:dir { getattr search };
#line 75
allow nfsd_t var_lib_t:dir search;
#line 75
allow nfsd_t var_lib_nfs_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 75
allow nfsd_t var_lib_nfs_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 75
# do not log when it tries to bind to a port belonging to another domain
#line 75
dontaudit nfsd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 75
allow nfsd_t reserved_port_t:{ udp_socket tcp_socket } name_bind;
#line 75
allow nfsd_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 75
allow nfsd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 75
allow nfsd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 75
# bind to arbitary unused ports
#line 75
allow nfsd_t port_t:{ tcp_socket udp_socket } name_bind;
#line 75
allow nfsd_t sysctl_rpc_t:dir search;
#line 75
allow nfsd_t sysctl_rpc_t:file { ioctl read getattr lock write append };
#line 75


#line 76

#line 76

#line 76
#
#line 76
# Allow the process to transition to the new domain.
#line 76
#
#line 76
allow sysadm_t nfsd_t:process transition;
#line 76

#line 76
#
#line 76
# Do not audit when glibc secure mode is enabled upon the transition.
#line 76
#
#line 76
dontaudit sysadm_t nfsd_t:process noatsecure;
#line 76

#line 76
#
#line 76
# Do not audit when signal-related state is cleared upon the transition.
#line 76
#
#line 76
dontaudit sysadm_t nfsd_t:process siginh;
#line 76

#line 76
#
#line 76
# Do not audit when resource limits are reset upon the transition.
#line 76
#
#line 76
dontaudit sysadm_t nfsd_t:process rlimitinh;
#line 76

#line 76
#
#line 76
# Allow the process to execute the program.
#line 76
# 
#line 76
allow sysadm_t nfsd_exec_t:file { read { getattr execute } };
#line 76

#line 76
#
#line 76
# Allow the process to reap the new domain.
#line 76
#
#line 76
allow nfsd_t sysadm_t:process sigchld;
#line 76

#line 76
#
#line 76
# Allow the new domain to inherit and use file 
#line 76
# descriptions from the creating process and vice versa.
#line 76
#
#line 76
allow nfsd_t sysadm_t:fd use;
#line 76
allow sysadm_t nfsd_t:fd use;
#line 76

#line 76
#
#line 76
# Allow the new domain to write back to the old domain via a pipe.
#line 76
#
#line 76
allow nfsd_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 76

#line 76
#
#line 76
# Allow the new domain to read and execute the program.
#line 76
#
#line 76
allow nfsd_t nfsd_exec_t:file { read getattr lock execute ioctl };
#line 76

#line 76
#
#line 76
# Allow the new domain to be entered via the program.
#line 76
#
#line 76
allow nfsd_t nfsd_exec_t:file entrypoint;
#line 76

#line 76
type_transition sysadm_t nfsd_exec_t:process nfsd_t;
#line 76

role sysadm_r types nfsd_t;

# for /proc/fs/nfs/exports - should we have a new type?
allow nfsd_t proc_t:file { read getattr lock ioctl };
allow nfsd_t proc_net_t:dir search;
allow nfsd_t exports_t:file { getattr read };

allow nfsd_t nfsd_fs_t:filesystem mount;
allow nfsd_t nfsd_fs_t:dir search;
allow nfsd_t nfsd_fs_t:file { ioctl read getattr lock write append };
allow initrc_t sysctl_rpc_t:dir search;
allow initrc_t sysctl_rpc_t:file { ioctl read getattr lock write append };

type nfsd_rw_t, file_type, sysadmfile, usercanread;
type nfsd_ro_t, file_type, sysadmfile, usercanread;

bool nfs_export_all_rw false;

if(nfs_export_all_rw) {
allow nfsd_t { noexattrfile file_type -shadow_t }:dir { read getattr lock search ioctl };

#line 97
allow kernel_t noexattrfile:dir { read getattr lock search ioctl };
#line 97
allow kernel_t noexattrfile:file { read getattr lock ioctl };
#line 97
allow kernel_t noexattrfile:lnk_file { getattr read };
#line 97


#line 98
allow kernel_t { file_type -shadow_t }:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 98
allow kernel_t { file_type -shadow_t }:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 98
allow kernel_t { file_type -shadow_t }:lnk_file { create read getattr setattr link unlink rename };
#line 98

}

dontaudit kernel_t shadow_t:file getattr;

bool nfs_export_all_ro false;

if(nfs_export_all_ro) {
allow nfsd_t { noexattrfile file_type -shadow_t }:dir { read getattr lock search ioctl };

#line 107
allow kernel_t { noexattrfile file_type -shadow_t }:dir { read getattr lock search ioctl };
#line 107
allow kernel_t { noexattrfile file_type -shadow_t }:file { read getattr lock ioctl };
#line 107
allow kernel_t { noexattrfile file_type -shadow_t }:lnk_file { getattr read };
#line 107

}

allow nfsd_t { nfsd_rw_t nfsd_ro_t }:dir { read getattr lock search ioctl };

#line 111
allow kernel_t nfsd_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 111
allow kernel_t nfsd_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 111
allow kernel_t nfsd_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 111
;

#line 112
allow kernel_t nfsd_ro_t:dir { read getattr lock search ioctl };
#line 112
allow kernel_t nfsd_ro_t:file { read getattr lock ioctl };
#line 112
allow kernel_t nfsd_ro_t:lnk_file { getattr read };
#line 112
;

allow kernel_t nfsd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };

#line 115
#allow kernel_t nfsd_t:udp_socket sendto;
#line 115
#allow nfsd_t kernel_t:udp_socket recvfrom;
#line 115


#line 116
#allow nfsd_t kernel_t:udp_socket sendto;
#line 116
#allow kernel_t nfsd_t:udp_socket recvfrom;
#line 116


# does not really need this, but it is easier to just allow it
allow nfsd_t var_run_t:dir search;

allow nfsd_t self:capability { sys_admin sys_resource };
allow nfsd_t fs_type:filesystem getattr;


#line 124
#allow nfsd_t portmap_t:udp_socket sendto;
#line 124
#allow portmap_t nfsd_t:udp_socket recvfrom;
#line 124


#line 125
#allow portmap_t nfsd_t:udp_socket sendto;
#line 125
#allow nfsd_t portmap_t:udp_socket recvfrom;
#line 125



#line 127
#allow nfsd_t portmap_t:tcp_socket { connectto recvfrom };
#line 127
#allow portmap_t nfsd_t:tcp_socket { acceptfrom recvfrom };
#line 127
#allow portmap_t kernel_t:tcp_socket recvfrom;
#line 127
#allow nfsd_t kernel_t:tcp_socket recvfrom;
#line 127


# for exportfs and rpc.mountd
allow nfsd_t tmp_t:dir getattr;


#line 132
allow rpcd_t rpc_pipefs_t:dir { read getattr lock search ioctl };
#line 132
allow rpcd_t rpc_pipefs_t:file { read getattr lock ioctl };
#line 132
allow rpcd_t rpc_pipefs_t:lnk_file { getattr read };
#line 132

allow rpcd_t rpc_pipefs_t:sock_file { read write };
dontaudit rpcd_t selinux_config_t:dir { search };
allow rpcd_t proc_net_t:dir search;



#line 138

#line 138

#line 138

#line 138
type gssd_t, domain, privlog, daemon , transitionbool;
#line 138
type gssd_exec_t, file_type, sysadmfile, exec_type;
#line 138
dontaudit gssd_t self:capability sys_tty_config;
#line 138

#line 138
role system_r types gssd_t;
#line 138

#line 138
# Inherit and use descriptors from init.
#line 138
allow gssd_t init_t:fd use;
#line 138
allow gssd_t init_t:process sigchld;
#line 138
allow gssd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 138

#line 138

#line 138
allow gssd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 138
allow gssd_t lib_t:lnk_file { read getattr lock ioctl };
#line 138
allow gssd_t ld_so_t:file { read getattr lock execute ioctl };
#line 138
#allow gssd_t ld_so_t:file execute_no_trans;
#line 138
allow gssd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 138
allow gssd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 138
allow gssd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 138
allow gssd_t texrel_shlib_t:file execmod;
#line 138
allow gssd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 138
allow gssd_t device_t:dir search;
#line 138
allow gssd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 138

#line 138

#line 138
allow gssd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 138
allow gssd_t { self proc_t }:lnk_file { getattr read };
#line 138

#line 138
allow gssd_t device_t:dir { read getattr lock search ioctl };
#line 138

#line 138
allow gssd_t udev_tdb_t:file { read getattr lock ioctl };
#line 138
allow gssd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 138
dontaudit gssd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 138
dontaudit gssd_t unpriv_userdomain:fd use;
#line 138

#line 138

#line 138
allow gssd_t sysfs_t:dir { read getattr lock search ioctl };
#line 138
allow gssd_t sysfs_t:file { read getattr lock ioctl };
#line 138
allow gssd_t sysfs_t:lnk_file { getattr read };
#line 138
 
#line 138

#line 138
allow gssd_t autofs_t:dir { search getattr };
#line 138

#line 138
dontaudit gssd_t { tty_device_t devpts_t }:chr_file { read write };
#line 138
dontaudit gssd_t root_t:file { getattr read };
#line 138
 
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
# Read system variables in /sys.
#line 138

#line 138
allow gssd_t sysctl_t:dir search;
#line 138
allow gssd_t sysctl_kernel_t:dir search;
#line 138
allow gssd_t sysctl_kernel_t:file { getattr read };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allows user to define a tunable to disable domain transition
#line 138
#
#line 138

#line 138
bool gssd_disable_trans false;
#line 138
if (gssd_disable_trans) {
#line 138

#line 138
allow initrc_t gssd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 138

#line 138

#line 138
allow sysadm_t gssd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 138

#line 138
} else {
#line 138
 
#line 138

#line 138

#line 138
#
#line 138
# Allow the process to transition to the new domain.
#line 138
#
#line 138
allow initrc_t gssd_t:process transition;
#line 138

#line 138
#
#line 138
# Do not audit when glibc secure mode is enabled upon the transition.
#line 138
#
#line 138
dontaudit initrc_t gssd_t:process noatsecure;
#line 138

#line 138
#
#line 138
# Do not audit when signal-related state is cleared upon the transition.
#line 138
#
#line 138
dontaudit initrc_t gssd_t:process siginh;
#line 138

#line 138
#
#line 138
# Do not audit when resource limits are reset upon the transition.
#line 138
#
#line 138
dontaudit initrc_t gssd_t:process rlimitinh;
#line 138

#line 138
#
#line 138
# Allow the process to execute the program.
#line 138
# 
#line 138
allow initrc_t gssd_exec_t:file { read { getattr execute } };
#line 138

#line 138
#
#line 138
# Allow the process to reap the new domain.
#line 138
#
#line 138
allow gssd_t initrc_t:process sigchld;
#line 138

#line 138
#
#line 138
# Allow the new domain to inherit and use file 
#line 138
# descriptions from the creating process and vice versa.
#line 138
#
#line 138
allow gssd_t initrc_t:fd use;
#line 138
allow initrc_t gssd_t:fd use;
#line 138

#line 138
#
#line 138
# Allow the new domain to write back to the old domain via a pipe.
#line 138
#
#line 138
allow gssd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 138

#line 138
#
#line 138
# Allow the new domain to read and execute the program.
#line 138
#
#line 138
allow gssd_t gssd_exec_t:file { read getattr lock execute ioctl };
#line 138

#line 138
#
#line 138
# Allow the new domain to be entered via the program.
#line 138
#
#line 138
allow gssd_t gssd_exec_t:file entrypoint;
#line 138

#line 138
type_transition initrc_t gssd_exec_t:process gssd_t;
#line 138

#line 138

#line 138
allow initrc_t gssd_t:process { noatsecure siginh rlimitinh };
#line 138

#line 138
}
#line 138
 
#line 138
allow gssd_t privfd:fd use;
#line 138

#line 138
allow gssd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow gssd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow gssd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow gssd_t node_type:node { tcp_send rawip_send };
#line 138
allow gssd_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow gssd_t port_type:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow gssd_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow gssd_t self:tcp_socket { listen accept };
#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow gssd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow gssd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow gssd_t node_type:node { tcp_send rawip_send };
#line 138
allow gssd_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow gssd_t port_type:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow gssd_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow gssd_t self:tcp_socket { connect };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use udp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow gssd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow gssd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow gssd_t node_type:node { udp_send rawip_send };
#line 138
allow gssd_t node_type:node { udp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow gssd_t port_type:udp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow gssd_t node_type:udp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow gssd_t self:udp_socket { connect };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
allow gssd_t port_type:tcp_socket name_connect;
#line 138

#line 138

#line 138
if (allow_ypbind) {
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow gssd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow gssd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow gssd_t node_type:node { tcp_send rawip_send };
#line 138
allow gssd_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow gssd_t port_type:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow gssd_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow gssd_t self:tcp_socket { listen accept };
#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use tcp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow gssd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow gssd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow gssd_t node_type:node { tcp_send rawip_send };
#line 138
allow gssd_t node_type:node { tcp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow gssd_t port_type:tcp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow gssd_t node_type:tcp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow gssd_t self:tcp_socket { connect };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
#
#line 138
# Allow the domain to create and use udp sockets.
#line 138
# Other kinds of sockets must be separately authorized for use.
#line 138
allow gssd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 138

#line 138
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 138

#line 138
#
#line 138
# Allow the domain to send or receive using any network interface.
#line 138
# netif_type is a type attribute for all network interface types.
#line 138
#
#line 138
allow gssd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 138
#
#line 138
# Allow the domain to send to or receive from any node.
#line 138
# node_type is a type attribute for all node types.
#line 138
#
#line 138
allow gssd_t node_type:node { udp_send rawip_send };
#line 138
allow gssd_t node_type:node { udp_recv rawip_recv };
#line 138

#line 138
#
#line 138
# Allow the domain to send to or receive from any port.
#line 138
# port_type is a type attribute for all port types.
#line 138
#
#line 138

#line 138
allow gssd_t port_type:udp_socket { send_msg recv_msg };
#line 138

#line 138

#line 138
# XXX Allow binding to any node type.  Remove once
#line 138
# individual rules have been added to all domains that 
#line 138
# bind sockets. 
#line 138
allow gssd_t node_type:udp_socket node_bind;
#line 138
#
#line 138
# Allow access to network files including /etc/resolv.conf
#line 138
#
#line 138
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 138

#line 138
allow gssd_t self:udp_socket { connect };
#line 138

#line 138

#line 138

#line 138

#line 138

#line 138

#line 138
allow gssd_t var_yp_t:dir { read getattr lock search ioctl };
#line 138
allow gssd_t var_yp_t:file { read getattr lock ioctl };
#line 138
allow gssd_t var_yp_t:lnk_file { getattr read };
#line 138

#line 138
allow gssd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 138
allow gssd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 138
dontaudit gssd_t self:capability net_bind_service;
#line 138
dontaudit gssd_t reserved_port_type:tcp_socket name_connect;
#line 138
dontaudit gssd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 138

#line 138
} else {
#line 138
dontaudit gssd_t var_yp_t:dir search;
#line 138
}
#line 138
 
#line 138
allow gssd_t { etc_runtime_t etc_t }:file { getattr read };
#line 138

#line 138
allow gssd_t etc_t:lnk_file read;
#line 138
allow gssd_t lib_t:file { read getattr lock ioctl };
#line 138

#line 138
allow gssd_t locale_t:dir { read getattr lock search ioctl };
#line 138
allow gssd_t locale_t:file { read getattr lock ioctl };
#line 138
allow gssd_t locale_t:lnk_file { getattr read };
#line 138

#line 138

#line 138
allow gssd_t self:capability net_bind_service;
#line 138
dontaudit gssd_t self:capability net_admin;
#line 138

#line 138
allow gssd_t var_t:dir { getattr search };
#line 138
allow gssd_t var_lib_t:dir search;
#line 138
allow gssd_t var_lib_nfs_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 138
allow gssd_t var_lib_nfs_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 138
# do not log when it tries to bind to a port belonging to another domain
#line 138
dontaudit gssd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 138
allow gssd_t reserved_port_t:{ udp_socket tcp_socket } name_bind;
#line 138
allow gssd_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 138
allow gssd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 138
allow gssd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 138
# bind to arbitary unused ports
#line 138
allow gssd_t port_t:{ tcp_socket udp_socket } name_bind;
#line 138
allow gssd_t sysctl_rpc_t:dir search;
#line 138
allow gssd_t sysctl_rpc_t:file { ioctl read getattr lock write append };
#line 138


#line 139

#line 139
if (allow_kerberos) {
#line 139

#line 139

#line 139

#line 139

#line 139
#
#line 139
# Allow the domain to create and use tcp sockets.
#line 139
# Other kinds of sockets must be separately authorized for use.
#line 139
allow gssd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 139

#line 139
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 139

#line 139
#
#line 139
# Allow the domain to send or receive using any network interface.
#line 139
# netif_type is a type attribute for all network interface types.
#line 139
#
#line 139
allow gssd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 139
#
#line 139
# Allow the domain to send to or receive from any node.
#line 139
# node_type is a type attribute for all node types.
#line 139
#
#line 139
allow gssd_t node_type:node { tcp_send rawip_send };
#line 139
allow gssd_t node_type:node { tcp_recv rawip_recv };
#line 139

#line 139
#
#line 139
# Allow the domain to send to or receive from any port.
#line 139
# port_type is a type attribute for all port types.
#line 139
#
#line 139

#line 139
allow gssd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 139

#line 139

#line 139
# XXX Allow binding to any node type.  Remove once
#line 139
# individual rules have been added to all domains that 
#line 139
# bind sockets. 
#line 139
allow gssd_t node_type:tcp_socket node_bind;
#line 139
#
#line 139
# Allow access to network files including /etc/resolv.conf
#line 139
#
#line 139
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 139

#line 139
allow gssd_t self:tcp_socket { connect };
#line 139

#line 139

#line 139

#line 139
#
#line 139
# Allow the domain to create and use udp sockets.
#line 139
# Other kinds of sockets must be separately authorized for use.
#line 139
allow gssd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 139

#line 139
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 139

#line 139
#
#line 139
# Allow the domain to send or receive using any network interface.
#line 139
# netif_type is a type attribute for all network interface types.
#line 139
#
#line 139
allow gssd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 139
#
#line 139
# Allow the domain to send to or receive from any node.
#line 139
# node_type is a type attribute for all node types.
#line 139
#
#line 139
allow gssd_t node_type:node { udp_send rawip_send };
#line 139
allow gssd_t node_type:node { udp_recv rawip_recv };
#line 139

#line 139
#
#line 139
# Allow the domain to send to or receive from any port.
#line 139
# port_type is a type attribute for all port types.
#line 139
#
#line 139

#line 139
allow gssd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 139

#line 139

#line 139
# XXX Allow binding to any node type.  Remove once
#line 139
# individual rules have been added to all domains that 
#line 139
# bind sockets. 
#line 139
allow gssd_t node_type:udp_socket node_bind;
#line 139
#
#line 139
# Allow access to network files including /etc/resolv.conf
#line 139
#
#line 139
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 139

#line 139
allow gssd_t self:udp_socket { connect };
#line 139

#line 139

#line 139

#line 139
allow gssd_t kerberos_port_t:tcp_socket name_connect;
#line 139

#line 139

#line 139

#line 139

#line 139

#line 139
#
#line 139
# Allow the domain to create and use tcp sockets.
#line 139
# Other kinds of sockets must be separately authorized for use.
#line 139
allow gssd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 139

#line 139
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 139

#line 139
#
#line 139
# Allow the domain to send or receive using any network interface.
#line 139
# netif_type is a type attribute for all network interface types.
#line 139
#
#line 139
allow gssd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 139
#
#line 139
# Allow the domain to send to or receive from any node.
#line 139
# node_type is a type attribute for all node types.
#line 139
#
#line 139
allow gssd_t node_type:node { tcp_send rawip_send };
#line 139
allow gssd_t node_type:node { tcp_recv rawip_recv };
#line 139

#line 139
#
#line 139
# Allow the domain to send to or receive from any port.
#line 139
# port_type is a type attribute for all port types.
#line 139
#
#line 139

#line 139
allow gssd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 139

#line 139

#line 139
# XXX Allow binding to any node type.  Remove once
#line 139
# individual rules have been added to all domains that 
#line 139
# bind sockets. 
#line 139
allow gssd_t node_type:tcp_socket node_bind;
#line 139
#
#line 139
# Allow access to network files including /etc/resolv.conf
#line 139
#
#line 139
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 139

#line 139
allow gssd_t self:tcp_socket { connect };
#line 139

#line 139

#line 139

#line 139
#
#line 139
# Allow the domain to create and use udp sockets.
#line 139
# Other kinds of sockets must be separately authorized for use.
#line 139
allow gssd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 139

#line 139
allow gssd_t unlabeled_t:association { sendto recvfrom };
#line 139

#line 139
#
#line 139
# Allow the domain to send or receive using any network interface.
#line 139
# netif_type is a type attribute for all network interface types.
#line 139
#
#line 139
allow gssd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 139
#
#line 139
# Allow the domain to send to or receive from any node.
#line 139
# node_type is a type attribute for all node types.
#line 139
#
#line 139
allow gssd_t node_type:node { udp_send rawip_send };
#line 139
allow gssd_t node_type:node { udp_recv rawip_recv };
#line 139

#line 139
#
#line 139
# Allow the domain to send to or receive from any port.
#line 139
# port_type is a type attribute for all port types.
#line 139
#
#line 139

#line 139
allow gssd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 139

#line 139

#line 139
# XXX Allow binding to any node type.  Remove once
#line 139
# individual rules have been added to all domains that 
#line 139
# bind sockets. 
#line 139
allow gssd_t node_type:udp_socket node_bind;
#line 139
#
#line 139
# Allow access to network files including /etc/resolv.conf
#line 139
#
#line 139
allow gssd_t net_conf_t:file { read getattr lock ioctl };
#line 139

#line 139
allow gssd_t self:udp_socket { connect };
#line 139

#line 139

#line 139

#line 139
allow gssd_t dns_port_t:tcp_socket name_connect;
#line 139

#line 139
}
#line 139
 dontaudit gssd_t krb5_conf_t:file write;
#line 139
allow gssd_t krb5_conf_t:file { getattr read };
#line 139

#line 142

#line 142
allow gssd_t krb5_keytab_t:file { read getattr lock ioctl };
#line 142

allow gssd_t urandom_device_t:chr_file { getattr read };

#line 144
allow gssd_t tmp_t:dir { read getattr lock search ioctl };
#line 144
allow gssd_t tmp_t:file { read getattr lock ioctl };
#line 144
allow gssd_t tmp_t:lnk_file { getattr read };
#line 144


#line 145
type gssd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 145

#line 145

#line 145

#line 145

#line 145
#
#line 145
# Allow the process to modify the directory.
#line 145
#
#line 145
allow gssd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 145

#line 145
#
#line 145
# Allow the process to create the file.
#line 145
#
#line 145

#line 145

#line 145

#line 145

#line 145

#line 145
allow gssd_t gssd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 145

#line 145

#line 145

#line 145

#line 145

#line 145

#line 145
allow gssd_t gssd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 145

#line 145

#line 145

#line 145

#line 145

#line 145

#line 145

#line 145

#line 145

#line 145

#line 145

#line 145
type_transition gssd_t tmp_t:{ file dir } gssd_tmp_t;
#line 145

#line 145

#line 145

allow gssd_t self:fifo_file { read write };

#line 147
allow gssd_t proc_net_t:dir { read getattr lock search ioctl };
#line 147
allow gssd_t proc_net_t:file { read getattr lock ioctl };
#line 147
allow gssd_t proc_net_t:lnk_file { getattr read };
#line 147

allow gssd_t rpc_pipefs_t:dir { read getattr lock search ioctl };
allow gssd_t rpc_pipefs_t:sock_file { read write };
allow gssd_t rpc_pipefs_t:file { read getattr lock ioctl };
allow gssd_t self:capability { dac_override dac_read_search setuid };
allow nfsd_t devtty_t:chr_file { ioctl read getattr lock write append };
allow rpcd_t devtty_t:chr_file { ioctl read getattr lock write append };

bool allow_gssd_read_tmp true;
if (allow_gssd_read_tmp) {
#
#needs to be able to udpate the kerberos ticket file
#
#line 166

#line 166

#line 166
allow gssd_t tmp_t:dir { read getattr lock search ioctl };
#line 166
allow gssd_t tmp_t:file { read getattr lock ioctl };
#line 166
allow gssd_t tmp_t:lnk_file { getattr read };
#line 166

#line 166
allow gssd_t tmp_t:file write;
#line 166

}
#line 1 "domains/program/rpm.te"
#DESC rpm - Linux configurable dynamic device naming support
#
# Authors:  Daniel Walsh <dwalsh@redhat.com>
#

#################################
#
# Rules for the rpm domain.
#
# rpm_exec_t is the type of the /bin/rpm and other programs.
# This domain is defined just for targeted policy to labeld /var/lib/rpm
#
type rpm_exec_t, file_type, sysadmfile, exec_type;
type rpm_var_lib_t, file_type, sysadmfile;
typealias var_log_t alias rpm_log_t;
type rpm_tmpfs_t, file_type, sysadmfile;
#line 1 "domains/program/rshd.te"
#DESC RSHD - RSH daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: rsh-server rsh-redone-server
# Depends: inetd.te
#

#################################
#
# Rules for the rshd_t domain.
#

#line 12
# inetd_t is the parent domain (or domains), rshd_t is the child domain,
#line 12
# and , auth_chkpwd, privuser, privrole is any attributes to apply to the child
#line 12
type rshd_t, domain, privlog, daemon , auth_chkpwd, privuser, privrole;
#line 12
type rshd_exec_t, file_type, sysadmfile, exec_type;
#line 12

#line 12
role system_r types rshd_t;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow inetd_t rshd_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit inetd_t rshd_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit inetd_t rshd_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit inetd_t rshd_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow inetd_t rshd_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow rshd_t inetd_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow rshd_t inetd_t:fd use;
#line 12
allow inetd_t rshd_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow rshd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow rshd_t rshd_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow rshd_t rshd_exec_t:file entrypoint;
#line 12

#line 12
type_transition inetd_t rshd_exec_t:process rshd_t;
#line 12

#line 12

#line 12
;
#line 12
# Inherit and use descriptors from parent.
#line 12
allow rshd_t inetd_t:fd use;
#line 12
allow rshd_t inetd_t:process sigchld;
#line 12

#line 12
allow rshd_t self:process { sigchld sigkill sigstop signull signal };
#line 12

#line 12

#line 12
allow rshd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 12
allow rshd_t lib_t:lnk_file { read getattr lock ioctl };
#line 12
allow rshd_t ld_so_t:file { read getattr lock execute ioctl };
#line 12
#allow rshd_t ld_so_t:file execute_no_trans;
#line 12
allow rshd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 12
allow rshd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 12
allow rshd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 12
allow rshd_t texrel_shlib_t:file execmod;
#line 12
allow rshd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 12
allow rshd_t device_t:dir search;
#line 12
allow rshd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
allow rshd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 12
allow rshd_t { self proc_t }:lnk_file read;
#line 12

#line 12
allow rshd_t device_t:dir getattr;
#line 12


#line 16


# Use sockets inherited from inetd.
allow rshd_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };

# Use capabilities.
allow rshd_t self:capability { net_bind_service setuid setgid fowner fsetid chown dac_override};

# Use the network.

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use tcp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow rshd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow rshd_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow rshd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow rshd_t node_type:node { tcp_send rawip_send };
#line 25
allow rshd_t node_type:node { tcp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow rshd_t port_type:tcp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow rshd_t node_type:tcp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow rshd_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow rshd_t self:tcp_socket { listen accept };
#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use udp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow rshd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow rshd_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow rshd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow rshd_t node_type:node { udp_send rawip_send };
#line 25
allow rshd_t node_type:node { udp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow rshd_t port_type:udp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow rshd_t node_type:udp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow rshd_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow rshd_t self:udp_socket { connect };
#line 25

#line 25

#line 25

allow rshd_t rsh_port_t:tcp_socket name_bind;

allow rshd_t etc_t:file { getattr read };

#line 29
allow rshd_t etc_t:lnk_file read;
#line 29
allow rshd_t lib_t:file { read getattr lock ioctl };
#line 29

#line 29
allow rshd_t locale_t:dir { read getattr lock search ioctl };
#line 29
allow rshd_t locale_t:file { read getattr lock ioctl };
#line 29
allow rshd_t locale_t:lnk_file { getattr read };
#line 29

#line 29

allow rshd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow rshd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow rshd_t { home_root_t home_dir_type }:dir { search getattr };

#line 33

#line 33
if (allow_kerberos) {
#line 33

#line 33

#line 33

#line 33

#line 33
#
#line 33
# Allow the domain to create and use tcp sockets.
#line 33
# Other kinds of sockets must be separately authorized for use.
#line 33
allow rshd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 33

#line 33
allow rshd_t unlabeled_t:association { sendto recvfrom };
#line 33

#line 33
#
#line 33
# Allow the domain to send or receive using any network interface.
#line 33
# netif_type is a type attribute for all network interface types.
#line 33
#
#line 33
allow rshd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 33
#
#line 33
# Allow the domain to send to or receive from any node.
#line 33
# node_type is a type attribute for all node types.
#line 33
#
#line 33
allow rshd_t node_type:node { tcp_send rawip_send };
#line 33
allow rshd_t node_type:node { tcp_recv rawip_recv };
#line 33

#line 33
#
#line 33
# Allow the domain to send to or receive from any port.
#line 33
# port_type is a type attribute for all port types.
#line 33
#
#line 33

#line 33
allow rshd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 33

#line 33

#line 33
# XXX Allow binding to any node type.  Remove once
#line 33
# individual rules have been added to all domains that 
#line 33
# bind sockets. 
#line 33
allow rshd_t node_type:tcp_socket node_bind;
#line 33
#
#line 33
# Allow access to network files including /etc/resolv.conf
#line 33
#
#line 33
allow rshd_t net_conf_t:file { read getattr lock ioctl };
#line 33

#line 33
allow rshd_t self:tcp_socket { connect };
#line 33

#line 33

#line 33

#line 33
#
#line 33
# Allow the domain to create and use udp sockets.
#line 33
# Other kinds of sockets must be separately authorized for use.
#line 33
allow rshd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 33

#line 33
allow rshd_t unlabeled_t:association { sendto recvfrom };
#line 33

#line 33
#
#line 33
# Allow the domain to send or receive using any network interface.
#line 33
# netif_type is a type attribute for all network interface types.
#line 33
#
#line 33
allow rshd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 33
#
#line 33
# Allow the domain to send to or receive from any node.
#line 33
# node_type is a type attribute for all node types.
#line 33
#
#line 33
allow rshd_t node_type:node { udp_send rawip_send };
#line 33
allow rshd_t node_type:node { udp_recv rawip_recv };
#line 33

#line 33
#
#line 33
# Allow the domain to send to or receive from any port.
#line 33
# port_type is a type attribute for all port types.
#line 33
#
#line 33

#line 33
allow rshd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 33

#line 33

#line 33
# XXX Allow binding to any node type.  Remove once
#line 33
# individual rules have been added to all domains that 
#line 33
# bind sockets. 
#line 33
allow rshd_t node_type:udp_socket node_bind;
#line 33
#
#line 33
# Allow access to network files including /etc/resolv.conf
#line 33
#
#line 33
allow rshd_t net_conf_t:file { read getattr lock ioctl };
#line 33

#line 33
allow rshd_t self:udp_socket { connect };
#line 33

#line 33

#line 33

#line 33
allow rshd_t kerberos_port_t:tcp_socket name_connect;
#line 33

#line 33

#line 33

#line 33

#line 33

#line 33
#
#line 33
# Allow the domain to create and use tcp sockets.
#line 33
# Other kinds of sockets must be separately authorized for use.
#line 33
allow rshd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 33

#line 33
allow rshd_t unlabeled_t:association { sendto recvfrom };
#line 33

#line 33
#
#line 33
# Allow the domain to send or receive using any network interface.
#line 33
# netif_type is a type attribute for all network interface types.
#line 33
#
#line 33
allow rshd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 33
#
#line 33
# Allow the domain to send to or receive from any node.
#line 33
# node_type is a type attribute for all node types.
#line 33
#
#line 33
allow rshd_t node_type:node { tcp_send rawip_send };
#line 33
allow rshd_t node_type:node { tcp_recv rawip_recv };
#line 33

#line 33
#
#line 33
# Allow the domain to send to or receive from any port.
#line 33
# port_type is a type attribute for all port types.
#line 33
#
#line 33

#line 33
allow rshd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 33

#line 33

#line 33
# XXX Allow binding to any node type.  Remove once
#line 33
# individual rules have been added to all domains that 
#line 33
# bind sockets. 
#line 33
allow rshd_t node_type:tcp_socket node_bind;
#line 33
#
#line 33
# Allow access to network files including /etc/resolv.conf
#line 33
#
#line 33
allow rshd_t net_conf_t:file { read getattr lock ioctl };
#line 33

#line 33
allow rshd_t self:tcp_socket { connect };
#line 33

#line 33

#line 33

#line 33
#
#line 33
# Allow the domain to create and use udp sockets.
#line 33
# Other kinds of sockets must be separately authorized for use.
#line 33
allow rshd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 33

#line 33
allow rshd_t unlabeled_t:association { sendto recvfrom };
#line 33

#line 33
#
#line 33
# Allow the domain to send or receive using any network interface.
#line 33
# netif_type is a type attribute for all network interface types.
#line 33
#
#line 33
allow rshd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 33
#
#line 33
# Allow the domain to send to or receive from any node.
#line 33
# node_type is a type attribute for all node types.
#line 33
#
#line 33
allow rshd_t node_type:node { udp_send rawip_send };
#line 33
allow rshd_t node_type:node { udp_recv rawip_recv };
#line 33

#line 33
#
#line 33
# Allow the domain to send to or receive from any port.
#line 33
# port_type is a type attribute for all port types.
#line 33
#
#line 33

#line 33
allow rshd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 33

#line 33

#line 33
# XXX Allow binding to any node type.  Remove once
#line 33
# individual rules have been added to all domains that 
#line 33
# bind sockets. 
#line 33
allow rshd_t node_type:udp_socket node_bind;
#line 33
#
#line 33
# Allow access to network files including /etc/resolv.conf
#line 33
#
#line 33
allow rshd_t net_conf_t:file { read getattr lock ioctl };
#line 33

#line 33
allow rshd_t self:udp_socket { connect };
#line 33

#line 33

#line 33

#line 33
allow rshd_t dns_port_t:tcp_socket name_connect;
#line 33

#line 33
}
#line 33
 dontaudit rshd_t krb5_conf_t:file write;
#line 33
allow rshd_t krb5_conf_t:file { getattr read };
#line 33

allow rshd_t { bin_t sbin_t tmp_t}:dir { search };
allow rshd_t { bin_t sbin_t }:lnk_file { read getattr lock ioctl };
#line 38

#line 38
allow rshd_t rlogind_tmp_t:file { ioctl read getattr lock write append };
#line 38

allow rshd_t urandom_device_t:chr_file { getattr read };

# Read the user's .rhosts file.
allow rshd_t home_type:file  { read getattr lock ioctl } ;

# Random reasons

#line 45
# Get the selinuxfs mount point via /proc/self/mounts.
#line 45
allow rshd_t proc_t:dir search;
#line 45
allow rshd_t proc_t:{ file lnk_file } { getattr read };
#line 45
allow rshd_t self:dir search;
#line 45
allow rshd_t self:file { getattr read };
#line 45
# Access selinuxfs.
#line 45
allow rshd_t security_t:dir { read search getattr };
#line 45
allow rshd_t security_t:file { getattr read write };
#line 45
allow rshd_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 45


#line 46
allow rshd_t self:process setexec;
#line 46
allow rshd_t proc_t:dir search;
#line 46
allow rshd_t proc_t:{ file lnk_file } read;
#line 46
allow rshd_t self:dir search;
#line 46
allow rshd_t self:file { getattr read write };
#line 46


#line 47
allow rshd_t selinux_config_t:dir { read getattr lock search ioctl };
#line 47
allow rshd_t selinux_config_t:file { read getattr lock ioctl };
#line 47
allow rshd_t selinux_config_t:lnk_file { getattr read };
#line 47


#line 48
allow rshd_t default_context_t:dir { read getattr lock search ioctl };
#line 48
allow rshd_t default_context_t:file { read getattr lock ioctl };
#line 48
allow rshd_t default_context_t:lnk_file { getattr read };
#line 48


#line 49
# Read system variables in /sys.
#line 49

#line 49
allow rshd_t sysctl_t:dir search;
#line 49
allow rshd_t sysctl_kernel_t:dir search;
#line 49
allow rshd_t sysctl_kernel_t:file { getattr read };
#line 49

#line 49

#line 49
;

if (use_nfs_home_dirs) {

#line 52
allow rshd_t nfs_t:dir { read getattr lock search ioctl };
#line 52
allow rshd_t nfs_t:file { read getattr lock ioctl };
#line 52
allow rshd_t nfs_t:lnk_file { getattr read };
#line 52

}

if (use_samba_home_dirs) {

#line 56
allow rshd_t cifs_t:dir { read getattr lock search ioctl };
#line 56
allow rshd_t cifs_t:file { read getattr lock ioctl };
#line 56
allow rshd_t cifs_t:lnk_file { getattr read };
#line 56

}

allow rshd_t self:process { fork signal setsched setpgid };
allow rshd_t self:fifo_file { ioctl read getattr lock write append };

#line 65

#line 65

#line 65

#line 65
typeattribute rshd_t unrestricted;
#line 65
typeattribute rshd_t privuser;
#line 65

#line 65
# Mount/unmount any filesystem. 
#line 65
allow rshd_t fs_type:filesystem *;
#line 65

#line 65
# Mount/unmount any filesystem with the context= option. 
#line 65
allow rshd_t file_type:filesystem *;
#line 65

#line 65
# Create/access any file in a labeled filesystem;
#line 65
allow rshd_t file_type:{ file chr_file } ~execmod;
#line 65
allow rshd_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 65
allow rshd_t sysctl_t:{ dir file } *;
#line 65
allow rshd_t device_type:{ chr_file blk_file } *;
#line 65
allow rshd_t mtrr_device_t:file *;
#line 65

#line 65
# Create/access other files.  fs_type is to pick up various
#line 65
# pseudo filesystem types that are applied to both the filesystem
#line 65
# and its files.
#line 65
allow rshd_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 65
allow rshd_t unlabeled_t:association { sendto recvfrom };
#line 65

#line 65
allow rshd_t proc_fs:{ dir file } *;
#line 65

#line 65
# For /proc/pid
#line 65

#line 65
allow rshd_t domain:dir { read getattr lock search ioctl };
#line 65
allow rshd_t domain:file { read getattr lock ioctl };
#line 65
allow rshd_t domain:lnk_file { getattr read };
#line 65

#line 65
# Write access is for setting attributes under /proc/self/attr.
#line 65
allow rshd_t self:file { ioctl read getattr lock write append };
#line 65

#line 65
# Read and write sysctls.
#line 65

#line 65
allow rshd_t sysctl_type:dir { read getattr lock search ioctl };
#line 65
allow rshd_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 65

#line 65

#line 65
# Access the network.
#line 65
allow rshd_t node_type:node *;
#line 65
allow rshd_t netif_type:netif *;
#line 65
allow rshd_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 65
allow rshd_t port_type:tcp_socket name_connect;
#line 65

#line 65
# Bind to any network address.
#line 65
allow rshd_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 65
allow rshd_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 65
allow rshd_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 65

#line 65
# Use/sendto/connectto sockets created by any domain.
#line 65
allow rshd_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 65

#line 65
# Use descriptors and pipes created by any domain.
#line 65
allow rshd_t domain:fd use;
#line 65
allow rshd_t domain:fifo_file { ioctl read getattr lock write append };
#line 65

#line 65
# Act upon any other process.
#line 65
allow rshd_t domain:process ~{ transition dyntransition execmem };
#line 65
# Transition to myself, to make get_ordered_context_list happy.
#line 65
allow rshd_t self:process transition;
#line 65

#line 65
if (allow_execmem) {
#line 65
# Allow making anonymous memory executable, e.g. 
#line 65
# for runtime-code generation or executable stack.
#line 65
allow rshd_t self:process execmem;
#line 65
}
#line 65

#line 65
if (allow_execmem && allow_execstack) {
#line 65
# Allow making the stack executable via mprotect.
#line 65
allow rshd_t self:process execstack;
#line 65
}
#line 65

#line 65
if (allow_execmod) {
#line 65
# Allow text relocations on system shared libraries, e.g. libGL.
#line 65

#line 65
allow rshd_t file_type:file execmod;
#line 65

#line 65
}
#line 65

#line 65
# Create/access any System V IPC objects.
#line 65
allow rshd_t domain:{ sem msgq shm } *;
#line 65
allow rshd_t domain:msg  { send receive };
#line 65

#line 65
# Access the security API.
#line 65
if (!secure_mode_policyload) {
#line 65
allow rshd_t security_t:security *;
#line 65
auditallow rshd_t security_t:security { load_policy setenforce setbool };
#line 65
}
#line 65
# Perform certain system operations that lacked individual capabilities.
#line 65
allow rshd_t kernel_t:system *;
#line 65

#line 65
# Use any Linux capability.
#line 65
allow rshd_t self:capability *;
#line 65

#line 65
# Set user information and skip authentication.
#line 65
allow rshd_t self:passwd *;
#line 65

#line 65
# Communicate via dbusd.
#line 65
allow rshd_t self:dbus *;
#line 65

#line 65
allow rshd_t system_dbusd_t:dbus *;
#line 65

#line 65

#line 65
# Get info via nscd.
#line 65
allow rshd_t self:nscd *;
#line 65

#line 65
allow rshd_t nscd_t:nscd *;
#line 65

#line 65

#line 65

#line 65

#line 65

#line 65

#line 65
#
#line 65
# Allow the process to transition to the new domain.
#line 65
#
#line 65
allow rshd_t unconfined_t:process transition;
#line 65

#line 65
#
#line 65
# Do not audit when glibc secure mode is enabled upon the transition.
#line 65
#
#line 65
dontaudit rshd_t unconfined_t:process noatsecure;
#line 65

#line 65
#
#line 65
# Do not audit when signal-related state is cleared upon the transition.
#line 65
#
#line 65
dontaudit rshd_t unconfined_t:process siginh;
#line 65

#line 65
#
#line 65
# Do not audit when resource limits are reset upon the transition.
#line 65
#
#line 65
dontaudit rshd_t unconfined_t:process rlimitinh;
#line 65

#line 65
#
#line 65
# Allow the process to execute the program.
#line 65
# 
#line 65
allow rshd_t shell_exec_t:file { read { getattr execute } };
#line 65

#line 65
#
#line 65
# Allow the process to reap the new domain.
#line 65
#
#line 65
allow unconfined_t rshd_t:process sigchld;
#line 65

#line 65
#
#line 65
# Allow the new domain to inherit and use file 
#line 65
# descriptions from the creating process and vice versa.
#line 65
#
#line 65
allow unconfined_t rshd_t:fd use;
#line 65
allow rshd_t unconfined_t:fd use;
#line 65

#line 65
#
#line 65
# Allow the new domain to write back to the old domain via a pipe.
#line 65
#
#line 65
allow unconfined_t rshd_t:fifo_file { ioctl read getattr lock write append };
#line 65

#line 65
#
#line 65
# Allow the new domain to read and execute the program.
#line 65
#
#line 65
allow unconfined_t shell_exec_t:file { read getattr lock execute ioctl };
#line 65

#line 65
#
#line 65
# Allow the new domain to be entered via the program.
#line 65
#
#line 65
allow unconfined_t shell_exec_t:file entrypoint;
#line 65

#line 65
type_transition rshd_t shell_exec_t:process unconfined_t;
#line 65

#line 65

#line 1 "domains/program/rsync.te"
#DESC rsync - flexible replacement for rcp
#
# Author:  Dan Walsh <dwalsh@redhat.com>
#
# Depends: inetd.te

#################################
#
# Rules for the rsync_t domain.
#
# rsync_exec_t is the type of the rsync executable.
#


#line 14
type rsync_t, domain, privlog, nscd_client_domain;
#line 14
role system_r types rsync_t;
#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14
bool rsync_disable_trans false;
#line 14
if (rsync_disable_trans) {
#line 14

#line 14
allow initrc_t rsync_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t rsync_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow inetd_t rsync_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit inetd_t rsync_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit inetd_t rsync_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit inetd_t rsync_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow inetd_t rsync_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow rsync_t inetd_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow rsync_t inetd_t:fd use;
#line 14
allow inetd_t rsync_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow rsync_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow rsync_t rsync_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow rsync_t rsync_exec_t:file entrypoint;
#line 14

#line 14
type_transition inetd_t rsync_exec_t:process rsync_t;
#line 14

#line 14
allow inetd_t rsync_t:process sigkill;
#line 14
}
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow rsync_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow rsync_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow rsync_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow rsync_t node_type:node { tcp_send rawip_send };
#line 14
allow rsync_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow rsync_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow rsync_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow rsync_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow rsync_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow rsync_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow rsync_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow rsync_t node_type:node { udp_send rawip_send };
#line 14
allow rsync_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow rsync_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow rsync_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow rsync_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
if (allow_ypbind) {
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow rsync_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow rsync_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow rsync_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow rsync_t node_type:node { tcp_send rawip_send };
#line 14
allow rsync_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow rsync_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow rsync_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow rsync_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow rsync_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow rsync_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow rsync_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow rsync_t node_type:node { tcp_send rawip_send };
#line 14
allow rsync_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow rsync_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow rsync_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow rsync_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow rsync_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow rsync_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow rsync_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow rsync_t node_type:node { udp_send rawip_send };
#line 14
allow rsync_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow rsync_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow rsync_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow rsync_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow rsync_t var_yp_t:dir { read getattr lock search ioctl };
#line 14
allow rsync_t var_yp_t:file { read getattr lock ioctl };
#line 14
allow rsync_t var_yp_t:lnk_file { getattr read };
#line 14

#line 14
allow rsync_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 14
allow rsync_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 14
dontaudit rsync_t self:capability net_bind_service;
#line 14
dontaudit rsync_t reserved_port_type:tcp_socket name_connect;
#line 14
dontaudit rsync_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 14

#line 14
} else {
#line 14
dontaudit rsync_t var_yp_t:dir search;
#line 14
}
#line 14
 
#line 14

#line 14
allow rsync_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow rsync_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow rsync_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow rsync_t ld_so_t:file execute_no_trans;
#line 14
allow rsync_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow rsync_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow rsync_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow rsync_t texrel_shlib_t:file execmod;
#line 14
allow rsync_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow rsync_t device_t:dir search;
#line 14
allow rsync_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
allow rsync_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow rsync_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow rsync_t self:fifo_file { ioctl read getattr lock write append };
#line 14
type rsync_exec_t, file_type, sysadmfile, exec_type;
#line 14

#line 14
allow rsync_t etc_t:lnk_file read;
#line 14
allow rsync_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow rsync_t locale_t:file { read getattr lock ioctl };
#line 14
allow rsync_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14
allow rsync_t device_t:dir search;
#line 14
allow rsync_t proc_t:dir search;
#line 14
allow rsync_t proc_t:{ file lnk_file } { getattr read };
#line 14
allow rsync_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 14
allow rsync_t fs_t:filesystem getattr;
#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow rsync_t sysctl_t:dir search;
#line 14
allow rsync_t sysctl_kernel_t:dir search;
#line 14
allow rsync_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14
allow rsync_t etc_t:file { getattr read };
#line 14

#line 14

#line 14
type rsync_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow rsync_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow rsync_t rsync_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow rsync_t rsync_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition rsync_t tmp_t:{ file dir } rsync_tmp_t;
#line 14

#line 14

#line 14

#line 14
allow rsync_t var_t:dir search;
#line 14

#line 14
type rsync_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow rsync_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow rsync_t rsync_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition rsync_t var_run_t:file rsync_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow rsync_t var_t:dir search;
#line 14
allow rsync_t rsync_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
# Inherit and use descriptors from inetd.
#line 14
allow rsync_t inetd_t:fd use;
#line 14

#line 14
# for identd
#line 14
allow rsync_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 14
allow rsync_t self:capability { setuid setgid };
#line 14
allow rsync_t home_root_t:dir search;
#line 14
allow rsync_t self:dir search;
#line 14
allow rsync_t self:{ lnk_file file } { getattr read };
#line 14

#line 14

#line 14
if (allow_kerberos) {
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow rsync_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow rsync_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow rsync_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow rsync_t node_type:node { tcp_send rawip_send };
#line 14
allow rsync_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow rsync_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow rsync_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow rsync_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow rsync_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow rsync_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow rsync_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow rsync_t node_type:node { udp_send rawip_send };
#line 14
allow rsync_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow rsync_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow rsync_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow rsync_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow rsync_t kerberos_port_t:tcp_socket name_connect;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow rsync_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow rsync_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow rsync_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow rsync_t node_type:node { tcp_send rawip_send };
#line 14
allow rsync_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow rsync_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow rsync_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow rsync_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow rsync_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow rsync_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow rsync_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow rsync_t node_type:node { udp_send rawip_send };
#line 14
allow rsync_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow rsync_t dns_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow rsync_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow rsync_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow rsync_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow rsync_t dns_port_t:tcp_socket name_connect;
#line 14

#line 14
}
#line 14
 dontaudit rsync_t krb5_conf_t:file write;
#line 14
allow rsync_t krb5_conf_t:file { getattr read };
#line 14

#line 14
allow rsync_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 14
# Use sockets inherited from inetd.
#line 14

#line 14
allow inetd_t rsync_port_t:udp_socket name_bind;
#line 14
allow rsync_t inetd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
#line 14
allow inetd_t rsync_port_t:tcp_socket name_bind;
#line 14
allow rsync_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 14

#line 14

#line 14

#line 14

#line 14
allow rsync_t proc_net_t:dir { read getattr lock search ioctl };
#line 14
allow rsync_t proc_net_t:file { read getattr lock ioctl };
#line 14
allow rsync_t proc_net_t:lnk_file { getattr read };
#line 14

#line 14

type rsync_data_t, file_type, sysadmfile;

#line 16
allow rsync_t rsync_data_t:dir { read getattr lock search ioctl };
#line 16
allow rsync_t rsync_data_t:file { read getattr lock ioctl };
#line 16
allow rsync_t rsync_data_t:lnk_file { getattr read };
#line 16


#line 17

#line 17
allow rsync_t { public_content_t public_content_rw_t } :dir { read getattr lock search ioctl };
#line 17
allow rsync_t { public_content_t public_content_rw_t } :file { read getattr lock ioctl };
#line 17
allow rsync_t { public_content_t public_content_rw_t } :lnk_file { getattr read };
#line 17

#line 17
bool allow_rsync_anon_write false;
#line 17
if (allow_rsync_anon_write) {
#line 17

#line 17
allow rsync_t public_content_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 17
allow rsync_t public_content_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 17
allow rsync_t public_content_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 17

#line 17
}
#line 17

allow rsync_t self:capability sys_chroot;
#line 1 "domains/program/samba.te"
#DESC SAMBA - SMB file server
#
# Author: Ryan Bergauer (bergauer@rice.edu)
# X-Debian-Packages: samba
#

#################################
#
# Declarations for Samba
#


#line 12

#line 12

#line 12

#line 12
type smbd_t, domain, privlog, daemon , auth_chkpwd, nscd_client_domain, transitionbool;
#line 12
type smbd_exec_t, file_type, sysadmfile, exec_type;
#line 12
dontaudit smbd_t self:capability sys_tty_config;
#line 12

#line 12
role system_r types smbd_t;
#line 12

#line 12
# Inherit and use descriptors from init.
#line 12
allow smbd_t init_t:fd use;
#line 12
allow smbd_t init_t:process sigchld;
#line 12
allow smbd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 12

#line 12

#line 12
allow smbd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 12
allow smbd_t lib_t:lnk_file { read getattr lock ioctl };
#line 12
allow smbd_t ld_so_t:file { read getattr lock execute ioctl };
#line 12
#allow smbd_t ld_so_t:file execute_no_trans;
#line 12
allow smbd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 12
allow smbd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 12
allow smbd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 12
allow smbd_t texrel_shlib_t:file execmod;
#line 12
allow smbd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 12
allow smbd_t device_t:dir search;
#line 12
allow smbd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
allow smbd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 12
allow smbd_t { self proc_t }:lnk_file { getattr read };
#line 12

#line 12
allow smbd_t device_t:dir { read getattr lock search ioctl };
#line 12

#line 12
allow smbd_t udev_tdb_t:file { read getattr lock ioctl };
#line 12
allow smbd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit smbd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit smbd_t unpriv_userdomain:fd use;
#line 12

#line 12

#line 12
allow smbd_t sysfs_t:dir { read getattr lock search ioctl };
#line 12
allow smbd_t sysfs_t:file { read getattr lock ioctl };
#line 12
allow smbd_t sysfs_t:lnk_file { getattr read };
#line 12
 
#line 12

#line 12
allow smbd_t autofs_t:dir { search getattr };
#line 12

#line 12
dontaudit smbd_t { tty_device_t devpts_t }:chr_file { read write };
#line 12
dontaudit smbd_t root_t:file { getattr read };
#line 12
 
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
# Read system variables in /sys.
#line 12

#line 12
allow smbd_t sysctl_t:dir search;
#line 12
allow smbd_t sysctl_kernel_t:dir search;
#line 12
allow smbd_t sysctl_kernel_t:file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allows user to define a tunable to disable domain transition
#line 12
#
#line 12

#line 12
bool smbd_disable_trans false;
#line 12
if (smbd_disable_trans) {
#line 12

#line 12
allow initrc_t smbd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12

#line 12
allow sysadm_t smbd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12
} else {
#line 12
 
#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow initrc_t smbd_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit initrc_t smbd_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit initrc_t smbd_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit initrc_t smbd_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow initrc_t smbd_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow smbd_t initrc_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow smbd_t initrc_t:fd use;
#line 12
allow initrc_t smbd_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow smbd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow smbd_t smbd_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow smbd_t smbd_exec_t:file entrypoint;
#line 12

#line 12
type_transition initrc_t smbd_exec_t:process smbd_t;
#line 12

#line 12

#line 12
allow initrc_t smbd_t:process { noatsecure siginh rlimitinh };
#line 12

#line 12
}
#line 12
 
#line 12
allow smbd_t privfd:fd use;
#line 12

#line 12
allow smbd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
# Create pid file.
#line 12
allow smbd_t var_t:dir { getattr search };
#line 12

#line 12
type smbd_var_run_t, file_type, sysadmfile, pidfile;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to modify the directory.
#line 12
#
#line 12
allow smbd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12
#
#line 12
# Allow the process to create the file.
#line 12
#
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow smbd_t smbd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
type_transition smbd_t var_run_t:file smbd_var_run_t;
#line 12

#line 12

#line 12

#line 12
allow smbd_t var_t:dir search;
#line 12
allow smbd_t smbd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12

#line 12
allow smbd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12
# for daemons that look at /root on startup
#line 12
dontaudit smbd_t sysadm_home_dir_t:dir search;
#line 12

#line 12
# for df
#line 12
allow smbd_t fs_type:filesystem getattr;
#line 12
allow smbd_t removable_t:filesystem getattr;
#line 12

#line 12

#line 12
allow smbd_t etc_t:lnk_file read;
#line 12
allow smbd_t lib_t:file { read getattr lock ioctl };
#line 12

#line 12
allow smbd_t locale_t:dir { read getattr lock search ioctl };
#line 12
allow smbd_t locale_t:file { read getattr lock ioctl };
#line 12
allow smbd_t locale_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12
# for localization
#line 12
allow smbd_t lib_t:file { getattr read };
#line 12


#line 13

#line 13

#line 13

#line 13
type nmbd_t, domain, privlog, daemon , transitionbool;
#line 13
type nmbd_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit nmbd_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types nmbd_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow nmbd_t init_t:fd use;
#line 13
allow nmbd_t init_t:process sigchld;
#line 13
allow nmbd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow nmbd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow nmbd_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow nmbd_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow nmbd_t ld_so_t:file execute_no_trans;
#line 13
allow nmbd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow nmbd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow nmbd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow nmbd_t texrel_shlib_t:file execmod;
#line 13
allow nmbd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow nmbd_t device_t:dir search;
#line 13
allow nmbd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow nmbd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow nmbd_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow nmbd_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow nmbd_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow nmbd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit nmbd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit nmbd_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow nmbd_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow nmbd_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow nmbd_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow nmbd_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit nmbd_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit nmbd_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow nmbd_t sysctl_t:dir search;
#line 13
allow nmbd_t sysctl_kernel_t:dir search;
#line 13
allow nmbd_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13

#line 13
bool nmbd_disable_trans false;
#line 13
if (nmbd_disable_trans) {
#line 13

#line 13
allow initrc_t nmbd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13

#line 13
allow sysadm_t nmbd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13
} else {
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t nmbd_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t nmbd_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t nmbd_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t nmbd_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t nmbd_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow nmbd_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow nmbd_t initrc_t:fd use;
#line 13
allow initrc_t nmbd_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow nmbd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow nmbd_t nmbd_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow nmbd_t nmbd_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t nmbd_exec_t:process nmbd_t;
#line 13

#line 13

#line 13
allow initrc_t nmbd_t:process { noatsecure siginh rlimitinh };
#line 13

#line 13
}
#line 13
 
#line 13
allow nmbd_t privfd:fd use;
#line 13

#line 13
allow nmbd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
# Create pid file.
#line 13
allow nmbd_t var_t:dir { getattr search };
#line 13

#line 13
type nmbd_var_run_t, file_type, sysadmfile, pidfile;
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow nmbd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow nmbd_t nmbd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition nmbd_t var_run_t:file nmbd_var_run_t;
#line 13

#line 13

#line 13

#line 13
allow nmbd_t var_t:dir search;
#line 13
allow nmbd_t nmbd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13

#line 13
allow nmbd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13
# for daemons that look at /root on startup
#line 13
dontaudit nmbd_t sysadm_home_dir_t:dir search;
#line 13

#line 13
# for df
#line 13
allow nmbd_t fs_type:filesystem getattr;
#line 13
allow nmbd_t removable_t:filesystem getattr;
#line 13

#line 13

#line 13
allow nmbd_t etc_t:lnk_file read;
#line 13
allow nmbd_t lib_t:file { read getattr lock ioctl };
#line 13

#line 13
allow nmbd_t locale_t:dir { read getattr lock search ioctl };
#line 13
allow nmbd_t locale_t:file { read getattr lock ioctl };
#line 13
allow nmbd_t locale_t:lnk_file { getattr read };
#line 13

#line 13

#line 13

#line 13
# for localization
#line 13
allow nmbd_t lib_t:file { getattr read };
#line 13

type samba_etc_t, file_type, sysadmfile, usercanread;
type samba_log_t, file_type, sysadmfile, logfile;
type samba_var_t, file_type, sysadmfile;
type samba_share_t, file_type, sysadmfile, customizable;
type samba_secrets_t, file_type, sysadmfile;

# for /var/run/samba/messages.tdb
allow smbd_t nmbd_var_run_t:file { ioctl read getattr lock write append };

allow smbd_t self:process setrlimit;

# not sure why it needs this

#line 26
type smbd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 26

#line 26

#line 26

#line 26

#line 26
#
#line 26
# Allow the process to modify the directory.
#line 26
#
#line 26
allow smbd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 26

#line 26
#
#line 26
# Allow the process to create the file.
#line 26
#
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
allow smbd_t smbd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
allow smbd_t smbd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
type_transition smbd_t tmp_t:{ file dir } smbd_tmp_t;
#line 26

#line 26

#line 26


# Allow samba to search mnt_t for potential mounted dirs
allow smbd_t mnt_t:dir { read getattr lock search ioctl };

#line 35

#line 35
allow system_crond_t samba_etc_t:file { read getattr lock };
#line 35
allow system_crond_t samba_log_t:file { read getattr lock };
#line 35
#allow system_crond_t samba_secrets_t:file { read getattr lock };
#line 35


#################################
#
# Rules for the smbd_t domain.
#

# Permissions normally found in every_domain.

#line 43
# Access other processes in the same domain.
#line 43
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 43
# These must be granted separately if desired.
#line 43
allow smbd_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 43

#line 43
# Access /proc/PID files for processes in the same domain.
#line 43
allow smbd_t self:dir { read getattr lock search ioctl };
#line 43
allow smbd_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 43

#line 43
# Access file descriptions, pipes, and sockets
#line 43
# created by processes in the same domain.
#line 43
allow smbd_t self:fd *;
#line 43
allow smbd_t self:fifo_file { ioctl read getattr lock write append };
#line 43
allow smbd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 43
allow smbd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 43

#line 43
# Allow the domain to communicate with other processes in the same domain.
#line 43
allow smbd_t self:unix_dgram_socket sendto;
#line 43
allow smbd_t self:unix_stream_socket connectto;
#line 43

#line 43
# Access System V IPC objects created by processes in the same domain.
#line 43
allow smbd_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 43
allow smbd_t self:msg  { send receive };
#line 43
allow smbd_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 43
allow smbd_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 43
allow smbd_t unpriv_userdomain:fd use;
#line 43
#
#line 43
# Every app is asking for ypbind so I am adding this here, 
#line 43
# eventually this should become can_nsswitch
#line 43
#
#line 43

#line 43

#line 43
if (allow_ypbind) {
#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43
#
#line 43
# Allow the domain to create and use tcp sockets.
#line 43
# Other kinds of sockets must be separately authorized for use.
#line 43
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 43

#line 43
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 43

#line 43
#
#line 43
# Allow the domain to send or receive using any network interface.
#line 43
# netif_type is a type attribute for all network interface types.
#line 43
#
#line 43
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 43
#
#line 43
# Allow the domain to send to or receive from any node.
#line 43
# node_type is a type attribute for all node types.
#line 43
#
#line 43
allow smbd_t node_type:node { tcp_send rawip_send };
#line 43
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 43

#line 43
#
#line 43
# Allow the domain to send to or receive from any port.
#line 43
# port_type is a type attribute for all port types.
#line 43
#
#line 43

#line 43
allow smbd_t port_type:tcp_socket { send_msg recv_msg };
#line 43

#line 43

#line 43
# XXX Allow binding to any node type.  Remove once
#line 43
# individual rules have been added to all domains that 
#line 43
# bind sockets. 
#line 43
allow smbd_t node_type:tcp_socket node_bind;
#line 43
#
#line 43
# Allow access to network files including /etc/resolv.conf
#line 43
#
#line 43
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 43

#line 43
allow smbd_t self:tcp_socket { listen accept };
#line 43

#line 43

#line 43

#line 43
#
#line 43
# Allow the domain to create and use tcp sockets.
#line 43
# Other kinds of sockets must be separately authorized for use.
#line 43
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 43

#line 43
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 43

#line 43
#
#line 43
# Allow the domain to send or receive using any network interface.
#line 43
# netif_type is a type attribute for all network interface types.
#line 43
#
#line 43
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 43
#
#line 43
# Allow the domain to send to or receive from any node.
#line 43
# node_type is a type attribute for all node types.
#line 43
#
#line 43
allow smbd_t node_type:node { tcp_send rawip_send };
#line 43
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 43

#line 43
#
#line 43
# Allow the domain to send to or receive from any port.
#line 43
# port_type is a type attribute for all port types.
#line 43
#
#line 43

#line 43
allow smbd_t port_type:tcp_socket { send_msg recv_msg };
#line 43

#line 43

#line 43
# XXX Allow binding to any node type.  Remove once
#line 43
# individual rules have been added to all domains that 
#line 43
# bind sockets. 
#line 43
allow smbd_t node_type:tcp_socket node_bind;
#line 43
#
#line 43
# Allow access to network files including /etc/resolv.conf
#line 43
#
#line 43
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 43

#line 43
allow smbd_t self:tcp_socket { connect };
#line 43

#line 43

#line 43

#line 43

#line 43

#line 43
#
#line 43
# Allow the domain to create and use udp sockets.
#line 43
# Other kinds of sockets must be separately authorized for use.
#line 43
allow smbd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 43

#line 43
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 43

#line 43
#
#line 43
# Allow the domain to send or receive using any network interface.
#line 43
# netif_type is a type attribute for all network interface types.
#line 43
#
#line 43
allow smbd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 43
#
#line 43
# Allow the domain to send to or receive from any node.
#line 43
# node_type is a type attribute for all node types.
#line 43
#
#line 43
allow smbd_t node_type:node { udp_send rawip_send };
#line 43
allow smbd_t node_type:node { udp_recv rawip_recv };
#line 43

#line 43
#
#line 43
# Allow the domain to send to or receive from any port.
#line 43
# port_type is a type attribute for all port types.
#line 43
#
#line 43

#line 43
allow smbd_t port_type:udp_socket { send_msg recv_msg };
#line 43

#line 43

#line 43
# XXX Allow binding to any node type.  Remove once
#line 43
# individual rules have been added to all domains that 
#line 43
# bind sockets. 
#line 43
allow smbd_t node_type:udp_socket node_bind;
#line 43
#
#line 43
# Allow access to network files including /etc/resolv.conf
#line 43
#
#line 43
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 43

#line 43
allow smbd_t self:udp_socket { connect };
#line 43

#line 43

#line 43

#line 43

#line 43

#line 43

#line 43
allow smbd_t var_yp_t:dir { read getattr lock search ioctl };
#line 43
allow smbd_t var_yp_t:file { read getattr lock ioctl };
#line 43
allow smbd_t var_yp_t:lnk_file { getattr read };
#line 43

#line 43
allow smbd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 43
allow smbd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 43
dontaudit smbd_t self:capability net_bind_service;
#line 43
dontaudit smbd_t reserved_port_type:tcp_socket name_connect;
#line 43
dontaudit smbd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 43

#line 43
} else {
#line 43
dontaudit smbd_t var_yp_t:dir search;
#line 43
}
#line 43
 
#line 43
allow smbd_t autofs_t:dir { search getattr };
#line 43


#line 44
# Read system information files in /proc.
#line 44

#line 44
allow smbd_t proc_t:dir { read getattr lock search ioctl };
#line 44
allow smbd_t proc_t:file { read getattr lock ioctl };
#line 44
allow smbd_t proc_t:lnk_file { getattr read };
#line 44

#line 44

#line 44
allow smbd_t proc_net_t:dir { read getattr lock search ioctl };
#line 44
allow smbd_t proc_net_t:file { read getattr lock ioctl };
#line 44
allow smbd_t proc_net_t:lnk_file { getattr read };
#line 44

#line 44
allow smbd_t proc_mdstat_t:file { read getattr lock ioctl };
#line 44

#line 44
# Stat /proc/kmsg and /proc/kcore.
#line 44
allow smbd_t proc_fs:file { getattr };
#line 44

#line 44
# Read system variables in /proc/sys.
#line 44

#line 44
# Read system variables in /sys.
#line 44

#line 44
allow smbd_t sysctl_t:dir search;
#line 44
allow smbd_t sysctl_kernel_t:dir search;
#line 44
allow smbd_t sysctl_kernel_t:file { getattr read };
#line 44

#line 44

#line 44

#line 44


allow smbd_t smbd_port_t:tcp_socket name_bind;

# Use capabilities.
allow smbd_t self:capability { fowner setgid setuid sys_resource net_bind_service lease dac_override dac_read_search };

# Use the network.

#line 52

#line 52

#line 52

#line 52

#line 52

#line 52
#
#line 52
# Allow the domain to create and use tcp sockets.
#line 52
# Other kinds of sockets must be separately authorized for use.
#line 52
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 52

#line 52
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 52

#line 52
#
#line 52
# Allow the domain to send or receive using any network interface.
#line 52
# netif_type is a type attribute for all network interface types.
#line 52
#
#line 52
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 52
#
#line 52
# Allow the domain to send to or receive from any node.
#line 52
# node_type is a type attribute for all node types.
#line 52
#
#line 52
allow smbd_t node_type:node { tcp_send rawip_send };
#line 52
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 52

#line 52
#
#line 52
# Allow the domain to send to or receive from any port.
#line 52
# port_type is a type attribute for all port types.
#line 52
#
#line 52

#line 52
allow smbd_t port_type:tcp_socket { send_msg recv_msg };
#line 52

#line 52

#line 52
# XXX Allow binding to any node type.  Remove once
#line 52
# individual rules have been added to all domains that 
#line 52
# bind sockets. 
#line 52
allow smbd_t node_type:tcp_socket node_bind;
#line 52
#
#line 52
# Allow access to network files including /etc/resolv.conf
#line 52
#
#line 52
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 52

#line 52
allow smbd_t self:tcp_socket { listen accept };
#line 52

#line 52

#line 52

#line 52
#
#line 52
# Allow the domain to create and use tcp sockets.
#line 52
# Other kinds of sockets must be separately authorized for use.
#line 52
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 52

#line 52
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 52

#line 52
#
#line 52
# Allow the domain to send or receive using any network interface.
#line 52
# netif_type is a type attribute for all network interface types.
#line 52
#
#line 52
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 52
#
#line 52
# Allow the domain to send to or receive from any node.
#line 52
# node_type is a type attribute for all node types.
#line 52
#
#line 52
allow smbd_t node_type:node { tcp_send rawip_send };
#line 52
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 52

#line 52
#
#line 52
# Allow the domain to send to or receive from any port.
#line 52
# port_type is a type attribute for all port types.
#line 52
#
#line 52

#line 52
allow smbd_t port_type:tcp_socket { send_msg recv_msg };
#line 52

#line 52

#line 52
# XXX Allow binding to any node type.  Remove once
#line 52
# individual rules have been added to all domains that 
#line 52
# bind sockets. 
#line 52
allow smbd_t node_type:tcp_socket node_bind;
#line 52
#
#line 52
# Allow access to network files including /etc/resolv.conf
#line 52
#
#line 52
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 52

#line 52
allow smbd_t self:tcp_socket { connect };
#line 52

#line 52

#line 52

#line 52

#line 52

#line 52
#
#line 52
# Allow the domain to create and use udp sockets.
#line 52
# Other kinds of sockets must be separately authorized for use.
#line 52
allow smbd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 52

#line 52
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 52

#line 52
#
#line 52
# Allow the domain to send or receive using any network interface.
#line 52
# netif_type is a type attribute for all network interface types.
#line 52
#
#line 52
allow smbd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 52
#
#line 52
# Allow the domain to send to or receive from any node.
#line 52
# node_type is a type attribute for all node types.
#line 52
#
#line 52
allow smbd_t node_type:node { udp_send rawip_send };
#line 52
allow smbd_t node_type:node { udp_recv rawip_recv };
#line 52

#line 52
#
#line 52
# Allow the domain to send to or receive from any port.
#line 52
# port_type is a type attribute for all port types.
#line 52
#
#line 52

#line 52
allow smbd_t port_type:udp_socket { send_msg recv_msg };
#line 52

#line 52

#line 52
# XXX Allow binding to any node type.  Remove once
#line 52
# individual rules have been added to all domains that 
#line 52
# bind sockets. 
#line 52
allow smbd_t node_type:udp_socket node_bind;
#line 52
#
#line 52
# Allow access to network files including /etc/resolv.conf
#line 52
#
#line 52
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 52

#line 52
allow smbd_t self:udp_socket { connect };
#line 52

#line 52

#line 52

#line 52

#line 52


#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow smbd_t node_type:node { tcp_send rawip_send };
#line 53
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow smbd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow smbd_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow smbd_t self:tcp_socket { connect };
#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use udp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow smbd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow smbd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow smbd_t node_type:node { udp_send rawip_send };
#line 53
allow smbd_t node_type:node { udp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow smbd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow smbd_t node_type:udp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow smbd_t self:udp_socket { connect };
#line 53

#line 53

#line 53

#line 53
allow smbd_t dns_port_t:tcp_socket name_connect;
#line 53

#line 53

#line 53

#line 53
if (allow_ypbind) {
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow smbd_t node_type:node { tcp_send rawip_send };
#line 53
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow smbd_t port_type:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow smbd_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow smbd_t self:tcp_socket { listen accept };
#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow smbd_t node_type:node { tcp_send rawip_send };
#line 53
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow smbd_t port_type:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow smbd_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow smbd_t self:tcp_socket { connect };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use udp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow smbd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow smbd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow smbd_t node_type:node { udp_send rawip_send };
#line 53
allow smbd_t node_type:node { udp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow smbd_t port_type:udp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow smbd_t node_type:udp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow smbd_t self:udp_socket { connect };
#line 53

#line 53

#line 53

#line 53

#line 53

#line 53

#line 53
allow smbd_t var_yp_t:dir { read getattr lock search ioctl };
#line 53
allow smbd_t var_yp_t:file { read getattr lock ioctl };
#line 53
allow smbd_t var_yp_t:lnk_file { getattr read };
#line 53

#line 53
allow smbd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 53
allow smbd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 53
dontaudit smbd_t self:capability net_bind_service;
#line 53
dontaudit smbd_t reserved_port_type:tcp_socket name_connect;
#line 53
dontaudit smbd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 53

#line 53
} else {
#line 53
dontaudit smbd_t var_yp_t:dir search;
#line 53
}
#line 53
 
#line 53

#line 53

#line 53

#line 53
#
#line 53
# Allow the domain to create and use tcp sockets.
#line 53
# Other kinds of sockets must be separately authorized for use.
#line 53
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 53

#line 53
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 53

#line 53
#
#line 53
# Allow the domain to send or receive using any network interface.
#line 53
# netif_type is a type attribute for all network interface types.
#line 53
#
#line 53
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 53
#
#line 53
# Allow the domain to send to or receive from any node.
#line 53
# node_type is a type attribute for all node types.
#line 53
#
#line 53
allow smbd_t node_type:node { tcp_send rawip_send };
#line 53
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 53

#line 53
#
#line 53
# Allow the domain to send to or receive from any port.
#line 53
# port_type is a type attribute for all port types.
#line 53
#
#line 53

#line 53
allow smbd_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 53

#line 53

#line 53
# XXX Allow binding to any node type.  Remove once
#line 53
# individual rules have been added to all domains that 
#line 53
# bind sockets. 
#line 53
allow smbd_t node_type:tcp_socket node_bind;
#line 53
#
#line 53
# Allow access to network files including /etc/resolv.conf
#line 53
#
#line 53
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 53

#line 53
allow smbd_t self:tcp_socket { connect };
#line 53

#line 53
allow smbd_t ldap_port_t:tcp_socket name_connect;
#line 53

#line 53

#line 53

#line 53
allow smbd_t winbind_var_run_t:dir { getattr search };
#line 53
allow smbd_t winbind_t:unix_stream_socket connectto;
#line 53
allow smbd_t winbind_var_run_t:sock_file { getattr read write };
#line 53

#line 53

#line 53


#line 54

#line 54
if (allow_kerberos) {
#line 54

#line 54

#line 54

#line 54

#line 54
#
#line 54
# Allow the domain to create and use tcp sockets.
#line 54
# Other kinds of sockets must be separately authorized for use.
#line 54
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 54

#line 54
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 54

#line 54
#
#line 54
# Allow the domain to send or receive using any network interface.
#line 54
# netif_type is a type attribute for all network interface types.
#line 54
#
#line 54
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 54
#
#line 54
# Allow the domain to send to or receive from any node.
#line 54
# node_type is a type attribute for all node types.
#line 54
#
#line 54
allow smbd_t node_type:node { tcp_send rawip_send };
#line 54
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 54

#line 54
#
#line 54
# Allow the domain to send to or receive from any port.
#line 54
# port_type is a type attribute for all port types.
#line 54
#
#line 54

#line 54
allow smbd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 54

#line 54

#line 54
# XXX Allow binding to any node type.  Remove once
#line 54
# individual rules have been added to all domains that 
#line 54
# bind sockets. 
#line 54
allow smbd_t node_type:tcp_socket node_bind;
#line 54
#
#line 54
# Allow access to network files including /etc/resolv.conf
#line 54
#
#line 54
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 54

#line 54
allow smbd_t self:tcp_socket { connect };
#line 54

#line 54

#line 54

#line 54
#
#line 54
# Allow the domain to create and use udp sockets.
#line 54
# Other kinds of sockets must be separately authorized for use.
#line 54
allow smbd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 54

#line 54
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 54

#line 54
#
#line 54
# Allow the domain to send or receive using any network interface.
#line 54
# netif_type is a type attribute for all network interface types.
#line 54
#
#line 54
allow smbd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 54
#
#line 54
# Allow the domain to send to or receive from any node.
#line 54
# node_type is a type attribute for all node types.
#line 54
#
#line 54
allow smbd_t node_type:node { udp_send rawip_send };
#line 54
allow smbd_t node_type:node { udp_recv rawip_recv };
#line 54

#line 54
#
#line 54
# Allow the domain to send to or receive from any port.
#line 54
# port_type is a type attribute for all port types.
#line 54
#
#line 54

#line 54
allow smbd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 54

#line 54

#line 54
# XXX Allow binding to any node type.  Remove once
#line 54
# individual rules have been added to all domains that 
#line 54
# bind sockets. 
#line 54
allow smbd_t node_type:udp_socket node_bind;
#line 54
#
#line 54
# Allow access to network files including /etc/resolv.conf
#line 54
#
#line 54
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 54

#line 54
allow smbd_t self:udp_socket { connect };
#line 54

#line 54

#line 54

#line 54
allow smbd_t kerberos_port_t:tcp_socket name_connect;
#line 54

#line 54

#line 54

#line 54

#line 54

#line 54
#
#line 54
# Allow the domain to create and use tcp sockets.
#line 54
# Other kinds of sockets must be separately authorized for use.
#line 54
allow smbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 54

#line 54
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 54

#line 54
#
#line 54
# Allow the domain to send or receive using any network interface.
#line 54
# netif_type is a type attribute for all network interface types.
#line 54
#
#line 54
allow smbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 54
#
#line 54
# Allow the domain to send to or receive from any node.
#line 54
# node_type is a type attribute for all node types.
#line 54
#
#line 54
allow smbd_t node_type:node { tcp_send rawip_send };
#line 54
allow smbd_t node_type:node { tcp_recv rawip_recv };
#line 54

#line 54
#
#line 54
# Allow the domain to send to or receive from any port.
#line 54
# port_type is a type attribute for all port types.
#line 54
#
#line 54

#line 54
allow smbd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 54

#line 54

#line 54
# XXX Allow binding to any node type.  Remove once
#line 54
# individual rules have been added to all domains that 
#line 54
# bind sockets. 
#line 54
allow smbd_t node_type:tcp_socket node_bind;
#line 54
#
#line 54
# Allow access to network files including /etc/resolv.conf
#line 54
#
#line 54
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 54

#line 54
allow smbd_t self:tcp_socket { connect };
#line 54

#line 54

#line 54

#line 54
#
#line 54
# Allow the domain to create and use udp sockets.
#line 54
# Other kinds of sockets must be separately authorized for use.
#line 54
allow smbd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 54

#line 54
allow smbd_t unlabeled_t:association { sendto recvfrom };
#line 54

#line 54
#
#line 54
# Allow the domain to send or receive using any network interface.
#line 54
# netif_type is a type attribute for all network interface types.
#line 54
#
#line 54
allow smbd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 54
#
#line 54
# Allow the domain to send to or receive from any node.
#line 54
# node_type is a type attribute for all node types.
#line 54
#
#line 54
allow smbd_t node_type:node { udp_send rawip_send };
#line 54
allow smbd_t node_type:node { udp_recv rawip_recv };
#line 54

#line 54
#
#line 54
# Allow the domain to send to or receive from any port.
#line 54
# port_type is a type attribute for all port types.
#line 54
#
#line 54

#line 54
allow smbd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 54

#line 54

#line 54
# XXX Allow binding to any node type.  Remove once
#line 54
# individual rules have been added to all domains that 
#line 54
# bind sockets. 
#line 54
allow smbd_t node_type:udp_socket node_bind;
#line 54
#
#line 54
# Allow access to network files including /etc/resolv.conf
#line 54
#
#line 54
allow smbd_t net_conf_t:file { read getattr lock ioctl };
#line 54

#line 54
allow smbd_t self:udp_socket { connect };
#line 54

#line 54

#line 54

#line 54
allow smbd_t dns_port_t:tcp_socket name_connect;
#line 54

#line 54
}
#line 54
 dontaudit smbd_t krb5_conf_t:file write;
#line 54
allow smbd_t krb5_conf_t:file { getattr read };
#line 54

allow smbd_t { smbd_port_t ipp_port_t }:tcp_socket name_connect;

allow smbd_t urandom_device_t:chr_file { getattr read };

# Permissions for Samba files in /etc/samba
# either allow read access to the directory or allow the auto_trans rule to
# allow creation of the secrets.tdb file and the MACHINE.SID file
#allow smbd_t samba_etc_t:dir { search getattr };

#line 63

#line 63

#line 63

#line 63
#
#line 63
# Allow the process to modify the directory.
#line 63
#
#line 63
allow smbd_t samba_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 63

#line 63
#
#line 63
# Allow the process to create the file.
#line 63
#
#line 63

#line 63

#line 63

#line 63

#line 63

#line 63
allow smbd_t samba_secrets_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 63

#line 63

#line 63

#line 63

#line 63

#line 63

#line 63

#line 63

#line 63

#line 63
type_transition smbd_t samba_etc_t:file samba_secrets_t;
#line 63

#line 63


allow smbd_t { etc_t samba_etc_t etc_runtime_t }:file { read getattr lock ioctl };

# Permissions for Samba cache files in /var/cache/samba and /var/lib/samba
allow smbd_t var_lib_t:dir search;

#line 69
allow smbd_t samba_var_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 69
allow smbd_t samba_var_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 69
allow smbd_t samba_var_t:lnk_file { create read getattr setattr link unlink rename };
#line 69


# Needed for shared printers
allow smbd_t var_spool_t:dir search;

# Permissions to write log files.
allow smbd_t samba_log_t:file { create { ioctl read getattr lock append } };
allow smbd_t var_log_t:dir search;
allow smbd_t samba_log_t:dir { read getattr lock search ioctl add_name write };
dontaudit smbd_t samba_log_t:dir remove_name;

#line 83

#line 83
dontaudit smbd_t { usbfs_t security_t devpts_t boot_t default_t tmpfs_t }:dir getattr;
#line 83
dontaudit smbd_t devpts_t:dir getattr;
#line 83

allow smbd_t fs_t:filesystem quotaget;

allow smbd_t usr_t:file { getattr read };

# Access Samba shares.

#line 89
allow smbd_t samba_share_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 89
allow smbd_t samba_share_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 89
allow smbd_t samba_share_t:lnk_file { create read getattr setattr link unlink rename };
#line 89



#line 91

#line 91
allow smbd_t { public_content_t public_content_rw_t } :dir { read getattr lock search ioctl };
#line 91
allow smbd_t { public_content_t public_content_rw_t } :file { read getattr lock ioctl };
#line 91
allow smbd_t { public_content_t public_content_rw_t } :lnk_file { getattr read };
#line 91

#line 91
bool allow_smbd_anon_write false;
#line 91
if (allow_smbd_anon_write) {
#line 91

#line 91
allow smbd_t public_content_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 91
allow smbd_t public_content_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 91
allow smbd_t public_content_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 91

#line 91
}
#line 91


#line 96

#################################
#
# Rules for the nmbd_t domain.
#

# Permissions normally found in every_domain.

#line 103
# Access other processes in the same domain.
#line 103
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 103
# These must be granted separately if desired.
#line 103
allow nmbd_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 103

#line 103
# Access /proc/PID files for processes in the same domain.
#line 103
allow nmbd_t self:dir { read getattr lock search ioctl };
#line 103
allow nmbd_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 103

#line 103
# Access file descriptions, pipes, and sockets
#line 103
# created by processes in the same domain.
#line 103
allow nmbd_t self:fd *;
#line 103
allow nmbd_t self:fifo_file { ioctl read getattr lock write append };
#line 103
allow nmbd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 103
allow nmbd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 103

#line 103
# Allow the domain to communicate with other processes in the same domain.
#line 103
allow nmbd_t self:unix_dgram_socket sendto;
#line 103
allow nmbd_t self:unix_stream_socket connectto;
#line 103

#line 103
# Access System V IPC objects created by processes in the same domain.
#line 103
allow nmbd_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 103
allow nmbd_t self:msg  { send receive };
#line 103
allow nmbd_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 103
allow nmbd_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 103
allow nmbd_t unpriv_userdomain:fd use;
#line 103
#
#line 103
# Every app is asking for ypbind so I am adding this here, 
#line 103
# eventually this should become can_nsswitch
#line 103
#
#line 103

#line 103

#line 103
if (allow_ypbind) {
#line 103

#line 103

#line 103

#line 103

#line 103

#line 103

#line 103

#line 103
#
#line 103
# Allow the domain to create and use tcp sockets.
#line 103
# Other kinds of sockets must be separately authorized for use.
#line 103
allow nmbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 103

#line 103
allow nmbd_t unlabeled_t:association { sendto recvfrom };
#line 103

#line 103
#
#line 103
# Allow the domain to send or receive using any network interface.
#line 103
# netif_type is a type attribute for all network interface types.
#line 103
#
#line 103
allow nmbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 103
#
#line 103
# Allow the domain to send to or receive from any node.
#line 103
# node_type is a type attribute for all node types.
#line 103
#
#line 103
allow nmbd_t node_type:node { tcp_send rawip_send };
#line 103
allow nmbd_t node_type:node { tcp_recv rawip_recv };
#line 103

#line 103
#
#line 103
# Allow the domain to send to or receive from any port.
#line 103
# port_type is a type attribute for all port types.
#line 103
#
#line 103

#line 103
allow nmbd_t port_type:tcp_socket { send_msg recv_msg };
#line 103

#line 103

#line 103
# XXX Allow binding to any node type.  Remove once
#line 103
# individual rules have been added to all domains that 
#line 103
# bind sockets. 
#line 103
allow nmbd_t node_type:tcp_socket node_bind;
#line 103
#
#line 103
# Allow access to network files including /etc/resolv.conf
#line 103
#
#line 103
allow nmbd_t net_conf_t:file { read getattr lock ioctl };
#line 103

#line 103
allow nmbd_t self:tcp_socket { listen accept };
#line 103

#line 103

#line 103

#line 103
#
#line 103
# Allow the domain to create and use tcp sockets.
#line 103
# Other kinds of sockets must be separately authorized for use.
#line 103
allow nmbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 103

#line 103
allow nmbd_t unlabeled_t:association { sendto recvfrom };
#line 103

#line 103
#
#line 103
# Allow the domain to send or receive using any network interface.
#line 103
# netif_type is a type attribute for all network interface types.
#line 103
#
#line 103
allow nmbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 103
#
#line 103
# Allow the domain to send to or receive from any node.
#line 103
# node_type is a type attribute for all node types.
#line 103
#
#line 103
allow nmbd_t node_type:node { tcp_send rawip_send };
#line 103
allow nmbd_t node_type:node { tcp_recv rawip_recv };
#line 103

#line 103
#
#line 103
# Allow the domain to send to or receive from any port.
#line 103
# port_type is a type attribute for all port types.
#line 103
#
#line 103

#line 103
allow nmbd_t port_type:tcp_socket { send_msg recv_msg };
#line 103

#line 103

#line 103
# XXX Allow binding to any node type.  Remove once
#line 103
# individual rules have been added to all domains that 
#line 103
# bind sockets. 
#line 103
allow nmbd_t node_type:tcp_socket node_bind;
#line 103
#
#line 103
# Allow access to network files including /etc/resolv.conf
#line 103
#
#line 103
allow nmbd_t net_conf_t:file { read getattr lock ioctl };
#line 103

#line 103
allow nmbd_t self:tcp_socket { connect };
#line 103

#line 103

#line 103

#line 103

#line 103

#line 103
#
#line 103
# Allow the domain to create and use udp sockets.
#line 103
# Other kinds of sockets must be separately authorized for use.
#line 103
allow nmbd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 103

#line 103
allow nmbd_t unlabeled_t:association { sendto recvfrom };
#line 103

#line 103
#
#line 103
# Allow the domain to send or receive using any network interface.
#line 103
# netif_type is a type attribute for all network interface types.
#line 103
#
#line 103
allow nmbd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 103
#
#line 103
# Allow the domain to send to or receive from any node.
#line 103
# node_type is a type attribute for all node types.
#line 103
#
#line 103
allow nmbd_t node_type:node { udp_send rawip_send };
#line 103
allow nmbd_t node_type:node { udp_recv rawip_recv };
#line 103

#line 103
#
#line 103
# Allow the domain to send to or receive from any port.
#line 103
# port_type is a type attribute for all port types.
#line 103
#
#line 103

#line 103
allow nmbd_t port_type:udp_socket { send_msg recv_msg };
#line 103

#line 103

#line 103
# XXX Allow binding to any node type.  Remove once
#line 103
# individual rules have been added to all domains that 
#line 103
# bind sockets. 
#line 103
allow nmbd_t node_type:udp_socket node_bind;
#line 103
#
#line 103
# Allow access to network files including /etc/resolv.conf
#line 103
#
#line 103
allow nmbd_t net_conf_t:file { read getattr lock ioctl };
#line 103

#line 103
allow nmbd_t self:udp_socket { connect };
#line 103

#line 103

#line 103

#line 103

#line 103

#line 103

#line 103
allow nmbd_t var_yp_t:dir { read getattr lock search ioctl };
#line 103
allow nmbd_t var_yp_t:file { read getattr lock ioctl };
#line 103
allow nmbd_t var_yp_t:lnk_file { getattr read };
#line 103

#line 103
allow nmbd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 103
allow nmbd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 103
dontaudit nmbd_t self:capability net_bind_service;
#line 103
dontaudit nmbd_t reserved_port_type:tcp_socket name_connect;
#line 103
dontaudit nmbd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 103

#line 103
} else {
#line 103
dontaudit nmbd_t var_yp_t:dir search;
#line 103
}
#line 103
 
#line 103
allow nmbd_t autofs_t:dir { search getattr };
#line 103


#line 104
# Read system information files in /proc.
#line 104

#line 104
allow nmbd_t proc_t:dir { read getattr lock search ioctl };
#line 104
allow nmbd_t proc_t:file { read getattr lock ioctl };
#line 104
allow nmbd_t proc_t:lnk_file { getattr read };
#line 104

#line 104

#line 104
allow nmbd_t proc_net_t:dir { read getattr lock search ioctl };
#line 104
allow nmbd_t proc_net_t:file { read getattr lock ioctl };
#line 104
allow nmbd_t proc_net_t:lnk_file { getattr read };
#line 104

#line 104
allow nmbd_t proc_mdstat_t:file { read getattr lock ioctl };
#line 104

#line 104
# Stat /proc/kmsg and /proc/kcore.
#line 104
allow nmbd_t proc_fs:file { getattr };
#line 104

#line 104
# Read system variables in /proc/sys.
#line 104

#line 104
# Read system variables in /sys.
#line 104

#line 104
allow nmbd_t sysctl_t:dir search;
#line 104
allow nmbd_t sysctl_kernel_t:dir search;
#line 104
allow nmbd_t sysctl_kernel_t:file { getattr read };
#line 104

#line 104

#line 104

#line 104


allow nmbd_t nmbd_port_t:udp_socket name_bind;

# Use capabilities.
allow nmbd_t self:capability net_bind_service;

# Use the network.

#line 112

#line 112

#line 112

#line 112
#
#line 112
# Allow the domain to create and use tcp sockets.
#line 112
# Other kinds of sockets must be separately authorized for use.
#line 112
allow nmbd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 112

#line 112
allow nmbd_t unlabeled_t:association { sendto recvfrom };
#line 112

#line 112
#
#line 112
# Allow the domain to send or receive using any network interface.
#line 112
# netif_type is a type attribute for all network interface types.
#line 112
#
#line 112
allow nmbd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 112
#
#line 112
# Allow the domain to send to or receive from any node.
#line 112
# node_type is a type attribute for all node types.
#line 112
#
#line 112
allow nmbd_t node_type:node { tcp_send rawip_send };
#line 112
allow nmbd_t node_type:node { tcp_recv rawip_recv };
#line 112

#line 112
#
#line 112
# Allow the domain to send to or receive from any port.
#line 112
# port_type is a type attribute for all port types.
#line 112
#
#line 112

#line 112
allow nmbd_t port_type:tcp_socket { send_msg recv_msg };
#line 112

#line 112

#line 112
# XXX Allow binding to any node type.  Remove once
#line 112
# individual rules have been added to all domains that 
#line 112
# bind sockets. 
#line 112
allow nmbd_t node_type:tcp_socket node_bind;
#line 112
#
#line 112
# Allow access to network files including /etc/resolv.conf
#line 112
#
#line 112
allow nmbd_t net_conf_t:file { read getattr lock ioctl };
#line 112

#line 112
allow nmbd_t self:tcp_socket { listen accept };
#line 112

#line 112

#line 112

#line 112
#
#line 112
# Allow the domain to create and use udp sockets.
#line 112
# Other kinds of sockets must be separately authorized for use.
#line 112
allow nmbd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 112

#line 112
allow nmbd_t unlabeled_t:association { sendto recvfrom };
#line 112

#line 112
#
#line 112
# Allow the domain to send or receive using any network interface.
#line 112
# netif_type is a type attribute for all network interface types.
#line 112
#
#line 112
allow nmbd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 112
#
#line 112
# Allow the domain to send to or receive from any node.
#line 112
# node_type is a type attribute for all node types.
#line 112
#
#line 112
allow nmbd_t node_type:node { udp_send rawip_send };
#line 112
allow nmbd_t node_type:node { udp_recv rawip_recv };
#line 112

#line 112
#
#line 112
# Allow the domain to send to or receive from any port.
#line 112
# port_type is a type attribute for all port types.
#line 112
#
#line 112

#line 112
allow nmbd_t port_type:udp_socket { send_msg recv_msg };
#line 112

#line 112

#line 112
# XXX Allow binding to any node type.  Remove once
#line 112
# individual rules have been added to all domains that 
#line 112
# bind sockets. 
#line 112
allow nmbd_t node_type:udp_socket node_bind;
#line 112
#
#line 112
# Allow access to network files including /etc/resolv.conf
#line 112
#
#line 112
allow nmbd_t net_conf_t:file { read getattr lock ioctl };
#line 112

#line 112
allow nmbd_t self:udp_socket { connect };
#line 112

#line 112

#line 112


# Permissions for Samba files in /etc/samba
allow nmbd_t samba_etc_t:file { getattr read };
allow nmbd_t samba_etc_t:dir { search getattr };

# Permissions for Samba cache files in /var/cache/samba
allow nmbd_t samba_var_t:dir { write remove_name add_name lock getattr search };
allow nmbd_t samba_var_t:file { lock unlink create write setattr read getattr rename };

allow nmbd_t usr_t:file { getattr read };

# Permissions to write log files.
allow nmbd_t samba_log_t:file { create { ioctl read getattr lock append } };
allow nmbd_t var_log_t:dir search;
allow nmbd_t samba_log_t:dir { read getattr lock search ioctl add_name write };
allow nmbd_t etc_t:file { getattr read };
#line 131

#line 131
allow smbd_t cupsd_rw_etc_t:file { getattr read };
#line 131

# Needed for winbindd
allow smbd_t { samba_var_t smbd_var_run_t }:sock_file { create ioctl read getattr lock write setattr append link unlink rename };

# Support Samba sharing of home directories
bool samba_enable_home_dirs false;

#line 199

# Derive from app. domain. Transition from mount.

#line 201
type samba_net_t, domain, privlog , nscd_client_domain;
#line 201
type samba_net_exec_t, file_type, sysadmfile, exec_type;
#line 201
role sysadm_r types samba_net_t;
#line 201

#line 201
role system_r types samba_net_t;
#line 201

#line 201

#line 201

#line 201

#line 201
#
#line 201
# Allow the process to transition to the new domain.
#line 201
#
#line 201
allow sysadm_t samba_net_t:process transition;
#line 201

#line 201
#
#line 201
# Do not audit when glibc secure mode is enabled upon the transition.
#line 201
#
#line 201
dontaudit sysadm_t samba_net_t:process noatsecure;
#line 201

#line 201
#
#line 201
# Do not audit when signal-related state is cleared upon the transition.
#line 201
#
#line 201
dontaudit sysadm_t samba_net_t:process siginh;
#line 201

#line 201
#
#line 201
# Do not audit when resource limits are reset upon the transition.
#line 201
#
#line 201
dontaudit sysadm_t samba_net_t:process rlimitinh;
#line 201

#line 201
#
#line 201
# Allow the process to execute the program.
#line 201
# 
#line 201
allow sysadm_t samba_net_exec_t:file { read { getattr execute } };
#line 201

#line 201
#
#line 201
# Allow the process to reap the new domain.
#line 201
#
#line 201
allow samba_net_t sysadm_t:process sigchld;
#line 201

#line 201
#
#line 201
# Allow the new domain to inherit and use file 
#line 201
# descriptions from the creating process and vice versa.
#line 201
#
#line 201
allow samba_net_t sysadm_t:fd use;
#line 201
allow sysadm_t samba_net_t:fd use;
#line 201

#line 201
#
#line 201
# Allow the new domain to write back to the old domain via a pipe.
#line 201
#
#line 201
allow samba_net_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 201

#line 201
#
#line 201
# Allow the new domain to read and execute the program.
#line 201
#
#line 201
allow samba_net_t samba_net_exec_t:file { read getattr lock execute ioctl };
#line 201

#line 201
#
#line 201
# Allow the new domain to be entered via the program.
#line 201
#
#line 201
allow samba_net_t samba_net_exec_t:file entrypoint;
#line 201

#line 201
type_transition sysadm_t samba_net_exec_t:process samba_net_t;
#line 201

#line 201

#line 201
allow samba_net_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 201
allow samba_net_t lib_t:lnk_file { read getattr lock ioctl };
#line 201
allow samba_net_t ld_so_t:file { read getattr lock execute ioctl };
#line 201
#allow samba_net_t ld_so_t:file execute_no_trans;
#line 201
allow samba_net_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 201
allow samba_net_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 201
allow samba_net_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 201
allow samba_net_t texrel_shlib_t:file execmod;
#line 201
allow samba_net_t ld_so_cache_t:file { read getattr lock ioctl };
#line 201
allow samba_net_t device_t:dir search;
#line 201
allow samba_net_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 201

#line 201

role system_r types samba_net_t;

#line 203
role user_r types samba_net_t;
#line 203
role staff_r types samba_net_t;
#line 203


#line 204

#line 204

#line 204

#line 204
#
#line 204
# Allow the process to modify the directory.
#line 204
#
#line 204
allow samba_net_t samba_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 204

#line 204
#
#line 204
# Allow the process to create the file.
#line 204
#
#line 204

#line 204

#line 204

#line 204

#line 204

#line 204
allow samba_net_t samba_secrets_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 204

#line 204

#line 204

#line 204

#line 204

#line 204

#line 204

#line 204

#line 204

#line 204
type_transition samba_net_t samba_etc_t:file samba_secrets_t;
#line 204

#line 204


#line 205
allow samba_net_t etc_t:lnk_file read;
#line 205
allow samba_net_t lib_t:file { read getattr lock ioctl };
#line 205

#line 205
allow samba_net_t locale_t:dir { read getattr lock search ioctl };
#line 205
allow samba_net_t locale_t:file { read getattr lock ioctl };
#line 205
allow samba_net_t locale_t:lnk_file { getattr read };
#line 205

#line 205
 
allow samba_net_t samba_etc_t:file { read getattr lock ioctl };

#line 207
allow samba_net_t samba_var_t:dir { read getattr lock search ioctl };
#line 207
allow samba_net_t samba_var_t:file { read getattr lock ioctl };
#line 207
allow samba_net_t samba_var_t:lnk_file { getattr read };
#line 207


#line 208

#line 208
#
#line 208
# Allow the domain to create and use udp sockets.
#line 208
# Other kinds of sockets must be separately authorized for use.
#line 208
allow samba_net_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 208

#line 208
allow samba_net_t unlabeled_t:association { sendto recvfrom };
#line 208

#line 208
#
#line 208
# Allow the domain to send or receive using any network interface.
#line 208
# netif_type is a type attribute for all network interface types.
#line 208
#
#line 208
allow samba_net_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 208
#
#line 208
# Allow the domain to send to or receive from any node.
#line 208
# node_type is a type attribute for all node types.
#line 208
#
#line 208
allow samba_net_t node_type:node { udp_send rawip_send };
#line 208
allow samba_net_t node_type:node { udp_recv rawip_recv };
#line 208

#line 208
#
#line 208
# Allow the domain to send to or receive from any port.
#line 208
# port_type is a type attribute for all port types.
#line 208
#
#line 208

#line 208
allow samba_net_t port_type:udp_socket { send_msg recv_msg };
#line 208

#line 208

#line 208
# XXX Allow binding to any node type.  Remove once
#line 208
# individual rules have been added to all domains that 
#line 208
# bind sockets. 
#line 208
allow samba_net_t node_type:udp_socket node_bind;
#line 208
#
#line 208
# Allow access to network files including /etc/resolv.conf
#line 208
#
#line 208
allow samba_net_t net_conf_t:file { read getattr lock ioctl };
#line 208

#line 208
allow samba_net_t self:udp_socket { connect };
#line 208


#line 209
allow samba_net_t sysadm_tty_device_t:chr_file { read write getattr ioctl };
#line 209
allow samba_net_t devtty_t:chr_file { read write getattr ioctl };
#line 209

#line 209
allow samba_net_t devpts_t:dir { read getattr lock search ioctl };
#line 209
allow samba_net_t sysadm_devpts_t:chr_file { ioctl read getattr lock write append };
#line 209

#line 209

allow samba_net_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow samba_net_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

#line 212
allow samba_net_t samba_var_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 212
allow samba_net_t samba_var_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 212
allow samba_net_t samba_var_t:lnk_file { create read getattr setattr link unlink rename };
#line 212

allow samba_net_t etc_t:file { getattr read };

#line 214

#line 214

#line 214

#line 214
#
#line 214
# Allow the domain to create and use tcp sockets.
#line 214
# Other kinds of sockets must be separately authorized for use.
#line 214
allow samba_net_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 214

#line 214
allow samba_net_t unlabeled_t:association { sendto recvfrom };
#line 214

#line 214
#
#line 214
# Allow the domain to send or receive using any network interface.
#line 214
# netif_type is a type attribute for all network interface types.
#line 214
#
#line 214
allow samba_net_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 214
#
#line 214
# Allow the domain to send to or receive from any node.
#line 214
# node_type is a type attribute for all node types.
#line 214
#
#line 214
allow samba_net_t node_type:node { tcp_send rawip_send };
#line 214
allow samba_net_t node_type:node { tcp_recv rawip_recv };
#line 214

#line 214
#
#line 214
# Allow the domain to send to or receive from any port.
#line 214
# port_type is a type attribute for all port types.
#line 214
#
#line 214

#line 214
allow samba_net_t port_type:tcp_socket { send_msg recv_msg };
#line 214

#line 214

#line 214
# XXX Allow binding to any node type.  Remove once
#line 214
# individual rules have been added to all domains that 
#line 214
# bind sockets. 
#line 214
allow samba_net_t node_type:tcp_socket node_bind;
#line 214
#
#line 214
# Allow access to network files including /etc/resolv.conf
#line 214
#
#line 214
allow samba_net_t net_conf_t:file { read getattr lock ioctl };
#line 214

#line 214
allow samba_net_t self:tcp_socket { connect };
#line 214

#line 214

#line 214

#line 214
#
#line 214
# Allow the domain to create and use udp sockets.
#line 214
# Other kinds of sockets must be separately authorized for use.
#line 214
allow samba_net_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 214

#line 214
allow samba_net_t unlabeled_t:association { sendto recvfrom };
#line 214

#line 214
#
#line 214
# Allow the domain to send or receive using any network interface.
#line 214
# netif_type is a type attribute for all network interface types.
#line 214
#
#line 214
allow samba_net_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 214
#
#line 214
# Allow the domain to send to or receive from any node.
#line 214
# node_type is a type attribute for all node types.
#line 214
#
#line 214
allow samba_net_t node_type:node { udp_send rawip_send };
#line 214
allow samba_net_t node_type:node { udp_recv rawip_recv };
#line 214

#line 214
#
#line 214
# Allow the domain to send to or receive from any port.
#line 214
# port_type is a type attribute for all port types.
#line 214
#
#line 214

#line 214
allow samba_net_t port_type:udp_socket { send_msg recv_msg };
#line 214

#line 214

#line 214
# XXX Allow binding to any node type.  Remove once
#line 214
# individual rules have been added to all domains that 
#line 214
# bind sockets. 
#line 214
allow samba_net_t node_type:udp_socket node_bind;
#line 214
#
#line 214
# Allow access to network files including /etc/resolv.conf
#line 214
#
#line 214
allow samba_net_t net_conf_t:file { read getattr lock ioctl };
#line 214

#line 214
allow samba_net_t self:udp_socket { connect };
#line 214

#line 214

#line 214

allow samba_net_t smbd_port_t:tcp_socket name_connect;

#line 216

#line 216

#line 216
#
#line 216
# Allow the domain to create and use tcp sockets.
#line 216
# Other kinds of sockets must be separately authorized for use.
#line 216
allow samba_net_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 216

#line 216
allow samba_net_t unlabeled_t:association { sendto recvfrom };
#line 216

#line 216
#
#line 216
# Allow the domain to send or receive using any network interface.
#line 216
# netif_type is a type attribute for all network interface types.
#line 216
#
#line 216
allow samba_net_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 216
#
#line 216
# Allow the domain to send to or receive from any node.
#line 216
# node_type is a type attribute for all node types.
#line 216
#
#line 216
allow samba_net_t node_type:node { tcp_send rawip_send };
#line 216
allow samba_net_t node_type:node { tcp_recv rawip_recv };
#line 216

#line 216
#
#line 216
# Allow the domain to send to or receive from any port.
#line 216
# port_type is a type attribute for all port types.
#line 216
#
#line 216

#line 216
allow samba_net_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 216

#line 216

#line 216
# XXX Allow binding to any node type.  Remove once
#line 216
# individual rules have been added to all domains that 
#line 216
# bind sockets. 
#line 216
allow samba_net_t node_type:tcp_socket node_bind;
#line 216
#
#line 216
# Allow access to network files including /etc/resolv.conf
#line 216
#
#line 216
allow samba_net_t net_conf_t:file { read getattr lock ioctl };
#line 216

#line 216
allow samba_net_t self:tcp_socket { connect };
#line 216

#line 216
allow samba_net_t ldap_port_t:tcp_socket name_connect;
#line 216


#line 217

#line 217
if (allow_kerberos) {
#line 217

#line 217

#line 217

#line 217

#line 217
#
#line 217
# Allow the domain to create and use tcp sockets.
#line 217
# Other kinds of sockets must be separately authorized for use.
#line 217
allow samba_net_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 217

#line 217
allow samba_net_t unlabeled_t:association { sendto recvfrom };
#line 217

#line 217
#
#line 217
# Allow the domain to send or receive using any network interface.
#line 217
# netif_type is a type attribute for all network interface types.
#line 217
#
#line 217
allow samba_net_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 217
#
#line 217
# Allow the domain to send to or receive from any node.
#line 217
# node_type is a type attribute for all node types.
#line 217
#
#line 217
allow samba_net_t node_type:node { tcp_send rawip_send };
#line 217
allow samba_net_t node_type:node { tcp_recv rawip_recv };
#line 217

#line 217
#
#line 217
# Allow the domain to send to or receive from any port.
#line 217
# port_type is a type attribute for all port types.
#line 217
#
#line 217

#line 217
allow samba_net_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 217

#line 217

#line 217
# XXX Allow binding to any node type.  Remove once
#line 217
# individual rules have been added to all domains that 
#line 217
# bind sockets. 
#line 217
allow samba_net_t node_type:tcp_socket node_bind;
#line 217
#
#line 217
# Allow access to network files including /etc/resolv.conf
#line 217
#
#line 217
allow samba_net_t net_conf_t:file { read getattr lock ioctl };
#line 217

#line 217
allow samba_net_t self:tcp_socket { connect };
#line 217

#line 217

#line 217

#line 217
#
#line 217
# Allow the domain to create and use udp sockets.
#line 217
# Other kinds of sockets must be separately authorized for use.
#line 217
allow samba_net_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 217

#line 217
allow samba_net_t unlabeled_t:association { sendto recvfrom };
#line 217

#line 217
#
#line 217
# Allow the domain to send or receive using any network interface.
#line 217
# netif_type is a type attribute for all network interface types.
#line 217
#
#line 217
allow samba_net_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 217
#
#line 217
# Allow the domain to send to or receive from any node.
#line 217
# node_type is a type attribute for all node types.
#line 217
#
#line 217
allow samba_net_t node_type:node { udp_send rawip_send };
#line 217
allow samba_net_t node_type:node { udp_recv rawip_recv };
#line 217

#line 217
#
#line 217
# Allow the domain to send to or receive from any port.
#line 217
# port_type is a type attribute for all port types.
#line 217
#
#line 217

#line 217
allow samba_net_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 217

#line 217

#line 217
# XXX Allow binding to any node type.  Remove once
#line 217
# individual rules have been added to all domains that 
#line 217
# bind sockets. 
#line 217
allow samba_net_t node_type:udp_socket node_bind;
#line 217
#
#line 217
# Allow access to network files including /etc/resolv.conf
#line 217
#
#line 217
allow samba_net_t net_conf_t:file { read getattr lock ioctl };
#line 217

#line 217
allow samba_net_t self:udp_socket { connect };
#line 217

#line 217

#line 217

#line 217
allow samba_net_t kerberos_port_t:tcp_socket name_connect;
#line 217

#line 217

#line 217

#line 217

#line 217

#line 217
#
#line 217
# Allow the domain to create and use tcp sockets.
#line 217
# Other kinds of sockets must be separately authorized for use.
#line 217
allow samba_net_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 217

#line 217
allow samba_net_t unlabeled_t:association { sendto recvfrom };
#line 217

#line 217
#
#line 217
# Allow the domain to send or receive using any network interface.
#line 217
# netif_type is a type attribute for all network interface types.
#line 217
#
#line 217
allow samba_net_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 217
#
#line 217
# Allow the domain to send to or receive from any node.
#line 217
# node_type is a type attribute for all node types.
#line 217
#
#line 217
allow samba_net_t node_type:node { tcp_send rawip_send };
#line 217
allow samba_net_t node_type:node { tcp_recv rawip_recv };
#line 217

#line 217
#
#line 217
# Allow the domain to send to or receive from any port.
#line 217
# port_type is a type attribute for all port types.
#line 217
#
#line 217

#line 217
allow samba_net_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 217

#line 217

#line 217
# XXX Allow binding to any node type.  Remove once
#line 217
# individual rules have been added to all domains that 
#line 217
# bind sockets. 
#line 217
allow samba_net_t node_type:tcp_socket node_bind;
#line 217
#
#line 217
# Allow access to network files including /etc/resolv.conf
#line 217
#
#line 217
allow samba_net_t net_conf_t:file { read getattr lock ioctl };
#line 217

#line 217
allow samba_net_t self:tcp_socket { connect };
#line 217

#line 217

#line 217

#line 217
#
#line 217
# Allow the domain to create and use udp sockets.
#line 217
# Other kinds of sockets must be separately authorized for use.
#line 217
allow samba_net_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 217

#line 217
allow samba_net_t unlabeled_t:association { sendto recvfrom };
#line 217

#line 217
#
#line 217
# Allow the domain to send or receive using any network interface.
#line 217
# netif_type is a type attribute for all network interface types.
#line 217
#
#line 217
allow samba_net_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 217
#
#line 217
# Allow the domain to send to or receive from any node.
#line 217
# node_type is a type attribute for all node types.
#line 217
#
#line 217
allow samba_net_t node_type:node { udp_send rawip_send };
#line 217
allow samba_net_t node_type:node { udp_recv rawip_recv };
#line 217

#line 217
#
#line 217
# Allow the domain to send to or receive from any port.
#line 217
# port_type is a type attribute for all port types.
#line 217
#
#line 217

#line 217
allow samba_net_t dns_port_t:udp_socket { send_msg recv_msg };
#line 217

#line 217

#line 217
# XXX Allow binding to any node type.  Remove once
#line 217
# individual rules have been added to all domains that 
#line 217
# bind sockets. 
#line 217
allow samba_net_t node_type:udp_socket node_bind;
#line 217
#
#line 217
# Allow access to network files including /etc/resolv.conf
#line 217
#
#line 217
allow samba_net_t net_conf_t:file { read getattr lock ioctl };
#line 217

#line 217
allow samba_net_t self:udp_socket { connect };
#line 217

#line 217

#line 217

#line 217
allow samba_net_t dns_port_t:tcp_socket name_connect;
#line 217

#line 217
}
#line 217
 dontaudit samba_net_t krb5_conf_t:file write;
#line 217
allow samba_net_t krb5_conf_t:file { getattr read };
#line 217

allow samba_net_t urandom_device_t:chr_file { read getattr lock ioctl };
allow samba_net_t proc_t:dir search;
allow samba_net_t proc_t:lnk_file read;
allow samba_net_t self:dir search;
allow samba_net_t self:file read;
allow samba_net_t self:process signal;

#line 224
type samba_net_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 224

#line 224

#line 224

#line 224

#line 224
#
#line 224
# Allow the process to modify the directory.
#line 224
#
#line 224
allow samba_net_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 224

#line 224
#
#line 224
# Allow the process to create the file.
#line 224
#
#line 224

#line 224

#line 224

#line 224

#line 224

#line 224
allow samba_net_t samba_net_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 224

#line 224

#line 224

#line 224

#line 224

#line 224

#line 224
allow samba_net_t samba_net_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 224

#line 224

#line 224

#line 224

#line 224

#line 224

#line 224

#line 224

#line 224

#line 224

#line 224

#line 224
type_transition samba_net_t tmp_t:{ file dir } samba_net_tmp_t;
#line 224

#line 224

#line 224

dontaudit samba_net_t sysadm_home_dir_t:dir search;
allow samba_net_t privfd:fd use;
#line 1 "domains/program/saslauthd.te"
#DESC saslauthd - Authentication daemon for SASL
#
# Author: Colin Walters <walters@verbum.org>
#


#line 6

#line 6

#line 6

#line 6
type saslauthd_t, domain, privlog, daemon , auth_chkpwd, auth_bool, transitionbool;
#line 6
type saslauthd_exec_t, file_type, sysadmfile, exec_type;
#line 6
dontaudit saslauthd_t self:capability sys_tty_config;
#line 6

#line 6
role system_r types saslauthd_t;
#line 6

#line 6
# Inherit and use descriptors from init.
#line 6
allow saslauthd_t init_t:fd use;
#line 6
allow saslauthd_t init_t:process sigchld;
#line 6
allow saslauthd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 6

#line 6

#line 6
allow saslauthd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 6
allow saslauthd_t lib_t:lnk_file { read getattr lock ioctl };
#line 6
allow saslauthd_t ld_so_t:file { read getattr lock execute ioctl };
#line 6
#allow saslauthd_t ld_so_t:file execute_no_trans;
#line 6
allow saslauthd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 6
allow saslauthd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 6
allow saslauthd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 6
allow saslauthd_t texrel_shlib_t:file execmod;
#line 6
allow saslauthd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 6
allow saslauthd_t device_t:dir search;
#line 6
allow saslauthd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 6

#line 6

#line 6
allow saslauthd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 6
allow saslauthd_t { self proc_t }:lnk_file { getattr read };
#line 6

#line 6
allow saslauthd_t device_t:dir { read getattr lock search ioctl };
#line 6

#line 6
allow saslauthd_t udev_tdb_t:file { read getattr lock ioctl };
#line 6
allow saslauthd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 6
dontaudit saslauthd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 6
dontaudit saslauthd_t unpriv_userdomain:fd use;
#line 6

#line 6

#line 6
allow saslauthd_t sysfs_t:dir { read getattr lock search ioctl };
#line 6
allow saslauthd_t sysfs_t:file { read getattr lock ioctl };
#line 6
allow saslauthd_t sysfs_t:lnk_file { getattr read };
#line 6
 
#line 6

#line 6
allow saslauthd_t autofs_t:dir { search getattr };
#line 6

#line 6
dontaudit saslauthd_t { tty_device_t devpts_t }:chr_file { read write };
#line 6
dontaudit saslauthd_t root_t:file { getattr read };
#line 6
 
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
# Read system variables in /sys.
#line 6

#line 6
allow saslauthd_t sysctl_t:dir search;
#line 6
allow saslauthd_t sysctl_kernel_t:dir search;
#line 6
allow saslauthd_t sysctl_kernel_t:file { getattr read };
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
#
#line 6
# Allows user to define a tunable to disable domain transition
#line 6
#
#line 6

#line 6
bool saslauthd_disable_trans false;
#line 6
if (saslauthd_disable_trans) {
#line 6

#line 6
allow initrc_t saslauthd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 6

#line 6

#line 6
allow sysadm_t saslauthd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 6

#line 6
} else {
#line 6
 
#line 6

#line 6

#line 6
#
#line 6
# Allow the process to transition to the new domain.
#line 6
#
#line 6
allow initrc_t saslauthd_t:process transition;
#line 6

#line 6
#
#line 6
# Do not audit when glibc secure mode is enabled upon the transition.
#line 6
#
#line 6
dontaudit initrc_t saslauthd_t:process noatsecure;
#line 6

#line 6
#
#line 6
# Do not audit when signal-related state is cleared upon the transition.
#line 6
#
#line 6
dontaudit initrc_t saslauthd_t:process siginh;
#line 6

#line 6
#
#line 6
# Do not audit when resource limits are reset upon the transition.
#line 6
#
#line 6
dontaudit initrc_t saslauthd_t:process rlimitinh;
#line 6

#line 6
#
#line 6
# Allow the process to execute the program.
#line 6
# 
#line 6
allow initrc_t saslauthd_exec_t:file { read { getattr execute } };
#line 6

#line 6
#
#line 6
# Allow the process to reap the new domain.
#line 6
#
#line 6
allow saslauthd_t initrc_t:process sigchld;
#line 6

#line 6
#
#line 6
# Allow the new domain to inherit and use file 
#line 6
# descriptions from the creating process and vice versa.
#line 6
#
#line 6
allow saslauthd_t initrc_t:fd use;
#line 6
allow initrc_t saslauthd_t:fd use;
#line 6

#line 6
#
#line 6
# Allow the new domain to write back to the old domain via a pipe.
#line 6
#
#line 6
allow saslauthd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 6

#line 6
#
#line 6
# Allow the new domain to read and execute the program.
#line 6
#
#line 6
allow saslauthd_t saslauthd_exec_t:file { read getattr lock execute ioctl };
#line 6

#line 6
#
#line 6
# Allow the new domain to be entered via the program.
#line 6
#
#line 6
allow saslauthd_t saslauthd_exec_t:file entrypoint;
#line 6

#line 6
type_transition initrc_t saslauthd_exec_t:process saslauthd_t;
#line 6

#line 6

#line 6
allow initrc_t saslauthd_t:process { noatsecure siginh rlimitinh };
#line 6

#line 6
}
#line 6
 
#line 6
allow saslauthd_t privfd:fd use;
#line 6

#line 6
allow saslauthd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 6

#line 6

#line 6
# Create pid file.
#line 6
allow saslauthd_t var_t:dir { getattr search };
#line 6

#line 6
type saslauthd_var_run_t, file_type, sysadmfile, pidfile;
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
#
#line 6
# Allow the process to modify the directory.
#line 6
#
#line 6
allow saslauthd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 6

#line 6
#
#line 6
# Allow the process to create the file.
#line 6
#
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
allow saslauthd_t saslauthd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
type_transition saslauthd_t var_run_t:file saslauthd_var_run_t;
#line 6

#line 6

#line 6

#line 6
allow saslauthd_t var_t:dir search;
#line 6
allow saslauthd_t saslauthd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 6

#line 6

#line 6
allow saslauthd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 6

#line 6
# for daemons that look at /root on startup
#line 6
dontaudit saslauthd_t sysadm_home_dir_t:dir search;
#line 6

#line 6
# for df
#line 6
allow saslauthd_t fs_type:filesystem getattr;
#line 6
allow saslauthd_t removable_t:filesystem getattr;
#line 6

#line 6

#line 6
allow saslauthd_t etc_t:lnk_file read;
#line 6
allow saslauthd_t lib_t:file { read getattr lock ioctl };
#line 6

#line 6
allow saslauthd_t locale_t:dir { read getattr lock search ioctl };
#line 6
allow saslauthd_t locale_t:file { read getattr lock ioctl };
#line 6
allow saslauthd_t locale_t:lnk_file { getattr read };
#line 6

#line 6

#line 6

#line 6
# for localization
#line 6
allow saslauthd_t lib_t:file { getattr read };
#line 6


allow saslauthd_t self:fifo_file { read write };
allow saslauthd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow saslauthd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow saslauthd_t saslauthd_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
allow saslauthd_t var_lib_t:dir search;

allow saslauthd_t etc_t:dir { getattr search };
allow saslauthd_t etc_t:file { read getattr lock ioctl };
allow saslauthd_t net_conf_t:file { read getattr lock ioctl };

allow saslauthd_t self:file { read getattr lock ioctl };
allow saslauthd_t proc_t:file { getattr read };

allow saslauthd_t urandom_device_t:chr_file { getattr read }; 

# Needs investigation
dontaudit saslauthd_t home_root_t:dir getattr;

#line 25

#line 25
#
#line 25
# Allow the domain to create and use tcp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow saslauthd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow saslauthd_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow saslauthd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow saslauthd_t node_type:node { tcp_send rawip_send };
#line 25
allow saslauthd_t node_type:node { tcp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow saslauthd_t port_type:tcp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow saslauthd_t node_type:tcp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow saslauthd_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow saslauthd_t self:tcp_socket { connect };
#line 25

allow saslauthd_t pop_port_t:tcp_socket name_connect;

bool allow_saslauthd_read_shadow false;

if (allow_saslauthd_read_shadow) {
allow saslauthd_t shadow_t:file { read getattr lock ioctl };
}
dontaudit saslauthd_t selinux_config_t:dir search;
dontaudit saslauthd_t selinux_config_t:file { getattr read };


dontaudit saslauthd_t initrc_t:unix_stream_socket connectto;
#line 41

#line 41
allow saslauthd_t mysqld_db_t:dir search;
#line 41
allow saslauthd_t mysqld_var_run_t:sock_file { ioctl read getattr lock write append };
#line 41

dontaudit saslauthd_t self:capability setuid;
#line 1 "domains/program/sendmail.te"
#DESC sendmail 
#
# Authors:  Daniel Walsh <dwalsh@redhat.com>
#

#################################
#
# Rules for the sendmaild domain.
#
# sendmail_exec_t is the type of the /usr/sbin/sendmail and other programs.
# This domain is defined just for targeted policy. 
#
type sendmail_exec_t, file_type, sysadmfile, exec_type;
type sendmail_log_t, file_type, sysadmfile;

#line 15

#line 15

#line 15
#
#line 15
# Allow the process to transition to the new domain.
#line 15
#
#line 15
allow initrc_t sendmail_t:process transition;
#line 15

#line 15
#
#line 15
# Do not audit when glibc secure mode is enabled upon the transition.
#line 15
#
#line 15
dontaudit initrc_t sendmail_t:process noatsecure;
#line 15

#line 15
#
#line 15
# Do not audit when signal-related state is cleared upon the transition.
#line 15
#
#line 15
dontaudit initrc_t sendmail_t:process siginh;
#line 15

#line 15
#
#line 15
# Do not audit when resource limits are reset upon the transition.
#line 15
#
#line 15
dontaudit initrc_t sendmail_t:process rlimitinh;
#line 15

#line 15
#
#line 15
# Allow the process to execute the program.
#line 15
# 
#line 15
allow initrc_t sendmail_exec_t:file { read { getattr execute } };
#line 15

#line 15
#
#line 15
# Allow the process to reap the new domain.
#line 15
#
#line 15
allow sendmail_t initrc_t:process sigchld;
#line 15

#line 15
#
#line 15
# Allow the new domain to inherit and use file 
#line 15
# descriptions from the creating process and vice versa.
#line 15
#
#line 15
allow sendmail_t initrc_t:fd use;
#line 15
allow initrc_t sendmail_t:fd use;
#line 15

#line 15
#
#line 15
# Allow the new domain to write back to the old domain via a pipe.
#line 15
#
#line 15
allow sendmail_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 15

#line 15
#
#line 15
# Allow the new domain to read and execute the program.
#line 15
#
#line 15
allow sendmail_t sendmail_exec_t:file { read getattr lock execute ioctl };
#line 15

#line 15
#
#line 15
# Allow the new domain to be entered via the program.
#line 15
#
#line 15
allow sendmail_t sendmail_exec_t:file entrypoint;
#line 15

#line 15
type_transition initrc_t sendmail_exec_t:process sendmail_t;
#line 15


#line 16
type sendmail_var_run_t, file_type, sysadmfile, pidfile;
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the process to modify the directory.
#line 16
#
#line 16
allow sendmail_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 16

#line 16
#
#line 16
# Allow the process to create the file.
#line 16
#
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
allow sendmail_t sendmail_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
type_transition sendmail_t var_run_t:file sendmail_var_run_t;
#line 16

#line 16

#line 16

#line 16
allow sendmail_t var_t:dir search;
#line 16
allow sendmail_t sendmail_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 16


#line 1 "domains/program/setfiles.te"
#DESC Setfiles - SELinux filesystem labeling utilities
#
# Authors:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: policycoreutils
#

#################################
#
# Rules for the setfiles_t domain.
#
# setfiles_exec_t is the type of the setfiles executable.
#
# needs auth_write attribute because it has relabelfrom/relabelto
# access to shadow_t
type setfiles_t, domain, privlog, privowner, auth_write, change_context, mlsfileread, mlsfilewrite, mlsfileupgrade, mlsfiledowngrade;
type setfiles_exec_t, file_type, sysadmfile, exec_type;

role system_r types setfiles_t;
role sysadm_r types setfiles_t;
role secadm_r types setfiles_t;

#line 24

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the process to transition to the new domain.
#line 24
#
#line 24
allow initrc_t setfiles_t:process transition;
#line 24

#line 24
#
#line 24
# Do not audit when glibc secure mode is enabled upon the transition.
#line 24
#
#line 24
dontaudit initrc_t setfiles_t:process noatsecure;
#line 24

#line 24
#
#line 24
# Do not audit when signal-related state is cleared upon the transition.
#line 24
#
#line 24
dontaudit initrc_t setfiles_t:process siginh;
#line 24

#line 24
#
#line 24
# Do not audit when resource limits are reset upon the transition.
#line 24
#
#line 24
dontaudit initrc_t setfiles_t:process rlimitinh;
#line 24

#line 24
#
#line 24
# Allow the process to execute the program.
#line 24
# 
#line 24
allow initrc_t setfiles_exec_t:file { read { getattr execute } };
#line 24

#line 24
#
#line 24
# Allow the process to reap the new domain.
#line 24
#
#line 24
allow setfiles_t initrc_t:process sigchld;
#line 24

#line 24
#
#line 24
# Allow the new domain to inherit and use file 
#line 24
# descriptions from the creating process and vice versa.
#line 24
#
#line 24
allow setfiles_t initrc_t:fd use;
#line 24
allow initrc_t setfiles_t:fd use;
#line 24

#line 24
#
#line 24
# Allow the new domain to write back to the old domain via a pipe.
#line 24
#
#line 24
allow setfiles_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 24

#line 24
#
#line 24
# Allow the new domain to read and execute the program.
#line 24
#
#line 24
allow setfiles_t setfiles_exec_t:file { read getattr lock execute ioctl };
#line 24

#line 24
#
#line 24
# Allow the new domain to be entered via the program.
#line 24
#
#line 24
allow setfiles_t setfiles_exec_t:file entrypoint;
#line 24

#line 24
type_transition initrc_t setfiles_exec_t:process setfiles_t;
#line 24

#line 24


#line 25
allow hostname_t devpts_t:dir { read getattr lock search ioctl };
#line 25
allow hostname_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 25

allow setfiles_t { ttyfile ptyfile tty_device_t admin_tty_type devtty_t }:chr_file { read write ioctl };

allow setfiles_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };


#line 30

#line 30

#line 30
#
#line 30
# Allow the process to transition to the new domain.
#line 30
#
#line 30
allow secadmin setfiles_t:process transition;
#line 30

#line 30
#
#line 30
# Do not audit when glibc secure mode is enabled upon the transition.
#line 30
#
#line 30
dontaudit secadmin setfiles_t:process noatsecure;
#line 30

#line 30
#
#line 30
# Do not audit when signal-related state is cleared upon the transition.
#line 30
#
#line 30
dontaudit secadmin setfiles_t:process siginh;
#line 30

#line 30
#
#line 30
# Do not audit when resource limits are reset upon the transition.
#line 30
#
#line 30
dontaudit secadmin setfiles_t:process rlimitinh;
#line 30

#line 30
#
#line 30
# Allow the process to execute the program.
#line 30
# 
#line 30
allow secadmin setfiles_exec_t:file { read { getattr execute } };
#line 30

#line 30
#
#line 30
# Allow the process to reap the new domain.
#line 30
#
#line 30
allow setfiles_t secadmin:process sigchld;
#line 30

#line 30
#
#line 30
# Allow the new domain to inherit and use file 
#line 30
# descriptions from the creating process and vice versa.
#line 30
#
#line 30
allow setfiles_t secadmin:fd use;
#line 30
allow secadmin setfiles_t:fd use;
#line 30

#line 30
#
#line 30
# Allow the new domain to write back to the old domain via a pipe.
#line 30
#
#line 30
allow setfiles_t secadmin:fifo_file { ioctl read getattr lock write append };
#line 30

#line 30
#
#line 30
# Allow the new domain to read and execute the program.
#line 30
#
#line 30
allow setfiles_t setfiles_exec_t:file { read getattr lock execute ioctl };
#line 30

#line 30
#
#line 30
# Allow the new domain to be entered via the program.
#line 30
#
#line 30
allow setfiles_t setfiles_exec_t:file entrypoint;
#line 30

#line 30
type_transition secadmin setfiles_exec_t:process setfiles_t;
#line 30

allow setfiles_t { userdomain privfd initrc_t init_t }:fd use;


#line 33
allow setfiles_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 33
allow setfiles_t lib_t:lnk_file { read getattr lock ioctl };
#line 33
allow setfiles_t ld_so_t:file { read getattr lock execute ioctl };
#line 33
#allow setfiles_t ld_so_t:file execute_no_trans;
#line 33
allow setfiles_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 33
allow setfiles_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 33
allow setfiles_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 33
allow setfiles_t texrel_shlib_t:file execmod;
#line 33
allow setfiles_t ld_so_cache_t:file { read getattr lock ioctl };
#line 33
allow setfiles_t device_t:dir search;
#line 33
allow setfiles_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 33

allow setfiles_t self:capability { dac_override dac_read_search fowner };

# for upgrading glibc and other shared objects - without this the upgrade
# scripts will put things in a state such that setfiles can not be run!
allow setfiles_t lib_t:file { read execute };

# Get security policy decisions.

#line 41
# Get the selinuxfs mount point via /proc/self/mounts.
#line 41
allow setfiles_t proc_t:dir search;
#line 41
allow setfiles_t proc_t:{ file lnk_file } { getattr read };
#line 41
allow setfiles_t self:dir search;
#line 41
allow setfiles_t self:file { getattr read };
#line 41
# Access selinuxfs.
#line 41
allow setfiles_t security_t:dir { read search getattr };
#line 41
allow setfiles_t security_t:file { getattr read write };
#line 41
allow setfiles_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 41



#line 43
allow setfiles_t { policy_src_t policy_config_t file_context_t selinux_config_t default_context_t }:dir { read getattr lock search ioctl };
#line 43
allow setfiles_t { policy_src_t policy_config_t file_context_t selinux_config_t default_context_t }:file { read getattr lock ioctl };
#line 43
allow setfiles_t { policy_src_t policy_config_t file_context_t selinux_config_t default_context_t }:lnk_file { getattr read };
#line 43


allow setfiles_t file_type:dir { read getattr lock search ioctl };
allow setfiles_t { file_type unlabeled_t device_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } { getattr relabelfrom };
allow setfiles_t file_type:{ dir file lnk_file sock_file fifo_file } relabelto;
allow setfiles_t unlabeled_t:dir read;
allow setfiles_t { device_type device_t }:{ chr_file blk_file } { getattr relabelfrom relabelto };
allow setfiles_t { ttyfile ptyfile }:chr_file getattr;
# dontaudit access to ttyfile - we do not want setfiles to relabel our terminal
dontaudit setfiles_t ttyfile:chr_file relabelfrom;

allow setfiles_t fs_t:filesystem getattr;
allow setfiles_t fs_type:dir { read getattr lock search ioctl };


#line 57
allow setfiles_t etc_t:lnk_file read;
#line 57
allow setfiles_t lib_t:file { read getattr lock ioctl };
#line 57

#line 57
allow setfiles_t locale_t:dir { read getattr lock search ioctl };
#line 57
allow setfiles_t locale_t:file { read getattr lock ioctl };
#line 57
allow setfiles_t locale_t:lnk_file { getattr read };
#line 57

#line 57


allow setfiles_t etc_runtime_t:file { getattr read };
allow setfiles_t etc_t:file { getattr read };
allow setfiles_t proc_t:file { getattr read };
dontaudit setfiles_t proc_t:lnk_file { getattr read };

# for config files in a home directory
allow setfiles_t home_type:file { read getattr lock ioctl };
dontaudit setfiles_t sysadm_tty_device_t:chr_file relabelfrom;
#line 1 "domains/program/slapd.te"
#DESC Slapd - OpenLDAP server
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: slapd
#

#################################
#
# Rules for the slapd_t domain.
#
# slapd_exec_t is the type of the slapd executable.
#

#line 13

#line 13

#line 13

#line 13
type slapd_t, domain, privlog, daemon , transitionbool;
#line 13
type slapd_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit slapd_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types slapd_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow slapd_t init_t:fd use;
#line 13
allow slapd_t init_t:process sigchld;
#line 13
allow slapd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow slapd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow slapd_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow slapd_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow slapd_t ld_so_t:file execute_no_trans;
#line 13
allow slapd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow slapd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow slapd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow slapd_t texrel_shlib_t:file execmod;
#line 13
allow slapd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow slapd_t device_t:dir search;
#line 13
allow slapd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow slapd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow slapd_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow slapd_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow slapd_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow slapd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit slapd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit slapd_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow slapd_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow slapd_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow slapd_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow slapd_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit slapd_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit slapd_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow slapd_t sysctl_t:dir search;
#line 13
allow slapd_t sysctl_kernel_t:dir search;
#line 13
allow slapd_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13

#line 13
bool slapd_disable_trans false;
#line 13
if (slapd_disable_trans) {
#line 13

#line 13
allow initrc_t slapd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13

#line 13
allow sysadm_t slapd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13
} else {
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t slapd_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t slapd_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t slapd_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t slapd_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t slapd_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow slapd_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow slapd_t initrc_t:fd use;
#line 13
allow initrc_t slapd_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow slapd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow slapd_t slapd_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow slapd_t slapd_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t slapd_exec_t:process slapd_t;
#line 13

#line 13

#line 13
allow initrc_t slapd_t:process { noatsecure siginh rlimitinh };
#line 13

#line 13
}
#line 13
 
#line 13
allow slapd_t privfd:fd use;
#line 13

#line 13
allow slapd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
# Create pid file.
#line 13
allow slapd_t var_t:dir { getattr search };
#line 13

#line 13
type slapd_var_run_t, file_type, sysadmfile, pidfile;
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow slapd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow slapd_t slapd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition slapd_t var_run_t:file slapd_var_run_t;
#line 13

#line 13

#line 13

#line 13
allow slapd_t var_t:dir search;
#line 13
allow slapd_t slapd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13

#line 13
allow slapd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13
# for daemons that look at /root on startup
#line 13
dontaudit slapd_t sysadm_home_dir_t:dir search;
#line 13

#line 13
# for df
#line 13
allow slapd_t fs_type:filesystem getattr;
#line 13
allow slapd_t removable_t:filesystem getattr;
#line 13

#line 13

#line 13
allow slapd_t etc_t:lnk_file read;
#line 13
allow slapd_t lib_t:file { read getattr lock ioctl };
#line 13

#line 13
allow slapd_t locale_t:dir { read getattr lock search ioctl };
#line 13
allow slapd_t locale_t:file { read getattr lock ioctl };
#line 13
allow slapd_t locale_t:lnk_file { getattr read };
#line 13

#line 13

#line 13

#line 13
# for localization
#line 13
allow slapd_t lib_t:file { getattr read };
#line 13


allow slapd_t ldap_port_t:tcp_socket name_bind;


#line 17
type slapd_etc_t, file_type, sysadmfile, usercanread;
#line 17
allow slapd_t slapd_etc_t:file { read getattr lock ioctl };
#line 17

type slapd_db_t, file_type, sysadmfile;
type slapd_replog_t, file_type, sysadmfile;


#line 21
type slapd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 21

#line 21

#line 21

#line 21

#line 21
#
#line 21
# Allow the process to modify the directory.
#line 21
#
#line 21
allow slapd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 21

#line 21
#
#line 21
# Allow the process to create the file.
#line 21
#
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
allow slapd_t slapd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
allow slapd_t slapd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21

#line 21
type_transition slapd_t tmp_t:{ file dir } slapd_tmp_t;
#line 21

#line 21

#line 21


# Use the network.

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the domain to create and use tcp sockets.
#line 24
# Other kinds of sockets must be separately authorized for use.
#line 24
allow slapd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 24

#line 24
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 24

#line 24
#
#line 24
# Allow the domain to send or receive using any network interface.
#line 24
# netif_type is a type attribute for all network interface types.
#line 24
#
#line 24
allow slapd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 24
#
#line 24
# Allow the domain to send to or receive from any node.
#line 24
# node_type is a type attribute for all node types.
#line 24
#
#line 24
allow slapd_t node_type:node { tcp_send rawip_send };
#line 24
allow slapd_t node_type:node { tcp_recv rawip_recv };
#line 24

#line 24
#
#line 24
# Allow the domain to send to or receive from any port.
#line 24
# port_type is a type attribute for all port types.
#line 24
#
#line 24

#line 24
allow slapd_t port_type:tcp_socket { send_msg recv_msg };
#line 24

#line 24

#line 24
# XXX Allow binding to any node type.  Remove once
#line 24
# individual rules have been added to all domains that 
#line 24
# bind sockets. 
#line 24
allow slapd_t node_type:tcp_socket node_bind;
#line 24
#
#line 24
# Allow access to network files including /etc/resolv.conf
#line 24
#
#line 24
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 24

#line 24
allow slapd_t self:tcp_socket { listen accept };
#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the domain to create and use tcp sockets.
#line 24
# Other kinds of sockets must be separately authorized for use.
#line 24
allow slapd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 24

#line 24
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 24

#line 24
#
#line 24
# Allow the domain to send or receive using any network interface.
#line 24
# netif_type is a type attribute for all network interface types.
#line 24
#
#line 24
allow slapd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 24
#
#line 24
# Allow the domain to send to or receive from any node.
#line 24
# node_type is a type attribute for all node types.
#line 24
#
#line 24
allow slapd_t node_type:node { tcp_send rawip_send };
#line 24
allow slapd_t node_type:node { tcp_recv rawip_recv };
#line 24

#line 24
#
#line 24
# Allow the domain to send to or receive from any port.
#line 24
# port_type is a type attribute for all port types.
#line 24
#
#line 24

#line 24
allow slapd_t port_type:tcp_socket { send_msg recv_msg };
#line 24

#line 24

#line 24
# XXX Allow binding to any node type.  Remove once
#line 24
# individual rules have been added to all domains that 
#line 24
# bind sockets. 
#line 24
allow slapd_t node_type:tcp_socket node_bind;
#line 24
#
#line 24
# Allow access to network files including /etc/resolv.conf
#line 24
#
#line 24
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 24

#line 24
allow slapd_t self:tcp_socket { connect };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the domain to create and use udp sockets.
#line 24
# Other kinds of sockets must be separately authorized for use.
#line 24
allow slapd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 24

#line 24
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 24

#line 24
#
#line 24
# Allow the domain to send or receive using any network interface.
#line 24
# netif_type is a type attribute for all network interface types.
#line 24
#
#line 24
allow slapd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 24
#
#line 24
# Allow the domain to send to or receive from any node.
#line 24
# node_type is a type attribute for all node types.
#line 24
#
#line 24
allow slapd_t node_type:node { udp_send rawip_send };
#line 24
allow slapd_t node_type:node { udp_recv rawip_recv };
#line 24

#line 24
#
#line 24
# Allow the domain to send to or receive from any port.
#line 24
# port_type is a type attribute for all port types.
#line 24
#
#line 24

#line 24
allow slapd_t port_type:udp_socket { send_msg recv_msg };
#line 24

#line 24

#line 24
# XXX Allow binding to any node type.  Remove once
#line 24
# individual rules have been added to all domains that 
#line 24
# bind sockets. 
#line 24
allow slapd_t node_type:udp_socket node_bind;
#line 24
#
#line 24
# Allow access to network files including /etc/resolv.conf
#line 24
#
#line 24
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 24

#line 24
allow slapd_t self:udp_socket { connect };
#line 24

#line 24

#line 24

#line 24

#line 24


#line 25

#line 25
if (allow_kerberos) {
#line 25

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use tcp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow slapd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow slapd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow slapd_t node_type:node { tcp_send rawip_send };
#line 25
allow slapd_t node_type:node { tcp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow slapd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow slapd_t node_type:tcp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow slapd_t self:tcp_socket { connect };
#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use udp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow slapd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow slapd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow slapd_t node_type:node { udp_send rawip_send };
#line 25
allow slapd_t node_type:node { udp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow slapd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow slapd_t node_type:udp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow slapd_t self:udp_socket { connect };
#line 25

#line 25

#line 25

#line 25
allow slapd_t kerberos_port_t:tcp_socket name_connect;
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use tcp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow slapd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow slapd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow slapd_t node_type:node { tcp_send rawip_send };
#line 25
allow slapd_t node_type:node { tcp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow slapd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow slapd_t node_type:tcp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow slapd_t self:tcp_socket { connect };
#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the domain to create and use udp sockets.
#line 25
# Other kinds of sockets must be separately authorized for use.
#line 25
allow slapd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 25

#line 25
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 25

#line 25
#
#line 25
# Allow the domain to send or receive using any network interface.
#line 25
# netif_type is a type attribute for all network interface types.
#line 25
#
#line 25
allow slapd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 25
#
#line 25
# Allow the domain to send to or receive from any node.
#line 25
# node_type is a type attribute for all node types.
#line 25
#
#line 25
allow slapd_t node_type:node { udp_send rawip_send };
#line 25
allow slapd_t node_type:node { udp_recv rawip_recv };
#line 25

#line 25
#
#line 25
# Allow the domain to send to or receive from any port.
#line 25
# port_type is a type attribute for all port types.
#line 25
#
#line 25

#line 25
allow slapd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 25

#line 25

#line 25
# XXX Allow binding to any node type.  Remove once
#line 25
# individual rules have been added to all domains that 
#line 25
# bind sockets. 
#line 25
allow slapd_t node_type:udp_socket node_bind;
#line 25
#
#line 25
# Allow access to network files including /etc/resolv.conf
#line 25
#
#line 25
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 25

#line 25
allow slapd_t self:udp_socket { connect };
#line 25

#line 25

#line 25

#line 25
allow slapd_t dns_port_t:tcp_socket name_connect;
#line 25

#line 25
}
#line 25
 dontaudit slapd_t krb5_conf_t:file write;
#line 25
allow slapd_t krb5_conf_t:file { getattr read };
#line 25

allow slapd_t port_type:tcp_socket name_connect;

#line 27

#line 27
if (allow_ypbind) {
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
#
#line 27
# Allow the domain to create and use tcp sockets.
#line 27
# Other kinds of sockets must be separately authorized for use.
#line 27
allow slapd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 27

#line 27
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 27

#line 27
#
#line 27
# Allow the domain to send or receive using any network interface.
#line 27
# netif_type is a type attribute for all network interface types.
#line 27
#
#line 27
allow slapd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 27
#
#line 27
# Allow the domain to send to or receive from any node.
#line 27
# node_type is a type attribute for all node types.
#line 27
#
#line 27
allow slapd_t node_type:node { tcp_send rawip_send };
#line 27
allow slapd_t node_type:node { tcp_recv rawip_recv };
#line 27

#line 27
#
#line 27
# Allow the domain to send to or receive from any port.
#line 27
# port_type is a type attribute for all port types.
#line 27
#
#line 27

#line 27
allow slapd_t port_type:tcp_socket { send_msg recv_msg };
#line 27

#line 27

#line 27
# XXX Allow binding to any node type.  Remove once
#line 27
# individual rules have been added to all domains that 
#line 27
# bind sockets. 
#line 27
allow slapd_t node_type:tcp_socket node_bind;
#line 27
#
#line 27
# Allow access to network files including /etc/resolv.conf
#line 27
#
#line 27
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 27

#line 27
allow slapd_t self:tcp_socket { listen accept };
#line 27

#line 27

#line 27

#line 27
#
#line 27
# Allow the domain to create and use tcp sockets.
#line 27
# Other kinds of sockets must be separately authorized for use.
#line 27
allow slapd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 27

#line 27
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 27

#line 27
#
#line 27
# Allow the domain to send or receive using any network interface.
#line 27
# netif_type is a type attribute for all network interface types.
#line 27
#
#line 27
allow slapd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 27
#
#line 27
# Allow the domain to send to or receive from any node.
#line 27
# node_type is a type attribute for all node types.
#line 27
#
#line 27
allow slapd_t node_type:node { tcp_send rawip_send };
#line 27
allow slapd_t node_type:node { tcp_recv rawip_recv };
#line 27

#line 27
#
#line 27
# Allow the domain to send to or receive from any port.
#line 27
# port_type is a type attribute for all port types.
#line 27
#
#line 27

#line 27
allow slapd_t port_type:tcp_socket { send_msg recv_msg };
#line 27

#line 27

#line 27
# XXX Allow binding to any node type.  Remove once
#line 27
# individual rules have been added to all domains that 
#line 27
# bind sockets. 
#line 27
allow slapd_t node_type:tcp_socket node_bind;
#line 27
#
#line 27
# Allow access to network files including /etc/resolv.conf
#line 27
#
#line 27
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 27

#line 27
allow slapd_t self:tcp_socket { connect };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
#
#line 27
# Allow the domain to create and use udp sockets.
#line 27
# Other kinds of sockets must be separately authorized for use.
#line 27
allow slapd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 27

#line 27
allow slapd_t unlabeled_t:association { sendto recvfrom };
#line 27

#line 27
#
#line 27
# Allow the domain to send or receive using any network interface.
#line 27
# netif_type is a type attribute for all network interface types.
#line 27
#
#line 27
allow slapd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 27
#
#line 27
# Allow the domain to send to or receive from any node.
#line 27
# node_type is a type attribute for all node types.
#line 27
#
#line 27
allow slapd_t node_type:node { udp_send rawip_send };
#line 27
allow slapd_t node_type:node { udp_recv rawip_recv };
#line 27

#line 27
#
#line 27
# Allow the domain to send to or receive from any port.
#line 27
# port_type is a type attribute for all port types.
#line 27
#
#line 27

#line 27
allow slapd_t port_type:udp_socket { send_msg recv_msg };
#line 27

#line 27

#line 27
# XXX Allow binding to any node type.  Remove once
#line 27
# individual rules have been added to all domains that 
#line 27
# bind sockets. 
#line 27
allow slapd_t node_type:udp_socket node_bind;
#line 27
#
#line 27
# Allow access to network files including /etc/resolv.conf
#line 27
#
#line 27
allow slapd_t net_conf_t:file { read getattr lock ioctl };
#line 27

#line 27
allow slapd_t self:udp_socket { connect };
#line 27

#line 27

#line 27

#line 27

#line 27

#line 27

#line 27
allow slapd_t var_yp_t:dir { read getattr lock search ioctl };
#line 27
allow slapd_t var_yp_t:file { read getattr lock ioctl };
#line 27
allow slapd_t var_yp_t:lnk_file { getattr read };
#line 27

#line 27
allow slapd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 27
allow slapd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 27
dontaudit slapd_t self:capability net_bind_service;
#line 27
dontaudit slapd_t reserved_port_type:tcp_socket name_connect;
#line 27
dontaudit slapd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 27

#line 27
} else {
#line 27
dontaudit slapd_t var_yp_t:dir search;
#line 27
}
#line 27
 
allow slapd_t self:fifo_file { ioctl read getattr lock write append };
allow slapd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

#line 30

#line 30

#line 30

#line 30
#
#line 30
# Allow the process to modify the directory.
#line 30
#
#line 30
allow slapd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 30

#line 30
#
#line 30
# Allow the process to create the file.
#line 30
#
#line 30

#line 30

#line 30

#line 30

#line 30

#line 30
allow slapd_t slapd_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 30

#line 30

#line 30

#line 30

#line 30

#line 30

#line 30

#line 30

#line 30

#line 30
type_transition slapd_t var_run_t:sock_file slapd_var_run_t;
#line 30

#line 30

allow slapd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
# allow any domain to connect to the LDAP server

#line 33
#allow domain slapd_t:tcp_socket { connectto recvfrom };
#line 33
#allow slapd_t domain:tcp_socket { acceptfrom recvfrom };
#line 33
#allow slapd_t kernel_t:tcp_socket recvfrom;
#line 33
#allow domain kernel_t:tcp_socket recvfrom;
#line 33


# Use capabilities  should not need kill...
allow slapd_t self:capability { kill setgid setuid net_bind_service net_raw dac_override dac_read_search };
allow slapd_t self:process setsched;

allow slapd_t proc_t:file { read getattr lock ioctl };

# Allow access to the slapd databases

#line 42
allow slapd_t slapd_db_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 42
allow slapd_t slapd_db_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 42
allow slapd_t slapd_db_t:lnk_file { create read getattr setattr link unlink rename };
#line 42

allow initrc_t slapd_db_t:dir { read getattr lock search ioctl };
allow slapd_t var_lib_t:dir { read getattr lock search ioctl };

# Allow access to write the replication log (should tighten this)

#line 47
allow slapd_t slapd_replog_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 47
allow slapd_t slapd_replog_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 47
allow slapd_t slapd_replog_t:lnk_file { create read getattr setattr link unlink rename };
#line 47


# read config files
allow slapd_t etc_t:{ file lnk_file } { read getattr lock ioctl };
allow slapd_t etc_runtime_t:file { getattr read };

# for startup script
allow initrc_t slapd_etc_t:file { getattr read };

allow slapd_t etc_t:dir { read getattr lock search ioctl };


#line 58
# Read system variables in /sys.
#line 58

#line 58
allow slapd_t sysctl_t:dir search;
#line 58
allow slapd_t sysctl_kernel_t:dir search;
#line 58
allow slapd_t sysctl_kernel_t:file { getattr read };
#line 58

#line 58

#line 58


allow slapd_t usr_t:{ lnk_file file } { read getattr };
allow slapd_t urandom_device_t:chr_file { getattr read ioctl };
allow slapd_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };

#line 63
allow slapd_t cert_t:dir { read getattr lock search ioctl };
#line 63
allow slapd_t cert_t:file { read getattr lock ioctl };
#line 63
allow slapd_t cert_t:lnk_file { getattr read };
#line 63



type slapd_cert_t, file_type, sysadmfile;
allow slapd_t bin_t:dir search;

#line 68
allow slapd_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 68


#line 69
allow slapd_t proc_net_t:dir { read getattr lock search ioctl };
#line 69
allow slapd_t proc_net_t:file { read getattr lock ioctl };
#line 69
allow slapd_t proc_net_t:lnk_file { getattr read };
#line 69

allow slapd_t self:capability { chown sys_nice };
allow slapd_t self:file { getattr read };
allow slapd_t self:process { execstack getsched };
allow slapd_t sysctl_net_t:dir { read getattr lock search ioctl };

#line 74
type slapd_lock_t, file_type, sysadmfile, lockfile;
#line 74

#line 74

#line 74

#line 74

#line 74
#
#line 74
# Allow the process to modify the directory.
#line 74
#
#line 74
allow slapd_t var_lock_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 74

#line 74
#
#line 74
# Allow the process to create the file.
#line 74
#
#line 74

#line 74

#line 74

#line 74

#line 74

#line 74
allow slapd_t slapd_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 74

#line 74

#line 74

#line 74

#line 74

#line 74

#line 74

#line 74

#line 74

#line 74
type_transition slapd_t var_lock_t:file slapd_lock_t;
#line 74

#line 74

#line 74


#line 75
allow slapd_t slapd_lock_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 75
allow slapd_t slapd_lock_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 75
allow slapd_t slapd_lock_t:lnk_file { create read getattr setattr link unlink rename };
#line 75

dontaudit slapd_t devpts_t:dir search;

#line 77
allow slapd_t slapd_cert_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 77
allow slapd_t slapd_cert_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 77
allow slapd_t slapd_cert_t:lnk_file { create read getattr setattr link unlink rename };
#line 77

allow slapd_t usr_t:dir { add_name write };
allow slapd_t usr_t:file { create write };
#line 1 "domains/program/snmpd.te"
#DESC SNMPD - Simple Network Management Protocol daemon
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: snmpd
#

#################################
#
# Rules for the snmpd_t domain.
#

#line 11

#line 11

#line 11

#line 11
type snmpd_t, domain, privlog, daemon , nscd_client_domain, transitionbool;
#line 11
type snmpd_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit snmpd_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types snmpd_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow snmpd_t init_t:fd use;
#line 11
allow snmpd_t init_t:process sigchld;
#line 11
allow snmpd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow snmpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow snmpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow snmpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow snmpd_t ld_so_t:file execute_no_trans;
#line 11
allow snmpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow snmpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow snmpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow snmpd_t texrel_shlib_t:file execmod;
#line 11
allow snmpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow snmpd_t device_t:dir search;
#line 11
allow snmpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow snmpd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow snmpd_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow snmpd_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow snmpd_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow snmpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit snmpd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit snmpd_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow snmpd_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow snmpd_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow snmpd_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow snmpd_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit snmpd_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit snmpd_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
# Read system variables in /sys.
#line 11

#line 11
allow snmpd_t sysctl_t:dir search;
#line 11
allow snmpd_t sysctl_kernel_t:dir search;
#line 11
allow snmpd_t sysctl_kernel_t:file { getattr read };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allows user to define a tunable to disable domain transition
#line 11
#
#line 11

#line 11
bool snmpd_disable_trans false;
#line 11
if (snmpd_disable_trans) {
#line 11

#line 11
allow initrc_t snmpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11

#line 11
allow sysadm_t snmpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11
 
#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow initrc_t snmpd_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit initrc_t snmpd_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit initrc_t snmpd_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit initrc_t snmpd_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow initrc_t snmpd_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow snmpd_t initrc_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow snmpd_t initrc_t:fd use;
#line 11
allow initrc_t snmpd_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow snmpd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow snmpd_t snmpd_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow snmpd_t snmpd_exec_t:file entrypoint;
#line 11

#line 11
type_transition initrc_t snmpd_exec_t:process snmpd_t;
#line 11

#line 11

#line 11
allow initrc_t snmpd_t:process { noatsecure siginh rlimitinh };
#line 11

#line 11
}
#line 11
 
#line 11
allow snmpd_t privfd:fd use;
#line 11

#line 11
allow snmpd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
# Create pid file.
#line 11
allow snmpd_t var_t:dir { getattr search };
#line 11

#line 11
type snmpd_var_run_t, file_type, sysadmfile, pidfile;
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow snmpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow snmpd_t snmpd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition snmpd_t var_run_t:file snmpd_var_run_t;
#line 11

#line 11

#line 11

#line 11
allow snmpd_t var_t:dir search;
#line 11
allow snmpd_t snmpd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11

#line 11
allow snmpd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11
# for daemons that look at /root on startup
#line 11
dontaudit snmpd_t sysadm_home_dir_t:dir search;
#line 11

#line 11
# for df
#line 11
allow snmpd_t fs_type:filesystem getattr;
#line 11
allow snmpd_t removable_t:filesystem getattr;
#line 11

#line 11

#line 11
allow snmpd_t etc_t:lnk_file read;
#line 11
allow snmpd_t lib_t:file { read getattr lock ioctl };
#line 11

#line 11
allow snmpd_t locale_t:dir { read getattr lock search ioctl };
#line 11
allow snmpd_t locale_t:file { read getattr lock ioctl };
#line 11
allow snmpd_t locale_t:lnk_file { getattr read };
#line 11

#line 11

#line 11

#line 11
# for localization
#line 11
allow snmpd_t lib_t:file { getattr read };
#line 11


#temp
allow snmpd_t var_t:dir getattr;


#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow snmpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow snmpd_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow snmpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow snmpd_t node_type:node { tcp_send rawip_send };
#line 16
allow snmpd_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow snmpd_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow snmpd_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow snmpd_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow snmpd_t self:tcp_socket { listen accept };
#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use udp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow snmpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow snmpd_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow snmpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow snmpd_t node_type:node { udp_send rawip_send };
#line 16
allow snmpd_t node_type:node { udp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow snmpd_t port_type:udp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow snmpd_t node_type:udp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow snmpd_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow snmpd_t self:udp_socket { connect };
#line 16

#line 16

#line 16


#line 17

#line 17
if (allow_ypbind) {
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the domain to create and use tcp sockets.
#line 17
# Other kinds of sockets must be separately authorized for use.
#line 17
allow snmpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 17

#line 17
allow snmpd_t unlabeled_t:association { sendto recvfrom };
#line 17

#line 17
#
#line 17
# Allow the domain to send or receive using any network interface.
#line 17
# netif_type is a type attribute for all network interface types.
#line 17
#
#line 17
allow snmpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 17
#
#line 17
# Allow the domain to send to or receive from any node.
#line 17
# node_type is a type attribute for all node types.
#line 17
#
#line 17
allow snmpd_t node_type:node { tcp_send rawip_send };
#line 17
allow snmpd_t node_type:node { tcp_recv rawip_recv };
#line 17

#line 17
#
#line 17
# Allow the domain to send to or receive from any port.
#line 17
# port_type is a type attribute for all port types.
#line 17
#
#line 17

#line 17
allow snmpd_t port_type:tcp_socket { send_msg recv_msg };
#line 17

#line 17

#line 17
# XXX Allow binding to any node type.  Remove once
#line 17
# individual rules have been added to all domains that 
#line 17
# bind sockets. 
#line 17
allow snmpd_t node_type:tcp_socket node_bind;
#line 17
#
#line 17
# Allow access to network files including /etc/resolv.conf
#line 17
#
#line 17
allow snmpd_t net_conf_t:file { read getattr lock ioctl };
#line 17

#line 17
allow snmpd_t self:tcp_socket { listen accept };
#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the domain to create and use tcp sockets.
#line 17
# Other kinds of sockets must be separately authorized for use.
#line 17
allow snmpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 17

#line 17
allow snmpd_t unlabeled_t:association { sendto recvfrom };
#line 17

#line 17
#
#line 17
# Allow the domain to send or receive using any network interface.
#line 17
# netif_type is a type attribute for all network interface types.
#line 17
#
#line 17
allow snmpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 17
#
#line 17
# Allow the domain to send to or receive from any node.
#line 17
# node_type is a type attribute for all node types.
#line 17
#
#line 17
allow snmpd_t node_type:node { tcp_send rawip_send };
#line 17
allow snmpd_t node_type:node { tcp_recv rawip_recv };
#line 17

#line 17
#
#line 17
# Allow the domain to send to or receive from any port.
#line 17
# port_type is a type attribute for all port types.
#line 17
#
#line 17

#line 17
allow snmpd_t port_type:tcp_socket { send_msg recv_msg };
#line 17

#line 17

#line 17
# XXX Allow binding to any node type.  Remove once
#line 17
# individual rules have been added to all domains that 
#line 17
# bind sockets. 
#line 17
allow snmpd_t node_type:tcp_socket node_bind;
#line 17
#
#line 17
# Allow access to network files including /etc/resolv.conf
#line 17
#
#line 17
allow snmpd_t net_conf_t:file { read getattr lock ioctl };
#line 17

#line 17
allow snmpd_t self:tcp_socket { connect };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the domain to create and use udp sockets.
#line 17
# Other kinds of sockets must be separately authorized for use.
#line 17
allow snmpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 17

#line 17
allow snmpd_t unlabeled_t:association { sendto recvfrom };
#line 17

#line 17
#
#line 17
# Allow the domain to send or receive using any network interface.
#line 17
# netif_type is a type attribute for all network interface types.
#line 17
#
#line 17
allow snmpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 17
#
#line 17
# Allow the domain to send to or receive from any node.
#line 17
# node_type is a type attribute for all node types.
#line 17
#
#line 17
allow snmpd_t node_type:node { udp_send rawip_send };
#line 17
allow snmpd_t node_type:node { udp_recv rawip_recv };
#line 17

#line 17
#
#line 17
# Allow the domain to send to or receive from any port.
#line 17
# port_type is a type attribute for all port types.
#line 17
#
#line 17

#line 17
allow snmpd_t port_type:udp_socket { send_msg recv_msg };
#line 17

#line 17

#line 17
# XXX Allow binding to any node type.  Remove once
#line 17
# individual rules have been added to all domains that 
#line 17
# bind sockets. 
#line 17
allow snmpd_t node_type:udp_socket node_bind;
#line 17
#
#line 17
# Allow access to network files including /etc/resolv.conf
#line 17
#
#line 17
allow snmpd_t net_conf_t:file { read getattr lock ioctl };
#line 17

#line 17
allow snmpd_t self:udp_socket { connect };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow snmpd_t var_yp_t:dir { read getattr lock search ioctl };
#line 17
allow snmpd_t var_yp_t:file { read getattr lock ioctl };
#line 17
allow snmpd_t var_yp_t:lnk_file { getattr read };
#line 17

#line 17
allow snmpd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 17
allow snmpd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 17
dontaudit snmpd_t self:capability net_bind_service;
#line 17
dontaudit snmpd_t reserved_port_type:tcp_socket name_connect;
#line 17
dontaudit snmpd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 17

#line 17
} else {
#line 17
dontaudit snmpd_t var_yp_t:dir search;
#line 17
}
#line 17
 

allow snmpd_t snmp_port_t:{ udp_socket tcp_socket } name_bind;


#line 21
type snmpd_etc_t, file_type, sysadmfile, usercanread;
#line 21
allow snmpd_t snmpd_etc_t:file { read getattr lock ioctl };
#line 21


# for the .index file

#line 24
type snmpd_var_lib_t, file_type, sysadmfile;
#line 24

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the process to modify the directory.
#line 24
#
#line 24
allow snmpd_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 24

#line 24
#
#line 24
# Allow the process to create the file.
#line 24
#
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
allow snmpd_t snmpd_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
type_transition snmpd_t var_lib_t:file snmpd_var_lib_t;
#line 24

#line 24

#line 24
allow snmpd_t snmpd_var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 24


#line 25

#line 25

#line 25

#line 25
#
#line 25
# Allow the process to modify the directory.
#line 25
#
#line 25
allow snmpd_t var_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 25

#line 25
#
#line 25
# Allow the process to create the file.
#line 25
#
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow snmpd_t snmpd_var_lib_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
allow snmpd_t snmpd_var_lib_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25

#line 25
type_transition snmpd_t var_t:{ dir sock_file } snmpd_var_lib_t;
#line 25

#line 25


#line 26

#line 26

#line 26

#line 26
#
#line 26
# Allow the process to modify the directory.
#line 26
#
#line 26
allow snmpd_t { usr_t var_t }:dir { read getattr lock search ioctl add_name remove_name write };
#line 26

#line 26
#
#line 26
# Allow the process to create the file.
#line 26
#
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
allow snmpd_t snmpd_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
type_transition snmpd_t { usr_t var_t }:file snmpd_var_lib_t;
#line 26

#line 26

allow snmpd_t snmpd_var_lib_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };


#line 29
type snmpd_log_t, file_type, sysadmfile, logfile;
#line 29

#line 29

#line 29

#line 29

#line 29
#
#line 29
# Allow the process to modify the directory.
#line 29
#
#line 29
allow snmpd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 29

#line 29
#
#line 29
# Allow the process to create the file.
#line 29
#
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
allow snmpd_t snmpd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29

#line 29
type_transition snmpd_t var_log_t:file snmpd_log_t;
#line 29

#line 29

#line 29

# for /usr/share/snmp/mibs
allow snmpd_t usr_t:file { getattr read };


#line 33
#allow sysadm_t snmpd_t:udp_socket sendto;
#line 33
#allow snmpd_t sysadm_t:udp_socket recvfrom;
#line 33


#line 34
#allow snmpd_t sysadm_t:udp_socket sendto;
#line 34
#allow sysadm_t snmpd_t:udp_socket recvfrom;
#line 34


allow snmpd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow snmpd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow snmpd_t etc_t:lnk_file read;
allow snmpd_t { etc_t etc_runtime_t }:file { read getattr lock ioctl };
allow snmpd_t { random_device_t urandom_device_t }:chr_file { getattr read };
allow snmpd_t self:capability { dac_override kill net_bind_service net_admin sys_nice sys_tty_config };

allow snmpd_t proc_t:dir search;
allow snmpd_t proc_t:file { read getattr lock ioctl };
allow snmpd_t self:file { getattr read };
allow snmpd_t self:fifo_file { ioctl read getattr lock write append };
allow snmpd_t { bin_t sbin_t }:dir search;

#line 48
allow snmpd_t { bin_t sbin_t shell_exec_t }:file { { read getattr lock execute ioctl } execute_no_trans };
#line 48


#line 56

#line 56

#line 56

#line 56
allow snmpd_t rpm_var_lib_t:dir { read getattr lock search ioctl };
#line 56
allow snmpd_t rpm_var_lib_t:file { read getattr lock ioctl };
#line 56
allow snmpd_t rpm_var_lib_t:lnk_file { getattr read };
#line 56

#line 56
dontaudit snmpd_t rpm_var_lib_t:dir write;
#line 56
dontaudit snmpd_t rpm_var_lib_t:file write;
#line 56

#line 56


allow snmpd_t home_root_t:dir search;
allow snmpd_t initrc_var_run_t:file { read getattr lock ioctl };
dontaudit snmpd_t initrc_var_run_t:file write;
dontaudit snmpd_t rpc_pipefs_t:dir getattr;
allow snmpd_t rpc_pipefs_t:dir getattr;

#line 63
# Read system variables in /sys.
#line 63

#line 63
allow snmpd_t sysctl_t:dir search;
#line 63
allow snmpd_t sysctl_kernel_t:dir search;
#line 63
allow snmpd_t sysctl_kernel_t:file { getattr read };
#line 63

#line 63

#line 63

allow snmpd_t sysctl_net_t:dir search;
allow snmpd_t sysctl_net_t:file { getattr read };

dontaudit snmpd_t { removable_device_t fixed_disk_device_t }:blk_file { getattr ioctl read };
allow snmpd_t sysfs_t:dir { getattr read search };
#line 71

#line 71
dontaudit snmpd_t amanda_dumpdates_t:file { getattr read };
#line 71

#line 74

allow snmpd_t var_lib_nfs_t:dir search;

# needed in order to retrieve net traffic data
allow snmpd_t proc_net_t:dir search;
allow snmpd_t proc_net_t:file { read getattr lock ioctl };

allow snmpd_t domain:dir { getattr search };
allow snmpd_t domain:file { getattr read };
allow snmpd_t domain:process signull;

dontaudit snmpd_t selinux_config_t:dir search;
#line 1 "domains/program/spamd.te"
#DESC Spamd - Spamassassin daemon
#
# Author: Colin Walters <walters@debian.org>
# X-Debian-Packages: spamassassin
# Depends: spamassassin.te
#


#line 8

#line 8

#line 8

#line 8
type spamd_t, domain, privlog, daemon , transitionbool;
#line 8
type spamd_exec_t, file_type, sysadmfile, exec_type;
#line 8
dontaudit spamd_t self:capability sys_tty_config;
#line 8

#line 8
role system_r types spamd_t;
#line 8

#line 8
# Inherit and use descriptors from init.
#line 8
allow spamd_t init_t:fd use;
#line 8
allow spamd_t init_t:process sigchld;
#line 8
allow spamd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 8

#line 8

#line 8
allow spamd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 8
allow spamd_t lib_t:lnk_file { read getattr lock ioctl };
#line 8
allow spamd_t ld_so_t:file { read getattr lock execute ioctl };
#line 8
#allow spamd_t ld_so_t:file execute_no_trans;
#line 8
allow spamd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 8
allow spamd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 8
allow spamd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 8
allow spamd_t texrel_shlib_t:file execmod;
#line 8
allow spamd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 8
allow spamd_t device_t:dir search;
#line 8
allow spamd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 8

#line 8

#line 8
allow spamd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 8
allow spamd_t { self proc_t }:lnk_file { getattr read };
#line 8

#line 8
allow spamd_t device_t:dir { read getattr lock search ioctl };
#line 8

#line 8
allow spamd_t udev_tdb_t:file { read getattr lock ioctl };
#line 8
allow spamd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 8
dontaudit spamd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 8
dontaudit spamd_t unpriv_userdomain:fd use;
#line 8

#line 8

#line 8
allow spamd_t sysfs_t:dir { read getattr lock search ioctl };
#line 8
allow spamd_t sysfs_t:file { read getattr lock ioctl };
#line 8
allow spamd_t sysfs_t:lnk_file { getattr read };
#line 8
 
#line 8

#line 8
allow spamd_t autofs_t:dir { search getattr };
#line 8

#line 8
dontaudit spamd_t { tty_device_t devpts_t }:chr_file { read write };
#line 8
dontaudit spamd_t root_t:file { getattr read };
#line 8
 
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
# Read system variables in /sys.
#line 8

#line 8
allow spamd_t sysctl_t:dir search;
#line 8
allow spamd_t sysctl_kernel_t:dir search;
#line 8
allow spamd_t sysctl_kernel_t:file { getattr read };
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
#
#line 8
# Allows user to define a tunable to disable domain transition
#line 8
#
#line 8

#line 8
bool spamd_disable_trans false;
#line 8
if (spamd_disable_trans) {
#line 8

#line 8
allow initrc_t spamd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 8

#line 8

#line 8
allow sysadm_t spamd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 8

#line 8
} else {
#line 8
 
#line 8

#line 8

#line 8
#
#line 8
# Allow the process to transition to the new domain.
#line 8
#
#line 8
allow initrc_t spamd_t:process transition;
#line 8

#line 8
#
#line 8
# Do not audit when glibc secure mode is enabled upon the transition.
#line 8
#
#line 8
dontaudit initrc_t spamd_t:process noatsecure;
#line 8

#line 8
#
#line 8
# Do not audit when signal-related state is cleared upon the transition.
#line 8
#
#line 8
dontaudit initrc_t spamd_t:process siginh;
#line 8

#line 8
#
#line 8
# Do not audit when resource limits are reset upon the transition.
#line 8
#
#line 8
dontaudit initrc_t spamd_t:process rlimitinh;
#line 8

#line 8
#
#line 8
# Allow the process to execute the program.
#line 8
# 
#line 8
allow initrc_t spamd_exec_t:file { read { getattr execute } };
#line 8

#line 8
#
#line 8
# Allow the process to reap the new domain.
#line 8
#
#line 8
allow spamd_t initrc_t:process sigchld;
#line 8

#line 8
#
#line 8
# Allow the new domain to inherit and use file 
#line 8
# descriptions from the creating process and vice versa.
#line 8
#
#line 8
allow spamd_t initrc_t:fd use;
#line 8
allow initrc_t spamd_t:fd use;
#line 8

#line 8
#
#line 8
# Allow the new domain to write back to the old domain via a pipe.
#line 8
#
#line 8
allow spamd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 8

#line 8
#
#line 8
# Allow the new domain to read and execute the program.
#line 8
#
#line 8
allow spamd_t spamd_exec_t:file { read getattr lock execute ioctl };
#line 8

#line 8
#
#line 8
# Allow the new domain to be entered via the program.
#line 8
#
#line 8
allow spamd_t spamd_exec_t:file entrypoint;
#line 8

#line 8
type_transition initrc_t spamd_exec_t:process spamd_t;
#line 8

#line 8

#line 8
allow initrc_t spamd_t:process { noatsecure siginh rlimitinh };
#line 8

#line 8
}
#line 8
 
#line 8
allow spamd_t privfd:fd use;
#line 8

#line 8
allow spamd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 8

#line 8

#line 8
# Create pid file.
#line 8
allow spamd_t var_t:dir { getattr search };
#line 8

#line 8
type spamd_var_run_t, file_type, sysadmfile, pidfile;
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
#
#line 8
# Allow the process to modify the directory.
#line 8
#
#line 8
allow spamd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 8

#line 8
#
#line 8
# Allow the process to create the file.
#line 8
#
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
allow spamd_t spamd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8

#line 8
type_transition spamd_t var_run_t:file spamd_var_run_t;
#line 8

#line 8

#line 8

#line 8
allow spamd_t var_t:dir search;
#line 8
allow spamd_t spamd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 8

#line 8

#line 8
allow spamd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 8

#line 8
# for daemons that look at /root on startup
#line 8
dontaudit spamd_t sysadm_home_dir_t:dir search;
#line 8

#line 8
# for df
#line 8
allow spamd_t fs_type:filesystem getattr;
#line 8
allow spamd_t removable_t:filesystem getattr;
#line 8

#line 8

#line 8
allow spamd_t etc_t:lnk_file read;
#line 8
allow spamd_t lib_t:file { read getattr lock ioctl };
#line 8

#line 8
allow spamd_t locale_t:dir { read getattr lock search ioctl };
#line 8
allow spamd_t locale_t:file { read getattr lock ioctl };
#line 8
allow spamd_t locale_t:lnk_file { getattr read };
#line 8

#line 8

#line 8

#line 8
# for localization
#line 8
allow spamd_t lib_t:file { getattr read };
#line 8



#line 10
type spamd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 10

#line 10

#line 10

#line 10

#line 10
#
#line 10
# Allow the process to modify the directory.
#line 10
#
#line 10
allow spamd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 10

#line 10
#
#line 10
# Allow the process to create the file.
#line 10
#
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
allow spamd_t spamd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
allow spamd_t spamd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10

#line 10
type_transition spamd_t tmp_t:{ file dir } spamd_tmp_t;
#line 10

#line 10

#line 10



#line 12
# Access other processes in the same domain.
#line 12
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 12
# These must be granted separately if desired.
#line 12
allow spamd_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 12

#line 12
# Access /proc/PID files for processes in the same domain.
#line 12
allow spamd_t self:dir { read getattr lock search ioctl };
#line 12
allow spamd_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 12

#line 12
# Access file descriptions, pipes, and sockets
#line 12
# created by processes in the same domain.
#line 12
allow spamd_t self:fd *;
#line 12
allow spamd_t self:fifo_file { ioctl read getattr lock write append };
#line 12
allow spamd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 12
allow spamd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 12

#line 12
# Allow the domain to communicate with other processes in the same domain.
#line 12
allow spamd_t self:unix_dgram_socket sendto;
#line 12
allow spamd_t self:unix_stream_socket connectto;
#line 12

#line 12
# Access System V IPC objects created by processes in the same domain.
#line 12
allow spamd_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 12
allow spamd_t self:msg  { send receive };
#line 12
allow spamd_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 12
allow spamd_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 12
allow spamd_t unpriv_userdomain:fd use;
#line 12
#
#line 12
# Every app is asking for ypbind so I am adding this here, 
#line 12
# eventually this should become can_nsswitch
#line 12
#
#line 12

#line 12

#line 12
if (allow_ypbind) {
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow spamd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow spamd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow spamd_t node_type:node { tcp_send rawip_send };
#line 12
allow spamd_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow spamd_t port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow spamd_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow spamd_t self:tcp_socket { listen accept };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow spamd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow spamd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow spamd_t node_type:node { tcp_send rawip_send };
#line 12
allow spamd_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow spamd_t port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow spamd_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow spamd_t self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow spamd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow spamd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow spamd_t node_type:node { udp_send rawip_send };
#line 12
allow spamd_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow spamd_t port_type:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow spamd_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow spamd_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow spamd_t var_yp_t:dir { read getattr lock search ioctl };
#line 12
allow spamd_t var_yp_t:file { read getattr lock ioctl };
#line 12
allow spamd_t var_yp_t:lnk_file { getattr read };
#line 12

#line 12
allow spamd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 12
allow spamd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 12
dontaudit spamd_t self:capability net_bind_service;
#line 12
dontaudit spamd_t reserved_port_type:tcp_socket name_connect;
#line 12
dontaudit spamd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 12

#line 12
} else {
#line 12
dontaudit spamd_t var_yp_t:dir search;
#line 12
}
#line 12
 
#line 12
allow spamd_t autofs_t:dir { search getattr };
#line 12


#line 13
allow spamd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow spamd_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow spamd_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow spamd_t ld_so_t:file execute_no_trans;
#line 13
allow spamd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow spamd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow spamd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow spamd_t texrel_shlib_t:file execmod;
#line 13
allow spamd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow spamd_t device_t:dir search;
#line 13
allow spamd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13


#line 14
# Read system variables in /sys.
#line 14

#line 14
allow spamd_t sysctl_t:dir search;
#line 14
allow spamd_t sysctl_kernel_t:dir search;
#line 14
allow spamd_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14


# Various Perl bits
allow spamd_t lib_t:file { read getattr lock execute ioctl };
dontaudit spamd_t shadow_t:file { getattr read };
dontaudit spamd_t initrc_var_run_t:file { read write lock };
dontaudit spamd_t sysadm_home_dir_t:dir { getattr search };


#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the domain to create and use tcp sockets.
#line 22
# Other kinds of sockets must be separately authorized for use.
#line 22
allow spamd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 22

#line 22
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 22

#line 22
#
#line 22
# Allow the domain to send or receive using any network interface.
#line 22
# netif_type is a type attribute for all network interface types.
#line 22
#
#line 22
allow spamd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 22
#
#line 22
# Allow the domain to send to or receive from any node.
#line 22
# node_type is a type attribute for all node types.
#line 22
#
#line 22
allow spamd_t node_type:node { tcp_send rawip_send };
#line 22
allow spamd_t node_type:node { tcp_recv rawip_recv };
#line 22

#line 22
#
#line 22
# Allow the domain to send to or receive from any port.
#line 22
# port_type is a type attribute for all port types.
#line 22
#
#line 22

#line 22
allow spamd_t port_type:tcp_socket { send_msg recv_msg };
#line 22

#line 22

#line 22
# XXX Allow binding to any node type.  Remove once
#line 22
# individual rules have been added to all domains that 
#line 22
# bind sockets. 
#line 22
allow spamd_t node_type:tcp_socket node_bind;
#line 22
#
#line 22
# Allow access to network files including /etc/resolv.conf
#line 22
#
#line 22
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 22

#line 22
allow spamd_t self:tcp_socket { listen accept };
#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the domain to create and use udp sockets.
#line 22
# Other kinds of sockets must be separately authorized for use.
#line 22
allow spamd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 22

#line 22
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 22

#line 22
#
#line 22
# Allow the domain to send or receive using any network interface.
#line 22
# netif_type is a type attribute for all network interface types.
#line 22
#
#line 22
allow spamd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 22
#
#line 22
# Allow the domain to send to or receive from any node.
#line 22
# node_type is a type attribute for all node types.
#line 22
#
#line 22
allow spamd_t node_type:node { udp_send rawip_send };
#line 22
allow spamd_t node_type:node { udp_recv rawip_recv };
#line 22

#line 22
#
#line 22
# Allow the domain to send to or receive from any port.
#line 22
# port_type is a type attribute for all port types.
#line 22
#
#line 22

#line 22
allow spamd_t port_type:udp_socket { send_msg recv_msg };
#line 22

#line 22

#line 22
# XXX Allow binding to any node type.  Remove once
#line 22
# individual rules have been added to all domains that 
#line 22
# bind sockets. 
#line 22
allow spamd_t node_type:udp_socket node_bind;
#line 22
#
#line 22
# Allow access to network files including /etc/resolv.conf
#line 22
#
#line 22
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 22

#line 22
allow spamd_t self:udp_socket { connect };
#line 22

#line 22

#line 22


#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use tcp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow spamd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow spamd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow spamd_t node_type:node { tcp_send rawip_send };
#line 23
allow spamd_t node_type:node { tcp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow spamd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow spamd_t node_type:tcp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow spamd_t self:tcp_socket { connect };
#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use udp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow spamd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow spamd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow spamd_t node_type:node { udp_send rawip_send };
#line 23
allow spamd_t node_type:node { udp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow spamd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow spamd_t node_type:udp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow spamd_t self:udp_socket { connect };
#line 23

#line 23

#line 23

#line 23
allow spamd_t dns_port_t:tcp_socket name_connect;
#line 23

#line 23

#line 23

#line 23
if (allow_ypbind) {
#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use tcp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow spamd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow spamd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow spamd_t node_type:node { tcp_send rawip_send };
#line 23
allow spamd_t node_type:node { tcp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow spamd_t port_type:tcp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow spamd_t node_type:tcp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow spamd_t self:tcp_socket { listen accept };
#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use tcp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow spamd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow spamd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow spamd_t node_type:node { tcp_send rawip_send };
#line 23
allow spamd_t node_type:node { tcp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow spamd_t port_type:tcp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow spamd_t node_type:tcp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow spamd_t self:tcp_socket { connect };
#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use udp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow spamd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow spamd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow spamd_t node_type:node { udp_send rawip_send };
#line 23
allow spamd_t node_type:node { udp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow spamd_t port_type:udp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow spamd_t node_type:udp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow spamd_t self:udp_socket { connect };
#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
allow spamd_t var_yp_t:dir { read getattr lock search ioctl };
#line 23
allow spamd_t var_yp_t:file { read getattr lock ioctl };
#line 23
allow spamd_t var_yp_t:lnk_file { getattr read };
#line 23

#line 23
allow spamd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 23
allow spamd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 23
dontaudit spamd_t self:capability net_bind_service;
#line 23
dontaudit spamd_t reserved_port_type:tcp_socket name_connect;
#line 23
dontaudit spamd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 23

#line 23
} else {
#line 23
dontaudit spamd_t var_yp_t:dir search;
#line 23
}
#line 23
 
#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the domain to create and use tcp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow spamd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow spamd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow spamd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow spamd_t node_type:node { tcp_send rawip_send };
#line 23
allow spamd_t node_type:node { tcp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow spamd_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow spamd_t node_type:tcp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow spamd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow spamd_t self:tcp_socket { connect };
#line 23

#line 23
allow spamd_t ldap_port_t:tcp_socket name_connect;
#line 23

#line 23

#line 23

#line 23
allow spamd_t winbind_var_run_t:dir { getattr search };
#line 23
allow spamd_t winbind_t:unix_stream_socket connectto;
#line 23
allow spamd_t winbind_var_run_t:sock_file { getattr read write };
#line 23

#line 23

#line 23

allow spamd_t spamd_port_t:tcp_socket name_bind;
allow spamd_t port_type:udp_socket name_bind;
dontaudit spamd_t reserved_port_type:udp_socket name_bind;
allow spamd_t self:capability net_bind_service;
allow spamd_t razor_port_t:tcp_socket name_connect;

allow spamd_t proc_t:file { getattr read };

# Spamassassin, when run as root and using per-user config files,
# setuids to the user running spamc.  Comment this if you are not
# using this ability.
allow spamd_t self:capability { setuid setgid dac_override sys_tty_config };

allow spamd_t { bin_t sbin_t }:dir { getattr search };

#line 38
allow spamd_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 38


#line 43

#line 43
allow spamd_t etc_mail_t:dir { getattr read search };
#line 43
allow spamd_t etc_mail_t:file { getattr ioctl read };
#line 43

allow spamd_t { etc_t etc_runtime_t }:file { getattr ioctl read };

#line 50


allow spamd_t usr_t:file { getattr ioctl read };
allow spamd_t usr_t:lnk_file { getattr read };
allow spamd_t urandom_device_t:chr_file { getattr read };


#line 56

#line 56

#line 56

#line 56

#line 56
#
#line 56
# Allow the process to transition to the new domain.
#line 56
#
#line 56
allow system_crond_t spamd_t:process transition;
#line 56

#line 56
#
#line 56
# Do not audit when glibc secure mode is enabled upon the transition.
#line 56
#
#line 56
dontaudit system_crond_t spamd_t:process noatsecure;
#line 56

#line 56
#
#line 56
# Do not audit when signal-related state is cleared upon the transition.
#line 56
#
#line 56
dontaudit system_crond_t spamd_t:process siginh;
#line 56

#line 56
#
#line 56
# Do not audit when resource limits are reset upon the transition.
#line 56
#
#line 56
dontaudit system_crond_t spamd_t:process rlimitinh;
#line 56

#line 56
#
#line 56
# Allow the process to execute the program.
#line 56
# 
#line 56
allow system_crond_t spamd_exec_t:file { read { getattr execute } };
#line 56

#line 56
#
#line 56
# Allow the process to reap the new domain.
#line 56
#
#line 56
allow spamd_t system_crond_t:process sigchld;
#line 56

#line 56
#
#line 56
# Allow the new domain to inherit and use file 
#line 56
# descriptions from the creating process and vice versa.
#line 56
#
#line 56
allow spamd_t system_crond_t:fd use;
#line 56
allow system_crond_t spamd_t:fd use;
#line 56

#line 56
#
#line 56
# Allow the new domain to write back to the old domain via a pipe.
#line 56
#
#line 56
allow spamd_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 56

#line 56
#
#line 56
# Allow the new domain to read and execute the program.
#line 56
#
#line 56
allow spamd_t spamd_exec_t:file { read getattr lock execute ioctl };
#line 56

#line 56
#
#line 56
# Allow the new domain to be entered via the program.
#line 56
#
#line 56
allow spamd_t spamd_exec_t:file entrypoint;
#line 56

#line 56
type_transition system_crond_t spamd_exec_t:process spamd_t;
#line 56

#line 56
allow spamd_t crond_t:fifo_file { getattr read write ioctl };
#line 56
# a rule for privfd may make this obsolete
#line 56
allow spamd_t crond_t:fd use;
#line 56
allow spamd_t crond_t:process sigchld;
#line 56


#line 57
allow spamd_t { home_root_t user_home_dir_t }:dir { search getattr };
#line 57

#line 57
allow spamd_t home_root_t:dir search;
#line 57

#line 57
if (use_nfs_home_dirs) {
#line 57

#line 57
allow spamd_t nfs_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 57
allow spamd_t nfs_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 57
allow spamd_t nfs_t:lnk_file { create read getattr setattr link unlink rename };
#line 57

#line 57
}
#line 57
if (use_samba_home_dirs) {
#line 57

#line 57
allow spamd_t cifs_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 57
allow spamd_t cifs_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 57
allow spamd_t cifs_t:lnk_file { create read getattr setattr link unlink rename };
#line 57

#line 57
}
#line 57
allow spamd_t autofs_t:dir { search getattr };
#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57
#
#line 57
# Allow the process to modify the directory.
#line 57
#
#line 57
allow spamd_t user_home_dir_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 57

#line 57
#
#line 57
# Allow the process to create the file.
#line 57
#
#line 57

#line 57

#line 57

#line 57

#line 57

#line 57
allow spamd_t user_home_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57
allow spamd_t user_home_t:lnk_file { create read getattr setattr link unlink rename };
#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57
allow spamd_t user_home_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57
allow spamd_t user_home_t:fifo_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57
allow spamd_t user_home_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57

#line 57
type_transition spamd_t user_home_dir_t:dir user_home_t;
#line 57
type_transition spamd_t user_home_dir_t:{ file lnk_file sock_file fifo_file } user_home_t;
#line 57

#line 57

#line 57

#line 57
allow spamd_t user_home_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 57
allow spamd_t user_home_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 57
allow spamd_t user_home_t:lnk_file { create read getattr setattr link unlink rename };
#line 57

#line 57

#line 57

#line 1 "domains/program/squid.te"
#DESC Squid - Web cache
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: squid
#

#################################
#
# Rules for the squid_t domain.
#
# squid_t is the domain the squid process runs in
#line 14

#line 14

#line 14
#allow squid_t httpd_t:tcp_socket { connectto recvfrom };
#line 14
#allow httpd_t squid_t:tcp_socket { acceptfrom recvfrom };
#line 14
#allow httpd_t kernel_t:tcp_socket recvfrom;
#line 14
#allow squid_t kernel_t:tcp_socket recvfrom;
#line 14

#line 14

bool squid_connect_any false;

#line 16

#line 16

#line 16

#line 16
type squid_t, domain, privlog, daemon , web_client_domain, nscd_client_domain, transitionbool;
#line 16
type squid_exec_t, file_type, sysadmfile, exec_type;
#line 16
dontaudit squid_t self:capability sys_tty_config;
#line 16

#line 16
role system_r types squid_t;
#line 16

#line 16
# Inherit and use descriptors from init.
#line 16
allow squid_t init_t:fd use;
#line 16
allow squid_t init_t:process sigchld;
#line 16
allow squid_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 16

#line 16

#line 16
allow squid_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 16
allow squid_t lib_t:lnk_file { read getattr lock ioctl };
#line 16
allow squid_t ld_so_t:file { read getattr lock execute ioctl };
#line 16
#allow squid_t ld_so_t:file execute_no_trans;
#line 16
allow squid_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 16
allow squid_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 16
allow squid_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 16
allow squid_t texrel_shlib_t:file execmod;
#line 16
allow squid_t ld_so_cache_t:file { read getattr lock ioctl };
#line 16
allow squid_t device_t:dir search;
#line 16
allow squid_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 16

#line 16

#line 16
allow squid_t { self proc_t }:dir { read getattr lock search ioctl };
#line 16
allow squid_t { self proc_t }:lnk_file { getattr read };
#line 16

#line 16
allow squid_t device_t:dir { read getattr lock search ioctl };
#line 16

#line 16
allow squid_t udev_tdb_t:file { read getattr lock ioctl };
#line 16
allow squid_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 16
dontaudit squid_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 16
dontaudit squid_t unpriv_userdomain:fd use;
#line 16

#line 16

#line 16
allow squid_t sysfs_t:dir { read getattr lock search ioctl };
#line 16
allow squid_t sysfs_t:file { read getattr lock ioctl };
#line 16
allow squid_t sysfs_t:lnk_file { getattr read };
#line 16
 
#line 16

#line 16
allow squid_t autofs_t:dir { search getattr };
#line 16

#line 16
dontaudit squid_t { tty_device_t devpts_t }:chr_file { read write };
#line 16
dontaudit squid_t root_t:file { getattr read };
#line 16
 
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
# Read system variables in /sys.
#line 16

#line 16
allow squid_t sysctl_t:dir search;
#line 16
allow squid_t sysctl_kernel_t:dir search;
#line 16
allow squid_t sysctl_kernel_t:file { getattr read };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allows user to define a tunable to disable domain transition
#line 16
#
#line 16

#line 16
bool squid_disable_trans false;
#line 16
if (squid_disable_trans) {
#line 16

#line 16
allow initrc_t squid_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 16

#line 16

#line 16
allow sysadm_t squid_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 16

#line 16
} else {
#line 16
 
#line 16

#line 16

#line 16
#
#line 16
# Allow the process to transition to the new domain.
#line 16
#
#line 16
allow initrc_t squid_t:process transition;
#line 16

#line 16
#
#line 16
# Do not audit when glibc secure mode is enabled upon the transition.
#line 16
#
#line 16
dontaudit initrc_t squid_t:process noatsecure;
#line 16

#line 16
#
#line 16
# Do not audit when signal-related state is cleared upon the transition.
#line 16
#
#line 16
dontaudit initrc_t squid_t:process siginh;
#line 16

#line 16
#
#line 16
# Do not audit when resource limits are reset upon the transition.
#line 16
#
#line 16
dontaudit initrc_t squid_t:process rlimitinh;
#line 16

#line 16
#
#line 16
# Allow the process to execute the program.
#line 16
# 
#line 16
allow initrc_t squid_exec_t:file { read { getattr execute } };
#line 16

#line 16
#
#line 16
# Allow the process to reap the new domain.
#line 16
#
#line 16
allow squid_t initrc_t:process sigchld;
#line 16

#line 16
#
#line 16
# Allow the new domain to inherit and use file 
#line 16
# descriptions from the creating process and vice versa.
#line 16
#
#line 16
allow squid_t initrc_t:fd use;
#line 16
allow initrc_t squid_t:fd use;
#line 16

#line 16
#
#line 16
# Allow the new domain to write back to the old domain via a pipe.
#line 16
#
#line 16
allow squid_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 16

#line 16
#
#line 16
# Allow the new domain to read and execute the program.
#line 16
#
#line 16
allow squid_t squid_exec_t:file { read getattr lock execute ioctl };
#line 16

#line 16
#
#line 16
# Allow the new domain to be entered via the program.
#line 16
#
#line 16
allow squid_t squid_exec_t:file entrypoint;
#line 16

#line 16
type_transition initrc_t squid_exec_t:process squid_t;
#line 16

#line 16

#line 16
allow initrc_t squid_t:process { noatsecure siginh rlimitinh };
#line 16

#line 16
}
#line 16
 
#line 16
allow squid_t privfd:fd use;
#line 16

#line 16
allow squid_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 16

#line 16

#line 16
# Create pid file.
#line 16
allow squid_t var_t:dir { getattr search };
#line 16

#line 16
type squid_var_run_t, file_type, sysadmfile, pidfile;
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the process to modify the directory.
#line 16
#
#line 16
allow squid_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 16

#line 16
#
#line 16
# Allow the process to create the file.
#line 16
#
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
allow squid_t squid_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
type_transition squid_t var_run_t:file squid_var_run_t;
#line 16

#line 16

#line 16

#line 16
allow squid_t var_t:dir search;
#line 16
allow squid_t squid_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 16

#line 16

#line 16
allow squid_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 16

#line 16
# for daemons that look at /root on startup
#line 16
dontaudit squid_t sysadm_home_dir_t:dir search;
#line 16

#line 16
# for df
#line 16
allow squid_t fs_type:filesystem getattr;
#line 16
allow squid_t removable_t:filesystem getattr;
#line 16

#line 16

#line 16
allow squid_t etc_t:lnk_file read;
#line 16
allow squid_t lib_t:file { read getattr lock ioctl };
#line 16

#line 16
allow squid_t locale_t:dir { read getattr lock search ioctl };
#line 16
allow squid_t locale_t:file { read getattr lock ioctl };
#line 16
allow squid_t locale_t:lnk_file { getattr read };
#line 16

#line 16

#line 16

#line 16
# for localization
#line 16
allow squid_t lib_t:file { getattr read };
#line 16

type squid_conf_t, file_type, sysadmfile;

#line 18
# Access other processes in the same domain.
#line 18
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 18
# These must be granted separately if desired.
#line 18
allow squid_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 18

#line 18
# Access /proc/PID files for processes in the same domain.
#line 18
allow squid_t self:dir { read getattr lock search ioctl };
#line 18
allow squid_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 18

#line 18
# Access file descriptions, pipes, and sockets
#line 18
# created by processes in the same domain.
#line 18
allow squid_t self:fd *;
#line 18
allow squid_t self:fifo_file { ioctl read getattr lock write append };
#line 18
allow squid_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 18
allow squid_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 18

#line 18
# Allow the domain to communicate with other processes in the same domain.
#line 18
allow squid_t self:unix_dgram_socket sendto;
#line 18
allow squid_t self:unix_stream_socket connectto;
#line 18

#line 18
# Access System V IPC objects created by processes in the same domain.
#line 18
allow squid_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 18
allow squid_t self:msg  { send receive };
#line 18
allow squid_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 18
allow squid_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 18
allow squid_t unpriv_userdomain:fd use;
#line 18
#
#line 18
# Every app is asking for ypbind so I am adding this here, 
#line 18
# eventually this should become can_nsswitch
#line 18
#
#line 18

#line 18

#line 18
if (allow_ypbind) {
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow squid_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow squid_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow squid_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow squid_t node_type:node { tcp_send rawip_send };
#line 18
allow squid_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow squid_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow squid_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow squid_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow squid_t self:tcp_socket { listen accept };
#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow squid_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow squid_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow squid_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow squid_t node_type:node { tcp_send rawip_send };
#line 18
allow squid_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow squid_t port_type:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow squid_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow squid_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow squid_t self:tcp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use udp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow squid_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow squid_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow squid_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow squid_t node_type:node { udp_send rawip_send };
#line 18
allow squid_t node_type:node { udp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow squid_t port_type:udp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow squid_t node_type:udp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow squid_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow squid_t self:udp_socket { connect };
#line 18

#line 18

#line 18

#line 18

#line 18

#line 18

#line 18
allow squid_t var_yp_t:dir { read getattr lock search ioctl };
#line 18
allow squid_t var_yp_t:file { read getattr lock ioctl };
#line 18
allow squid_t var_yp_t:lnk_file { getattr read };
#line 18

#line 18
allow squid_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 18
allow squid_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 18
dontaudit squid_t self:capability net_bind_service;
#line 18
dontaudit squid_t reserved_port_type:tcp_socket name_connect;
#line 18
dontaudit squid_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 18

#line 18
} else {
#line 18
dontaudit squid_t var_yp_t:dir search;
#line 18
}
#line 18
 
#line 18
allow squid_t autofs_t:dir { search getattr };
#line 18

allow { squid_t initrc_t } squid_conf_t:file { read getattr lock ioctl };
allow squid_t squid_conf_t:dir { read getattr lock search ioctl };
allow squid_t squid_conf_t:lnk_file read;


#line 23

#line 23
type squid_log_t, file_type, sysadmfile, logfile;
#line 23

#line 23

#line 23

#line 23

#line 23
#
#line 23
# Allow the process to modify the directory.
#line 23
#
#line 23
allow squid_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 23

#line 23
#
#line 23
# Allow the process to create the file.
#line 23
#
#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
allow squid_t squid_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23

#line 23
type_transition squid_t var_log_t:file squid_log_t;
#line 23

#line 23

#line 23

#line 23
allow squid_t squid_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 23


#line 24
allow initrc_t squid_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 24
allow initrc_t squid_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 24
allow initrc_t squid_log_t:lnk_file { create read getattr setattr link unlink rename };
#line 24


allow squid_t usr_t:file { getattr read };

# type for /var/cache/squid
type squid_cache_t, file_type, sysadmfile;

allow squid_t self:capability { setgid setuid net_bind_service dac_override };
allow squid_t { etc_t etc_runtime_t }:file { read getattr lock ioctl };
allow squid_t etc_t:lnk_file read;
allow squid_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow squid_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow squid_t self:fifo_file { ioctl read getattr lock write append };


#line 38
# Read system variables in /sys.
#line 38

#line 38
allow squid_t sysctl_t:dir search;
#line 38
allow squid_t sysctl_kernel_t:dir search;
#line 38
allow squid_t sysctl_kernel_t:file { getattr read };
#line 38

#line 38

#line 38


allow squid_t devtty_t:chr_file { ioctl read getattr lock write append };

allow squid_t { self proc_t }:file { read getattr };

# for when we use /var/spool/cache
allow squid_t var_spool_t:dir search;

# Grant permissions to create, access, and delete cache files.
# No type transitions required, as the files inherit the parent directory type.

#line 49
allow squid_t squid_cache_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 49
allow squid_t squid_cache_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 49
allow squid_t squid_cache_t:lnk_file { create read getattr setattr link unlink rename };
#line 49

#line 51


#line 52

#line 52

#line 52
#
#line 52
# Allow the process to transition to the new domain.
#line 52
#
#line 52
allow system_crond_t squid_t:process transition;
#line 52

#line 52
#
#line 52
# Do not audit when glibc secure mode is enabled upon the transition.
#line 52
#
#line 52
dontaudit system_crond_t squid_t:process noatsecure;
#line 52

#line 52
#
#line 52
# Do not audit when signal-related state is cleared upon the transition.
#line 52
#
#line 52
dontaudit system_crond_t squid_t:process siginh;
#line 52

#line 52
#
#line 52
# Do not audit when resource limits are reset upon the transition.
#line 52
#
#line 52
dontaudit system_crond_t squid_t:process rlimitinh;
#line 52

#line 52
#
#line 52
# Allow the process to execute the program.
#line 52
# 
#line 52
allow system_crond_t squid_exec_t:file { read { getattr execute } };
#line 52

#line 52
#
#line 52
# Allow the process to reap the new domain.
#line 52
#
#line 52
allow squid_t system_crond_t:process sigchld;
#line 52

#line 52
#
#line 52
# Allow the new domain to inherit and use file 
#line 52
# descriptions from the creating process and vice versa.
#line 52
#
#line 52
allow squid_t system_crond_t:fd use;
#line 52
allow system_crond_t squid_t:fd use;
#line 52

#line 52
#
#line 52
# Allow the new domain to write back to the old domain via a pipe.
#line 52
#
#line 52
allow squid_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 52

#line 52
#
#line 52
# Allow the new domain to read and execute the program.
#line 52
#
#line 52
allow squid_t squid_exec_t:file { read getattr lock execute ioctl };
#line 52

#line 52
#
#line 52
# Allow the new domain to be entered via the program.
#line 52
#
#line 52
allow squid_t squid_exec_t:file entrypoint;
#line 52

#line 52
type_transition system_crond_t squid_exec_t:process squid_t;
#line 52


# Use the network

#line 55

#line 55

#line 55

#line 55

#line 55

#line 55
#
#line 55
# Allow the domain to create and use tcp sockets.
#line 55
# Other kinds of sockets must be separately authorized for use.
#line 55
allow squid_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 55

#line 55
allow squid_t unlabeled_t:association { sendto recvfrom };
#line 55

#line 55
#
#line 55
# Allow the domain to send or receive using any network interface.
#line 55
# netif_type is a type attribute for all network interface types.
#line 55
#
#line 55
allow squid_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 55
#
#line 55
# Allow the domain to send to or receive from any node.
#line 55
# node_type is a type attribute for all node types.
#line 55
#
#line 55
allow squid_t node_type:node { tcp_send rawip_send };
#line 55
allow squid_t node_type:node { tcp_recv rawip_recv };
#line 55

#line 55
#
#line 55
# Allow the domain to send to or receive from any port.
#line 55
# port_type is a type attribute for all port types.
#line 55
#
#line 55

#line 55
allow squid_t port_type:tcp_socket { send_msg recv_msg };
#line 55

#line 55

#line 55
# XXX Allow binding to any node type.  Remove once
#line 55
# individual rules have been added to all domains that 
#line 55
# bind sockets. 
#line 55
allow squid_t node_type:tcp_socket node_bind;
#line 55
#
#line 55
# Allow access to network files including /etc/resolv.conf
#line 55
#
#line 55
allow squid_t net_conf_t:file { read getattr lock ioctl };
#line 55

#line 55
allow squid_t self:tcp_socket { listen accept };
#line 55

#line 55

#line 55

#line 55
#
#line 55
# Allow the domain to create and use tcp sockets.
#line 55
# Other kinds of sockets must be separately authorized for use.
#line 55
allow squid_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 55

#line 55
allow squid_t unlabeled_t:association { sendto recvfrom };
#line 55

#line 55
#
#line 55
# Allow the domain to send or receive using any network interface.
#line 55
# netif_type is a type attribute for all network interface types.
#line 55
#
#line 55
allow squid_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 55
#
#line 55
# Allow the domain to send to or receive from any node.
#line 55
# node_type is a type attribute for all node types.
#line 55
#
#line 55
allow squid_t node_type:node { tcp_send rawip_send };
#line 55
allow squid_t node_type:node { tcp_recv rawip_recv };
#line 55

#line 55
#
#line 55
# Allow the domain to send to or receive from any port.
#line 55
# port_type is a type attribute for all port types.
#line 55
#
#line 55

#line 55
allow squid_t port_type:tcp_socket { send_msg recv_msg };
#line 55

#line 55

#line 55
# XXX Allow binding to any node type.  Remove once
#line 55
# individual rules have been added to all domains that 
#line 55
# bind sockets. 
#line 55
allow squid_t node_type:tcp_socket node_bind;
#line 55
#
#line 55
# Allow access to network files including /etc/resolv.conf
#line 55
#
#line 55
allow squid_t net_conf_t:file { read getattr lock ioctl };
#line 55

#line 55
allow squid_t self:tcp_socket { connect };
#line 55

#line 55

#line 55

#line 55

#line 55

#line 55
#
#line 55
# Allow the domain to create and use udp sockets.
#line 55
# Other kinds of sockets must be separately authorized for use.
#line 55
allow squid_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 55

#line 55
allow squid_t unlabeled_t:association { sendto recvfrom };
#line 55

#line 55
#
#line 55
# Allow the domain to send or receive using any network interface.
#line 55
# netif_type is a type attribute for all network interface types.
#line 55
#
#line 55
allow squid_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 55
#
#line 55
# Allow the domain to send to or receive from any node.
#line 55
# node_type is a type attribute for all node types.
#line 55
#
#line 55
allow squid_t node_type:node { udp_send rawip_send };
#line 55
allow squid_t node_type:node { udp_recv rawip_recv };
#line 55

#line 55
#
#line 55
# Allow the domain to send to or receive from any port.
#line 55
# port_type is a type attribute for all port types.
#line 55
#
#line 55

#line 55
allow squid_t port_type:udp_socket { send_msg recv_msg };
#line 55

#line 55

#line 55
# XXX Allow binding to any node type.  Remove once
#line 55
# individual rules have been added to all domains that 
#line 55
# bind sockets. 
#line 55
allow squid_t node_type:udp_socket node_bind;
#line 55
#
#line 55
# Allow access to network files including /etc/resolv.conf
#line 55
#
#line 55
allow squid_t net_conf_t:file { read getattr lock ioctl };
#line 55

#line 55
allow squid_t self:udp_socket { connect };
#line 55

#line 55

#line 55

#line 55

#line 55

if (squid_connect_any) {
allow squid_t port_type:tcp_socket name_connect;
} 

#line 59

#line 59
if (allow_ypbind) {
#line 59

#line 59

#line 59

#line 59

#line 59

#line 59

#line 59

#line 59
#
#line 59
# Allow the domain to create and use tcp sockets.
#line 59
# Other kinds of sockets must be separately authorized for use.
#line 59
allow squid_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 59

#line 59
allow squid_t unlabeled_t:association { sendto recvfrom };
#line 59

#line 59
#
#line 59
# Allow the domain to send or receive using any network interface.
#line 59
# netif_type is a type attribute for all network interface types.
#line 59
#
#line 59
allow squid_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 59
#
#line 59
# Allow the domain to send to or receive from any node.
#line 59
# node_type is a type attribute for all node types.
#line 59
#
#line 59
allow squid_t node_type:node { tcp_send rawip_send };
#line 59
allow squid_t node_type:node { tcp_recv rawip_recv };
#line 59

#line 59
#
#line 59
# Allow the domain to send to or receive from any port.
#line 59
# port_type is a type attribute for all port types.
#line 59
#
#line 59

#line 59
allow squid_t port_type:tcp_socket { send_msg recv_msg };
#line 59

#line 59

#line 59
# XXX Allow binding to any node type.  Remove once
#line 59
# individual rules have been added to all domains that 
#line 59
# bind sockets. 
#line 59
allow squid_t node_type:tcp_socket node_bind;
#line 59
#
#line 59
# Allow access to network files including /etc/resolv.conf
#line 59
#
#line 59
allow squid_t net_conf_t:file { read getattr lock ioctl };
#line 59

#line 59
allow squid_t self:tcp_socket { listen accept };
#line 59

#line 59

#line 59

#line 59
#
#line 59
# Allow the domain to create and use tcp sockets.
#line 59
# Other kinds of sockets must be separately authorized for use.
#line 59
allow squid_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 59

#line 59
allow squid_t unlabeled_t:association { sendto recvfrom };
#line 59

#line 59
#
#line 59
# Allow the domain to send or receive using any network interface.
#line 59
# netif_type is a type attribute for all network interface types.
#line 59
#
#line 59
allow squid_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 59
#
#line 59
# Allow the domain to send to or receive from any node.
#line 59
# node_type is a type attribute for all node types.
#line 59
#
#line 59
allow squid_t node_type:node { tcp_send rawip_send };
#line 59
allow squid_t node_type:node { tcp_recv rawip_recv };
#line 59

#line 59
#
#line 59
# Allow the domain to send to or receive from any port.
#line 59
# port_type is a type attribute for all port types.
#line 59
#
#line 59

#line 59
allow squid_t port_type:tcp_socket { send_msg recv_msg };
#line 59

#line 59

#line 59
# XXX Allow binding to any node type.  Remove once
#line 59
# individual rules have been added to all domains that 
#line 59
# bind sockets. 
#line 59
allow squid_t node_type:tcp_socket node_bind;
#line 59
#
#line 59
# Allow access to network files including /etc/resolv.conf
#line 59
#
#line 59
allow squid_t net_conf_t:file { read getattr lock ioctl };
#line 59

#line 59
allow squid_t self:tcp_socket { connect };
#line 59

#line 59

#line 59

#line 59

#line 59

#line 59
#
#line 59
# Allow the domain to create and use udp sockets.
#line 59
# Other kinds of sockets must be separately authorized for use.
#line 59
allow squid_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 59

#line 59
allow squid_t unlabeled_t:association { sendto recvfrom };
#line 59

#line 59
#
#line 59
# Allow the domain to send or receive using any network interface.
#line 59
# netif_type is a type attribute for all network interface types.
#line 59
#
#line 59
allow squid_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 59
#
#line 59
# Allow the domain to send to or receive from any node.
#line 59
# node_type is a type attribute for all node types.
#line 59
#
#line 59
allow squid_t node_type:node { udp_send rawip_send };
#line 59
allow squid_t node_type:node { udp_recv rawip_recv };
#line 59

#line 59
#
#line 59
# Allow the domain to send to or receive from any port.
#line 59
# port_type is a type attribute for all port types.
#line 59
#
#line 59

#line 59
allow squid_t port_type:udp_socket { send_msg recv_msg };
#line 59

#line 59

#line 59
# XXX Allow binding to any node type.  Remove once
#line 59
# individual rules have been added to all domains that 
#line 59
# bind sockets. 
#line 59
allow squid_t node_type:udp_socket node_bind;
#line 59
#
#line 59
# Allow access to network files including /etc/resolv.conf
#line 59
#
#line 59
allow squid_t net_conf_t:file { read getattr lock ioctl };
#line 59

#line 59
allow squid_t self:udp_socket { connect };
#line 59

#line 59

#line 59

#line 59

#line 59

#line 59

#line 59
allow squid_t var_yp_t:dir { read getattr lock search ioctl };
#line 59
allow squid_t var_yp_t:file { read getattr lock ioctl };
#line 59
allow squid_t var_yp_t:lnk_file { getattr read };
#line 59

#line 59
allow squid_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 59
allow squid_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 59
dontaudit squid_t self:capability net_bind_service;
#line 59
dontaudit squid_t reserved_port_type:tcp_socket name_connect;
#line 59
dontaudit squid_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 59

#line 59
} else {
#line 59
dontaudit squid_t var_yp_t:dir search;
#line 59
}
#line 59
 

#line 60
#allow web_client_domain squid_t:tcp_socket { connectto recvfrom };
#line 60
#allow squid_t web_client_domain:tcp_socket { acceptfrom recvfrom };
#line 60
#allow squid_t kernel_t:tcp_socket recvfrom;
#line 60
#allow web_client_domain kernel_t:tcp_socket recvfrom;
#line 60


# tcp port 8080 and udp port 3130 is http_cache_port_t (see net_contexts)
allow squid_t { gopher_port_t ftp_port_t http_port_t http_cache_port_t }:{ tcp_socket udp_socket } name_bind;
allow squid_t { gopher_port_t ftp_port_t http_port_t http_cache_port_t }:tcp_socket name_connect;

# to allow running programs from /usr/lib/squid (IE unlinkd)
# also allow exec()ing itself

#line 68
allow squid_t { lib_t squid_exec_t bin_t sbin_t shell_exec_t } :file { { read getattr lock execute ioctl } execute_no_trans };
#line 68

allow squid_t { bin_t sbin_t }:dir search;
allow squid_t { bin_t sbin_t }:lnk_file read;

dontaudit squid_t { boot_t tmp_t home_root_t security_t devpts_t }:dir getattr;
#line 75

#line 75
dontaudit squid_t tty_device_t:chr_file { read write };
#line 75

allow squid_t urandom_device_t:chr_file { getattr read };

#squid requires the following when run in diskd mode, the recommended setting

#line 79
allow squid_t cert_t:dir { read getattr lock search ioctl };
#line 79
allow squid_t cert_t:file { read getattr lock ioctl };
#line 79
allow squid_t cert_t:lnk_file { getattr read };
#line 79

#line 84

#line 84

#line 84

#line 84

#line 84
#
#line 84
# Allow the process to transition to the new domain.
#line 84
#
#line 84
allow squid_t winbind_helper_t:process transition;
#line 84

#line 84
#
#line 84
# Do not audit when glibc secure mode is enabled upon the transition.
#line 84
#
#line 84
dontaudit squid_t winbind_helper_t:process noatsecure;
#line 84

#line 84
#
#line 84
# Do not audit when signal-related state is cleared upon the transition.
#line 84
#
#line 84
dontaudit squid_t winbind_helper_t:process siginh;
#line 84

#line 84
#
#line 84
# Do not audit when resource limits are reset upon the transition.
#line 84
#
#line 84
dontaudit squid_t winbind_helper_t:process rlimitinh;
#line 84

#line 84
#
#line 84
# Allow the process to execute the program.
#line 84
# 
#line 84
allow squid_t winbind_helper_exec_t:file { read { getattr execute } };
#line 84

#line 84
#
#line 84
# Allow the process to reap the new domain.
#line 84
#
#line 84
allow winbind_helper_t squid_t:process sigchld;
#line 84

#line 84
#
#line 84
# Allow the new domain to inherit and use file 
#line 84
# descriptions from the creating process and vice versa.
#line 84
#
#line 84
allow winbind_helper_t squid_t:fd use;
#line 84
allow squid_t winbind_helper_t:fd use;
#line 84

#line 84
#
#line 84
# Allow the new domain to write back to the old domain via a pipe.
#line 84
#
#line 84
allow winbind_helper_t squid_t:fifo_file { ioctl read getattr lock write append };
#line 84

#line 84
#
#line 84
# Allow the new domain to read and execute the program.
#line 84
#
#line 84
allow winbind_helper_t winbind_helper_exec_t:file { read getattr lock execute ioctl };
#line 84

#line 84
#
#line 84
# Allow the new domain to be entered via the program.
#line 84
#
#line 84
allow winbind_helper_t winbind_helper_exec_t:file entrypoint;
#line 84

#line 84
type_transition squid_t winbind_helper_exec_t:process winbind_helper_t;
#line 84

#line 84
allow winbind_helper_t squid_t:tcp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
#line 84
allow winbind_helper_t squid_log_t:file { ioctl read getattr lock append };
#line 84

#line 1 "domains/program/ssh.te"
#DESC sshd 
#
# Authors:  Daniel Walsh <dwalsh@redhat.com>
#

#################################
#
# Rules for the sshd domain.
#
# sshd_exec_t is the type of the /bin/sshd and other programs.
# This domain is defined just for targeted policy. 
#
type sshd_exec_t, file_type, sysadmfile, exec_type;
type ssh_exec_t, file_type, sysadmfile, exec_type;
type ssh_keygen_exec_t, file_type, sysadmfile, exec_type;
type ssh_keysign_exec_t, file_type, sysadmfile, exec_type;
type sshd_key_t, file_type, sysadmfile;
type sshd_var_run_t, file_type, sysadmfile;

#line 19

#line 19

#line 19
#
#line 19
# Allow the process to transition to the new domain.
#line 19
#
#line 19
allow initrc_t sshd_t:process transition;
#line 19

#line 19
#
#line 19
# Do not audit when glibc secure mode is enabled upon the transition.
#line 19
#
#line 19
dontaudit initrc_t sshd_t:process noatsecure;
#line 19

#line 19
#
#line 19
# Do not audit when signal-related state is cleared upon the transition.
#line 19
#
#line 19
dontaudit initrc_t sshd_t:process siginh;
#line 19

#line 19
#
#line 19
# Do not audit when resource limits are reset upon the transition.
#line 19
#
#line 19
dontaudit initrc_t sshd_t:process rlimitinh;
#line 19

#line 19
#
#line 19
# Allow the process to execute the program.
#line 19
# 
#line 19
allow initrc_t sshd_exec_t:file { read { getattr execute } };
#line 19

#line 19
#
#line 19
# Allow the process to reap the new domain.
#line 19
#
#line 19
allow sshd_t initrc_t:process sigchld;
#line 19

#line 19
#
#line 19
# Allow the new domain to inherit and use file 
#line 19
# descriptions from the creating process and vice versa.
#line 19
#
#line 19
allow sshd_t initrc_t:fd use;
#line 19
allow initrc_t sshd_t:fd use;
#line 19

#line 19
#
#line 19
# Allow the new domain to write back to the old domain via a pipe.
#line 19
#
#line 19
allow sshd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 19

#line 19
#
#line 19
# Allow the new domain to read and execute the program.
#line 19
#
#line 19
allow sshd_t sshd_exec_t:file { read getattr lock execute ioctl };
#line 19

#line 19
#
#line 19
# Allow the new domain to be entered via the program.
#line 19
#
#line 19
allow sshd_t sshd_exec_t:file entrypoint;
#line 19

#line 19
type_transition initrc_t sshd_exec_t:process sshd_t;
#line 19

#line 22

#line 1 "domains/program/stunnel.te"
# DESC: selinux policy for stunnel
#
# Author:   petre rodan <kaiowas@gentoo.org>
#
#line 28

#line 28

#line 28
type stunnel_t, domain, privlog, nscd_client_domain;
#line 28
role system_r types stunnel_t;
#line 28

#line 28
#
#line 28
# Allows user to define a tunable to disable domain transition
#line 28
#
#line 28
bool stunnel_disable_trans false;
#line 28
if (stunnel_disable_trans) {
#line 28

#line 28
allow initrc_t stunnel_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 28

#line 28

#line 28
allow sysadm_t stunnel_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 28

#line 28
} else {
#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the process to transition to the new domain.
#line 28
#
#line 28
allow inetd_t stunnel_t:process transition;
#line 28

#line 28
#
#line 28
# Do not audit when glibc secure mode is enabled upon the transition.
#line 28
#
#line 28
dontaudit inetd_t stunnel_t:process noatsecure;
#line 28

#line 28
#
#line 28
# Do not audit when signal-related state is cleared upon the transition.
#line 28
#
#line 28
dontaudit inetd_t stunnel_t:process siginh;
#line 28

#line 28
#
#line 28
# Do not audit when resource limits are reset upon the transition.
#line 28
#
#line 28
dontaudit inetd_t stunnel_t:process rlimitinh;
#line 28

#line 28
#
#line 28
# Allow the process to execute the program.
#line 28
# 
#line 28
allow inetd_t stunnel_exec_t:file { read { getattr execute } };
#line 28

#line 28
#
#line 28
# Allow the process to reap the new domain.
#line 28
#
#line 28
allow stunnel_t inetd_t:process sigchld;
#line 28

#line 28
#
#line 28
# Allow the new domain to inherit and use file 
#line 28
# descriptions from the creating process and vice versa.
#line 28
#
#line 28
allow stunnel_t inetd_t:fd use;
#line 28
allow inetd_t stunnel_t:fd use;
#line 28

#line 28
#
#line 28
# Allow the new domain to write back to the old domain via a pipe.
#line 28
#
#line 28
allow stunnel_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 28

#line 28
#
#line 28
# Allow the new domain to read and execute the program.
#line 28
#
#line 28
allow stunnel_t stunnel_exec_t:file { read getattr lock execute ioctl };
#line 28

#line 28
#
#line 28
# Allow the new domain to be entered via the program.
#line 28
#
#line 28
allow stunnel_t stunnel_exec_t:file entrypoint;
#line 28

#line 28
type_transition inetd_t stunnel_exec_t:process stunnel_t;
#line 28

#line 28
allow inetd_t stunnel_t:process sigkill;
#line 28
}
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the domain to create and use tcp sockets.
#line 28
# Other kinds of sockets must be separately authorized for use.
#line 28
allow stunnel_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 28

#line 28
allow stunnel_t unlabeled_t:association { sendto recvfrom };
#line 28

#line 28
#
#line 28
# Allow the domain to send or receive using any network interface.
#line 28
# netif_type is a type attribute for all network interface types.
#line 28
#
#line 28
allow stunnel_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 28
#
#line 28
# Allow the domain to send to or receive from any node.
#line 28
# node_type is a type attribute for all node types.
#line 28
#
#line 28
allow stunnel_t node_type:node { tcp_send rawip_send };
#line 28
allow stunnel_t node_type:node { tcp_recv rawip_recv };
#line 28

#line 28
#
#line 28
# Allow the domain to send to or receive from any port.
#line 28
# port_type is a type attribute for all port types.
#line 28
#
#line 28

#line 28
allow stunnel_t port_type:tcp_socket { send_msg recv_msg };
#line 28

#line 28

#line 28
# XXX Allow binding to any node type.  Remove once
#line 28
# individual rules have been added to all domains that 
#line 28
# bind sockets. 
#line 28
allow stunnel_t node_type:tcp_socket node_bind;
#line 28
#
#line 28
# Allow access to network files including /etc/resolv.conf
#line 28
#
#line 28
allow stunnel_t net_conf_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t self:tcp_socket { listen accept };
#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the domain to create and use udp sockets.
#line 28
# Other kinds of sockets must be separately authorized for use.
#line 28
allow stunnel_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 28

#line 28
allow stunnel_t unlabeled_t:association { sendto recvfrom };
#line 28

#line 28
#
#line 28
# Allow the domain to send or receive using any network interface.
#line 28
# netif_type is a type attribute for all network interface types.
#line 28
#
#line 28
allow stunnel_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 28
#
#line 28
# Allow the domain to send to or receive from any node.
#line 28
# node_type is a type attribute for all node types.
#line 28
#
#line 28
allow stunnel_t node_type:node { udp_send rawip_send };
#line 28
allow stunnel_t node_type:node { udp_recv rawip_recv };
#line 28

#line 28
#
#line 28
# Allow the domain to send to or receive from any port.
#line 28
# port_type is a type attribute for all port types.
#line 28
#
#line 28

#line 28
allow stunnel_t port_type:udp_socket { send_msg recv_msg };
#line 28

#line 28

#line 28
# XXX Allow binding to any node type.  Remove once
#line 28
# individual rules have been added to all domains that 
#line 28
# bind sockets. 
#line 28
allow stunnel_t node_type:udp_socket node_bind;
#line 28
#
#line 28
# Allow access to network files including /etc/resolv.conf
#line 28
#
#line 28
allow stunnel_t net_conf_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t self:udp_socket { connect };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
if (allow_ypbind) {
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the domain to create and use tcp sockets.
#line 28
# Other kinds of sockets must be separately authorized for use.
#line 28
allow stunnel_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 28

#line 28
allow stunnel_t unlabeled_t:association { sendto recvfrom };
#line 28

#line 28
#
#line 28
# Allow the domain to send or receive using any network interface.
#line 28
# netif_type is a type attribute for all network interface types.
#line 28
#
#line 28
allow stunnel_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 28
#
#line 28
# Allow the domain to send to or receive from any node.
#line 28
# node_type is a type attribute for all node types.
#line 28
#
#line 28
allow stunnel_t node_type:node { tcp_send rawip_send };
#line 28
allow stunnel_t node_type:node { tcp_recv rawip_recv };
#line 28

#line 28
#
#line 28
# Allow the domain to send to or receive from any port.
#line 28
# port_type is a type attribute for all port types.
#line 28
#
#line 28

#line 28
allow stunnel_t port_type:tcp_socket { send_msg recv_msg };
#line 28

#line 28

#line 28
# XXX Allow binding to any node type.  Remove once
#line 28
# individual rules have been added to all domains that 
#line 28
# bind sockets. 
#line 28
allow stunnel_t node_type:tcp_socket node_bind;
#line 28
#
#line 28
# Allow access to network files including /etc/resolv.conf
#line 28
#
#line 28
allow stunnel_t net_conf_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t self:tcp_socket { listen accept };
#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the domain to create and use tcp sockets.
#line 28
# Other kinds of sockets must be separately authorized for use.
#line 28
allow stunnel_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 28

#line 28
allow stunnel_t unlabeled_t:association { sendto recvfrom };
#line 28

#line 28
#
#line 28
# Allow the domain to send or receive using any network interface.
#line 28
# netif_type is a type attribute for all network interface types.
#line 28
#
#line 28
allow stunnel_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 28
#
#line 28
# Allow the domain to send to or receive from any node.
#line 28
# node_type is a type attribute for all node types.
#line 28
#
#line 28
allow stunnel_t node_type:node { tcp_send rawip_send };
#line 28
allow stunnel_t node_type:node { tcp_recv rawip_recv };
#line 28

#line 28
#
#line 28
# Allow the domain to send to or receive from any port.
#line 28
# port_type is a type attribute for all port types.
#line 28
#
#line 28

#line 28
allow stunnel_t port_type:tcp_socket { send_msg recv_msg };
#line 28

#line 28

#line 28
# XXX Allow binding to any node type.  Remove once
#line 28
# individual rules have been added to all domains that 
#line 28
# bind sockets. 
#line 28
allow stunnel_t node_type:tcp_socket node_bind;
#line 28
#
#line 28
# Allow access to network files including /etc/resolv.conf
#line 28
#
#line 28
allow stunnel_t net_conf_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t self:tcp_socket { connect };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the domain to create and use udp sockets.
#line 28
# Other kinds of sockets must be separately authorized for use.
#line 28
allow stunnel_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 28

#line 28
allow stunnel_t unlabeled_t:association { sendto recvfrom };
#line 28

#line 28
#
#line 28
# Allow the domain to send or receive using any network interface.
#line 28
# netif_type is a type attribute for all network interface types.
#line 28
#
#line 28
allow stunnel_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 28
#
#line 28
# Allow the domain to send to or receive from any node.
#line 28
# node_type is a type attribute for all node types.
#line 28
#
#line 28
allow stunnel_t node_type:node { udp_send rawip_send };
#line 28
allow stunnel_t node_type:node { udp_recv rawip_recv };
#line 28

#line 28
#
#line 28
# Allow the domain to send to or receive from any port.
#line 28
# port_type is a type attribute for all port types.
#line 28
#
#line 28

#line 28
allow stunnel_t port_type:udp_socket { send_msg recv_msg };
#line 28

#line 28

#line 28
# XXX Allow binding to any node type.  Remove once
#line 28
# individual rules have been added to all domains that 
#line 28
# bind sockets. 
#line 28
allow stunnel_t node_type:udp_socket node_bind;
#line 28
#
#line 28
# Allow access to network files including /etc/resolv.conf
#line 28
#
#line 28
allow stunnel_t net_conf_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t self:udp_socket { connect };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
allow stunnel_t var_yp_t:dir { read getattr lock search ioctl };
#line 28
allow stunnel_t var_yp_t:file { read getattr lock ioctl };
#line 28
allow stunnel_t var_yp_t:lnk_file { getattr read };
#line 28

#line 28
allow stunnel_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 28
allow stunnel_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 28
dontaudit stunnel_t self:capability net_bind_service;
#line 28
dontaudit stunnel_t reserved_port_type:tcp_socket name_connect;
#line 28
dontaudit stunnel_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 28

#line 28
} else {
#line 28
dontaudit stunnel_t var_yp_t:dir search;
#line 28
}
#line 28
 
#line 28

#line 28
allow stunnel_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 28
allow stunnel_t lib_t:lnk_file { read getattr lock ioctl };
#line 28
allow stunnel_t ld_so_t:file { read getattr lock execute ioctl };
#line 28
#allow stunnel_t ld_so_t:file execute_no_trans;
#line 28
allow stunnel_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 28
allow stunnel_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 28
allow stunnel_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 28
allow stunnel_t texrel_shlib_t:file execmod;
#line 28
allow stunnel_t ld_so_cache_t:file { read getattr lock ioctl };
#line 28
allow stunnel_t device_t:dir search;
#line 28
allow stunnel_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 28

#line 28
allow stunnel_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 28
allow stunnel_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 28
allow stunnel_t self:fifo_file { ioctl read getattr lock write append };
#line 28
type stunnel_exec_t, file_type, sysadmfile, exec_type;
#line 28

#line 28
allow stunnel_t etc_t:lnk_file read;
#line 28
allow stunnel_t lib_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t locale_t:dir { read getattr lock search ioctl };
#line 28
allow stunnel_t locale_t:file { read getattr lock ioctl };
#line 28
allow stunnel_t locale_t:lnk_file { getattr read };
#line 28

#line 28

#line 28
allow stunnel_t device_t:dir search;
#line 28
allow stunnel_t proc_t:dir search;
#line 28
allow stunnel_t proc_t:{ file lnk_file } { getattr read };
#line 28
allow stunnel_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 28
allow stunnel_t fs_t:filesystem getattr;
#line 28

#line 28

#line 28
# Read system variables in /sys.
#line 28

#line 28
allow stunnel_t sysctl_t:dir search;
#line 28
allow stunnel_t sysctl_kernel_t:dir search;
#line 28
allow stunnel_t sysctl_kernel_t:file { getattr read };
#line 28

#line 28

#line 28

#line 28

#line 28
allow stunnel_t etc_t:file { getattr read };
#line 28

#line 28

#line 28
type stunnel_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the process to modify the directory.
#line 28
#
#line 28
allow stunnel_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 28

#line 28
#
#line 28
# Allow the process to create the file.
#line 28
#
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
allow stunnel_t stunnel_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
allow stunnel_t stunnel_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
type_transition stunnel_t tmp_t:{ file dir } stunnel_tmp_t;
#line 28

#line 28

#line 28

#line 28
allow stunnel_t var_t:dir search;
#line 28

#line 28
type stunnel_var_run_t, file_type, sysadmfile, pidfile;
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the process to modify the directory.
#line 28
#
#line 28
allow stunnel_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 28

#line 28
#
#line 28
# Allow the process to create the file.
#line 28
#
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
allow stunnel_t stunnel_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
type_transition stunnel_t var_run_t:file stunnel_var_run_t;
#line 28

#line 28

#line 28

#line 28
allow stunnel_t var_t:dir search;
#line 28
allow stunnel_t stunnel_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 28

#line 28

#line 28
# Inherit and use descriptors from inetd.
#line 28
allow stunnel_t inetd_t:fd use;
#line 28

#line 28
# for identd
#line 28
allow stunnel_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 28
allow stunnel_t self:capability { setuid setgid };
#line 28
allow stunnel_t home_root_t:dir search;
#line 28
allow stunnel_t self:dir search;
#line 28
allow stunnel_t self:{ lnk_file file } { getattr read };
#line 28

#line 28

#line 28
if (allow_kerberos) {
#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the domain to create and use tcp sockets.
#line 28
# Other kinds of sockets must be separately authorized for use.
#line 28
allow stunnel_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 28

#line 28
allow stunnel_t unlabeled_t:association { sendto recvfrom };
#line 28

#line 28
#
#line 28
# Allow the domain to send or receive using any network interface.
#line 28
# netif_type is a type attribute for all network interface types.
#line 28
#
#line 28
allow stunnel_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 28
#
#line 28
# Allow the domain to send to or receive from any node.
#line 28
# node_type is a type attribute for all node types.
#line 28
#
#line 28
allow stunnel_t node_type:node { tcp_send rawip_send };
#line 28
allow stunnel_t node_type:node { tcp_recv rawip_recv };
#line 28

#line 28
#
#line 28
# Allow the domain to send to or receive from any port.
#line 28
# port_type is a type attribute for all port types.
#line 28
#
#line 28

#line 28
allow stunnel_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 28

#line 28

#line 28
# XXX Allow binding to any node type.  Remove once
#line 28
# individual rules have been added to all domains that 
#line 28
# bind sockets. 
#line 28
allow stunnel_t node_type:tcp_socket node_bind;
#line 28
#
#line 28
# Allow access to network files including /etc/resolv.conf
#line 28
#
#line 28
allow stunnel_t net_conf_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t self:tcp_socket { connect };
#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the domain to create and use udp sockets.
#line 28
# Other kinds of sockets must be separately authorized for use.
#line 28
allow stunnel_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 28

#line 28
allow stunnel_t unlabeled_t:association { sendto recvfrom };
#line 28

#line 28
#
#line 28
# Allow the domain to send or receive using any network interface.
#line 28
# netif_type is a type attribute for all network interface types.
#line 28
#
#line 28
allow stunnel_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 28
#
#line 28
# Allow the domain to send to or receive from any node.
#line 28
# node_type is a type attribute for all node types.
#line 28
#
#line 28
allow stunnel_t node_type:node { udp_send rawip_send };
#line 28
allow stunnel_t node_type:node { udp_recv rawip_recv };
#line 28

#line 28
#
#line 28
# Allow the domain to send to or receive from any port.
#line 28
# port_type is a type attribute for all port types.
#line 28
#
#line 28

#line 28
allow stunnel_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 28

#line 28

#line 28
# XXX Allow binding to any node type.  Remove once
#line 28
# individual rules have been added to all domains that 
#line 28
# bind sockets. 
#line 28
allow stunnel_t node_type:udp_socket node_bind;
#line 28
#
#line 28
# Allow access to network files including /etc/resolv.conf
#line 28
#
#line 28
allow stunnel_t net_conf_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t self:udp_socket { connect };
#line 28

#line 28

#line 28

#line 28
allow stunnel_t kerberos_port_t:tcp_socket name_connect;
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the domain to create and use tcp sockets.
#line 28
# Other kinds of sockets must be separately authorized for use.
#line 28
allow stunnel_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 28

#line 28
allow stunnel_t unlabeled_t:association { sendto recvfrom };
#line 28

#line 28
#
#line 28
# Allow the domain to send or receive using any network interface.
#line 28
# netif_type is a type attribute for all network interface types.
#line 28
#
#line 28
allow stunnel_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 28
#
#line 28
# Allow the domain to send to or receive from any node.
#line 28
# node_type is a type attribute for all node types.
#line 28
#
#line 28
allow stunnel_t node_type:node { tcp_send rawip_send };
#line 28
allow stunnel_t node_type:node { tcp_recv rawip_recv };
#line 28

#line 28
#
#line 28
# Allow the domain to send to or receive from any port.
#line 28
# port_type is a type attribute for all port types.
#line 28
#
#line 28

#line 28
allow stunnel_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 28

#line 28

#line 28
# XXX Allow binding to any node type.  Remove once
#line 28
# individual rules have been added to all domains that 
#line 28
# bind sockets. 
#line 28
allow stunnel_t node_type:tcp_socket node_bind;
#line 28
#
#line 28
# Allow access to network files including /etc/resolv.conf
#line 28
#
#line 28
allow stunnel_t net_conf_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t self:tcp_socket { connect };
#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the domain to create and use udp sockets.
#line 28
# Other kinds of sockets must be separately authorized for use.
#line 28
allow stunnel_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 28

#line 28
allow stunnel_t unlabeled_t:association { sendto recvfrom };
#line 28

#line 28
#
#line 28
# Allow the domain to send or receive using any network interface.
#line 28
# netif_type is a type attribute for all network interface types.
#line 28
#
#line 28
allow stunnel_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 28
#
#line 28
# Allow the domain to send to or receive from any node.
#line 28
# node_type is a type attribute for all node types.
#line 28
#
#line 28
allow stunnel_t node_type:node { udp_send rawip_send };
#line 28
allow stunnel_t node_type:node { udp_recv rawip_recv };
#line 28

#line 28
#
#line 28
# Allow the domain to send to or receive from any port.
#line 28
# port_type is a type attribute for all port types.
#line 28
#
#line 28

#line 28
allow stunnel_t dns_port_t:udp_socket { send_msg recv_msg };
#line 28

#line 28

#line 28
# XXX Allow binding to any node type.  Remove once
#line 28
# individual rules have been added to all domains that 
#line 28
# bind sockets. 
#line 28
allow stunnel_t node_type:udp_socket node_bind;
#line 28
#
#line 28
# Allow access to network files including /etc/resolv.conf
#line 28
#
#line 28
allow stunnel_t net_conf_t:file { read getattr lock ioctl };
#line 28

#line 28
allow stunnel_t self:udp_socket { connect };
#line 28

#line 28

#line 28

#line 28
allow stunnel_t dns_port_t:tcp_socket name_connect;
#line 28

#line 28
}
#line 28
 dontaudit stunnel_t krb5_conf_t:file write;
#line 28
allow stunnel_t krb5_conf_t:file { getattr read };
#line 28

#line 28
allow stunnel_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 28
# Use sockets inherited from inetd.
#line 28

#line 28

#line 28
allow inetd_t stunnel_port_t:tcp_socket name_bind;
#line 28
allow stunnel_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 28

#line 28

#line 28

#line 28
allow stunnel_t proc_net_t:dir { read getattr lock search ioctl };
#line 28
allow stunnel_t proc_net_t:file { read getattr lock ioctl };
#line 28
allow stunnel_t proc_net_t:lnk_file { getattr read };
#line 28

#line 28

#line 28
allow stunnel_t self:capability sys_chroot;
#line 28

#line 28
bool stunnel_is_daemon false;
#line 28
if (stunnel_is_daemon) {
#line 28
# Policy to run stunnel as a daemon should go here.
#line 28
allow stunnel_t self:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 28
allow stunnel_t stunnel_port_t:tcp_socket name_bind;
#line 28
}
#line 28


type stunnel_etc_t, file_type, sysadmfile;

#line 31
allow stunnel_t stunnel_etc_t:dir { read getattr lock search ioctl };
#line 31
allow stunnel_t stunnel_etc_t:file { read getattr lock ioctl };
#line 31
allow stunnel_t stunnel_etc_t:lnk_file { getattr read };
#line 31

allow stunnel_t stunnel_port_t:tcp_socket { name_bind };

#line 1 "domains/program/syslogd.te"
#DESC Syslogd - System log daemon
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
# X-Debian-Packages: sysklogd syslog-ng
#

#################################
#
# Rules for the syslogd_t domain.
#
# syslogd_t is the domain of syslogd.
# syslogd_exec_t is the type of the syslogd executable.
# devlog_t is the type of the Unix domain socket created 
# by syslogd.
#
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
type syslogd_t, domain, privlog, daemon , privkmsg, nscd_client_domain, transitionbool;
#line 20
type syslogd_exec_t, file_type, sysadmfile, exec_type;
#line 20
dontaudit syslogd_t self:capability sys_tty_config;
#line 20

#line 20
role system_r types syslogd_t;
#line 20

#line 20
# Inherit and use descriptors from init.
#line 20
allow syslogd_t init_t:fd use;
#line 20
allow syslogd_t init_t:process sigchld;
#line 20
allow syslogd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 20

#line 20

#line 20
allow syslogd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 20
allow syslogd_t lib_t:lnk_file { read getattr lock ioctl };
#line 20
allow syslogd_t ld_so_t:file { read getattr lock execute ioctl };
#line 20
#allow syslogd_t ld_so_t:file execute_no_trans;
#line 20
allow syslogd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 20
allow syslogd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 20
allow syslogd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 20
allow syslogd_t texrel_shlib_t:file execmod;
#line 20
allow syslogd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 20
allow syslogd_t device_t:dir search;
#line 20
allow syslogd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 20

#line 20

#line 20
allow syslogd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 20
allow syslogd_t { self proc_t }:lnk_file { getattr read };
#line 20

#line 20
allow syslogd_t device_t:dir { read getattr lock search ioctl };
#line 20

#line 20
allow syslogd_t udev_tdb_t:file { read getattr lock ioctl };
#line 20
allow syslogd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 20
dontaudit syslogd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 20
dontaudit syslogd_t unpriv_userdomain:fd use;
#line 20

#line 20

#line 20
allow syslogd_t sysfs_t:dir { read getattr lock search ioctl };
#line 20
allow syslogd_t sysfs_t:file { read getattr lock ioctl };
#line 20
allow syslogd_t sysfs_t:lnk_file { getattr read };
#line 20
 
#line 20

#line 20
allow syslogd_t autofs_t:dir { search getattr };
#line 20

#line 20
dontaudit syslogd_t { tty_device_t devpts_t }:chr_file { read write };
#line 20
dontaudit syslogd_t root_t:file { getattr read };
#line 20
 
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
# Read system variables in /sys.
#line 20

#line 20
allow syslogd_t sysctl_t:dir search;
#line 20
allow syslogd_t sysctl_kernel_t:dir search;
#line 20
allow syslogd_t sysctl_kernel_t:file { getattr read };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allows user to define a tunable to disable domain transition
#line 20
#
#line 20

#line 20
bool syslogd_disable_trans false;
#line 20
if (syslogd_disable_trans) {
#line 20

#line 20
allow initrc_t syslogd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 20

#line 20

#line 20
allow sysadm_t syslogd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 20

#line 20
} else {
#line 20
 
#line 20

#line 20

#line 20
#
#line 20
# Allow the process to transition to the new domain.
#line 20
#
#line 20
allow initrc_t syslogd_t:process transition;
#line 20

#line 20
#
#line 20
# Do not audit when glibc secure mode is enabled upon the transition.
#line 20
#
#line 20
dontaudit initrc_t syslogd_t:process noatsecure;
#line 20

#line 20
#
#line 20
# Do not audit when signal-related state is cleared upon the transition.
#line 20
#
#line 20
dontaudit initrc_t syslogd_t:process siginh;
#line 20

#line 20
#
#line 20
# Do not audit when resource limits are reset upon the transition.
#line 20
#
#line 20
dontaudit initrc_t syslogd_t:process rlimitinh;
#line 20

#line 20
#
#line 20
# Allow the process to execute the program.
#line 20
# 
#line 20
allow initrc_t syslogd_exec_t:file { read { getattr execute } };
#line 20

#line 20
#
#line 20
# Allow the process to reap the new domain.
#line 20
#
#line 20
allow syslogd_t initrc_t:process sigchld;
#line 20

#line 20
#
#line 20
# Allow the new domain to inherit and use file 
#line 20
# descriptions from the creating process and vice versa.
#line 20
#
#line 20
allow syslogd_t initrc_t:fd use;
#line 20
allow initrc_t syslogd_t:fd use;
#line 20

#line 20
#
#line 20
# Allow the new domain to write back to the old domain via a pipe.
#line 20
#
#line 20
allow syslogd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 20

#line 20
#
#line 20
# Allow the new domain to read and execute the program.
#line 20
#
#line 20
allow syslogd_t syslogd_exec_t:file { read getattr lock execute ioctl };
#line 20

#line 20
#
#line 20
# Allow the new domain to be entered via the program.
#line 20
#
#line 20
allow syslogd_t syslogd_exec_t:file entrypoint;
#line 20

#line 20
type_transition initrc_t syslogd_exec_t:process syslogd_t;
#line 20

#line 20

#line 20
allow initrc_t syslogd_t:process { noatsecure siginh rlimitinh };
#line 20

#line 20
}
#line 20
 
#line 20
allow syslogd_t privfd:fd use;
#line 20

#line 20
allow syslogd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 20

#line 20

#line 20
# Create pid file.
#line 20
allow syslogd_t var_t:dir { getattr search };
#line 20

#line 20
type syslogd_var_run_t, file_type, sysadmfile, pidfile;
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
#
#line 20
# Allow the process to modify the directory.
#line 20
#
#line 20
allow syslogd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 20

#line 20
#
#line 20
# Allow the process to create the file.
#line 20
#
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
allow syslogd_t syslogd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20

#line 20
type_transition syslogd_t var_run_t:file syslogd_var_run_t;
#line 20

#line 20

#line 20

#line 20
allow syslogd_t var_t:dir search;
#line 20
allow syslogd_t syslogd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 20

#line 20

#line 20
allow syslogd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 20

#line 20
# for daemons that look at /root on startup
#line 20
dontaudit syslogd_t sysadm_home_dir_t:dir search;
#line 20

#line 20
# for df
#line 20
allow syslogd_t fs_type:filesystem getattr;
#line 20
allow syslogd_t removable_t:filesystem getattr;
#line 20

#line 20

#line 20
allow syslogd_t etc_t:lnk_file read;
#line 20
allow syslogd_t lib_t:file { read getattr lock ioctl };
#line 20

#line 20
allow syslogd_t locale_t:dir { read getattr lock search ioctl };
#line 20
allow syslogd_t locale_t:file { read getattr lock ioctl };
#line 20
allow syslogd_t locale_t:lnk_file { getattr read };
#line 20

#line 20

#line 20

#line 20
# for localization
#line 20
allow syslogd_t lib_t:file { getattr read };
#line 20

#line 20


# can_network is for the UDP socket

#line 23

#line 23
#
#line 23
# Allow the domain to create and use udp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow syslogd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow syslogd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow syslogd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow syslogd_t node_type:node { udp_send rawip_send };
#line 23
allow syslogd_t node_type:node { udp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow syslogd_t port_type:udp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow syslogd_t node_type:udp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow syslogd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow syslogd_t self:udp_socket { connect };
#line 23


#line 24

#line 24
if (allow_ypbind) {
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the domain to create and use tcp sockets.
#line 24
# Other kinds of sockets must be separately authorized for use.
#line 24
allow syslogd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 24

#line 24
allow syslogd_t unlabeled_t:association { sendto recvfrom };
#line 24

#line 24
#
#line 24
# Allow the domain to send or receive using any network interface.
#line 24
# netif_type is a type attribute for all network interface types.
#line 24
#
#line 24
allow syslogd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 24
#
#line 24
# Allow the domain to send to or receive from any node.
#line 24
# node_type is a type attribute for all node types.
#line 24
#
#line 24
allow syslogd_t node_type:node { tcp_send rawip_send };
#line 24
allow syslogd_t node_type:node { tcp_recv rawip_recv };
#line 24

#line 24
#
#line 24
# Allow the domain to send to or receive from any port.
#line 24
# port_type is a type attribute for all port types.
#line 24
#
#line 24

#line 24
allow syslogd_t port_type:tcp_socket { send_msg recv_msg };
#line 24

#line 24

#line 24
# XXX Allow binding to any node type.  Remove once
#line 24
# individual rules have been added to all domains that 
#line 24
# bind sockets. 
#line 24
allow syslogd_t node_type:tcp_socket node_bind;
#line 24
#
#line 24
# Allow access to network files including /etc/resolv.conf
#line 24
#
#line 24
allow syslogd_t net_conf_t:file { read getattr lock ioctl };
#line 24

#line 24
allow syslogd_t self:tcp_socket { listen accept };
#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the domain to create and use tcp sockets.
#line 24
# Other kinds of sockets must be separately authorized for use.
#line 24
allow syslogd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 24

#line 24
allow syslogd_t unlabeled_t:association { sendto recvfrom };
#line 24

#line 24
#
#line 24
# Allow the domain to send or receive using any network interface.
#line 24
# netif_type is a type attribute for all network interface types.
#line 24
#
#line 24
allow syslogd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 24
#
#line 24
# Allow the domain to send to or receive from any node.
#line 24
# node_type is a type attribute for all node types.
#line 24
#
#line 24
allow syslogd_t node_type:node { tcp_send rawip_send };
#line 24
allow syslogd_t node_type:node { tcp_recv rawip_recv };
#line 24

#line 24
#
#line 24
# Allow the domain to send to or receive from any port.
#line 24
# port_type is a type attribute for all port types.
#line 24
#
#line 24

#line 24
allow syslogd_t port_type:tcp_socket { send_msg recv_msg };
#line 24

#line 24

#line 24
# XXX Allow binding to any node type.  Remove once
#line 24
# individual rules have been added to all domains that 
#line 24
# bind sockets. 
#line 24
allow syslogd_t node_type:tcp_socket node_bind;
#line 24
#
#line 24
# Allow access to network files including /etc/resolv.conf
#line 24
#
#line 24
allow syslogd_t net_conf_t:file { read getattr lock ioctl };
#line 24

#line 24
allow syslogd_t self:tcp_socket { connect };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
#
#line 24
# Allow the domain to create and use udp sockets.
#line 24
# Other kinds of sockets must be separately authorized for use.
#line 24
allow syslogd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 24

#line 24
allow syslogd_t unlabeled_t:association { sendto recvfrom };
#line 24

#line 24
#
#line 24
# Allow the domain to send or receive using any network interface.
#line 24
# netif_type is a type attribute for all network interface types.
#line 24
#
#line 24
allow syslogd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 24
#
#line 24
# Allow the domain to send to or receive from any node.
#line 24
# node_type is a type attribute for all node types.
#line 24
#
#line 24
allow syslogd_t node_type:node { udp_send rawip_send };
#line 24
allow syslogd_t node_type:node { udp_recv rawip_recv };
#line 24

#line 24
#
#line 24
# Allow the domain to send to or receive from any port.
#line 24
# port_type is a type attribute for all port types.
#line 24
#
#line 24

#line 24
allow syslogd_t port_type:udp_socket { send_msg recv_msg };
#line 24

#line 24

#line 24
# XXX Allow binding to any node type.  Remove once
#line 24
# individual rules have been added to all domains that 
#line 24
# bind sockets. 
#line 24
allow syslogd_t node_type:udp_socket node_bind;
#line 24
#
#line 24
# Allow access to network files including /etc/resolv.conf
#line 24
#
#line 24
allow syslogd_t net_conf_t:file { read getattr lock ioctl };
#line 24

#line 24
allow syslogd_t self:udp_socket { connect };
#line 24

#line 24

#line 24

#line 24

#line 24

#line 24

#line 24
allow syslogd_t var_yp_t:dir { read getattr lock search ioctl };
#line 24
allow syslogd_t var_yp_t:file { read getattr lock ioctl };
#line 24
allow syslogd_t var_yp_t:lnk_file { getattr read };
#line 24

#line 24
allow syslogd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 24
allow syslogd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 24
dontaudit syslogd_t self:capability net_bind_service;
#line 24
dontaudit syslogd_t reserved_port_type:tcp_socket name_connect;
#line 24
dontaudit syslogd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 24

#line 24
} else {
#line 24
dontaudit syslogd_t var_yp_t:dir search;
#line 24
}
#line 24
 


#line 26
allow syslogd_t sysfs_t:dir { read getattr lock search ioctl };
#line 26
allow syslogd_t sysfs_t:file { read getattr lock ioctl };
#line 26
allow syslogd_t sysfs_t:lnk_file { getattr read };
#line 26


type devlog_t, file_type, sysadmfile, dev_fs, mlstrustedobject;

# if something can log to syslog they should be able to log to the console
allow privlog console_device_t:chr_file { ioctl read write getattr };


#line 33
type syslogd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 33

#line 33

#line 33

#line 33

#line 33
#
#line 33
# Allow the process to modify the directory.
#line 33
#
#line 33
allow syslogd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 33

#line 33
#
#line 33
# Allow the process to create the file.
#line 33
#
#line 33

#line 33

#line 33

#line 33

#line 33

#line 33
allow syslogd_t syslogd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33
allow syslogd_t syslogd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33

#line 33
type_transition syslogd_t tmp_t:{ file dir } syslogd_tmp_t;
#line 33

#line 33

#line 33


# read files in /etc
allow syslogd_t { etc_runtime_t etc_t }:file { read getattr lock ioctl };

# Use capabilities.
allow syslogd_t self:capability { dac_override net_admin net_bind_service sys_resource sys_tty_config };

# Modify/create log files.

#line 42
allow syslogd_t var_log_t:dir { read getattr search add_name write };
#line 42
allow syslogd_t var_log_t:file { create ioctl getattr setattr append link };
#line 42


# Create and bind to /dev/log or /var/run/log.

#line 45

#line 45

#line 45

#line 45
#
#line 45
# Allow the process to modify the directory.
#line 45
#
#line 45
allow syslogd_t { device_t var_run_t }:dir { read getattr lock search ioctl add_name remove_name write };
#line 45

#line 45
#
#line 45
# Allow the process to create the file.
#line 45
#
#line 45

#line 45

#line 45

#line 45

#line 45

#line 45
allow syslogd_t devlog_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 45

#line 45

#line 45

#line 45

#line 45

#line 45

#line 45

#line 45

#line 45

#line 45
type_transition syslogd_t { device_t var_run_t }:sock_file devlog_t;
#line 45

#line 45

#line 49

allow syslogd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow syslogd_t self:unix_dgram_socket sendto;
allow syslogd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow syslogd_t self:fifo_file { ioctl read getattr lock write append };
allow syslogd_t devlog_t:unix_stream_socket name_bind;
allow syslogd_t devlog_t:unix_dgram_socket name_bind;
# log to the xconsole
allow syslogd_t xconsole_device_t:fifo_file { ioctl read write };

# Domains with the privlog attribute may log to syslogd.
allow privlog devlog_t:sock_file { ioctl read getattr lock write append };

#line 61
allow privlog syslogd_t:unix_dgram_socket sendto;
#line 61


#line 62
allow privlog syslogd_t:unix_stream_socket connectto;
#line 62

# allow /dev/log to be a link elsewhere for chroot setup
allow privlog devlog_t:lnk_file read;

#line 69

#line 69
# for daemon re-start
#line 69
allow system_crond_t syslogd_t:lnk_file read;
#line 69


#line 73


# for sending messages to logged in users
allow syslogd_t initrc_var_run_t:file { read lock };
dontaudit syslogd_t initrc_var_run_t:file write;
allow syslogd_t ttyfile:chr_file { getattr write };

#
# Special case to handle crashes
#
allow syslogd_t { device_t file_t }:sock_file { getattr unlink };

# Allow syslog to a terminal
allow syslogd_t tty_device_t:chr_file { getattr write ioctl append };

# Allow name_bind for remote logging
allow syslogd_t syslogd_port_t:udp_socket name_bind;
#
# /initrd is not umounted before minilog starts
#
dontaudit syslogd_t file_t:dir search;
allow syslogd_t { tmpfs_t devpts_t }:dir search;
dontaudit syslogd_t unlabeled_t:file { getattr read };
dontaudit syslogd_t { userpty_type devpts_t }:chr_file getattr;
allow syslogd_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 101

#line 101
allow syslogd_t var_run_t:fifo_file { ioctl read write };
#line 101
allow syslogd_t ttyfile:chr_file { getattr write ioctl append };
#line 101


# Allow access to /proc/kmsg for syslog-ng
allow syslogd_t proc_t:dir search;
allow syslogd_t proc_kmsg_t:file { getattr read };
allow syslogd_t kernel_t:system { syslog_mod syslog_console };
allow syslogd_t self:capability { sys_admin chown fsetid };
allow syslogd_t var_log_t:dir { create setattr };
allow syslogd_t syslogd_port_t:tcp_socket name_bind;
allow syslogd_t rsh_port_t:tcp_socket name_connect;
#line 1 "domains/program/telnetd.te"
# telnet server daemon
#

#################################
#
# Rules for the telnetd_t domain 
#


#line 9

#line 9
type telnetd_t, domain, privlog, nscd_client_domain;
#line 9
role system_r types telnetd_t;
#line 9

#line 9
#
#line 9
# Allows user to define a tunable to disable domain transition
#line 9
#
#line 9
bool telnetd_disable_trans false;
#line 9
if (telnetd_disable_trans) {
#line 9

#line 9
allow initrc_t telnetd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 9

#line 9

#line 9
allow sysadm_t telnetd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 9

#line 9
} else {
#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the process to transition to the new domain.
#line 9
#
#line 9
allow inetd_t telnetd_t:process transition;
#line 9

#line 9
#
#line 9
# Do not audit when glibc secure mode is enabled upon the transition.
#line 9
#
#line 9
dontaudit inetd_t telnetd_t:process noatsecure;
#line 9

#line 9
#
#line 9
# Do not audit when signal-related state is cleared upon the transition.
#line 9
#
#line 9
dontaudit inetd_t telnetd_t:process siginh;
#line 9

#line 9
#
#line 9
# Do not audit when resource limits are reset upon the transition.
#line 9
#
#line 9
dontaudit inetd_t telnetd_t:process rlimitinh;
#line 9

#line 9
#
#line 9
# Allow the process to execute the program.
#line 9
# 
#line 9
allow inetd_t telnetd_exec_t:file { read { getattr execute } };
#line 9

#line 9
#
#line 9
# Allow the process to reap the new domain.
#line 9
#
#line 9
allow telnetd_t inetd_t:process sigchld;
#line 9

#line 9
#
#line 9
# Allow the new domain to inherit and use file 
#line 9
# descriptions from the creating process and vice versa.
#line 9
#
#line 9
allow telnetd_t inetd_t:fd use;
#line 9
allow inetd_t telnetd_t:fd use;
#line 9

#line 9
#
#line 9
# Allow the new domain to write back to the old domain via a pipe.
#line 9
#
#line 9
allow telnetd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 9

#line 9
#
#line 9
# Allow the new domain to read and execute the program.
#line 9
#
#line 9
allow telnetd_t telnetd_exec_t:file { read getattr lock execute ioctl };
#line 9

#line 9
#
#line 9
# Allow the new domain to be entered via the program.
#line 9
#
#line 9
allow telnetd_t telnetd_exec_t:file entrypoint;
#line 9

#line 9
type_transition inetd_t telnetd_exec_t:process telnetd_t;
#line 9

#line 9
allow inetd_t telnetd_t:process sigkill;
#line 9
}
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use tcp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow telnetd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow telnetd_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow telnetd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow telnetd_t node_type:node { tcp_send rawip_send };
#line 9
allow telnetd_t node_type:node { tcp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow telnetd_t port_type:tcp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow telnetd_t node_type:tcp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow telnetd_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t self:tcp_socket { listen accept };
#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use udp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow telnetd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow telnetd_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow telnetd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow telnetd_t node_type:node { udp_send rawip_send };
#line 9
allow telnetd_t node_type:node { udp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow telnetd_t port_type:udp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow telnetd_t node_type:udp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow telnetd_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t self:udp_socket { connect };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
if (allow_ypbind) {
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use tcp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow telnetd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow telnetd_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow telnetd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow telnetd_t node_type:node { tcp_send rawip_send };
#line 9
allow telnetd_t node_type:node { tcp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow telnetd_t port_type:tcp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow telnetd_t node_type:tcp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow telnetd_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t self:tcp_socket { listen accept };
#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use tcp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow telnetd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow telnetd_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow telnetd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow telnetd_t node_type:node { tcp_send rawip_send };
#line 9
allow telnetd_t node_type:node { tcp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow telnetd_t port_type:tcp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow telnetd_t node_type:tcp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow telnetd_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t self:tcp_socket { connect };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use udp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow telnetd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow telnetd_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow telnetd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow telnetd_t node_type:node { udp_send rawip_send };
#line 9
allow telnetd_t node_type:node { udp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow telnetd_t port_type:udp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow telnetd_t node_type:udp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow telnetd_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t self:udp_socket { connect };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
allow telnetd_t var_yp_t:dir { read getattr lock search ioctl };
#line 9
allow telnetd_t var_yp_t:file { read getattr lock ioctl };
#line 9
allow telnetd_t var_yp_t:lnk_file { getattr read };
#line 9

#line 9
allow telnetd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 9
allow telnetd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 9
dontaudit telnetd_t self:capability net_bind_service;
#line 9
dontaudit telnetd_t reserved_port_type:tcp_socket name_connect;
#line 9
dontaudit telnetd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 9

#line 9
} else {
#line 9
dontaudit telnetd_t var_yp_t:dir search;
#line 9
}
#line 9
 
#line 9

#line 9
allow telnetd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 9
allow telnetd_t lib_t:lnk_file { read getattr lock ioctl };
#line 9
allow telnetd_t ld_so_t:file { read getattr lock execute ioctl };
#line 9
#allow telnetd_t ld_so_t:file execute_no_trans;
#line 9
allow telnetd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 9
allow telnetd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 9
allow telnetd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 9
allow telnetd_t texrel_shlib_t:file execmod;
#line 9
allow telnetd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 9
allow telnetd_t device_t:dir search;
#line 9
allow telnetd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 9

#line 9
allow telnetd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 9
allow telnetd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 9
allow telnetd_t self:fifo_file { ioctl read getattr lock write append };
#line 9
type telnetd_exec_t, file_type, sysadmfile, exec_type;
#line 9

#line 9
allow telnetd_t etc_t:lnk_file read;
#line 9
allow telnetd_t lib_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t locale_t:dir { read getattr lock search ioctl };
#line 9
allow telnetd_t locale_t:file { read getattr lock ioctl };
#line 9
allow telnetd_t locale_t:lnk_file { getattr read };
#line 9

#line 9

#line 9
allow telnetd_t device_t:dir search;
#line 9
allow telnetd_t proc_t:dir search;
#line 9
allow telnetd_t proc_t:{ file lnk_file } { getattr read };
#line 9
allow telnetd_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 9
allow telnetd_t fs_t:filesystem getattr;
#line 9

#line 9

#line 9
# Read system variables in /sys.
#line 9

#line 9
allow telnetd_t sysctl_t:dir search;
#line 9
allow telnetd_t sysctl_kernel_t:dir search;
#line 9
allow telnetd_t sysctl_kernel_t:file { getattr read };
#line 9

#line 9

#line 9

#line 9

#line 9
allow telnetd_t etc_t:file { getattr read };
#line 9

#line 9

#line 9
type telnetd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the process to modify the directory.
#line 9
#
#line 9
allow telnetd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 9

#line 9
#
#line 9
# Allow the process to create the file.
#line 9
#
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
allow telnetd_t telnetd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
allow telnetd_t telnetd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
type_transition telnetd_t tmp_t:{ file dir } telnetd_tmp_t;
#line 9

#line 9

#line 9

#line 9
allow telnetd_t var_t:dir search;
#line 9

#line 9
type telnetd_var_run_t, file_type, sysadmfile, pidfile;
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the process to modify the directory.
#line 9
#
#line 9
allow telnetd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 9

#line 9
#
#line 9
# Allow the process to create the file.
#line 9
#
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
allow telnetd_t telnetd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
type_transition telnetd_t var_run_t:file telnetd_var_run_t;
#line 9

#line 9

#line 9

#line 9
allow telnetd_t var_t:dir search;
#line 9
allow telnetd_t telnetd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 9

#line 9

#line 9
# Inherit and use descriptors from inetd.
#line 9
allow telnetd_t inetd_t:fd use;
#line 9

#line 9
# for identd
#line 9
allow telnetd_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 9
allow telnetd_t self:capability { setuid setgid };
#line 9
allow telnetd_t home_root_t:dir search;
#line 9
allow telnetd_t self:dir search;
#line 9
allow telnetd_t self:{ lnk_file file } { getattr read };
#line 9

#line 9

#line 9
if (allow_kerberos) {
#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use tcp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow telnetd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow telnetd_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow telnetd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow telnetd_t node_type:node { tcp_send rawip_send };
#line 9
allow telnetd_t node_type:node { tcp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow telnetd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow telnetd_t node_type:tcp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow telnetd_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t self:tcp_socket { connect };
#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use udp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow telnetd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow telnetd_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow telnetd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow telnetd_t node_type:node { udp_send rawip_send };
#line 9
allow telnetd_t node_type:node { udp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow telnetd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow telnetd_t node_type:udp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow telnetd_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t self:udp_socket { connect };
#line 9

#line 9

#line 9

#line 9
allow telnetd_t kerberos_port_t:tcp_socket name_connect;
#line 9

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use tcp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow telnetd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow telnetd_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow telnetd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow telnetd_t node_type:node { tcp_send rawip_send };
#line 9
allow telnetd_t node_type:node { tcp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow telnetd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow telnetd_t node_type:tcp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow telnetd_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t self:tcp_socket { connect };
#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the domain to create and use udp sockets.
#line 9
# Other kinds of sockets must be separately authorized for use.
#line 9
allow telnetd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 9

#line 9
allow telnetd_t unlabeled_t:association { sendto recvfrom };
#line 9

#line 9
#
#line 9
# Allow the domain to send or receive using any network interface.
#line 9
# netif_type is a type attribute for all network interface types.
#line 9
#
#line 9
allow telnetd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 9
#
#line 9
# Allow the domain to send to or receive from any node.
#line 9
# node_type is a type attribute for all node types.
#line 9
#
#line 9
allow telnetd_t node_type:node { udp_send rawip_send };
#line 9
allow telnetd_t node_type:node { udp_recv rawip_recv };
#line 9

#line 9
#
#line 9
# Allow the domain to send to or receive from any port.
#line 9
# port_type is a type attribute for all port types.
#line 9
#
#line 9

#line 9
allow telnetd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 9

#line 9

#line 9
# XXX Allow binding to any node type.  Remove once
#line 9
# individual rules have been added to all domains that 
#line 9
# bind sockets. 
#line 9
allow telnetd_t node_type:udp_socket node_bind;
#line 9
#
#line 9
# Allow access to network files including /etc/resolv.conf
#line 9
#
#line 9
allow telnetd_t net_conf_t:file { read getattr lock ioctl };
#line 9

#line 9
allow telnetd_t self:udp_socket { connect };
#line 9

#line 9

#line 9

#line 9
allow telnetd_t dns_port_t:tcp_socket name_connect;
#line 9

#line 9
}
#line 9
 dontaudit telnetd_t krb5_conf_t:file write;
#line 9
allow telnetd_t krb5_conf_t:file { getattr read };
#line 9

#line 9
allow telnetd_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 9
# Use sockets inherited from inetd.
#line 9

#line 9
allow inetd_t telnetd_port_t:udp_socket name_bind;
#line 9
allow telnetd_t inetd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };
#line 9
allow inetd_t telnetd_port_t:tcp_socket name_bind;
#line 9
allow telnetd_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 9

#line 9

#line 9

#line 9

#line 9
allow telnetd_t proc_net_t:dir { read getattr lock search ioctl };
#line 9
allow telnetd_t proc_net_t:file { read getattr lock ioctl };
#line 9
allow telnetd_t proc_net_t:lnk_file { getattr read };
#line 9

#line 9

#line 9

#line 9
# Execute /bin/login on a new PTY
#line 9
allow telnetd_t { bin_t sbin_t }:dir search;
#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the process to transition to the new domain.
#line 9
#
#line 9
allow telnetd_t remote_login_t:process transition;
#line 9

#line 9
#
#line 9
# Do not audit when glibc secure mode is enabled upon the transition.
#line 9
#
#line 9
dontaudit telnetd_t remote_login_t:process noatsecure;
#line 9

#line 9
#
#line 9
# Do not audit when signal-related state is cleared upon the transition.
#line 9
#
#line 9
dontaudit telnetd_t remote_login_t:process siginh;
#line 9

#line 9
#
#line 9
# Do not audit when resource limits are reset upon the transition.
#line 9
#
#line 9
dontaudit telnetd_t remote_login_t:process rlimitinh;
#line 9

#line 9
#
#line 9
# Allow the process to execute the program.
#line 9
# 
#line 9
allow telnetd_t login_exec_t:file { read { getattr execute } };
#line 9

#line 9
#
#line 9
# Allow the process to reap the new domain.
#line 9
#
#line 9
allow remote_login_t telnetd_t:process sigchld;
#line 9

#line 9
#
#line 9
# Allow the new domain to inherit and use file 
#line 9
# descriptions from the creating process and vice versa.
#line 9
#
#line 9
allow remote_login_t telnetd_t:fd use;
#line 9
allow telnetd_t remote_login_t:fd use;
#line 9

#line 9
#
#line 9
# Allow the new domain to write back to the old domain via a pipe.
#line 9
#
#line 9
allow remote_login_t telnetd_t:fifo_file { ioctl read getattr lock write append };
#line 9

#line 9
#
#line 9
# Allow the new domain to read and execute the program.
#line 9
#
#line 9
allow remote_login_t login_exec_t:file { read getattr lock execute ioctl };
#line 9

#line 9
#
#line 9
# Allow the new domain to be entered via the program.
#line 9
#
#line 9
allow remote_login_t login_exec_t:file entrypoint;
#line 9

#line 9
type_transition telnetd_t login_exec_t:process remote_login_t;
#line 9

#line 9

#line 9

#line 9
# Access the pty master multiplexer.
#line 9
allow telnetd_t ptmx_t:chr_file { ioctl read getattr lock write append };
#line 9

#line 9
allow telnetd_t devpts_t:filesystem getattr;
#line 9

#line 9
# allow searching /dev/pts
#line 9
allow telnetd_t devpts_t:dir { getattr read search };
#line 9

#line 9
# ignore old BSD pty devices
#line 9
dontaudit telnetd_t bsdpty_device_t:chr_file { getattr read write };
#line 9

#line 9

#line 9
type telnetd_devpts_t, file_type, sysadmfile, ptyfile , server_pty, userpty_type;
#line 9

#line 9
# Allow the pty to be associated with the file system.
#line 9
allow telnetd_devpts_t devpts_t:filesystem associate;
#line 9

#line 9
# Label pty files with a derived type.
#line 9
type_transition telnetd_t devpts_t:chr_file telnetd_devpts_t;
#line 9

#line 9
# allow searching /dev/pts
#line 9
allow telnetd_t devpts_t:dir { getattr read search };
#line 9

#line 9
# Read and write my pty files.
#line 9
allow telnetd_t telnetd_devpts_t:chr_file { setattr { ioctl read getattr lock write append } };
#line 9

#line 9

#line 9
allow telnetd_t self:capability { fsetid chown fowner sys_tty_config dac_override } ;
#line 9

#line 9
# Append to /var/log/wtmp.
#line 9
allow telnetd_t var_log_t:dir search;
#line 9
allow telnetd_t wtmp_t:file { ioctl read getattr lock write append };
#line 9
allow telnetd_t initrc_var_run_t:file { ioctl read getattr lock write append };
#line 9

#line 9
# Allow reading of /etc/issue.net
#line 9
allow telnetd_t etc_runtime_t:file { read getattr lock ioctl };
#line 9

#line 9
# Allow krb5 telnetd to use fork and open /dev/tty for use
#line 9
allow telnetd_t userpty_type:chr_file setattr;
#line 9
allow telnetd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 9
dontaudit telnetd_t selinux_config_t:dir search;
#line 9

typealias telnetd_port_t alias telnet_port_t;
#line 1 "domains/program/tftpd.te"
#DESC TFTP - UDP based file server for boot loaders
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: tftpd atftpd
# Depends: inetd.te
#

#################################
#
# Rules for the tftpd_t domain.
#
# tftpd_exec_t is the type of the tftpd executable.
#

#line 14

#line 14

#line 14

#line 14
type tftpd_t, domain, privlog, daemon , transitionbool;
#line 14
type tftpd_exec_t, file_type, sysadmfile, exec_type;
#line 14
dontaudit tftpd_t self:capability sys_tty_config;
#line 14

#line 14
role system_r types tftpd_t;
#line 14

#line 14
# Inherit and use descriptors from init.
#line 14
allow tftpd_t init_t:fd use;
#line 14
allow tftpd_t init_t:process sigchld;
#line 14
allow tftpd_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 14

#line 14

#line 14
allow tftpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow tftpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow tftpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow tftpd_t ld_so_t:file execute_no_trans;
#line 14
allow tftpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow tftpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow tftpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow tftpd_t texrel_shlib_t:file execmod;
#line 14
allow tftpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow tftpd_t device_t:dir search;
#line 14
allow tftpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
allow tftpd_t { self proc_t }:dir { read getattr lock search ioctl };
#line 14
allow tftpd_t { self proc_t }:lnk_file { getattr read };
#line 14

#line 14
allow tftpd_t device_t:dir { read getattr lock search ioctl };
#line 14

#line 14
allow tftpd_t udev_tdb_t:file { read getattr lock ioctl };
#line 14
allow tftpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit tftpd_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 14
dontaudit tftpd_t unpriv_userdomain:fd use;
#line 14

#line 14

#line 14
allow tftpd_t sysfs_t:dir { read getattr lock search ioctl };
#line 14
allow tftpd_t sysfs_t:file { read getattr lock ioctl };
#line 14
allow tftpd_t sysfs_t:lnk_file { getattr read };
#line 14
 
#line 14

#line 14
allow tftpd_t autofs_t:dir { search getattr };
#line 14

#line 14
dontaudit tftpd_t { tty_device_t devpts_t }:chr_file { read write };
#line 14
dontaudit tftpd_t root_t:file { getattr read };
#line 14
 
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow tftpd_t sysctl_t:dir search;
#line 14
allow tftpd_t sysctl_kernel_t:dir search;
#line 14
allow tftpd_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14

#line 14
bool tftpd_disable_trans false;
#line 14
if (tftpd_disable_trans) {
#line 14

#line 14
allow initrc_t tftpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t tftpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14
 
#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow initrc_t tftpd_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit initrc_t tftpd_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit initrc_t tftpd_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit initrc_t tftpd_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow initrc_t tftpd_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow tftpd_t initrc_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow tftpd_t initrc_t:fd use;
#line 14
allow initrc_t tftpd_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow tftpd_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow tftpd_t tftpd_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow tftpd_t tftpd_exec_t:file entrypoint;
#line 14

#line 14
type_transition initrc_t tftpd_exec_t:process tftpd_t;
#line 14

#line 14

#line 14
allow initrc_t tftpd_t:process { noatsecure siginh rlimitinh };
#line 14

#line 14
}
#line 14
 
#line 14
allow tftpd_t privfd:fd use;
#line 14

#line 14
allow tftpd_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14

#line 14
# Create pid file.
#line 14
allow tftpd_t var_t:dir { getattr search };
#line 14

#line 14
type tftpd_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow tftpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow tftpd_t tftpd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition tftpd_t var_run_t:file tftpd_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow tftpd_t var_t:dir search;
#line 14
allow tftpd_t tftpd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
allow tftpd_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
# for daemons that look at /root on startup
#line 14
dontaudit tftpd_t sysadm_home_dir_t:dir search;
#line 14

#line 14
# for df
#line 14
allow tftpd_t fs_type:filesystem getattr;
#line 14
allow tftpd_t removable_t:filesystem getattr;
#line 14

#line 14

#line 14
allow tftpd_t etc_t:lnk_file read;
#line 14
allow tftpd_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow tftpd_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow tftpd_t locale_t:file { read getattr lock ioctl };
#line 14
allow tftpd_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14

#line 14
# for localization
#line 14
allow tftpd_t lib_t:file { getattr read };
#line 14


# tftpdir_t is the type of files in the /tftpboot directories.
type tftpdir_t, file_type, sysadmfile;

#line 18
allow tftpd_t tftpdir_t:dir { read getattr lock search ioctl };
#line 18
allow tftpd_t tftpdir_t:file { read getattr lock ioctl };
#line 18
allow tftpd_t tftpdir_t:lnk_file { getattr read };
#line 18



#line 20

#line 20

#line 20
#
#line 20
# Allow the process to transition to the new domain.
#line 20
#
#line 20
allow inetd_t tftpd_t:process transition;
#line 20

#line 20
#
#line 20
# Do not audit when glibc secure mode is enabled upon the transition.
#line 20
#
#line 20
dontaudit inetd_t tftpd_t:process noatsecure;
#line 20

#line 20
#
#line 20
# Do not audit when signal-related state is cleared upon the transition.
#line 20
#
#line 20
dontaudit inetd_t tftpd_t:process siginh;
#line 20

#line 20
#
#line 20
# Do not audit when resource limits are reset upon the transition.
#line 20
#
#line 20
dontaudit inetd_t tftpd_t:process rlimitinh;
#line 20

#line 20
#
#line 20
# Allow the process to execute the program.
#line 20
# 
#line 20
allow inetd_t tftpd_exec_t:file { read { getattr execute } };
#line 20

#line 20
#
#line 20
# Allow the process to reap the new domain.
#line 20
#
#line 20
allow tftpd_t inetd_t:process sigchld;
#line 20

#line 20
#
#line 20
# Allow the new domain to inherit and use file 
#line 20
# descriptions from the creating process and vice versa.
#line 20
#
#line 20
allow tftpd_t inetd_t:fd use;
#line 20
allow inetd_t tftpd_t:fd use;
#line 20

#line 20
#
#line 20
# Allow the new domain to write back to the old domain via a pipe.
#line 20
#
#line 20
allow tftpd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 20

#line 20
#
#line 20
# Allow the new domain to read and execute the program.
#line 20
#
#line 20
allow tftpd_t tftpd_exec_t:file { read getattr lock execute ioctl };
#line 20

#line 20
#
#line 20
# Allow the new domain to be entered via the program.
#line 20
#
#line 20
allow tftpd_t tftpd_exec_t:file entrypoint;
#line 20

#line 20
type_transition inetd_t tftpd_exec_t:process tftpd_t;
#line 20


# Use the network.

#line 23

#line 23
#
#line 23
# Allow the domain to create and use udp sockets.
#line 23
# Other kinds of sockets must be separately authorized for use.
#line 23
allow tftpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 23

#line 23
allow tftpd_t unlabeled_t:association { sendto recvfrom };
#line 23

#line 23
#
#line 23
# Allow the domain to send or receive using any network interface.
#line 23
# netif_type is a type attribute for all network interface types.
#line 23
#
#line 23
allow tftpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 23
#
#line 23
# Allow the domain to send to or receive from any node.
#line 23
# node_type is a type attribute for all node types.
#line 23
#
#line 23
allow tftpd_t node_type:node { udp_send rawip_send };
#line 23
allow tftpd_t node_type:node { udp_recv rawip_recv };
#line 23

#line 23
#
#line 23
# Allow the domain to send to or receive from any port.
#line 23
# port_type is a type attribute for all port types.
#line 23
#
#line 23

#line 23
allow tftpd_t port_type:udp_socket { send_msg recv_msg };
#line 23

#line 23

#line 23
# XXX Allow binding to any node type.  Remove once
#line 23
# individual rules have been added to all domains that 
#line 23
# bind sockets. 
#line 23
allow tftpd_t node_type:udp_socket node_bind;
#line 23
#
#line 23
# Allow access to network files including /etc/resolv.conf
#line 23
#
#line 23
allow tftpd_t net_conf_t:file { read getattr lock ioctl };
#line 23

#line 23
allow tftpd_t self:udp_socket { connect };
#line 23

allow tftpd_t tftp_port_t:udp_socket name_bind;
#line 27

#line 27
allow inetd_t tftp_port_t:udp_socket name_bind;
#line 27

allow tftpd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow tftpd_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };

# allow any domain to connect to the TFTP server
allow tftpd_t inetd_t:udp_socket { ioctl read getattr write setattr append bind connect getopt setopt shutdown };

# Use capabilities
allow tftpd_t self:capability { setgid setuid net_bind_service sys_chroot };

allow tftpd_t etc_t:dir { read getattr lock search ioctl };
allow tftpd_t etc_t:file { read getattr lock ioctl };

allow tftpd_t var_t:dir { read getattr lock search ioctl };
allow tftpd_t var_t:{ file lnk_file } { read getattr lock ioctl };
#line 1 "domains/program/udev.te"
#DESC udev - Linux configurable dynamic device naming support
#
# Author:  Dan Walsh dwalsh@redhat.com
#

#################################
#
# Rules for the udev_t domain.
#
# udev_exec_t is the type of the udev executable.
#

#line 12

#line 12

#line 12

#line 12
type udev_t, domain, privlog, daemon , nscd_client_domain, privmodule, privmem, fs_domain, privfd, privowner, mlsfileread, mlsfilewrite, mlsfileupgrade, mlsfiledowngrade, mlsprocwrite, transitionbool;
#line 12
type udev_exec_t, file_type, sysadmfile, exec_type;
#line 12
dontaudit udev_t self:capability sys_tty_config;
#line 12

#line 12
role system_r types udev_t;
#line 12

#line 12
# Inherit and use descriptors from init.
#line 12
allow udev_t init_t:fd use;
#line 12
allow udev_t init_t:process sigchld;
#line 12
allow udev_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 12

#line 12

#line 12
allow udev_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 12
allow udev_t lib_t:lnk_file { read getattr lock ioctl };
#line 12
allow udev_t ld_so_t:file { read getattr lock execute ioctl };
#line 12
#allow udev_t ld_so_t:file execute_no_trans;
#line 12
allow udev_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 12
allow udev_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 12
allow udev_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 12
allow udev_t texrel_shlib_t:file execmod;
#line 12
allow udev_t ld_so_cache_t:file { read getattr lock ioctl };
#line 12
allow udev_t device_t:dir search;
#line 12
allow udev_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
allow udev_t { self proc_t }:dir { read getattr lock search ioctl };
#line 12
allow udev_t { self proc_t }:lnk_file { getattr read };
#line 12

#line 12
allow udev_t device_t:dir { read getattr lock search ioctl };
#line 12

#line 12
allow udev_t udev_tdb_t:file { read getattr lock ioctl };
#line 12
allow udev_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit udev_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 12
dontaudit udev_t unpriv_userdomain:fd use;
#line 12

#line 12

#line 12
allow udev_t sysfs_t:dir { read getattr lock search ioctl };
#line 12
allow udev_t sysfs_t:file { read getattr lock ioctl };
#line 12
allow udev_t sysfs_t:lnk_file { getattr read };
#line 12
 
#line 12

#line 12
allow udev_t autofs_t:dir { search getattr };
#line 12

#line 12
dontaudit udev_t { tty_device_t devpts_t }:chr_file { read write };
#line 12
dontaudit udev_t root_t:file { getattr read };
#line 12
 
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
# Read system variables in /sys.
#line 12

#line 12
allow udev_t sysctl_t:dir search;
#line 12
allow udev_t sysctl_kernel_t:dir search;
#line 12
allow udev_t sysctl_kernel_t:file { getattr read };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allows user to define a tunable to disable domain transition
#line 12
#
#line 12

#line 12
bool udev_disable_trans false;
#line 12
if (udev_disable_trans) {
#line 12

#line 12
allow initrc_t udev_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12

#line 12
allow sysadm_t udev_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 12

#line 12
} else {
#line 12
 
#line 12

#line 12

#line 12
#
#line 12
# Allow the process to transition to the new domain.
#line 12
#
#line 12
allow initrc_t udev_t:process transition;
#line 12

#line 12
#
#line 12
# Do not audit when glibc secure mode is enabled upon the transition.
#line 12
#
#line 12
dontaudit initrc_t udev_t:process noatsecure;
#line 12

#line 12
#
#line 12
# Do not audit when signal-related state is cleared upon the transition.
#line 12
#
#line 12
dontaudit initrc_t udev_t:process siginh;
#line 12

#line 12
#
#line 12
# Do not audit when resource limits are reset upon the transition.
#line 12
#
#line 12
dontaudit initrc_t udev_t:process rlimitinh;
#line 12

#line 12
#
#line 12
# Allow the process to execute the program.
#line 12
# 
#line 12
allow initrc_t udev_exec_t:file { read { getattr execute } };
#line 12

#line 12
#
#line 12
# Allow the process to reap the new domain.
#line 12
#
#line 12
allow udev_t initrc_t:process sigchld;
#line 12

#line 12
#
#line 12
# Allow the new domain to inherit and use file 
#line 12
# descriptions from the creating process and vice versa.
#line 12
#
#line 12
allow udev_t initrc_t:fd use;
#line 12
allow initrc_t udev_t:fd use;
#line 12

#line 12
#
#line 12
# Allow the new domain to write back to the old domain via a pipe.
#line 12
#
#line 12
allow udev_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 12

#line 12
#
#line 12
# Allow the new domain to read and execute the program.
#line 12
#
#line 12
allow udev_t udev_exec_t:file { read getattr lock execute ioctl };
#line 12

#line 12
#
#line 12
# Allow the new domain to be entered via the program.
#line 12
#
#line 12
allow udev_t udev_exec_t:file entrypoint;
#line 12

#line 12
type_transition initrc_t udev_exec_t:process udev_t;
#line 12

#line 12

#line 12
allow initrc_t udev_t:process { noatsecure siginh rlimitinh };
#line 12

#line 12
}
#line 12
 
#line 12
allow udev_t privfd:fd use;
#line 12

#line 12
allow udev_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12

#line 12
# Create pid file.
#line 12
allow udev_t var_t:dir { getattr search };
#line 12

#line 12
type udev_var_run_t, file_type, sysadmfile, pidfile;
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to modify the directory.
#line 12
#
#line 12
allow udev_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12
#
#line 12
# Allow the process to create the file.
#line 12
#
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow udev_t udev_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
type_transition udev_t var_run_t:file udev_var_run_t;
#line 12

#line 12

#line 12

#line 12
allow udev_t var_t:dir search;
#line 12
allow udev_t udev_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12

#line 12
allow udev_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 12

#line 12
# for daemons that look at /root on startup
#line 12
dontaudit udev_t sysadm_home_dir_t:dir search;
#line 12

#line 12
# for df
#line 12
allow udev_t fs_type:filesystem getattr;
#line 12
allow udev_t removable_t:filesystem getattr;
#line 12

#line 12

#line 12
allow udev_t etc_t:lnk_file read;
#line 12
allow udev_t lib_t:file { read getattr lock ioctl };
#line 12

#line 12
allow udev_t locale_t:dir { read getattr lock search ioctl };
#line 12
allow udev_t locale_t:file { read getattr lock ioctl };
#line 12
allow udev_t locale_t:lnk_file { getattr read };
#line 12

#line 12

#line 12

#line 12
# for localization
#line 12
allow udev_t lib_t:file { getattr read };
#line 12



#line 14
# Access other processes in the same domain.
#line 14
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 14
# These must be granted separately if desired.
#line 14
allow udev_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 14

#line 14
# Access /proc/PID files for processes in the same domain.
#line 14
allow udev_t self:dir { read getattr lock search ioctl };
#line 14
allow udev_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 14

#line 14
# Access file descriptions, pipes, and sockets
#line 14
# created by processes in the same domain.
#line 14
allow udev_t self:fd *;
#line 14
allow udev_t self:fifo_file { ioctl read getattr lock write append };
#line 14
allow udev_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow udev_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 14

#line 14
# Allow the domain to communicate with other processes in the same domain.
#line 14
allow udev_t self:unix_dgram_socket sendto;
#line 14
allow udev_t self:unix_stream_socket connectto;
#line 14

#line 14
# Access System V IPC objects created by processes in the same domain.
#line 14
allow udev_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 14
allow udev_t self:msg  { send receive };
#line 14
allow udev_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 14
allow udev_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 14
allow udev_t unpriv_userdomain:fd use;
#line 14
#
#line 14
# Every app is asking for ypbind so I am adding this here, 
#line 14
# eventually this should become can_nsswitch
#line 14
#
#line 14

#line 14

#line 14
if (allow_ypbind) {
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow udev_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow udev_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow udev_t node_type:node { tcp_send rawip_send };
#line 14
allow udev_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow udev_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow udev_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow udev_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow udev_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow udev_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow udev_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow udev_t node_type:node { tcp_send rawip_send };
#line 14
allow udev_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow udev_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow udev_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow udev_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow udev_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow udev_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow udev_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow udev_t node_type:node { udp_send rawip_send };
#line 14
allow udev_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow udev_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow udev_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow udev_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow udev_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow udev_t var_yp_t:dir { read getattr lock search ioctl };
#line 14
allow udev_t var_yp_t:file { read getattr lock ioctl };
#line 14
allow udev_t var_yp_t:lnk_file { getattr read };
#line 14

#line 14
allow udev_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 14
allow udev_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 14
dontaudit udev_t self:capability net_bind_service;
#line 14
dontaudit udev_t reserved_port_type:tcp_socket name_connect;
#line 14
dontaudit udev_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 14

#line 14
} else {
#line 14
dontaudit udev_t var_yp_t:dir search;
#line 14
}
#line 14
 
#line 14
allow udev_t autofs_t:dir { search getattr };
#line 14


if (allow_execmem) {
# for alsactl
allow udev_t self:process execmem;
}


#line 21
type udev_etc_t, file_type, sysadmfile, usercanread;
#line 21
allow udev_t udev_etc_t:file { read getattr lock ioctl };
#line 21

type udev_helper_exec_t, file_type, sysadmfile, exec_type;

#line 23
allow udev_t { bin_t sbin_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 23
allow udev_t { bin_t sbin_t etc_t }:lnk_file { getattr read };
#line 23

#line 23
allow udev_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 23
allow udev_t lib_t:lnk_file { read getattr lock ioctl };
#line 23
allow udev_t ld_so_t:file { read getattr lock execute ioctl };
#line 23
#allow udev_t ld_so_t:file execute_no_trans;
#line 23
allow udev_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 23
allow udev_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 23
allow udev_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 23
allow udev_t texrel_shlib_t:file execmod;
#line 23
allow udev_t ld_so_cache_t:file { read getattr lock ioctl };
#line 23
allow udev_t device_t:dir search;
#line 23
allow udev_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 23

#line 23

#line 23
allow udev_t etc_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23

#line 23

#line 23
allow udev_t lib_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23

#line 23

#line 23
allow udev_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23

#line 23

#line 23
allow udev_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23

#line 23

#line 23
allow udev_t exec_type:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23

#line 23

#line 23
allow udev_t ld_so_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 23

#line 23


#
# Rules used for udev
#
type udev_tdb_t, file_type, sysadmfile, dev_fs;
typealias udev_tdb_t alias udev_tbl_t;

#line 30

#line 30

#line 30

#line 30
#
#line 30
# Allow the process to modify the directory.
#line 30
#
#line 30
allow udev_t device_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 30

#line 30
#
#line 30
# Allow the process to create the file.
#line 30
#
#line 30

#line 30

#line 30

#line 30

#line 30

#line 30
allow udev_t udev_tdb_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 30

#line 30

#line 30

#line 30

#line 30

#line 30

#line 30

#line 30

#line 30

#line 30
type_transition udev_t device_t:file udev_tdb_t;
#line 30

#line 30

allow udev_t self:capability { chown dac_override dac_read_search fowner fsetid sys_admin sys_nice mknod net_raw net_admin sys_rawio sys_nice };
allow udev_t self:file { getattr read };
allow udev_t self:unix_stream_socket {connectto { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept }};
allow udev_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow udev_t self:fifo_file { ioctl read getattr lock write append };
allow udev_t self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } }; 
allow udev_t device_t:file { unlink { ioctl read getattr lock write append } };
allow udev_t device_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
allow udev_t device_t:lnk_file { create read getattr setattr link unlink rename };
allow udev_t { device_t device_type }:{ chr_file blk_file } { relabelfrom relabelto { create ioctl read getattr lock write setattr append link unlink rename } };
#line 50

#line 50
allow udev_t tmpfs_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 50
allow udev_t tmpfs_t:{ sock_file file } { create ioctl read getattr lock write setattr append link unlink rename };
#line 50
allow udev_t tmpfs_t:lnk_file { create read getattr setattr link unlink rename };
#line 50
allow udev_t tmpfs_t:{ chr_file blk_file } { relabelfrom relabelto { create ioctl read getattr lock write setattr append link unlink rename } };
#line 50
allow udev_t tmpfs_t:dir search;
#line 50

#line 50
# for arping used for static IP addresses on PCMCIA ethernet
#line 50

#line 50

#line 50

#line 50
#
#line 50
# Allow the process to transition to the new domain.
#line 50
#
#line 50
allow udev_t netutils_t:process transition;
#line 50

#line 50
#
#line 50
# Do not audit when glibc secure mode is enabled upon the transition.
#line 50
#
#line 50
dontaudit udev_t netutils_t:process noatsecure;
#line 50

#line 50
#
#line 50
# Do not audit when signal-related state is cleared upon the transition.
#line 50
#
#line 50
dontaudit udev_t netutils_t:process siginh;
#line 50

#line 50
#
#line 50
# Do not audit when resource limits are reset upon the transition.
#line 50
#
#line 50
dontaudit udev_t netutils_t:process rlimitinh;
#line 50

#line 50
#
#line 50
# Allow the process to execute the program.
#line 50
# 
#line 50
allow udev_t netutils_exec_t:file { read { getattr execute } };
#line 50

#line 50
#
#line 50
# Allow the process to reap the new domain.
#line 50
#
#line 50
allow netutils_t udev_t:process sigchld;
#line 50

#line 50
#
#line 50
# Allow the new domain to inherit and use file 
#line 50
# descriptions from the creating process and vice versa.
#line 50
#
#line 50
allow netutils_t udev_t:fd use;
#line 50
allow udev_t netutils_t:fd use;
#line 50

#line 50
#
#line 50
# Allow the new domain to write back to the old domain via a pipe.
#line 50
#
#line 50
allow netutils_t udev_t:fifo_file { ioctl read getattr lock write append };
#line 50

#line 50
#
#line 50
# Allow the new domain to read and execute the program.
#line 50
#
#line 50
allow netutils_t netutils_exec_t:file { read getattr lock execute ioctl };
#line 50

#line 50
#
#line 50
# Allow the new domain to be entered via the program.
#line 50
#
#line 50
allow netutils_t netutils_exec_t:file entrypoint;
#line 50

#line 50
type_transition udev_t netutils_exec_t:process netutils_t;
#line 50

#line 50

allow udev_t etc_t:file { getattr read ioctl };
allow udev_t { bin_t sbin_t }:dir { read getattr lock search ioctl };
allow udev_t { sbin_t bin_t }:lnk_file read;
allow udev_t bin_t:lnk_file read;

#line 55
allow udev_t { shell_exec_t bin_t sbin_t etc_t } :file { { read getattr lock execute ioctl } execute_no_trans };
#line 55


#line 56
allow udev_t udev_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 56


#line 57
allow udev_t sysfs_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 57
allow udev_t sysfs_t:file { ioctl read getattr lock write append };
#line 57
allow udev_t sysfs_t:lnk_file { getattr read };
#line 57

allow udev_t sysadm_tty_device_t:chr_file { read write };

# to read the file_contexts file

#line 61
allow udev_t { selinux_config_t file_context_t default_context_t } :dir { read getattr lock search ioctl };
#line 61
allow udev_t { selinux_config_t file_context_t default_context_t } :file { read getattr lock ioctl };
#line 61
allow udev_t { selinux_config_t file_context_t default_context_t } :lnk_file { getattr read };
#line 61


allow udev_t policy_config_t:dir search;
allow udev_t proc_t:file { getattr read ioctl };
allow udev_t proc_kcore_t:file getattr;

# Get security policy decisions.

#line 68
# Get the selinuxfs mount point via /proc/self/mounts.
#line 68
allow udev_t proc_t:dir search;
#line 68
allow udev_t proc_t:{ file lnk_file } { getattr read };
#line 68
allow udev_t self:dir search;
#line 68
allow udev_t self:file { getattr read };
#line 68
# Access selinuxfs.
#line 68
allow udev_t security_t:dir { read search getattr };
#line 68
allow udev_t security_t:file { getattr read write };
#line 68
allow udev_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 68


# set file system create context

#line 71
allow udev_t self:process setfscreate;
#line 71
allow udev_t proc_t:dir search;
#line 71
allow udev_t proc_t:{ file lnk_file } read;
#line 71
allow udev_t self:dir search;
#line 71
allow udev_t self:file { getattr read write };
#line 71


allow udev_t kernel_t:fd use;
allow udev_t kernel_t:unix_dgram_socket { sendto ioctl read write };
allow udev_t kernel_t:process signal;

allow udev_t initrc_var_run_t:file { read getattr lock ioctl };
dontaudit udev_t initrc_var_run_t:file write;


#line 80

#line 80

#line 80
#
#line 80
# Allow the process to transition to the new domain.
#line 80
#
#line 80
allow kernel_t udev_t:process transition;
#line 80

#line 80
#
#line 80
# Do not audit when glibc secure mode is enabled upon the transition.
#line 80
#
#line 80
dontaudit kernel_t udev_t:process noatsecure;
#line 80

#line 80
#
#line 80
# Do not audit when signal-related state is cleared upon the transition.
#line 80
#
#line 80
dontaudit kernel_t udev_t:process siginh;
#line 80

#line 80
#
#line 80
# Do not audit when resource limits are reset upon the transition.
#line 80
#
#line 80
dontaudit kernel_t udev_t:process rlimitinh;
#line 80

#line 80
#
#line 80
# Allow the process to execute the program.
#line 80
# 
#line 80
allow kernel_t udev_exec_t:file { read { getattr execute } };
#line 80

#line 80
#
#line 80
# Allow the process to reap the new domain.
#line 80
#
#line 80
allow udev_t kernel_t:process sigchld;
#line 80

#line 80
#
#line 80
# Allow the new domain to inherit and use file 
#line 80
# descriptions from the creating process and vice versa.
#line 80
#
#line 80
allow udev_t kernel_t:fd use;
#line 80
allow kernel_t udev_t:fd use;
#line 80

#line 80
#
#line 80
# Allow the new domain to write back to the old domain via a pipe.
#line 80
#
#line 80
allow udev_t kernel_t:fifo_file { ioctl read getattr lock write append };
#line 80

#line 80
#
#line 80
# Allow the new domain to read and execute the program.
#line 80
#
#line 80
allow udev_t udev_exec_t:file { read getattr lock execute ioctl };
#line 80

#line 80
#
#line 80
# Allow the new domain to be entered via the program.
#line 80
#
#line 80
allow udev_t udev_exec_t:file entrypoint;
#line 80

#line 80
type_transition kernel_t udev_exec_t:process udev_t;
#line 80


#line 81

#line 81

#line 81
#
#line 81
# Allow the process to transition to the new domain.
#line 81
#
#line 81
allow udev_t restorecon_t:process transition;
#line 81

#line 81
#
#line 81
# Do not audit when glibc secure mode is enabled upon the transition.
#line 81
#
#line 81
dontaudit udev_t restorecon_t:process noatsecure;
#line 81

#line 81
#
#line 81
# Do not audit when signal-related state is cleared upon the transition.
#line 81
#
#line 81
dontaudit udev_t restorecon_t:process siginh;
#line 81

#line 81
#
#line 81
# Do not audit when resource limits are reset upon the transition.
#line 81
#
#line 81
dontaudit udev_t restorecon_t:process rlimitinh;
#line 81

#line 81
#
#line 81
# Allow the process to execute the program.
#line 81
# 
#line 81
allow udev_t restorecon_exec_t:file { read { getattr execute } };
#line 81

#line 81
#
#line 81
# Allow the process to reap the new domain.
#line 81
#
#line 81
allow restorecon_t udev_t:process sigchld;
#line 81

#line 81
#
#line 81
# Allow the new domain to inherit and use file 
#line 81
# descriptions from the creating process and vice versa.
#line 81
#
#line 81
allow restorecon_t udev_t:fd use;
#line 81
allow udev_t restorecon_t:fd use;
#line 81

#line 81
#
#line 81
# Allow the new domain to write back to the old domain via a pipe.
#line 81
#
#line 81
allow restorecon_t udev_t:fifo_file { ioctl read getattr lock write append };
#line 81

#line 81
#
#line 81
# Allow the new domain to read and execute the program.
#line 81
#
#line 81
allow restorecon_t restorecon_exec_t:file { read getattr lock execute ioctl };
#line 81

#line 81
#
#line 81
# Allow the new domain to be entered via the program.
#line 81
#
#line 81
allow restorecon_t restorecon_exec_t:file entrypoint;
#line 81

#line 81
type_transition udev_t restorecon_exec_t:process restorecon_t;
#line 81

#line 84

#line 84
dontaudit restorecon_t udev_t:unix_dgram_socket { read write };
#line 84

allow udev_t devpts_t:dir { getattr search };
allow udev_t etc_runtime_t:file { getattr read };
#line 89

#line 89
allow udev_t xdm_var_run_t:file { getattr read };
#line 89


#line 93

#line 93

#line 93
allow udev_t hotplug_etc_t:dir { read getattr lock search ioctl };
#line 93
allow udev_t hotplug_etc_t:file { read getattr lock ioctl };
#line 93
allow udev_t hotplug_etc_t:lnk_file { getattr read };
#line 93

#line 93

allow udev_t var_log_t:dir search;

#line 98

#line 98

#line 98
allow udev_t consoletype_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 98

#line 98

#line 103

allow udev_t var_lock_t:dir search;
allow udev_t var_lock_t:file getattr;

#line 106

#line 106

#line 106
#
#line 106
# Allow the process to transition to the new domain.
#line 106
#
#line 106
allow udev_t ifconfig_t:process transition;
#line 106

#line 106
#
#line 106
# Do not audit when glibc secure mode is enabled upon the transition.
#line 106
#
#line 106
dontaudit udev_t ifconfig_t:process noatsecure;
#line 106

#line 106
#
#line 106
# Do not audit when signal-related state is cleared upon the transition.
#line 106
#
#line 106
dontaudit udev_t ifconfig_t:process siginh;
#line 106

#line 106
#
#line 106
# Do not audit when resource limits are reset upon the transition.
#line 106
#
#line 106
dontaudit udev_t ifconfig_t:process rlimitinh;
#line 106

#line 106
#
#line 106
# Allow the process to execute the program.
#line 106
# 
#line 106
allow udev_t ifconfig_exec_t:file { read { getattr execute } };
#line 106

#line 106
#
#line 106
# Allow the process to reap the new domain.
#line 106
#
#line 106
allow ifconfig_t udev_t:process sigchld;
#line 106

#line 106
#
#line 106
# Allow the new domain to inherit and use file 
#line 106
# descriptions from the creating process and vice versa.
#line 106
#
#line 106
allow ifconfig_t udev_t:fd use;
#line 106
allow udev_t ifconfig_t:fd use;
#line 106

#line 106
#
#line 106
# Allow the new domain to write back to the old domain via a pipe.
#line 106
#
#line 106
allow ifconfig_t udev_t:fifo_file { ioctl read getattr lock write append };
#line 106

#line 106
#
#line 106
# Allow the new domain to read and execute the program.
#line 106
#
#line 106
allow ifconfig_t ifconfig_exec_t:file { read getattr lock execute ioctl };
#line 106

#line 106
#
#line 106
# Allow the new domain to be entered via the program.
#line 106
#
#line 106
allow ifconfig_t ifconfig_exec_t:file entrypoint;
#line 106

#line 106
type_transition udev_t ifconfig_exec_t:process ifconfig_t;
#line 106

#line 109

#line 109
dontaudit ifconfig_t udev_t:unix_dgram_socket { read write };
#line 109


dontaudit udev_t file_t:dir search;
#line 114

#line 114

#line 114

#line 114

#line 114
#
#line 114
# Allow the process to transition to the new domain.
#line 114
#
#line 114
allow udev_t dhcpc_t:process transition;
#line 114

#line 114
#
#line 114
# Do not audit when glibc secure mode is enabled upon the transition.
#line 114
#
#line 114
dontaudit udev_t dhcpc_t:process noatsecure;
#line 114

#line 114
#
#line 114
# Do not audit when signal-related state is cleared upon the transition.
#line 114
#
#line 114
dontaudit udev_t dhcpc_t:process siginh;
#line 114

#line 114
#
#line 114
# Do not audit when resource limits are reset upon the transition.
#line 114
#
#line 114
dontaudit udev_t dhcpc_t:process rlimitinh;
#line 114

#line 114
#
#line 114
# Allow the process to execute the program.
#line 114
# 
#line 114
allow udev_t dhcpc_exec_t:file { read { getattr execute } };
#line 114

#line 114
#
#line 114
# Allow the process to reap the new domain.
#line 114
#
#line 114
allow dhcpc_t udev_t:process sigchld;
#line 114

#line 114
#
#line 114
# Allow the new domain to inherit and use file 
#line 114
# descriptions from the creating process and vice versa.
#line 114
#
#line 114
allow dhcpc_t udev_t:fd use;
#line 114
allow udev_t dhcpc_t:fd use;
#line 114

#line 114
#
#line 114
# Allow the new domain to write back to the old domain via a pipe.
#line 114
#
#line 114
allow dhcpc_t udev_t:fifo_file { ioctl read getattr lock write append };
#line 114

#line 114
#
#line 114
# Allow the new domain to read and execute the program.
#line 114
#
#line 114
allow dhcpc_t dhcpc_exec_t:file { read getattr lock execute ioctl };
#line 114

#line 114
#
#line 114
# Allow the new domain to be entered via the program.
#line 114
#
#line 114
allow dhcpc_t dhcpc_exec_t:file entrypoint;
#line 114

#line 114
type_transition udev_t dhcpc_exec_t:process dhcpc_t;
#line 114

#line 114


allow udev_t udev_helper_exec_t:dir { read getattr lock search ioctl };


#line 118

#line 118

#line 118
# Derived type used for connection
#line 118
type udev_dbusd_system_t;
#line 118
type_change udev_t system_dbusd_t:dbus udev_dbusd_system_t;
#line 118

#line 118
# SE-DBus specific permissions
#line 118
allow udev_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 118

#line 118
# For connecting to the bus
#line 118
allow udev_t system_dbusd_t:unix_stream_socket connectto;
#line 118

#line 118

#line 118
allow { udev_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 118
allow { udev_t } system_dbusd_var_run_t:sock_file write;
#line 118
  

allow udev_t device_t:dir { relabelfrom relabelto { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir } };
allow udev_t sysctl_dev_t:dir search;
allow udev_t mnt_t:dir search;
allow udev_t { sysctl_dev_t sysctl_modprobe_t sysctl_kernel_t sysctl_hotplug_t }:file { getattr read };
allow udev_t self:rawip_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
dontaudit udev_t domain:dir { read getattr lock search ioctl };
dontaudit udev_t ttyfile:chr_file unlink;
#line 129

#line 129

#line 129
allow udev_t hotplug_var_run_t:dir { read getattr lock search ioctl };
#line 129
allow udev_t hotplug_var_run_t:file { read getattr lock ioctl };
#line 129
allow udev_t hotplug_var_run_t:lnk_file { getattr read };
#line 129

#line 129


#line 130
allow udev_t modules_object_t:dir { read getattr lock search ioctl };
#line 130
allow udev_t modules_object_t:file { read getattr lock ioctl };
#line 130
allow udev_t modules_object_t:lnk_file { getattr read };
#line 130

#
# Udev is now writing dhclient-eth*.conf* files.
#


#line 139

#line 139
allow udev_t dhcp_etc_t:file { ioctl read getattr lock write append };
#line 139

#line 139

#line 139

#line 139

#line 139
#
#line 139
# Allow the process to modify the directory.
#line 139
#
#line 139
allow udev_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 139

#line 139
#
#line 139
# Allow the process to create the file.
#line 139
#
#line 139

#line 139

#line 139

#line 139

#line 139

#line 139
allow udev_t dhcp_etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 139

#line 139

#line 139

#line 139

#line 139

#line 139

#line 139

#line 139

#line 139

#line 139
type_transition udev_t etc_t:file dhcp_etc_t;
#line 139

#line 139

#line 139


#line 140
allow udev_t domain:dir { read getattr lock search ioctl };
#line 140
allow udev_t domain:file { read getattr lock ioctl };
#line 140
allow udev_t domain:lnk_file { getattr read };
#line 140

allow udev_t modules_dep_t:file { read getattr lock ioctl };


#line 143

#line 143

#line 143

#line 143

#line 143

#line 143
#
#line 143
# Allow the domain to create and use tcp sockets.
#line 143
# Other kinds of sockets must be separately authorized for use.
#line 143
allow udev_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 143

#line 143
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 143

#line 143
#
#line 143
# Allow the domain to send or receive using any network interface.
#line 143
# netif_type is a type attribute for all network interface types.
#line 143
#
#line 143
allow udev_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 143
#
#line 143
# Allow the domain to send to or receive from any node.
#line 143
# node_type is a type attribute for all node types.
#line 143
#
#line 143
allow udev_t node_type:node { tcp_send rawip_send };
#line 143
allow udev_t node_type:node { tcp_recv rawip_recv };
#line 143

#line 143
#
#line 143
# Allow the domain to send to or receive from any port.
#line 143
# port_type is a type attribute for all port types.
#line 143
#
#line 143

#line 143
allow udev_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 143

#line 143

#line 143
# XXX Allow binding to any node type.  Remove once
#line 143
# individual rules have been added to all domains that 
#line 143
# bind sockets. 
#line 143
allow udev_t node_type:tcp_socket node_bind;
#line 143
#
#line 143
# Allow access to network files including /etc/resolv.conf
#line 143
#
#line 143
allow udev_t net_conf_t:file { read getattr lock ioctl };
#line 143

#line 143
allow udev_t self:tcp_socket { connect };
#line 143

#line 143

#line 143

#line 143
#
#line 143
# Allow the domain to create and use udp sockets.
#line 143
# Other kinds of sockets must be separately authorized for use.
#line 143
allow udev_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 143

#line 143
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 143

#line 143
#
#line 143
# Allow the domain to send or receive using any network interface.
#line 143
# netif_type is a type attribute for all network interface types.
#line 143
#
#line 143
allow udev_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 143
#
#line 143
# Allow the domain to send to or receive from any node.
#line 143
# node_type is a type attribute for all node types.
#line 143
#
#line 143
allow udev_t node_type:node { udp_send rawip_send };
#line 143
allow udev_t node_type:node { udp_recv rawip_recv };
#line 143

#line 143
#
#line 143
# Allow the domain to send to or receive from any port.
#line 143
# port_type is a type attribute for all port types.
#line 143
#
#line 143

#line 143
allow udev_t dns_port_t:udp_socket { send_msg recv_msg };
#line 143

#line 143

#line 143
# XXX Allow binding to any node type.  Remove once
#line 143
# individual rules have been added to all domains that 
#line 143
# bind sockets. 
#line 143
allow udev_t node_type:udp_socket node_bind;
#line 143
#
#line 143
# Allow access to network files including /etc/resolv.conf
#line 143
#
#line 143
allow udev_t net_conf_t:file { read getattr lock ioctl };
#line 143

#line 143
allow udev_t self:udp_socket { connect };
#line 143

#line 143

#line 143

#line 143
allow udev_t dns_port_t:tcp_socket name_connect;
#line 143

#line 143

#line 143

#line 143
if (allow_ypbind) {
#line 143

#line 143

#line 143

#line 143

#line 143

#line 143

#line 143

#line 143
#
#line 143
# Allow the domain to create and use tcp sockets.
#line 143
# Other kinds of sockets must be separately authorized for use.
#line 143
allow udev_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 143

#line 143
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 143

#line 143
#
#line 143
# Allow the domain to send or receive using any network interface.
#line 143
# netif_type is a type attribute for all network interface types.
#line 143
#
#line 143
allow udev_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 143
#
#line 143
# Allow the domain to send to or receive from any node.
#line 143
# node_type is a type attribute for all node types.
#line 143
#
#line 143
allow udev_t node_type:node { tcp_send rawip_send };
#line 143
allow udev_t node_type:node { tcp_recv rawip_recv };
#line 143

#line 143
#
#line 143
# Allow the domain to send to or receive from any port.
#line 143
# port_type is a type attribute for all port types.
#line 143
#
#line 143

#line 143
allow udev_t port_type:tcp_socket { send_msg recv_msg };
#line 143

#line 143

#line 143
# XXX Allow binding to any node type.  Remove once
#line 143
# individual rules have been added to all domains that 
#line 143
# bind sockets. 
#line 143
allow udev_t node_type:tcp_socket node_bind;
#line 143
#
#line 143
# Allow access to network files including /etc/resolv.conf
#line 143
#
#line 143
allow udev_t net_conf_t:file { read getattr lock ioctl };
#line 143

#line 143
allow udev_t self:tcp_socket { listen accept };
#line 143

#line 143

#line 143

#line 143
#
#line 143
# Allow the domain to create and use tcp sockets.
#line 143
# Other kinds of sockets must be separately authorized for use.
#line 143
allow udev_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 143

#line 143
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 143

#line 143
#
#line 143
# Allow the domain to send or receive using any network interface.
#line 143
# netif_type is a type attribute for all network interface types.
#line 143
#
#line 143
allow udev_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 143
#
#line 143
# Allow the domain to send to or receive from any node.
#line 143
# node_type is a type attribute for all node types.
#line 143
#
#line 143
allow udev_t node_type:node { tcp_send rawip_send };
#line 143
allow udev_t node_type:node { tcp_recv rawip_recv };
#line 143

#line 143
#
#line 143
# Allow the domain to send to or receive from any port.
#line 143
# port_type is a type attribute for all port types.
#line 143
#
#line 143

#line 143
allow udev_t port_type:tcp_socket { send_msg recv_msg };
#line 143

#line 143

#line 143
# XXX Allow binding to any node type.  Remove once
#line 143
# individual rules have been added to all domains that 
#line 143
# bind sockets. 
#line 143
allow udev_t node_type:tcp_socket node_bind;
#line 143
#
#line 143
# Allow access to network files including /etc/resolv.conf
#line 143
#
#line 143
allow udev_t net_conf_t:file { read getattr lock ioctl };
#line 143

#line 143
allow udev_t self:tcp_socket { connect };
#line 143

#line 143

#line 143

#line 143

#line 143

#line 143
#
#line 143
# Allow the domain to create and use udp sockets.
#line 143
# Other kinds of sockets must be separately authorized for use.
#line 143
allow udev_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 143

#line 143
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 143

#line 143
#
#line 143
# Allow the domain to send or receive using any network interface.
#line 143
# netif_type is a type attribute for all network interface types.
#line 143
#
#line 143
allow udev_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 143
#
#line 143
# Allow the domain to send to or receive from any node.
#line 143
# node_type is a type attribute for all node types.
#line 143
#
#line 143
allow udev_t node_type:node { udp_send rawip_send };
#line 143
allow udev_t node_type:node { udp_recv rawip_recv };
#line 143

#line 143
#
#line 143
# Allow the domain to send to or receive from any port.
#line 143
# port_type is a type attribute for all port types.
#line 143
#
#line 143

#line 143
allow udev_t port_type:udp_socket { send_msg recv_msg };
#line 143

#line 143

#line 143
# XXX Allow binding to any node type.  Remove once
#line 143
# individual rules have been added to all domains that 
#line 143
# bind sockets. 
#line 143
allow udev_t node_type:udp_socket node_bind;
#line 143
#
#line 143
# Allow access to network files including /etc/resolv.conf
#line 143
#
#line 143
allow udev_t net_conf_t:file { read getattr lock ioctl };
#line 143

#line 143
allow udev_t self:udp_socket { connect };
#line 143

#line 143

#line 143

#line 143

#line 143

#line 143

#line 143
allow udev_t var_yp_t:dir { read getattr lock search ioctl };
#line 143
allow udev_t var_yp_t:file { read getattr lock ioctl };
#line 143
allow udev_t var_yp_t:lnk_file { getattr read };
#line 143

#line 143
allow udev_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 143
allow udev_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 143
dontaudit udev_t self:capability net_bind_service;
#line 143
dontaudit udev_t reserved_port_type:tcp_socket name_connect;
#line 143
dontaudit udev_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 143

#line 143
} else {
#line 143
dontaudit udev_t var_yp_t:dir search;
#line 143
}
#line 143
 
#line 143

#line 143

#line 143

#line 143
#
#line 143
# Allow the domain to create and use tcp sockets.
#line 143
# Other kinds of sockets must be separately authorized for use.
#line 143
allow udev_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 143

#line 143
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 143

#line 143
#
#line 143
# Allow the domain to send or receive using any network interface.
#line 143
# netif_type is a type attribute for all network interface types.
#line 143
#
#line 143
allow udev_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 143
#
#line 143
# Allow the domain to send to or receive from any node.
#line 143
# node_type is a type attribute for all node types.
#line 143
#
#line 143
allow udev_t node_type:node { tcp_send rawip_send };
#line 143
allow udev_t node_type:node { tcp_recv rawip_recv };
#line 143

#line 143
#
#line 143
# Allow the domain to send to or receive from any port.
#line 143
# port_type is a type attribute for all port types.
#line 143
#
#line 143

#line 143
allow udev_t ldap_port_t:tcp_socket { send_msg recv_msg };
#line 143

#line 143

#line 143
# XXX Allow binding to any node type.  Remove once
#line 143
# individual rules have been added to all domains that 
#line 143
# bind sockets. 
#line 143
allow udev_t node_type:tcp_socket node_bind;
#line 143
#
#line 143
# Allow access to network files including /etc/resolv.conf
#line 143
#
#line 143
allow udev_t net_conf_t:file { read getattr lock ioctl };
#line 143

#line 143
allow udev_t self:tcp_socket { connect };
#line 143

#line 143
allow udev_t ldap_port_t:tcp_socket name_connect;
#line 143

#line 143

#line 143

#line 143
allow udev_t winbind_var_run_t:dir { getattr search };
#line 143
allow udev_t winbind_t:unix_stream_socket connectto;
#line 143
allow udev_t winbind_var_run_t:sock_file { getattr read write };
#line 143

#line 143

#line 143


#line 147

#line 147

#line 147

#line 147
typeattribute udev_t unrestricted;
#line 147
typeattribute udev_t privuser;
#line 147

#line 147
# Mount/unmount any filesystem. 
#line 147
allow udev_t fs_type:filesystem *;
#line 147

#line 147
# Mount/unmount any filesystem with the context= option. 
#line 147
allow udev_t file_type:filesystem *;
#line 147

#line 147
# Create/access any file in a labeled filesystem;
#line 147
allow udev_t file_type:{ file chr_file } ~execmod;
#line 147
allow udev_t file_type:{ dir lnk_file sock_file fifo_file blk_file } *;
#line 147
allow udev_t sysctl_t:{ dir file } *;
#line 147
allow udev_t device_type:{ chr_file blk_file } *;
#line 147
allow udev_t mtrr_device_t:file *;
#line 147

#line 147
# Create/access other files.  fs_type is to pick up various
#line 147
# pseudo filesystem types that are applied to both the filesystem
#line 147
# and its files.
#line 147
allow udev_t { unlabeled_t fs_type }:{ dir file lnk_file sock_file fifo_file chr_file blk_file } *;
#line 147
allow udev_t unlabeled_t:association { sendto recvfrom };
#line 147

#line 147
allow udev_t proc_fs:{ dir file } *;
#line 147

#line 147
# For /proc/pid
#line 147

#line 147
allow udev_t domain:dir { read getattr lock search ioctl };
#line 147
allow udev_t domain:file { read getattr lock ioctl };
#line 147
allow udev_t domain:lnk_file { getattr read };
#line 147

#line 147
# Write access is for setting attributes under /proc/self/attr.
#line 147
allow udev_t self:file { ioctl read getattr lock write append };
#line 147

#line 147
# Read and write sysctls.
#line 147

#line 147
allow udev_t sysctl_type:dir { read getattr lock search ioctl };
#line 147
allow udev_t sysctl_type:file { setattr { ioctl read getattr lock write append } };
#line 147

#line 147

#line 147
# Access the network.
#line 147
allow udev_t node_type:node *;
#line 147
allow udev_t netif_type:netif *;
#line 147
allow udev_t port_type:{ tcp_socket udp_socket } { send_msg recv_msg };
#line 147
allow udev_t port_type:tcp_socket name_connect;
#line 147

#line 147
# Bind to any network address.
#line 147
allow udev_t port_type:{ rawip_socket tcp_socket udp_socket } name_bind;
#line 147
allow udev_t node_type:{ tcp_socket udp_socket rawip_socket } node_bind;
#line 147
allow udev_t file_type:{ unix_stream_socket unix_dgram_socket } name_bind;
#line 147

#line 147
# Use/sendto/connectto sockets created by any domain.
#line 147
allow udev_t domain:{ { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } socket key_socket } *;
#line 147

#line 147
# Use descriptors and pipes created by any domain.
#line 147
allow udev_t domain:fd use;
#line 147
allow udev_t domain:fifo_file { ioctl read getattr lock write append };
#line 147

#line 147
# Act upon any other process.
#line 147
allow udev_t domain:process ~{ transition dyntransition execmem };
#line 147
# Transition to myself, to make get_ordered_context_list happy.
#line 147
allow udev_t self:process transition;
#line 147

#line 147
if (allow_execmem) {
#line 147
# Allow making anonymous memory executable, e.g. 
#line 147
# for runtime-code generation or executable stack.
#line 147
allow udev_t self:process execmem;
#line 147
}
#line 147

#line 147
if (allow_execmem && allow_execstack) {
#line 147
# Allow making the stack executable via mprotect.
#line 147
allow udev_t self:process execstack;
#line 147
}
#line 147

#line 147
if (allow_execmod) {
#line 147
# Allow text relocations on system shared libraries, e.g. libGL.
#line 147

#line 147
allow udev_t file_type:file execmod;
#line 147

#line 147
}
#line 147

#line 147
# Create/access any System V IPC objects.
#line 147
allow udev_t domain:{ sem msgq shm } *;
#line 147
allow udev_t domain:msg  { send receive };
#line 147

#line 147
# Access the security API.
#line 147
if (!secure_mode_policyload) {
#line 147
allow udev_t security_t:security *;
#line 147
auditallow udev_t security_t:security { load_policy setenforce setbool };
#line 147
}
#line 147
# Perform certain system operations that lacked individual capabilities.
#line 147
allow udev_t kernel_t:system *;
#line 147

#line 147
# Use any Linux capability.
#line 147
allow udev_t self:capability *;
#line 147

#line 147
# Set user information and skip authentication.
#line 147
allow udev_t self:passwd *;
#line 147

#line 147
# Communicate via dbusd.
#line 147
allow udev_t self:dbus *;
#line 147

#line 147
allow udev_t system_dbusd_t:dbus *;
#line 147

#line 147

#line 147
# Get info via nscd.
#line 147
allow udev_t self:nscd *;
#line 147

#line 147
allow udev_t nscd_t:nscd *;
#line 147

#line 147

#line 147
 
#line 147

dontaudit hostname_t udev_t:fd use;
#line 152

#line 1 "domains/program/updfstab.te"
#DESC updfstab - Red Hat utility to change /etc/fstab
#
# Author:  Russell Coker <russell@coker.com.au>
#


#line 6

#line 6
type updfstab_t, domain, privlog, daemon , fs_domain, etc_writer;
#line 6
type updfstab_exec_t, file_type, sysadmfile, exec_type;
#line 6
dontaudit updfstab_t self:capability sys_tty_config;
#line 6

#line 6
role system_r types updfstab_t;
#line 6

#line 6
# Inherit and use descriptors from init.
#line 6
allow updfstab_t init_t:fd use;
#line 6
allow updfstab_t init_t:process sigchld;
#line 6
allow updfstab_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 6

#line 6

#line 6
allow updfstab_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 6
allow updfstab_t lib_t:lnk_file { read getattr lock ioctl };
#line 6
allow updfstab_t ld_so_t:file { read getattr lock execute ioctl };
#line 6
#allow updfstab_t ld_so_t:file execute_no_trans;
#line 6
allow updfstab_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 6
allow updfstab_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 6
allow updfstab_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 6
allow updfstab_t texrel_shlib_t:file execmod;
#line 6
allow updfstab_t ld_so_cache_t:file { read getattr lock ioctl };
#line 6
allow updfstab_t device_t:dir search;
#line 6
allow updfstab_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 6

#line 6

#line 6
allow updfstab_t { self proc_t }:dir { read getattr lock search ioctl };
#line 6
allow updfstab_t { self proc_t }:lnk_file { getattr read };
#line 6

#line 6
allow updfstab_t device_t:dir { read getattr lock search ioctl };
#line 6

#line 6
allow updfstab_t udev_tdb_t:file { read getattr lock ioctl };
#line 6
allow updfstab_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 6
dontaudit updfstab_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 6
dontaudit updfstab_t unpriv_userdomain:fd use;
#line 6

#line 6

#line 6
allow updfstab_t sysfs_t:dir { read getattr lock search ioctl };
#line 6
allow updfstab_t sysfs_t:file { read getattr lock ioctl };
#line 6
allow updfstab_t sysfs_t:lnk_file { getattr read };
#line 6
 
#line 6

#line 6
allow updfstab_t autofs_t:dir { search getattr };
#line 6

#line 6
dontaudit updfstab_t { tty_device_t devpts_t }:chr_file { read write };
#line 6
dontaudit updfstab_t root_t:file { getattr read };
#line 6
 
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
# Read system variables in /sys.
#line 6

#line 6
allow updfstab_t sysctl_t:dir search;
#line 6
allow updfstab_t sysctl_kernel_t:dir search;
#line 6
allow updfstab_t sysctl_kernel_t:file { getattr read };
#line 6

#line 6

#line 6

#line 6

#line 6

#line 6

#line 6
#
#line 6
# Allows user to define a tunable to disable domain transition
#line 6
#
#line 6
 
#line 6

#line 6

#line 6
#
#line 6
# Allow the process to transition to the new domain.
#line 6
#
#line 6
allow initrc_t updfstab_t:process transition;
#line 6

#line 6
#
#line 6
# Do not audit when glibc secure mode is enabled upon the transition.
#line 6
#
#line 6
dontaudit initrc_t updfstab_t:process noatsecure;
#line 6

#line 6
#
#line 6
# Do not audit when signal-related state is cleared upon the transition.
#line 6
#
#line 6
dontaudit initrc_t updfstab_t:process siginh;
#line 6

#line 6
#
#line 6
# Do not audit when resource limits are reset upon the transition.
#line 6
#
#line 6
dontaudit initrc_t updfstab_t:process rlimitinh;
#line 6

#line 6
#
#line 6
# Allow the process to execute the program.
#line 6
# 
#line 6
allow initrc_t updfstab_exec_t:file { read { getattr execute } };
#line 6

#line 6
#
#line 6
# Allow the process to reap the new domain.
#line 6
#
#line 6
allow updfstab_t initrc_t:process sigchld;
#line 6

#line 6
#
#line 6
# Allow the new domain to inherit and use file 
#line 6
# descriptions from the creating process and vice versa.
#line 6
#
#line 6
allow updfstab_t initrc_t:fd use;
#line 6
allow initrc_t updfstab_t:fd use;
#line 6

#line 6
#
#line 6
# Allow the new domain to write back to the old domain via a pipe.
#line 6
#
#line 6
allow updfstab_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 6

#line 6
#
#line 6
# Allow the new domain to read and execute the program.
#line 6
#
#line 6
allow updfstab_t updfstab_exec_t:file { read getattr lock execute ioctl };
#line 6

#line 6
#
#line 6
# Allow the new domain to be entered via the program.
#line 6
#
#line 6
allow updfstab_t updfstab_exec_t:file entrypoint;
#line 6

#line 6
type_transition initrc_t updfstab_exec_t:process updfstab_t;
#line 6

#line 6

#line 6
allow initrc_t updfstab_t:process { noatsecure siginh rlimitinh };
#line 6
 
#line 6
allow updfstab_t privfd:fd use;
#line 6

#line 6
allow updfstab_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 6



#line 8
allow updfstab_t etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 8
allow updfstab_t etc_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 8
allow updfstab_t etc_t:lnk_file { create read getattr setattr link unlink rename };
#line 8


#line 9
allow updfstab_t mnt_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 9
allow updfstab_t mnt_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 9
allow updfstab_t mnt_t:lnk_file { create read getattr setattr link unlink rename };
#line 9


# Read /dev directories and modify sym-links
allow updfstab_t device_t:dir { read getattr lock search ioctl add_name remove_name write };
allow updfstab_t device_t:lnk_file { create ioctl read getattr lock write setattr append link unlink rename };

# Access disk devices.
allow updfstab_t fixed_disk_device_t:blk_file { ioctl read getattr lock write append };
allow updfstab_t removable_device_t:blk_file { ioctl read getattr lock write append };
allow updfstab_t scsi_generic_device_t:chr_file { ioctl read getattr lock write append };

# for /proc/partitions
allow updfstab_t proc_t:file { getattr read };

# for /proc/self/mounts

#line 24
allow updfstab_t self:dir { read getattr lock search ioctl };
#line 24
allow updfstab_t self:file { read getattr lock ioctl };
#line 24
allow updfstab_t self:lnk_file { getattr read };
#line 24


# for /etc/mtab
allow updfstab_t etc_runtime_t:file { getattr read };


#line 29
allow updfstab_t etc_t:lnk_file read;
#line 29
allow updfstab_t lib_t:file { read getattr lock ioctl };
#line 29

#line 29
allow updfstab_t locale_t:dir { read getattr lock search ioctl };
#line 29
allow updfstab_t locale_t:file { read getattr lock ioctl };
#line 29
allow updfstab_t locale_t:lnk_file { getattr read };
#line 29

#line 29


#line 36

#line 36

#line 36

#line 36

#line 36
# Derived type used for connection
#line 36
type updfstab_dbusd_system_t;
#line 36
type_change updfstab_t system_dbusd_t:dbus updfstab_dbusd_system_t;
#line 36

#line 36
# SE-DBus specific permissions
#line 36
allow updfstab_dbusd_system_t { system_dbusd_t self }:dbus send_msg;
#line 36

#line 36
# For connecting to the bus
#line 36
allow updfstab_t system_dbusd_t:unix_stream_socket connectto;
#line 36

#line 36

#line 36
allow { updfstab_t } { var_run_t system_dbusd_var_run_t }:dir search;
#line 36
allow { updfstab_t } system_dbusd_var_run_t:sock_file write;
#line 36
  
#line 36
allow updfstab_t system_dbusd_t:dbus { send_msg };
#line 36
allow initrc_t updfstab_t:dbus send_msg;
#line 36
allow updfstab_t initrc_t:dbus send_msg;
#line 36


# not sure what the sysctl_kernel_t file is, or why it wants to write it, so
# I will not allow it

#line 40
# Read system variables in /sys.
#line 40

#line 40
allow updfstab_t sysctl_t:dir search;
#line 40
allow updfstab_t sysctl_kernel_t:dir search;
#line 40
allow updfstab_t sysctl_kernel_t:file { getattr read };
#line 40

#line 40

#line 40

dontaudit updfstab_t sysctl_kernel_t:file write;
allow updfstab_t modules_conf_t:file { getattr read };
allow updfstab_t sbin_t:dir search;
allow updfstab_t sbin_t:lnk_file read;
allow updfstab_t { var_t var_log_t }:dir search;

allow updfstab_t kernel_t:fd use;

allow updfstab_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow updfstab_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };

#line 57

#line 57

#line 57
allow updfstab_t insmod_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 57

#line 57
allow updfstab_t modules_object_t:dir search;
#line 57
allow updfstab_t modules_dep_t:file { getattr read };
#line 57


#line 61

allow updfstab_t kernel_t:system syslog_console;
allow updfstab_t sysadm_tty_device_t:chr_file { read write };
allow updfstab_t self:capability dac_override;
dontaudit updfstab_t self:capability sys_admin;


#line 67
allow updfstab_t { selinux_config_t file_context_t default_context_t } :dir { read getattr lock search ioctl };
#line 67
allow updfstab_t { selinux_config_t file_context_t default_context_t } :file { read getattr lock ioctl };
#line 67
allow updfstab_t { selinux_config_t file_context_t default_context_t } :lnk_file { getattr read };
#line 67


#line 68
# Get the selinuxfs mount point via /proc/self/mounts.
#line 68
allow updfstab_t proc_t:dir search;
#line 68
allow updfstab_t proc_t:{ file lnk_file } { getattr read };
#line 68
allow updfstab_t self:dir search;
#line 68
allow updfstab_t self:file { getattr read };
#line 68
# Access selinuxfs.
#line 68
allow updfstab_t security_t:dir { read search getattr };
#line 68
allow updfstab_t security_t:file { getattr read write };
#line 68
allow updfstab_t security_t:security { check_context compute_av compute_create compute_relabel compute_user };
#line 68


allow updfstab_t { sbin_t bin_t }:dir { search getattr };
dontaudit updfstab_t devtty_t:chr_file { read write };
allow updfstab_t self:fifo_file { getattr read write ioctl };

#line 73
allow updfstab_t { sbin_t bin_t ls_exec_t } :file { { read getattr lock execute ioctl } execute_no_trans };
#line 73

dontaudit updfstab_t home_root_t:dir { getattr search };
dontaudit updfstab_t { home_dir_type home_type }:dir search;
allow updfstab_t fs_t:filesystem { getattr };
allow updfstab_t tmpfs_t:dir getattr;
#line 80

#line 80

#line 80
allow updfstab_t hald_t:unix_stream_socket connectto;
#line 80

#line 80


#line 1 "domains/program/uucpd.te"
#DESC uucpd - UUCP file transfer daemon
#
# Author:  Dan Walsh <dwalsh@redhat.com>
#
# Depends: inetd.te

#################################
#
# Rules for the uucpd_t domain.
#
# uucpd_exec_t is the type of the uucpd executable.
#


#line 14
type uucpd_t, domain, privlog, nscd_client_domain;
#line 14
role system_r types uucpd_t;
#line 14

#line 14
#
#line 14
# Allows user to define a tunable to disable domain transition
#line 14
#
#line 14
bool uucpd_disable_trans false;
#line 14
if (uucpd_disable_trans) {
#line 14

#line 14
allow initrc_t uucpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14

#line 14
allow sysadm_t uucpd_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 14

#line 14
} else {
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to transition to the new domain.
#line 14
#
#line 14
allow inetd_t uucpd_t:process transition;
#line 14

#line 14
#
#line 14
# Do not audit when glibc secure mode is enabled upon the transition.
#line 14
#
#line 14
dontaudit inetd_t uucpd_t:process noatsecure;
#line 14

#line 14
#
#line 14
# Do not audit when signal-related state is cleared upon the transition.
#line 14
#
#line 14
dontaudit inetd_t uucpd_t:process siginh;
#line 14

#line 14
#
#line 14
# Do not audit when resource limits are reset upon the transition.
#line 14
#
#line 14
dontaudit inetd_t uucpd_t:process rlimitinh;
#line 14

#line 14
#
#line 14
# Allow the process to execute the program.
#line 14
# 
#line 14
allow inetd_t uucpd_exec_t:file { read { getattr execute } };
#line 14

#line 14
#
#line 14
# Allow the process to reap the new domain.
#line 14
#
#line 14
allow uucpd_t inetd_t:process sigchld;
#line 14

#line 14
#
#line 14
# Allow the new domain to inherit and use file 
#line 14
# descriptions from the creating process and vice versa.
#line 14
#
#line 14
allow uucpd_t inetd_t:fd use;
#line 14
allow inetd_t uucpd_t:fd use;
#line 14

#line 14
#
#line 14
# Allow the new domain to write back to the old domain via a pipe.
#line 14
#
#line 14
allow uucpd_t inetd_t:fifo_file { ioctl read getattr lock write append };
#line 14

#line 14
#
#line 14
# Allow the new domain to read and execute the program.
#line 14
#
#line 14
allow uucpd_t uucpd_exec_t:file { read getattr lock execute ioctl };
#line 14

#line 14
#
#line 14
# Allow the new domain to be entered via the program.
#line 14
#
#line 14
allow uucpd_t uucpd_exec_t:file entrypoint;
#line 14

#line 14
type_transition inetd_t uucpd_exec_t:process uucpd_t;
#line 14

#line 14
allow inetd_t uucpd_t:process sigkill;
#line 14
}
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow uucpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow uucpd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow uucpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow uucpd_t node_type:node { tcp_send rawip_send };
#line 14
allow uucpd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow uucpd_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow uucpd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow uucpd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow uucpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow uucpd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow uucpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow uucpd_t node_type:node { udp_send rawip_send };
#line 14
allow uucpd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow uucpd_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow uucpd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow uucpd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
if (allow_ypbind) {
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow uucpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow uucpd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow uucpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow uucpd_t node_type:node { tcp_send rawip_send };
#line 14
allow uucpd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow uucpd_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow uucpd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow uucpd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t self:tcp_socket { listen accept };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow uucpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow uucpd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow uucpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow uucpd_t node_type:node { tcp_send rawip_send };
#line 14
allow uucpd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow uucpd_t port_type:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow uucpd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow uucpd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow uucpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow uucpd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow uucpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow uucpd_t node_type:node { udp_send rawip_send };
#line 14
allow uucpd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow uucpd_t port_type:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow uucpd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow uucpd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow uucpd_t var_yp_t:dir { read getattr lock search ioctl };
#line 14
allow uucpd_t var_yp_t:file { read getattr lock ioctl };
#line 14
allow uucpd_t var_yp_t:lnk_file { getattr read };
#line 14

#line 14
allow uucpd_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 14
allow uucpd_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 14
dontaudit uucpd_t self:capability net_bind_service;
#line 14
dontaudit uucpd_t reserved_port_type:tcp_socket name_connect;
#line 14
dontaudit uucpd_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 14

#line 14
} else {
#line 14
dontaudit uucpd_t var_yp_t:dir search;
#line 14
}
#line 14
 
#line 14

#line 14
allow uucpd_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 14
allow uucpd_t lib_t:lnk_file { read getattr lock ioctl };
#line 14
allow uucpd_t ld_so_t:file { read getattr lock execute ioctl };
#line 14
#allow uucpd_t ld_so_t:file execute_no_trans;
#line 14
allow uucpd_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 14
allow uucpd_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 14
allow uucpd_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 14
allow uucpd_t texrel_shlib_t:file execmod;
#line 14
allow uucpd_t ld_so_cache_t:file { read getattr lock ioctl };
#line 14
allow uucpd_t device_t:dir search;
#line 14
allow uucpd_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 14

#line 14
allow uucpd_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow uucpd_t self:unix_stream_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 14
allow uucpd_t self:fifo_file { ioctl read getattr lock write append };
#line 14
type uucpd_exec_t, file_type, sysadmfile, exec_type;
#line 14

#line 14
allow uucpd_t etc_t:lnk_file read;
#line 14
allow uucpd_t lib_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t locale_t:dir { read getattr lock search ioctl };
#line 14
allow uucpd_t locale_t:file { read getattr lock ioctl };
#line 14
allow uucpd_t locale_t:lnk_file { getattr read };
#line 14

#line 14

#line 14
allow uucpd_t device_t:dir search;
#line 14
allow uucpd_t proc_t:dir search;
#line 14
allow uucpd_t proc_t:{ file lnk_file } { getattr read };
#line 14
allow uucpd_t self:process { fork { sigchld sigkill sigstop signull signal } };
#line 14
allow uucpd_t fs_t:filesystem getattr;
#line 14

#line 14

#line 14
# Read system variables in /sys.
#line 14

#line 14
allow uucpd_t sysctl_t:dir search;
#line 14
allow uucpd_t sysctl_kernel_t:dir search;
#line 14
allow uucpd_t sysctl_kernel_t:file { getattr read };
#line 14

#line 14

#line 14

#line 14

#line 14
allow uucpd_t etc_t:file { getattr read };
#line 14

#line 14

#line 14
type uucpd_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow uucpd_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow uucpd_t uucpd_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow uucpd_t uucpd_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition uucpd_t tmp_t:{ file dir } uucpd_tmp_t;
#line 14

#line 14

#line 14

#line 14
allow uucpd_t var_t:dir search;
#line 14

#line 14
type uucpd_var_run_t, file_type, sysadmfile, pidfile;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the process to modify the directory.
#line 14
#
#line 14
allow uucpd_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14
#
#line 14
# Allow the process to create the file.
#line 14
#
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
allow uucpd_t uucpd_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
type_transition uucpd_t var_run_t:file uucpd_var_run_t;
#line 14

#line 14

#line 14

#line 14
allow uucpd_t var_t:dir search;
#line 14
allow uucpd_t uucpd_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 14

#line 14

#line 14
# Inherit and use descriptors from inetd.
#line 14
allow uucpd_t inetd_t:fd use;
#line 14

#line 14
# for identd
#line 14
allow uucpd_t self:netlink_tcpdiag_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 14
allow uucpd_t self:capability { setuid setgid };
#line 14
allow uucpd_t home_root_t:dir search;
#line 14
allow uucpd_t self:dir search;
#line 14
allow uucpd_t self:{ lnk_file file } { getattr read };
#line 14

#line 14

#line 14
if (allow_kerberos) {
#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow uucpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow uucpd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow uucpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow uucpd_t node_type:node { tcp_send rawip_send };
#line 14
allow uucpd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow uucpd_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow uucpd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow uucpd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow uucpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow uucpd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow uucpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow uucpd_t node_type:node { udp_send rawip_send };
#line 14
allow uucpd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow uucpd_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow uucpd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow uucpd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow uucpd_t kerberos_port_t:tcp_socket name_connect;
#line 14

#line 14

#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use tcp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow uucpd_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow uucpd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow uucpd_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow uucpd_t node_type:node { tcp_send rawip_send };
#line 14
allow uucpd_t node_type:node { tcp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow uucpd_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow uucpd_t node_type:tcp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow uucpd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t self:tcp_socket { connect };
#line 14

#line 14

#line 14

#line 14
#
#line 14
# Allow the domain to create and use udp sockets.
#line 14
# Other kinds of sockets must be separately authorized for use.
#line 14
allow uucpd_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 14

#line 14
allow uucpd_t unlabeled_t:association { sendto recvfrom };
#line 14

#line 14
#
#line 14
# Allow the domain to send or receive using any network interface.
#line 14
# netif_type is a type attribute for all network interface types.
#line 14
#
#line 14
allow uucpd_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 14
#
#line 14
# Allow the domain to send to or receive from any node.
#line 14
# node_type is a type attribute for all node types.
#line 14
#
#line 14
allow uucpd_t node_type:node { udp_send rawip_send };
#line 14
allow uucpd_t node_type:node { udp_recv rawip_recv };
#line 14

#line 14
#
#line 14
# Allow the domain to send to or receive from any port.
#line 14
# port_type is a type attribute for all port types.
#line 14
#
#line 14

#line 14
allow uucpd_t dns_port_t:udp_socket { send_msg recv_msg };
#line 14

#line 14

#line 14
# XXX Allow binding to any node type.  Remove once
#line 14
# individual rules have been added to all domains that 
#line 14
# bind sockets. 
#line 14
allow uucpd_t node_type:udp_socket node_bind;
#line 14
#
#line 14
# Allow access to network files including /etc/resolv.conf
#line 14
#
#line 14
allow uucpd_t net_conf_t:file { read getattr lock ioctl };
#line 14

#line 14
allow uucpd_t self:udp_socket { connect };
#line 14

#line 14

#line 14

#line 14
allow uucpd_t dns_port_t:tcp_socket name_connect;
#line 14

#line 14
}
#line 14
 dontaudit uucpd_t krb5_conf_t:file write;
#line 14
allow uucpd_t krb5_conf_t:file { getattr read };
#line 14

#line 14
allow uucpd_t urandom_device_t:chr_file { read getattr lock ioctl };
#line 14
# Use sockets inherited from inetd.
#line 14

#line 14

#line 14
allow inetd_t uucpd_port_t:tcp_socket name_bind;
#line 14
allow uucpd_t inetd_t:tcp_socket { { ioctl read getattr write setattr append bind connect getopt setopt shutdown } listen accept };
#line 14

#line 14

#line 14

#line 14
allow uucpd_t proc_net_t:dir { read getattr lock search ioctl };
#line 14
allow uucpd_t proc_net_t:file { read getattr lock ioctl };
#line 14
allow uucpd_t proc_net_t:lnk_file { getattr read };
#line 14

#line 14

type uucpd_rw_t, file_type, sysadmfile;
type uucpd_ro_t, file_type, sysadmfile;
type uucpd_spool_t, file_type, sysadmfile;

#line 18
allow uucpd_t uucpd_rw_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 18
allow uucpd_t uucpd_rw_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 18
allow uucpd_t uucpd_rw_t:lnk_file { create read getattr setattr link unlink rename };
#line 18


#line 19
allow uucpd_t uucpd_ro_t:dir { read getattr lock search ioctl };
#line 19
allow uucpd_t uucpd_ro_t:file { read getattr lock ioctl };
#line 19
allow uucpd_t uucpd_ro_t:lnk_file { getattr read };
#line 19

allow uucpd_t sbin_t:dir search;

#line 21
allow uucpd_t sbin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 21


#line 22

#line 22
type uucpd_log_t, file_type, sysadmfile, logfile;
#line 22

#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the process to modify the directory.
#line 22
#
#line 22
allow uucpd_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 22

#line 22
#
#line 22
# Allow the process to create the file.
#line 22
#
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
allow uucpd_t uucpd_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
type_transition uucpd_t var_log_t:file uucpd_log_t;
#line 22

#line 22

#line 22

#line 22
allow uucpd_t uucpd_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 22

allow uucpd_t var_spool_t:dir search;

#line 24
allow uucpd_t uucpd_spool_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 24
allow uucpd_t uucpd_spool_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 24
allow uucpd_t uucpd_spool_t:lnk_file { create read getattr setattr link unlink rename };
#line 24

#line 1 "domains/program/webalizer.te"
# DESC webalizer - webalizer
#
# Author: Yuichi Nakamura (ynakam @ selinux.gr.jp)
#
# Depends: apache.te


#line 7
type webalizer_t, domain, privlog , nscd_client_domain;
#line 7
type webalizer_exec_t, file_type, sysadmfile, exec_type;
#line 7
role sysadm_r types webalizer_t;
#line 7

#line 7
role system_r types webalizer_t;
#line 7

#line 7

#line 7

#line 7

#line 7
#
#line 7
# Allow the process to transition to the new domain.
#line 7
#
#line 7
allow sysadm_t webalizer_t:process transition;
#line 7

#line 7
#
#line 7
# Do not audit when glibc secure mode is enabled upon the transition.
#line 7
#
#line 7
dontaudit sysadm_t webalizer_t:process noatsecure;
#line 7

#line 7
#
#line 7
# Do not audit when signal-related state is cleared upon the transition.
#line 7
#
#line 7
dontaudit sysadm_t webalizer_t:process siginh;
#line 7

#line 7
#
#line 7
# Do not audit when resource limits are reset upon the transition.
#line 7
#
#line 7
dontaudit sysadm_t webalizer_t:process rlimitinh;
#line 7

#line 7
#
#line 7
# Allow the process to execute the program.
#line 7
# 
#line 7
allow sysadm_t webalizer_exec_t:file { read { getattr execute } };
#line 7

#line 7
#
#line 7
# Allow the process to reap the new domain.
#line 7
#
#line 7
allow webalizer_t sysadm_t:process sigchld;
#line 7

#line 7
#
#line 7
# Allow the new domain to inherit and use file 
#line 7
# descriptions from the creating process and vice versa.
#line 7
#
#line 7
allow webalizer_t sysadm_t:fd use;
#line 7
allow sysadm_t webalizer_t:fd use;
#line 7

#line 7
#
#line 7
# Allow the new domain to write back to the old domain via a pipe.
#line 7
#
#line 7
allow webalizer_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 7

#line 7
#
#line 7
# Allow the new domain to read and execute the program.
#line 7
#
#line 7
allow webalizer_t webalizer_exec_t:file { read getattr lock execute ioctl };
#line 7

#line 7
#
#line 7
# Allow the new domain to be entered via the program.
#line 7
#
#line 7
allow webalizer_t webalizer_exec_t:file entrypoint;
#line 7

#line 7
type_transition sysadm_t webalizer_exec_t:process webalizer_t;
#line 7

#line 7

#line 7
allow webalizer_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 7
allow webalizer_t lib_t:lnk_file { read getattr lock ioctl };
#line 7
allow webalizer_t ld_so_t:file { read getattr lock execute ioctl };
#line 7
#allow webalizer_t ld_so_t:file execute_no_trans;
#line 7
allow webalizer_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 7
allow webalizer_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 7
allow webalizer_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 7
allow webalizer_t texrel_shlib_t:file execmod;
#line 7
allow webalizer_t ld_so_cache_t:file { read getattr lock ioctl };
#line 7
allow webalizer_t device_t:dir search;
#line 7
allow webalizer_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 7

#line 7

# to use from cron

#line 9

#line 9

#line 9

#line 9

#line 9
#
#line 9
# Allow the process to transition to the new domain.
#line 9
#
#line 9
allow system_crond_t webalizer_t:process transition;
#line 9

#line 9
#
#line 9
# Do not audit when glibc secure mode is enabled upon the transition.
#line 9
#
#line 9
dontaudit system_crond_t webalizer_t:process noatsecure;
#line 9

#line 9
#
#line 9
# Do not audit when signal-related state is cleared upon the transition.
#line 9
#
#line 9
dontaudit system_crond_t webalizer_t:process siginh;
#line 9

#line 9
#
#line 9
# Do not audit when resource limits are reset upon the transition.
#line 9
#
#line 9
dontaudit system_crond_t webalizer_t:process rlimitinh;
#line 9

#line 9
#
#line 9
# Allow the process to execute the program.
#line 9
# 
#line 9
allow system_crond_t webalizer_exec_t:file { read { getattr execute } };
#line 9

#line 9
#
#line 9
# Allow the process to reap the new domain.
#line 9
#
#line 9
allow webalizer_t system_crond_t:process sigchld;
#line 9

#line 9
#
#line 9
# Allow the new domain to inherit and use file 
#line 9
# descriptions from the creating process and vice versa.
#line 9
#
#line 9
allow webalizer_t system_crond_t:fd use;
#line 9
allow system_crond_t webalizer_t:fd use;
#line 9

#line 9
#
#line 9
# Allow the new domain to write back to the old domain via a pipe.
#line 9
#
#line 9
allow webalizer_t system_crond_t:fifo_file { ioctl read getattr lock write append };
#line 9

#line 9
#
#line 9
# Allow the new domain to read and execute the program.
#line 9
#
#line 9
allow webalizer_t webalizer_exec_t:file { read getattr lock execute ioctl };
#line 9

#line 9
#
#line 9
# Allow the new domain to be entered via the program.
#line 9
#
#line 9
allow webalizer_t webalizer_exec_t:file entrypoint;
#line 9

#line 9
type_transition system_crond_t webalizer_exec_t:process webalizer_t;
#line 9

#line 9
allow webalizer_t crond_t:fifo_file { getattr read write ioctl };
#line 9
# a rule for privfd may make this obsolete
#line 9
allow webalizer_t crond_t:fd use;
#line 9
allow webalizer_t crond_t:process sigchld;
#line 9

role system_r types webalizer_t;

##type definision
# type for usage file
type webalizer_usage_t,file_type,sysadmfile;
# type for /var/lib/webalizer
type webalizer_write_t,file_type,sysadmfile;
# type for webalizer.conf

#line 18
type webalizer_etc_t, file_type, sysadmfile, usercanread;
#line 18
allow webalizer_t webalizer_etc_t:file { read getattr lock ioctl };
#line 18


#read apache log
allow webalizer_t var_log_t:dir { read getattr lock search ioctl };

#line 22
allow webalizer_t httpd_log_t:dir { read getattr lock search ioctl };
#line 22
allow webalizer_t httpd_log_t:file { read getattr lock ioctl };
#line 22
allow webalizer_t httpd_log_t:lnk_file { getattr read };
#line 22

#line 25

#line 25
allow webalizer_t xferlog_t:file { getattr read };
#line 25


#r/w /var/lib/webalizer

#line 28
type webalizer_var_lib_t, file_type, sysadmfile;
#line 28

#line 28

#line 28

#line 28

#line 28
#
#line 28
# Allow the process to modify the directory.
#line 28
#
#line 28
allow webalizer_t var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 28

#line 28
#
#line 28
# Allow the process to create the file.
#line 28
#
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
allow webalizer_t webalizer_var_lib_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28

#line 28
type_transition webalizer_t var_lib_t:file webalizer_var_lib_t;
#line 28

#line 28

#line 28
allow webalizer_t webalizer_var_lib_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 28


#read /var/www/usage

#line 31
allow webalizer_t httpd_sys_content_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 31
allow webalizer_t httpd_sys_content_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 31
allow webalizer_t httpd_sys_content_t:lnk_file { create read getattr setattr link unlink rename };
#line 31


#read system files under /etc
allow webalizer_t { etc_t etc_runtime_t }:file { getattr read };

#line 35
allow webalizer_t etc_t:lnk_file read;
#line 35
allow webalizer_t lib_t:file { read getattr lock ioctl };
#line 35

#line 35
allow webalizer_t locale_t:dir { read getattr lock search ioctl };
#line 35
allow webalizer_t locale_t:file { read getattr lock ioctl };
#line 35
allow webalizer_t locale_t:lnk_file { getattr read };
#line 35

#line 35


# can use tmp file

#line 38
type webalizer_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 38

#line 38

#line 38

#line 38

#line 38
#
#line 38
# Allow the process to modify the directory.
#line 38
#
#line 38
allow webalizer_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 38

#line 38
#
#line 38
# Allow the process to create the file.
#line 38
#
#line 38

#line 38

#line 38

#line 38

#line 38

#line 38
allow webalizer_t webalizer_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38
allow webalizer_t webalizer_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38

#line 38
type_transition webalizer_t tmp_t:{ file dir } webalizer_tmp_t;
#line 38

#line 38

#line 38


# can read /proc

#line 41
# Read system variables in /sys.
#line 41

#line 41
allow webalizer_t sysctl_t:dir search;
#line 41
allow webalizer_t sysctl_kernel_t:dir search;
#line 41
allow webalizer_t sysctl_kernel_t:file { getattr read };
#line 41

#line 41

#line 41

allow webalizer_t proc_t:dir search;
allow webalizer_t proc_t:file { read getattr lock ioctl };

# network

#line 46

#line 46

#line 46

#line 46
#
#line 46
# Allow the domain to create and use tcp sockets.
#line 46
# Other kinds of sockets must be separately authorized for use.
#line 46
allow webalizer_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 46

#line 46
allow webalizer_t unlabeled_t:association { sendto recvfrom };
#line 46

#line 46
#
#line 46
# Allow the domain to send or receive using any network interface.
#line 46
# netif_type is a type attribute for all network interface types.
#line 46
#
#line 46
allow webalizer_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 46
#
#line 46
# Allow the domain to send to or receive from any node.
#line 46
# node_type is a type attribute for all node types.
#line 46
#
#line 46
allow webalizer_t node_type:node { tcp_send rawip_send };
#line 46
allow webalizer_t node_type:node { tcp_recv rawip_recv };
#line 46

#line 46
#
#line 46
# Allow the domain to send to or receive from any port.
#line 46
# port_type is a type attribute for all port types.
#line 46
#
#line 46

#line 46
allow webalizer_t port_type:tcp_socket { send_msg recv_msg };
#line 46

#line 46

#line 46
# XXX Allow binding to any node type.  Remove once
#line 46
# individual rules have been added to all domains that 
#line 46
# bind sockets. 
#line 46
allow webalizer_t node_type:tcp_socket node_bind;
#line 46
#
#line 46
# Allow access to network files including /etc/resolv.conf
#line 46
#
#line 46
allow webalizer_t net_conf_t:file { read getattr lock ioctl };
#line 46

#line 46
allow webalizer_t self:tcp_socket { listen accept };
#line 46

#line 46

#line 46

#line 46
#
#line 46
# Allow the domain to create and use udp sockets.
#line 46
# Other kinds of sockets must be separately authorized for use.
#line 46
allow webalizer_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 46

#line 46
allow webalizer_t unlabeled_t:association { sendto recvfrom };
#line 46

#line 46
#
#line 46
# Allow the domain to send or receive using any network interface.
#line 46
# netif_type is a type attribute for all network interface types.
#line 46
#
#line 46
allow webalizer_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 46
#
#line 46
# Allow the domain to send to or receive from any node.
#line 46
# node_type is a type attribute for all node types.
#line 46
#
#line 46
allow webalizer_t node_type:node { udp_send rawip_send };
#line 46
allow webalizer_t node_type:node { udp_recv rawip_recv };
#line 46

#line 46
#
#line 46
# Allow the domain to send to or receive from any port.
#line 46
# port_type is a type attribute for all port types.
#line 46
#
#line 46

#line 46
allow webalizer_t port_type:udp_socket { send_msg recv_msg };
#line 46

#line 46

#line 46
# XXX Allow binding to any node type.  Remove once
#line 46
# individual rules have been added to all domains that 
#line 46
# bind sockets. 
#line 46
allow webalizer_t node_type:udp_socket node_bind;
#line 46
#
#line 46
# Allow access to network files including /etc/resolv.conf
#line 46
#
#line 46
allow webalizer_t net_conf_t:file { read getattr lock ioctl };
#line 46

#line 46
allow webalizer_t self:udp_socket { connect };
#line 46

#line 46

#line 46


#process communication inside webalizer itself

#line 49
# Access other processes in the same domain.
#line 49
# Omits ptrace, setcurrent, setexec, setfscreate, setrlimit, execmem, execstack and execheap.
#line 49
# These must be granted separately if desired.
#line 49
allow webalizer_t self:process ~{ptrace setcurrent setexec setfscreate setrlimit execmem execstack execheap};
#line 49

#line 49
# Access /proc/PID files for processes in the same domain.
#line 49
allow webalizer_t self:dir { read getattr lock search ioctl };
#line 49
allow webalizer_t self:{ file lnk_file sock_file fifo_file } { read getattr lock ioctl };
#line 49

#line 49
# Access file descriptions, pipes, and sockets
#line 49
# created by processes in the same domain.
#line 49
allow webalizer_t self:fd *;
#line 49
allow webalizer_t self:fifo_file { ioctl read getattr lock write append };
#line 49
allow webalizer_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
#line 49
allow webalizer_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 49

#line 49
# Allow the domain to communicate with other processes in the same domain.
#line 49
allow webalizer_t self:unix_dgram_socket sendto;
#line 49
allow webalizer_t self:unix_stream_socket connectto;
#line 49

#line 49
# Access System V IPC objects created by processes in the same domain.
#line 49
allow webalizer_t self:sem  { associate getattr setattr create destroy read write unix_read unix_write };
#line 49
allow webalizer_t self:msg  { send receive };
#line 49
allow webalizer_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
#line 49
allow webalizer_t self:shm  { associate getattr setattr create destroy read write lock unix_read unix_write };
#line 49
allow webalizer_t unpriv_userdomain:fd use;
#line 49
#
#line 49
# Every app is asking for ypbind so I am adding this here, 
#line 49
# eventually this should become can_nsswitch
#line 49
#
#line 49

#line 49

#line 49
if (allow_ypbind) {
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use tcp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow webalizer_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow webalizer_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow webalizer_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow webalizer_t node_type:node { tcp_send rawip_send };
#line 49
allow webalizer_t node_type:node { tcp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow webalizer_t port_type:tcp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow webalizer_t node_type:tcp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow webalizer_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow webalizer_t self:tcp_socket { listen accept };
#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use tcp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow webalizer_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow webalizer_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow webalizer_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow webalizer_t node_type:node { tcp_send rawip_send };
#line 49
allow webalizer_t node_type:node { tcp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow webalizer_t port_type:tcp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow webalizer_t node_type:tcp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow webalizer_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow webalizer_t self:tcp_socket { connect };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
#
#line 49
# Allow the domain to create and use udp sockets.
#line 49
# Other kinds of sockets must be separately authorized for use.
#line 49
allow webalizer_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 49

#line 49
allow webalizer_t unlabeled_t:association { sendto recvfrom };
#line 49

#line 49
#
#line 49
# Allow the domain to send or receive using any network interface.
#line 49
# netif_type is a type attribute for all network interface types.
#line 49
#
#line 49
allow webalizer_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 49
#
#line 49
# Allow the domain to send to or receive from any node.
#line 49
# node_type is a type attribute for all node types.
#line 49
#
#line 49
allow webalizer_t node_type:node { udp_send rawip_send };
#line 49
allow webalizer_t node_type:node { udp_recv rawip_recv };
#line 49

#line 49
#
#line 49
# Allow the domain to send to or receive from any port.
#line 49
# port_type is a type attribute for all port types.
#line 49
#
#line 49

#line 49
allow webalizer_t port_type:udp_socket { send_msg recv_msg };
#line 49

#line 49

#line 49
# XXX Allow binding to any node type.  Remove once
#line 49
# individual rules have been added to all domains that 
#line 49
# bind sockets. 
#line 49
allow webalizer_t node_type:udp_socket node_bind;
#line 49
#
#line 49
# Allow access to network files including /etc/resolv.conf
#line 49
#
#line 49
allow webalizer_t net_conf_t:file { read getattr lock ioctl };
#line 49

#line 49
allow webalizer_t self:udp_socket { connect };
#line 49

#line 49

#line 49

#line 49

#line 49

#line 49

#line 49
allow webalizer_t var_yp_t:dir { read getattr lock search ioctl };
#line 49
allow webalizer_t var_yp_t:file { read getattr lock ioctl };
#line 49
allow webalizer_t var_yp_t:lnk_file { getattr read };
#line 49

#line 49
allow webalizer_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 49
allow webalizer_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 49
dontaudit webalizer_t self:capability net_bind_service;
#line 49
dontaudit webalizer_t reserved_port_type:tcp_socket name_connect;
#line 49
dontaudit webalizer_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 49

#line 49
} else {
#line 49
dontaudit webalizer_t var_yp_t:dir search;
#line 49
}
#line 49
 
#line 49
allow webalizer_t autofs_t:dir { search getattr };
#line 49


allow webalizer_t self:capability dac_override;
#line 1 "domains/program/winbind.te"
#DESC winbind - Name  Service  Switch  daemon for resolving names from NT servers
#
# Author: Dan Walsh (dwalsh@redhat.com)
#

#################################
#
# Declarations for winbind
#


#line 11

#line 11

#line 11

#line 11
type winbind_t, domain, privlog, daemon , privhome, auth_chkpwd, nscd_client_domain, transitionbool;
#line 11
type winbind_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit winbind_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types winbind_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow winbind_t init_t:fd use;
#line 11
allow winbind_t init_t:process sigchld;
#line 11
allow winbind_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow winbind_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow winbind_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow winbind_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow winbind_t ld_so_t:file execute_no_trans;
#line 11
allow winbind_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow winbind_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow winbind_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow winbind_t texrel_shlib_t:file execmod;
#line 11
allow winbind_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow winbind_t device_t:dir search;
#line 11
allow winbind_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow winbind_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow winbind_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow winbind_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow winbind_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow winbind_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit winbind_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit winbind_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow winbind_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow winbind_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow winbind_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow winbind_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit winbind_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit winbind_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
# Read system variables in /sys.
#line 11

#line 11
allow winbind_t sysctl_t:dir search;
#line 11
allow winbind_t sysctl_kernel_t:dir search;
#line 11
allow winbind_t sysctl_kernel_t:file { getattr read };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allows user to define a tunable to disable domain transition
#line 11
#
#line 11

#line 11
bool winbind_disable_trans false;
#line 11
if (winbind_disable_trans) {
#line 11

#line 11
allow initrc_t winbind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11

#line 11
allow sysadm_t winbind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11
 
#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow initrc_t winbind_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit initrc_t winbind_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit initrc_t winbind_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit initrc_t winbind_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow initrc_t winbind_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow winbind_t initrc_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow winbind_t initrc_t:fd use;
#line 11
allow initrc_t winbind_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow winbind_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow winbind_t winbind_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow winbind_t winbind_exec_t:file entrypoint;
#line 11

#line 11
type_transition initrc_t winbind_exec_t:process winbind_t;
#line 11

#line 11

#line 11
allow initrc_t winbind_t:process { noatsecure siginh rlimitinh };
#line 11

#line 11
}
#line 11
 
#line 11
allow winbind_t privfd:fd use;
#line 11

#line 11
allow winbind_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
# Create pid file.
#line 11
allow winbind_t var_t:dir { getattr search };
#line 11

#line 11
type winbind_var_run_t, file_type, sysadmfile, pidfile;
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow winbind_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow winbind_t winbind_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition winbind_t var_run_t:file winbind_var_run_t;
#line 11

#line 11

#line 11

#line 11
allow winbind_t var_t:dir search;
#line 11
allow winbind_t winbind_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11

#line 11
allow winbind_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11
# for daemons that look at /root on startup
#line 11
dontaudit winbind_t sysadm_home_dir_t:dir search;
#line 11

#line 11
# for df
#line 11
allow winbind_t fs_type:filesystem getattr;
#line 11
allow winbind_t removable_t:filesystem getattr;
#line 11

#line 11

#line 11
allow winbind_t etc_t:lnk_file read;
#line 11
allow winbind_t lib_t:file { read getattr lock ioctl };
#line 11

#line 11
allow winbind_t locale_t:dir { read getattr lock search ioctl };
#line 11
allow winbind_t locale_t:file { read getattr lock ioctl };
#line 11
allow winbind_t locale_t:lnk_file { getattr read };
#line 11

#line 11

#line 11

#line 11
# for localization
#line 11
allow winbind_t lib_t:file { getattr read };
#line 11


#line 12
type winbind_log_t, file_type, sysadmfile, logfile;
#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the process to modify the directory.
#line 12
#
#line 12
allow winbind_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 12

#line 12
#
#line 12
# Allow the process to create the file.
#line 12
#
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow winbind_t winbind_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
type_transition winbind_t var_log_t:file winbind_log_t;
#line 12

#line 12

#line 12


#line 13
type winbind_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow winbind_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow winbind_t winbind_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow winbind_t winbind_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition winbind_t tmp_t:{ file dir } winbind_tmp_t;
#line 13

#line 13

#line 13

allow winbind_t etc_t:file { read getattr lock ioctl };
allow winbind_t etc_t:lnk_file read;

#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow winbind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow winbind_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow winbind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow winbind_t node_type:node { tcp_send rawip_send };
#line 16
allow winbind_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow winbind_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow winbind_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow winbind_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow winbind_t self:tcp_socket { listen accept };
#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use tcp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow winbind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow winbind_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow winbind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow winbind_t node_type:node { tcp_send rawip_send };
#line 16
allow winbind_t node_type:node { tcp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow winbind_t port_type:tcp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow winbind_t node_type:tcp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow winbind_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow winbind_t self:tcp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

#line 16
#
#line 16
# Allow the domain to create and use udp sockets.
#line 16
# Other kinds of sockets must be separately authorized for use.
#line 16
allow winbind_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 16

#line 16
allow winbind_t unlabeled_t:association { sendto recvfrom };
#line 16

#line 16
#
#line 16
# Allow the domain to send or receive using any network interface.
#line 16
# netif_type is a type attribute for all network interface types.
#line 16
#
#line 16
allow winbind_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 16
#
#line 16
# Allow the domain to send to or receive from any node.
#line 16
# node_type is a type attribute for all node types.
#line 16
#
#line 16
allow winbind_t node_type:node { udp_send rawip_send };
#line 16
allow winbind_t node_type:node { udp_recv rawip_recv };
#line 16

#line 16
#
#line 16
# Allow the domain to send to or receive from any port.
#line 16
# port_type is a type attribute for all port types.
#line 16
#
#line 16

#line 16
allow winbind_t port_type:udp_socket { send_msg recv_msg };
#line 16

#line 16

#line 16
# XXX Allow binding to any node type.  Remove once
#line 16
# individual rules have been added to all domains that 
#line 16
# bind sockets. 
#line 16
allow winbind_t node_type:udp_socket node_bind;
#line 16
#
#line 16
# Allow access to network files including /etc/resolv.conf
#line 16
#
#line 16
allow winbind_t net_conf_t:file { read getattr lock ioctl };
#line 16

#line 16
allow winbind_t self:udp_socket { connect };
#line 16

#line 16

#line 16

#line 16

#line 16

allow winbind_t smbd_port_t:tcp_socket name_connect;

#line 18

#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use tcp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow winbind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow winbind_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow winbind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow winbind_t node_type:node { tcp_send rawip_send };
#line 18
allow winbind_t node_type:node { tcp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow winbind_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow winbind_t node_type:tcp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow winbind_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow winbind_t self:tcp_socket { connect };
#line 18

#line 18

#line 18

#line 18
#
#line 18
# Allow the domain to create and use udp sockets.
#line 18
# Other kinds of sockets must be separately authorized for use.
#line 18
allow winbind_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 18

#line 18
allow winbind_t unlabeled_t:association { sendto recvfrom };
#line 18

#line 18
#
#line 18
# Allow the domain to send or receive using any network interface.
#line 18
# netif_type is a type attribute for all network interface types.
#line 18
#
#line 18
allow winbind_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 18
#
#line 18
# Allow the domain to send to or receive from any node.
#line 18
# node_type is a type attribute for all node types.
#line 18
#
#line 18
allow winbind_t node_type:node { udp_send rawip_send };
#line 18
allow winbind_t node_type:node { udp_recv rawip_recv };
#line 18

#line 18
#
#line 18
# Allow the domain to send to or receive from any port.
#line 18
# port_type is a type attribute for all port types.
#line 18
#
#line 18

#line 18
allow winbind_t dns_port_t:udp_socket { send_msg recv_msg };
#line 18

#line 18

#line 18
# XXX Allow binding to any node type.  Remove once
#line 18
# individual rules have been added to all domains that 
#line 18
# bind sockets. 
#line 18
allow winbind_t node_type:udp_socket node_bind;
#line 18
#
#line 18
# Allow access to network files including /etc/resolv.conf
#line 18
#
#line 18
allow winbind_t net_conf_t:file { read getattr lock ioctl };
#line 18

#line 18
allow winbind_t self:udp_socket { connect };
#line 18

#line 18

#line 18

#line 18
allow winbind_t dns_port_t:tcp_socket name_connect;
#line 18


#line 25


#line 26

#line 26

#line 26

#line 26
#
#line 26
# Allow the process to modify the directory.
#line 26
#
#line 26
allow winbind_t samba_etc_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 26

#line 26
#
#line 26
# Allow the process to create the file.
#line 26
#
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
allow winbind_t samba_secrets_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26

#line 26
type_transition winbind_t samba_etc_t:file samba_secrets_t;
#line 26

#line 26


#line 27
allow winbind_t samba_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 27
allow winbind_t samba_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 27
allow winbind_t samba_log_t:lnk_file { create read getattr setattr link unlink rename };
#line 27

allow winbind_t samba_secrets_t:file { ioctl read getattr lock write append };
allow winbind_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow winbind_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow winbind_t urandom_device_t:chr_file { getattr read };
allow winbind_t self:fifo_file { read write };

#line 33
allow winbind_t samba_var_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 33
allow winbind_t samba_var_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 33
allow winbind_t samba_var_t:lnk_file { create read getattr setattr link unlink rename };
#line 33


#line 34

#line 34
if (allow_kerberos) {
#line 34

#line 34

#line 34

#line 34

#line 34
#
#line 34
# Allow the domain to create and use tcp sockets.
#line 34
# Other kinds of sockets must be separately authorized for use.
#line 34
allow winbind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 34

#line 34
allow winbind_t unlabeled_t:association { sendto recvfrom };
#line 34

#line 34
#
#line 34
# Allow the domain to send or receive using any network interface.
#line 34
# netif_type is a type attribute for all network interface types.
#line 34
#
#line 34
allow winbind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 34
#
#line 34
# Allow the domain to send to or receive from any node.
#line 34
# node_type is a type attribute for all node types.
#line 34
#
#line 34
allow winbind_t node_type:node { tcp_send rawip_send };
#line 34
allow winbind_t node_type:node { tcp_recv rawip_recv };
#line 34

#line 34
#
#line 34
# Allow the domain to send to or receive from any port.
#line 34
# port_type is a type attribute for all port types.
#line 34
#
#line 34

#line 34
allow winbind_t kerberos_port_t:tcp_socket { send_msg recv_msg };
#line 34

#line 34

#line 34
# XXX Allow binding to any node type.  Remove once
#line 34
# individual rules have been added to all domains that 
#line 34
# bind sockets. 
#line 34
allow winbind_t node_type:tcp_socket node_bind;
#line 34
#
#line 34
# Allow access to network files including /etc/resolv.conf
#line 34
#
#line 34
allow winbind_t net_conf_t:file { read getattr lock ioctl };
#line 34

#line 34
allow winbind_t self:tcp_socket { connect };
#line 34

#line 34

#line 34

#line 34
#
#line 34
# Allow the domain to create and use udp sockets.
#line 34
# Other kinds of sockets must be separately authorized for use.
#line 34
allow winbind_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 34

#line 34
allow winbind_t unlabeled_t:association { sendto recvfrom };
#line 34

#line 34
#
#line 34
# Allow the domain to send or receive using any network interface.
#line 34
# netif_type is a type attribute for all network interface types.
#line 34
#
#line 34
allow winbind_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 34
#
#line 34
# Allow the domain to send to or receive from any node.
#line 34
# node_type is a type attribute for all node types.
#line 34
#
#line 34
allow winbind_t node_type:node { udp_send rawip_send };
#line 34
allow winbind_t node_type:node { udp_recv rawip_recv };
#line 34

#line 34
#
#line 34
# Allow the domain to send to or receive from any port.
#line 34
# port_type is a type attribute for all port types.
#line 34
#
#line 34

#line 34
allow winbind_t kerberos_port_t:udp_socket { send_msg recv_msg };
#line 34

#line 34

#line 34
# XXX Allow binding to any node type.  Remove once
#line 34
# individual rules have been added to all domains that 
#line 34
# bind sockets. 
#line 34
allow winbind_t node_type:udp_socket node_bind;
#line 34
#
#line 34
# Allow access to network files including /etc/resolv.conf
#line 34
#
#line 34
allow winbind_t net_conf_t:file { read getattr lock ioctl };
#line 34

#line 34
allow winbind_t self:udp_socket { connect };
#line 34

#line 34

#line 34

#line 34
allow winbind_t kerberos_port_t:tcp_socket name_connect;
#line 34

#line 34

#line 34

#line 34

#line 34

#line 34
#
#line 34
# Allow the domain to create and use tcp sockets.
#line 34
# Other kinds of sockets must be separately authorized for use.
#line 34
allow winbind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 34

#line 34
allow winbind_t unlabeled_t:association { sendto recvfrom };
#line 34

#line 34
#
#line 34
# Allow the domain to send or receive using any network interface.
#line 34
# netif_type is a type attribute for all network interface types.
#line 34
#
#line 34
allow winbind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 34
#
#line 34
# Allow the domain to send to or receive from any node.
#line 34
# node_type is a type attribute for all node types.
#line 34
#
#line 34
allow winbind_t node_type:node { tcp_send rawip_send };
#line 34
allow winbind_t node_type:node { tcp_recv rawip_recv };
#line 34

#line 34
#
#line 34
# Allow the domain to send to or receive from any port.
#line 34
# port_type is a type attribute for all port types.
#line 34
#
#line 34

#line 34
allow winbind_t dns_port_t:tcp_socket { send_msg recv_msg };
#line 34

#line 34

#line 34
# XXX Allow binding to any node type.  Remove once
#line 34
# individual rules have been added to all domains that 
#line 34
# bind sockets. 
#line 34
allow winbind_t node_type:tcp_socket node_bind;
#line 34
#
#line 34
# Allow access to network files including /etc/resolv.conf
#line 34
#
#line 34
allow winbind_t net_conf_t:file { read getattr lock ioctl };
#line 34

#line 34
allow winbind_t self:tcp_socket { connect };
#line 34

#line 34

#line 34

#line 34
#
#line 34
# Allow the domain to create and use udp sockets.
#line 34
# Other kinds of sockets must be separately authorized for use.
#line 34
allow winbind_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 34

#line 34
allow winbind_t unlabeled_t:association { sendto recvfrom };
#line 34

#line 34
#
#line 34
# Allow the domain to send or receive using any network interface.
#line 34
# netif_type is a type attribute for all network interface types.
#line 34
#
#line 34
allow winbind_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 34
#
#line 34
# Allow the domain to send to or receive from any node.
#line 34
# node_type is a type attribute for all node types.
#line 34
#
#line 34
allow winbind_t node_type:node { udp_send rawip_send };
#line 34
allow winbind_t node_type:node { udp_recv rawip_recv };
#line 34

#line 34
#
#line 34
# Allow the domain to send to or receive from any port.
#line 34
# port_type is a type attribute for all port types.
#line 34
#
#line 34

#line 34
allow winbind_t dns_port_t:udp_socket { send_msg recv_msg };
#line 34

#line 34

#line 34
# XXX Allow binding to any node type.  Remove once
#line 34
# individual rules have been added to all domains that 
#line 34
# bind sockets. 
#line 34
allow winbind_t node_type:udp_socket node_bind;
#line 34
#
#line 34
# Allow access to network files including /etc/resolv.conf
#line 34
#
#line 34
allow winbind_t net_conf_t:file { read getattr lock ioctl };
#line 34

#line 34
allow winbind_t self:udp_socket { connect };
#line 34

#line 34

#line 34

#line 34
allow winbind_t dns_port_t:tcp_socket name_connect;
#line 34

#line 34
}
#line 34
 dontaudit winbind_t krb5_conf_t:file write;
#line 34
allow winbind_t krb5_conf_t:file { getattr read };
#line 34

allow winbind_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
allow winbind_t winbind_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
allow initrc_t winbind_var_run_t:file { read getattr lock ioctl };


#line 39
type winbind_helper_t, domain, privlog , nscd_client_domain;
#line 39
type winbind_helper_exec_t, file_type, sysadmfile, exec_type;
#line 39
role sysadm_r types winbind_helper_t;
#line 39

#line 39
role system_r types winbind_helper_t;
#line 39

#line 39

#line 39

#line 39

#line 39
#
#line 39
# Allow the process to transition to the new domain.
#line 39
#
#line 39
allow sysadm_t winbind_helper_t:process transition;
#line 39

#line 39
#
#line 39
# Do not audit when glibc secure mode is enabled upon the transition.
#line 39
#
#line 39
dontaudit sysadm_t winbind_helper_t:process noatsecure;
#line 39

#line 39
#
#line 39
# Do not audit when signal-related state is cleared upon the transition.
#line 39
#
#line 39
dontaudit sysadm_t winbind_helper_t:process siginh;
#line 39

#line 39
#
#line 39
# Do not audit when resource limits are reset upon the transition.
#line 39
#
#line 39
dontaudit sysadm_t winbind_helper_t:process rlimitinh;
#line 39

#line 39
#
#line 39
# Allow the process to execute the program.
#line 39
# 
#line 39
allow sysadm_t winbind_helper_exec_t:file { read { getattr execute } };
#line 39

#line 39
#
#line 39
# Allow the process to reap the new domain.
#line 39
#
#line 39
allow winbind_helper_t sysadm_t:process sigchld;
#line 39

#line 39
#
#line 39
# Allow the new domain to inherit and use file 
#line 39
# descriptions from the creating process and vice versa.
#line 39
#
#line 39
allow winbind_helper_t sysadm_t:fd use;
#line 39
allow sysadm_t winbind_helper_t:fd use;
#line 39

#line 39
#
#line 39
# Allow the new domain to write back to the old domain via a pipe.
#line 39
#
#line 39
allow winbind_helper_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 39

#line 39
#
#line 39
# Allow the new domain to read and execute the program.
#line 39
#
#line 39
allow winbind_helper_t winbind_helper_exec_t:file { read getattr lock execute ioctl };
#line 39

#line 39
#
#line 39
# Allow the new domain to be entered via the program.
#line 39
#
#line 39
allow winbind_helper_t winbind_helper_exec_t:file entrypoint;
#line 39

#line 39
type_transition sysadm_t winbind_helper_exec_t:process winbind_helper_t;
#line 39

#line 39

#line 39
allow winbind_helper_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 39
allow winbind_helper_t lib_t:lnk_file { read getattr lock ioctl };
#line 39
allow winbind_helper_t ld_so_t:file { read getattr lock execute ioctl };
#line 39
#allow winbind_helper_t ld_so_t:file execute_no_trans;
#line 39
allow winbind_helper_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 39
allow winbind_helper_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 39
allow winbind_helper_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 39
allow winbind_helper_t texrel_shlib_t:file execmod;
#line 39
allow winbind_helper_t ld_so_cache_t:file { read getattr lock ioctl };
#line 39
allow winbind_helper_t device_t:dir search;
#line 39
allow winbind_helper_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 39

#line 39

role system_r types winbind_helper_t;

#line 41
allow winbind_helper_t sysadm_tty_device_t:chr_file { read write getattr ioctl };
#line 41
allow winbind_helper_t devtty_t:chr_file { read write getattr ioctl };
#line 41

#line 41
allow winbind_helper_t devpts_t:dir { read getattr lock search ioctl };
#line 41
allow winbind_helper_t sysadm_devpts_t:chr_file { ioctl read getattr lock write append };
#line 41

#line 41


#line 42
allow winbind_helper_t etc_t:lnk_file read;
#line 42
allow winbind_helper_t lib_t:file { read getattr lock ioctl };
#line 42

#line 42
allow winbind_helper_t locale_t:dir { read getattr lock search ioctl };
#line 42
allow winbind_helper_t locale_t:file { read getattr lock ioctl };
#line 42
allow winbind_helper_t locale_t:lnk_file { getattr read };
#line 42

#line 42
 

#line 43
allow winbind_helper_t samba_etc_t:dir { read getattr lock search ioctl };
#line 43
allow winbind_helper_t samba_etc_t:file { read getattr lock ioctl };
#line 43
allow winbind_helper_t samba_etc_t:lnk_file { getattr read };
#line 43


#line 44
allow winbind_t samba_etc_t:dir { read getattr lock search ioctl };
#line 44
allow winbind_t samba_etc_t:file { read getattr lock ioctl };
#line 44
allow winbind_t samba_etc_t:lnk_file { getattr read };
#line 44

allow winbind_helper_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow winbind_helper_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
allow winbind_helper_t samba_var_t:dir search;
allow winbind_helper_t winbind_var_run_t:dir { read getattr lock search ioctl };

#line 49

#line 49
allow winbind_helper_t winbind_var_run_t:dir { getattr search };
#line 49
allow winbind_helper_t winbind_t:unix_stream_socket connectto;
#line 49
allow winbind_helper_t winbind_var_run_t:sock_file { getattr read write };
#line 49

#line 49

allow winbind_helper_t privfd:fd use;
#line 1 "domains/program/xdm.te"
#DESC xdm - Linux configurable dynamic device naming support
#
# Authors:  Daniel Walsh <dwalsh@redhat.com>
#

#################################
#
# Rules for the xdm domain.
#
# xdm_exec_t is the type of the /usr/bin/gdm and other programs.
# This domain is defined just for targeted policy.
#
type xdm_exec_t, file_type, sysadmfile, exec_type;
type xsession_exec_t, file_type, sysadmfile, exec_type;
type xserver_log_t, file_type, sysadmfile;
type xdm_xserver_tmp_t, file_type, sysadmfile;
type xdm_rw_etc_t, file_type, sysadmfile;
type xdm_var_run_t, file_type, sysadmfile;
type xdm_var_lib_t, file_type, sysadmfile;
type xdm_tmp_t, file_type, sysadmfile;

#line 21

#line 21

#line 21
#
#line 21
# Allow the process to transition to the new domain.
#line 21
#
#line 21
allow initrc_t xdm_t:process transition;
#line 21

#line 21
#
#line 21
# Do not audit when glibc secure mode is enabled upon the transition.
#line 21
#
#line 21
dontaudit initrc_t xdm_t:process noatsecure;
#line 21

#line 21
#
#line 21
# Do not audit when signal-related state is cleared upon the transition.
#line 21
#
#line 21
dontaudit initrc_t xdm_t:process siginh;
#line 21

#line 21
#
#line 21
# Do not audit when resource limits are reset upon the transition.
#line 21
#
#line 21
dontaudit initrc_t xdm_t:process rlimitinh;
#line 21

#line 21
#
#line 21
# Allow the process to execute the program.
#line 21
# 
#line 21
allow initrc_t xdm_exec_t:file { read { getattr execute } };
#line 21

#line 21
#
#line 21
# Allow the process to reap the new domain.
#line 21
#
#line 21
allow xdm_t initrc_t:process sigchld;
#line 21

#line 21
#
#line 21
# Allow the new domain to inherit and use file 
#line 21
# descriptions from the creating process and vice versa.
#line 21
#
#line 21
allow xdm_t initrc_t:fd use;
#line 21
allow initrc_t xdm_t:fd use;
#line 21

#line 21
#
#line 21
# Allow the new domain to write back to the old domain via a pipe.
#line 21
#
#line 21
allow xdm_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 21

#line 21
#
#line 21
# Allow the new domain to read and execute the program.
#line 21
#
#line 21
allow xdm_t xdm_exec_t:file { read getattr lock execute ioctl };
#line 21

#line 21
#
#line 21
# Allow the new domain to be entered via the program.
#line 21
#
#line 21
allow xdm_t xdm_exec_t:file entrypoint;
#line 21

#line 21
type_transition initrc_t xdm_exec_t:process xdm_t;
#line 21


#line 22

#line 22

#line 22
#
#line 22
# Allow the process to transition to the new domain.
#line 22
#
#line 22
allow init_t xdm_t:process transition;
#line 22

#line 22
#
#line 22
# Do not audit when glibc secure mode is enabled upon the transition.
#line 22
#
#line 22
dontaudit init_t xdm_t:process noatsecure;
#line 22

#line 22
#
#line 22
# Do not audit when signal-related state is cleared upon the transition.
#line 22
#
#line 22
dontaudit init_t xdm_t:process siginh;
#line 22

#line 22
#
#line 22
# Do not audit when resource limits are reset upon the transition.
#line 22
#
#line 22
dontaudit init_t xdm_t:process rlimitinh;
#line 22

#line 22
#
#line 22
# Allow the process to execute the program.
#line 22
# 
#line 22
allow init_t xdm_exec_t:file { read { getattr execute } };
#line 22

#line 22
#
#line 22
# Allow the process to reap the new domain.
#line 22
#
#line 22
allow xdm_t init_t:process sigchld;
#line 22

#line 22
#
#line 22
# Allow the new domain to inherit and use file 
#line 22
# descriptions from the creating process and vice versa.
#line 22
#
#line 22
allow xdm_t init_t:fd use;
#line 22
allow init_t xdm_t:fd use;
#line 22

#line 22
#
#line 22
# Allow the new domain to write back to the old domain via a pipe.
#line 22
#
#line 22
allow xdm_t init_t:fifo_file { ioctl read getattr lock write append };
#line 22

#line 22
#
#line 22
# Allow the new domain to read and execute the program.
#line 22
#
#line 22
allow xdm_t xdm_exec_t:file { read getattr lock execute ioctl };
#line 22

#line 22
#
#line 22
# Allow the new domain to be entered via the program.
#line 22
#
#line 22
allow xdm_t xdm_exec_t:file entrypoint;
#line 22

#line 22
type_transition init_t xdm_exec_t:process xdm_t;
#line 22

#line 26

#line 1 "domains/program/ypbind.te"
#DESC Ypbind - NIS/YP
#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#           Russell Coker <russell@coker.com.au>
# X-Debian-Packages: nis
# Depends: portmap.te named.te
#

#################################
#
# Rules for the ypbind_t domain.
#

#line 13

#line 13

#line 13

#line 13
type ypbind_t, domain, privlog, daemon , transitionbool;
#line 13
type ypbind_exec_t, file_type, sysadmfile, exec_type;
#line 13
dontaudit ypbind_t self:capability sys_tty_config;
#line 13

#line 13
role system_r types ypbind_t;
#line 13

#line 13
# Inherit and use descriptors from init.
#line 13
allow ypbind_t init_t:fd use;
#line 13
allow ypbind_t init_t:process sigchld;
#line 13
allow ypbind_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 13

#line 13

#line 13
allow ypbind_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 13
allow ypbind_t lib_t:lnk_file { read getattr lock ioctl };
#line 13
allow ypbind_t ld_so_t:file { read getattr lock execute ioctl };
#line 13
#allow ypbind_t ld_so_t:file execute_no_trans;
#line 13
allow ypbind_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 13
allow ypbind_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 13
allow ypbind_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 13
allow ypbind_t texrel_shlib_t:file execmod;
#line 13
allow ypbind_t ld_so_cache_t:file { read getattr lock ioctl };
#line 13
allow ypbind_t device_t:dir search;
#line 13
allow ypbind_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
allow ypbind_t { self proc_t }:dir { read getattr lock search ioctl };
#line 13
allow ypbind_t { self proc_t }:lnk_file { getattr read };
#line 13

#line 13
allow ypbind_t device_t:dir { read getattr lock search ioctl };
#line 13

#line 13
allow ypbind_t udev_tdb_t:file { read getattr lock ioctl };
#line 13
allow ypbind_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit ypbind_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 13
dontaudit ypbind_t unpriv_userdomain:fd use;
#line 13

#line 13

#line 13
allow ypbind_t sysfs_t:dir { read getattr lock search ioctl };
#line 13
allow ypbind_t sysfs_t:file { read getattr lock ioctl };
#line 13
allow ypbind_t sysfs_t:lnk_file { getattr read };
#line 13
 
#line 13

#line 13
allow ypbind_t autofs_t:dir { search getattr };
#line 13

#line 13
dontaudit ypbind_t { tty_device_t devpts_t }:chr_file { read write };
#line 13
dontaudit ypbind_t root_t:file { getattr read };
#line 13
 
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
# Read system variables in /sys.
#line 13

#line 13
allow ypbind_t sysctl_t:dir search;
#line 13
allow ypbind_t sysctl_kernel_t:dir search;
#line 13
allow ypbind_t sysctl_kernel_t:file { getattr read };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allows user to define a tunable to disable domain transition
#line 13
#
#line 13

#line 13
bool ypbind_disable_trans false;
#line 13
if (ypbind_disable_trans) {
#line 13

#line 13
allow initrc_t ypbind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13

#line 13
allow sysadm_t ypbind_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 13

#line 13
} else {
#line 13
 
#line 13

#line 13

#line 13
#
#line 13
# Allow the process to transition to the new domain.
#line 13
#
#line 13
allow initrc_t ypbind_t:process transition;
#line 13

#line 13
#
#line 13
# Do not audit when glibc secure mode is enabled upon the transition.
#line 13
#
#line 13
dontaudit initrc_t ypbind_t:process noatsecure;
#line 13

#line 13
#
#line 13
# Do not audit when signal-related state is cleared upon the transition.
#line 13
#
#line 13
dontaudit initrc_t ypbind_t:process siginh;
#line 13

#line 13
#
#line 13
# Do not audit when resource limits are reset upon the transition.
#line 13
#
#line 13
dontaudit initrc_t ypbind_t:process rlimitinh;
#line 13

#line 13
#
#line 13
# Allow the process to execute the program.
#line 13
# 
#line 13
allow initrc_t ypbind_exec_t:file { read { getattr execute } };
#line 13

#line 13
#
#line 13
# Allow the process to reap the new domain.
#line 13
#
#line 13
allow ypbind_t initrc_t:process sigchld;
#line 13

#line 13
#
#line 13
# Allow the new domain to inherit and use file 
#line 13
# descriptions from the creating process and vice versa.
#line 13
#
#line 13
allow ypbind_t initrc_t:fd use;
#line 13
allow initrc_t ypbind_t:fd use;
#line 13

#line 13
#
#line 13
# Allow the new domain to write back to the old domain via a pipe.
#line 13
#
#line 13
allow ypbind_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 13

#line 13
#
#line 13
# Allow the new domain to read and execute the program.
#line 13
#
#line 13
allow ypbind_t ypbind_exec_t:file { read getattr lock execute ioctl };
#line 13

#line 13
#
#line 13
# Allow the new domain to be entered via the program.
#line 13
#
#line 13
allow ypbind_t ypbind_exec_t:file entrypoint;
#line 13

#line 13
type_transition initrc_t ypbind_exec_t:process ypbind_t;
#line 13

#line 13

#line 13
allow initrc_t ypbind_t:process { noatsecure siginh rlimitinh };
#line 13

#line 13
}
#line 13
 
#line 13
allow ypbind_t privfd:fd use;
#line 13

#line 13
allow ypbind_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13

#line 13
# Create pid file.
#line 13
allow ypbind_t var_t:dir { getattr search };
#line 13

#line 13
type ypbind_var_run_t, file_type, sysadmfile, pidfile;
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow ypbind_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow ypbind_t ypbind_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition ypbind_t var_run_t:file ypbind_var_run_t;
#line 13

#line 13

#line 13

#line 13
allow ypbind_t var_t:dir search;
#line 13
allow ypbind_t ypbind_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13

#line 13
allow ypbind_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 13

#line 13
# for daemons that look at /root on startup
#line 13
dontaudit ypbind_t sysadm_home_dir_t:dir search;
#line 13

#line 13
# for df
#line 13
allow ypbind_t fs_type:filesystem getattr;
#line 13
allow ypbind_t removable_t:filesystem getattr;
#line 13

#line 13

#line 13
allow ypbind_t etc_t:lnk_file read;
#line 13
allow ypbind_t lib_t:file { read getattr lock ioctl };
#line 13

#line 13
allow ypbind_t locale_t:dir { read getattr lock search ioctl };
#line 13
allow ypbind_t locale_t:file { read getattr lock ioctl };
#line 13
allow ypbind_t locale_t:lnk_file { getattr read };
#line 13

#line 13

#line 13

#line 13
# for localization
#line 13
allow ypbind_t lib_t:file { getattr read };
#line 13



#line 15
type ypbind_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 15

#line 15

#line 15

#line 15

#line 15
#
#line 15
# Allow the process to modify the directory.
#line 15
#
#line 15
allow ypbind_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 15

#line 15
#
#line 15
# Allow the process to create the file.
#line 15
#
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
allow ypbind_t ypbind_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
allow ypbind_t ypbind_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15

#line 15
type_transition ypbind_t tmp_t:{ file dir } ypbind_tmp_t;
#line 15

#line 15

#line 15


# Use capabilities.
allow ypbind_t self:capability { net_bind_service };
dontaudit ypbind_t self:capability net_admin;

# Use the network.

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the domain to create and use tcp sockets.
#line 22
# Other kinds of sockets must be separately authorized for use.
#line 22
allow ypbind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 22

#line 22
allow ypbind_t unlabeled_t:association { sendto recvfrom };
#line 22

#line 22
#
#line 22
# Allow the domain to send or receive using any network interface.
#line 22
# netif_type is a type attribute for all network interface types.
#line 22
#
#line 22
allow ypbind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 22
#
#line 22
# Allow the domain to send to or receive from any node.
#line 22
# node_type is a type attribute for all node types.
#line 22
#
#line 22
allow ypbind_t node_type:node { tcp_send rawip_send };
#line 22
allow ypbind_t node_type:node { tcp_recv rawip_recv };
#line 22

#line 22
#
#line 22
# Allow the domain to send to or receive from any port.
#line 22
# port_type is a type attribute for all port types.
#line 22
#
#line 22

#line 22
allow ypbind_t port_type:tcp_socket { send_msg recv_msg };
#line 22

#line 22

#line 22
# XXX Allow binding to any node type.  Remove once
#line 22
# individual rules have been added to all domains that 
#line 22
# bind sockets. 
#line 22
allow ypbind_t node_type:tcp_socket node_bind;
#line 22
#
#line 22
# Allow access to network files including /etc/resolv.conf
#line 22
#
#line 22
allow ypbind_t net_conf_t:file { read getattr lock ioctl };
#line 22

#line 22
allow ypbind_t self:tcp_socket { listen accept };
#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the domain to create and use tcp sockets.
#line 22
# Other kinds of sockets must be separately authorized for use.
#line 22
allow ypbind_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 22

#line 22
allow ypbind_t unlabeled_t:association { sendto recvfrom };
#line 22

#line 22
#
#line 22
# Allow the domain to send or receive using any network interface.
#line 22
# netif_type is a type attribute for all network interface types.
#line 22
#
#line 22
allow ypbind_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 22
#
#line 22
# Allow the domain to send to or receive from any node.
#line 22
# node_type is a type attribute for all node types.
#line 22
#
#line 22
allow ypbind_t node_type:node { tcp_send rawip_send };
#line 22
allow ypbind_t node_type:node { tcp_recv rawip_recv };
#line 22

#line 22
#
#line 22
# Allow the domain to send to or receive from any port.
#line 22
# port_type is a type attribute for all port types.
#line 22
#
#line 22

#line 22
allow ypbind_t port_type:tcp_socket { send_msg recv_msg };
#line 22

#line 22

#line 22
# XXX Allow binding to any node type.  Remove once
#line 22
# individual rules have been added to all domains that 
#line 22
# bind sockets. 
#line 22
allow ypbind_t node_type:tcp_socket node_bind;
#line 22
#
#line 22
# Allow access to network files including /etc/resolv.conf
#line 22
#
#line 22
allow ypbind_t net_conf_t:file { read getattr lock ioctl };
#line 22

#line 22
allow ypbind_t self:tcp_socket { connect };
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the domain to create and use udp sockets.
#line 22
# Other kinds of sockets must be separately authorized for use.
#line 22
allow ypbind_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 22

#line 22
allow ypbind_t unlabeled_t:association { sendto recvfrom };
#line 22

#line 22
#
#line 22
# Allow the domain to send or receive using any network interface.
#line 22
# netif_type is a type attribute for all network interface types.
#line 22
#
#line 22
allow ypbind_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 22
#
#line 22
# Allow the domain to send to or receive from any node.
#line 22
# node_type is a type attribute for all node types.
#line 22
#
#line 22
allow ypbind_t node_type:node { udp_send rawip_send };
#line 22
allow ypbind_t node_type:node { udp_recv rawip_recv };
#line 22

#line 22
#
#line 22
# Allow the domain to send to or receive from any port.
#line 22
# port_type is a type attribute for all port types.
#line 22
#
#line 22

#line 22
allow ypbind_t port_type:udp_socket { send_msg recv_msg };
#line 22

#line 22

#line 22
# XXX Allow binding to any node type.  Remove once
#line 22
# individual rules have been added to all domains that 
#line 22
# bind sockets. 
#line 22
allow ypbind_t node_type:udp_socket node_bind;
#line 22
#
#line 22
# Allow access to network files including /etc/resolv.conf
#line 22
#
#line 22
allow ypbind_t net_conf_t:file { read getattr lock ioctl };
#line 22

#line 22
allow ypbind_t self:udp_socket { connect };
#line 22

#line 22

#line 22

#line 22

#line 22

allow ypbind_t port_type:tcp_socket name_connect;
allow ypbind_t port_t:{ tcp_socket udp_socket } name_bind;

allow ypbind_t self:fifo_file { ioctl read getattr lock write append };


#line 28
# Read system variables in /sys.
#line 28

#line 28
allow ypbind_t sysctl_t:dir search;
#line 28
allow ypbind_t sysctl_kernel_t:dir search;
#line 28
allow ypbind_t sysctl_kernel_t:file { getattr read };
#line 28

#line 28

#line 28


# Send to portmap and initrc.

#line 31
#allow ypbind_t portmap_t:udp_socket sendto;
#line 31
#allow portmap_t ypbind_t:udp_socket recvfrom;
#line 31


#line 32
#allow ypbind_t initrc_t:udp_socket sendto;
#line 32
#allow initrc_t ypbind_t:udp_socket recvfrom;
#line 32


# Read and write /var/yp.
allow ypbind_t var_yp_t:dir { read getattr lock search ioctl add_name remove_name write };
allow ypbind_t var_yp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
allow initrc_t var_yp_t:dir { getattr read };
allow ypbind_t etc_t:file { getattr read };
allow ypbind_t self:{ unix_dgram_socket unix_stream_socket } { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow ypbind_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
allow ypbind_t reserved_port_t:{ tcp_socket udp_socket } name_bind;
dontaudit ypbind_t reserved_port_type:{ tcp_socket udp_socket } name_bind;

#line 43
#allow initrc_t ypbind_t:udp_socket sendto;
#line 43
#allow ypbind_t initrc_t:udp_socket recvfrom;
#line 43


#line 1 "domains/program/ypserv.te"
#DESC Ypserv - NIS/YP
#
# Authors:  Dan Walsh <dwalsh@redhat.com>
# Depends: portmap.te
#

#################################
#
# Rules for the ypserv_t domain.
#

#line 11

#line 11

#line 11

#line 11
type ypserv_t, domain, privlog, daemon , transitionbool;
#line 11
type ypserv_exec_t, file_type, sysadmfile, exec_type;
#line 11
dontaudit ypserv_t self:capability sys_tty_config;
#line 11

#line 11
role system_r types ypserv_t;
#line 11

#line 11
# Inherit and use descriptors from init.
#line 11
allow ypserv_t init_t:fd use;
#line 11
allow ypserv_t init_t:process sigchld;
#line 11
allow ypserv_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 11

#line 11

#line 11
allow ypserv_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 11
allow ypserv_t lib_t:lnk_file { read getattr lock ioctl };
#line 11
allow ypserv_t ld_so_t:file { read getattr lock execute ioctl };
#line 11
#allow ypserv_t ld_so_t:file execute_no_trans;
#line 11
allow ypserv_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 11
allow ypserv_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 11
allow ypserv_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 11
allow ypserv_t texrel_shlib_t:file execmod;
#line 11
allow ypserv_t ld_so_cache_t:file { read getattr lock ioctl };
#line 11
allow ypserv_t device_t:dir search;
#line 11
allow ypserv_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
allow ypserv_t { self proc_t }:dir { read getattr lock search ioctl };
#line 11
allow ypserv_t { self proc_t }:lnk_file { getattr read };
#line 11

#line 11
allow ypserv_t device_t:dir { read getattr lock search ioctl };
#line 11

#line 11
allow ypserv_t udev_tdb_t:file { read getattr lock ioctl };
#line 11
allow ypserv_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit ypserv_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 11
dontaudit ypserv_t unpriv_userdomain:fd use;
#line 11

#line 11

#line 11
allow ypserv_t sysfs_t:dir { read getattr lock search ioctl };
#line 11
allow ypserv_t sysfs_t:file { read getattr lock ioctl };
#line 11
allow ypserv_t sysfs_t:lnk_file { getattr read };
#line 11
 
#line 11

#line 11
allow ypserv_t autofs_t:dir { search getattr };
#line 11

#line 11
dontaudit ypserv_t { tty_device_t devpts_t }:chr_file { read write };
#line 11
dontaudit ypserv_t root_t:file { getattr read };
#line 11
 
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
# Read system variables in /sys.
#line 11

#line 11
allow ypserv_t sysctl_t:dir search;
#line 11
allow ypserv_t sysctl_kernel_t:dir search;
#line 11
allow ypserv_t sysctl_kernel_t:file { getattr read };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allows user to define a tunable to disable domain transition
#line 11
#
#line 11

#line 11
bool ypserv_disable_trans false;
#line 11
if (ypserv_disable_trans) {
#line 11

#line 11
allow initrc_t ypserv_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11

#line 11
allow sysadm_t ypserv_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 11

#line 11
} else {
#line 11
 
#line 11

#line 11

#line 11
#
#line 11
# Allow the process to transition to the new domain.
#line 11
#
#line 11
allow initrc_t ypserv_t:process transition;
#line 11

#line 11
#
#line 11
# Do not audit when glibc secure mode is enabled upon the transition.
#line 11
#
#line 11
dontaudit initrc_t ypserv_t:process noatsecure;
#line 11

#line 11
#
#line 11
# Do not audit when signal-related state is cleared upon the transition.
#line 11
#
#line 11
dontaudit initrc_t ypserv_t:process siginh;
#line 11

#line 11
#
#line 11
# Do not audit when resource limits are reset upon the transition.
#line 11
#
#line 11
dontaudit initrc_t ypserv_t:process rlimitinh;
#line 11

#line 11
#
#line 11
# Allow the process to execute the program.
#line 11
# 
#line 11
allow initrc_t ypserv_exec_t:file { read { getattr execute } };
#line 11

#line 11
#
#line 11
# Allow the process to reap the new domain.
#line 11
#
#line 11
allow ypserv_t initrc_t:process sigchld;
#line 11

#line 11
#
#line 11
# Allow the new domain to inherit and use file 
#line 11
# descriptions from the creating process and vice versa.
#line 11
#
#line 11
allow ypserv_t initrc_t:fd use;
#line 11
allow initrc_t ypserv_t:fd use;
#line 11

#line 11
#
#line 11
# Allow the new domain to write back to the old domain via a pipe.
#line 11
#
#line 11
allow ypserv_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 11

#line 11
#
#line 11
# Allow the new domain to read and execute the program.
#line 11
#
#line 11
allow ypserv_t ypserv_exec_t:file { read getattr lock execute ioctl };
#line 11

#line 11
#
#line 11
# Allow the new domain to be entered via the program.
#line 11
#
#line 11
allow ypserv_t ypserv_exec_t:file entrypoint;
#line 11

#line 11
type_transition initrc_t ypserv_exec_t:process ypserv_t;
#line 11

#line 11

#line 11
allow initrc_t ypserv_t:process { noatsecure siginh rlimitinh };
#line 11

#line 11
}
#line 11
 
#line 11
allow ypserv_t privfd:fd use;
#line 11

#line 11
allow ypserv_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11

#line 11
# Create pid file.
#line 11
allow ypserv_t var_t:dir { getattr search };
#line 11

#line 11
type ypserv_var_run_t, file_type, sysadmfile, pidfile;
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the process to modify the directory.
#line 11
#
#line 11
allow ypserv_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11
#
#line 11
# Allow the process to create the file.
#line 11
#
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
allow ypserv_t ypserv_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
type_transition ypserv_t var_run_t:file ypserv_var_run_t;
#line 11

#line 11

#line 11

#line 11
allow ypserv_t var_t:dir search;
#line 11
allow ypserv_t ypserv_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 11

#line 11

#line 11
allow ypserv_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 11

#line 11
# for daemons that look at /root on startup
#line 11
dontaudit ypserv_t sysadm_home_dir_t:dir search;
#line 11

#line 11
# for df
#line 11
allow ypserv_t fs_type:filesystem getattr;
#line 11
allow ypserv_t removable_t:filesystem getattr;
#line 11

#line 11

#line 11
allow ypserv_t etc_t:lnk_file read;
#line 11
allow ypserv_t lib_t:file { read getattr lock ioctl };
#line 11

#line 11
allow ypserv_t locale_t:dir { read getattr lock search ioctl };
#line 11
allow ypserv_t locale_t:file { read getattr lock ioctl };
#line 11
allow ypserv_t locale_t:lnk_file { getattr read };
#line 11

#line 11

#line 11

#line 11
# for localization
#line 11
allow ypserv_t lib_t:file { getattr read };
#line 11



#line 13
type ypserv_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 13

#line 13

#line 13

#line 13

#line 13
#
#line 13
# Allow the process to modify the directory.
#line 13
#
#line 13
allow ypserv_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 13

#line 13
#
#line 13
# Allow the process to create the file.
#line 13
#
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow ypserv_t ypserv_tmp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
allow ypserv_t ypserv_tmp_t:dir { create read getattr lock setattr ioctl link unlink rename search add_name remove_name reparent write rmdir };
#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13

#line 13
type_transition ypserv_t tmp_t:{ file dir } ypserv_tmp_t;
#line 13

#line 13

#line 13


# Use capabilities.
allow ypserv_t self:capability { net_bind_service };

# Use the network.

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use tcp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow ypserv_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow ypserv_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow ypserv_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow ypserv_t node_type:node { tcp_send rawip_send };
#line 19
allow ypserv_t node_type:node { tcp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow ypserv_t port_type:tcp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow ypserv_t node_type:tcp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow ypserv_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow ypserv_t self:tcp_socket { listen accept };
#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the domain to create and use udp sockets.
#line 19
# Other kinds of sockets must be separately authorized for use.
#line 19
allow ypserv_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 19

#line 19
allow ypserv_t unlabeled_t:association { sendto recvfrom };
#line 19

#line 19
#
#line 19
# Allow the domain to send or receive using any network interface.
#line 19
# netif_type is a type attribute for all network interface types.
#line 19
#
#line 19
allow ypserv_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 19
#
#line 19
# Allow the domain to send to or receive from any node.
#line 19
# node_type is a type attribute for all node types.
#line 19
#
#line 19
allow ypserv_t node_type:node { udp_send rawip_send };
#line 19
allow ypserv_t node_type:node { udp_recv rawip_recv };
#line 19

#line 19
#
#line 19
# Allow the domain to send to or receive from any port.
#line 19
# port_type is a type attribute for all port types.
#line 19
#
#line 19

#line 19
allow ypserv_t port_type:udp_socket { send_msg recv_msg };
#line 19

#line 19

#line 19
# XXX Allow binding to any node type.  Remove once
#line 19
# individual rules have been added to all domains that 
#line 19
# bind sockets. 
#line 19
allow ypserv_t node_type:udp_socket node_bind;
#line 19
#
#line 19
# Allow access to network files including /etc/resolv.conf
#line 19
#
#line 19
allow ypserv_t net_conf_t:file { read getattr lock ioctl };
#line 19

#line 19
allow ypserv_t self:udp_socket { connect };
#line 19

#line 19

#line 19


allow ypserv_t self:fifo_file { ioctl read getattr lock write append };


#line 23
# Read system variables in /sys.
#line 23

#line 23
allow ypserv_t sysctl_t:dir search;
#line 23
allow ypserv_t sysctl_kernel_t:dir search;
#line 23
allow ypserv_t sysctl_kernel_t:file { getattr read };
#line 23

#line 23

#line 23


# Send to portmap and initrc.

#line 26
#allow ypserv_t portmap_t:udp_socket sendto;
#line 26
#allow portmap_t ypserv_t:udp_socket recvfrom;
#line 26


#line 27
#allow ypserv_t initrc_t:udp_socket sendto;
#line 27
#allow initrc_t ypserv_t:udp_socket recvfrom;
#line 27


type ypserv_conf_t, file_type, sysadmfile;

# Read and write /var/yp.
allow ypserv_t var_yp_t:dir { read getattr lock search ioctl add_name remove_name write };
allow ypserv_t var_yp_t:file { create ioctl read getattr lock write setattr append link unlink rename };
allow ypserv_t ypserv_conf_t:file { getattr read };
allow ypserv_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow ypserv_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read };
#line 39

#line 39
allow rpcd_t ypserv_conf_t:file { getattr read };
#line 39

allow ypserv_t reserved_port_t:{ udp_socket tcp_socket } name_bind;
dontaudit ypserv_t reserved_port_type:{ tcp_socket udp_socket } name_bind;

#line 42
allow ypserv_t bin_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 42



#line 44
type ypxfr_t, domain, privlog , nscd_client_domain;
#line 44
type ypxfr_exec_t, file_type, sysadmfile, exec_type;
#line 44
role sysadm_r types ypxfr_t;
#line 44

#line 44
role system_r types ypxfr_t;
#line 44

#line 44

#line 44

#line 44

#line 44
#
#line 44
# Allow the process to transition to the new domain.
#line 44
#
#line 44
allow sysadm_t ypxfr_t:process transition;
#line 44

#line 44
#
#line 44
# Do not audit when glibc secure mode is enabled upon the transition.
#line 44
#
#line 44
dontaudit sysadm_t ypxfr_t:process noatsecure;
#line 44

#line 44
#
#line 44
# Do not audit when signal-related state is cleared upon the transition.
#line 44
#
#line 44
dontaudit sysadm_t ypxfr_t:process siginh;
#line 44

#line 44
#
#line 44
# Do not audit when resource limits are reset upon the transition.
#line 44
#
#line 44
dontaudit sysadm_t ypxfr_t:process rlimitinh;
#line 44

#line 44
#
#line 44
# Allow the process to execute the program.
#line 44
# 
#line 44
allow sysadm_t ypxfr_exec_t:file { read { getattr execute } };
#line 44

#line 44
#
#line 44
# Allow the process to reap the new domain.
#line 44
#
#line 44
allow ypxfr_t sysadm_t:process sigchld;
#line 44

#line 44
#
#line 44
# Allow the new domain to inherit and use file 
#line 44
# descriptions from the creating process and vice versa.
#line 44
#
#line 44
allow ypxfr_t sysadm_t:fd use;
#line 44
allow sysadm_t ypxfr_t:fd use;
#line 44

#line 44
#
#line 44
# Allow the new domain to write back to the old domain via a pipe.
#line 44
#
#line 44
allow ypxfr_t sysadm_t:fifo_file { ioctl read getattr lock write append };
#line 44

#line 44
#
#line 44
# Allow the new domain to read and execute the program.
#line 44
#
#line 44
allow ypxfr_t ypxfr_exec_t:file { read getattr lock execute ioctl };
#line 44

#line 44
#
#line 44
# Allow the new domain to be entered via the program.
#line 44
#
#line 44
allow ypxfr_t ypxfr_exec_t:file entrypoint;
#line 44

#line 44
type_transition sysadm_t ypxfr_exec_t:process ypxfr_t;
#line 44

#line 44

#line 44
allow ypxfr_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 44
allow ypxfr_t lib_t:lnk_file { read getattr lock ioctl };
#line 44
allow ypxfr_t ld_so_t:file { read getattr lock execute ioctl };
#line 44
#allow ypxfr_t ld_so_t:file execute_no_trans;
#line 44
allow ypxfr_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 44
allow ypxfr_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 44
allow ypxfr_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 44
allow ypxfr_t texrel_shlib_t:file execmod;
#line 44
allow ypxfr_t ld_so_cache_t:file { read getattr lock ioctl };
#line 44
allow ypxfr_t device_t:dir search;
#line 44
allow ypxfr_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 44

#line 44


#line 45

#line 45

#line 45

#line 45
#
#line 45
# Allow the domain to create and use tcp sockets.
#line 45
# Other kinds of sockets must be separately authorized for use.
#line 45
allow ypxfr_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 45

#line 45
allow ypxfr_t unlabeled_t:association { sendto recvfrom };
#line 45

#line 45
#
#line 45
# Allow the domain to send or receive using any network interface.
#line 45
# netif_type is a type attribute for all network interface types.
#line 45
#
#line 45
allow ypxfr_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 45
#
#line 45
# Allow the domain to send to or receive from any node.
#line 45
# node_type is a type attribute for all node types.
#line 45
#
#line 45
allow ypxfr_t node_type:node { tcp_send rawip_send };
#line 45
allow ypxfr_t node_type:node { tcp_recv rawip_recv };
#line 45

#line 45
#
#line 45
# Allow the domain to send to or receive from any port.
#line 45
# port_type is a type attribute for all port types.
#line 45
#
#line 45

#line 45
allow ypxfr_t port_type:tcp_socket { send_msg recv_msg };
#line 45

#line 45

#line 45
# XXX Allow binding to any node type.  Remove once
#line 45
# individual rules have been added to all domains that 
#line 45
# bind sockets. 
#line 45
allow ypxfr_t node_type:tcp_socket node_bind;
#line 45
#
#line 45
# Allow access to network files including /etc/resolv.conf
#line 45
#
#line 45
allow ypxfr_t net_conf_t:file { read getattr lock ioctl };
#line 45

#line 45
allow ypxfr_t self:tcp_socket { connect };
#line 45

#line 45

#line 45

#line 45
#
#line 45
# Allow the domain to create and use udp sockets.
#line 45
# Other kinds of sockets must be separately authorized for use.
#line 45
allow ypxfr_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 45

#line 45
allow ypxfr_t unlabeled_t:association { sendto recvfrom };
#line 45

#line 45
#
#line 45
# Allow the domain to send or receive using any network interface.
#line 45
# netif_type is a type attribute for all network interface types.
#line 45
#
#line 45
allow ypxfr_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 45
#
#line 45
# Allow the domain to send to or receive from any node.
#line 45
# node_type is a type attribute for all node types.
#line 45
#
#line 45
allow ypxfr_t node_type:node { udp_send rawip_send };
#line 45
allow ypxfr_t node_type:node { udp_recv rawip_recv };
#line 45

#line 45
#
#line 45
# Allow the domain to send to or receive from any port.
#line 45
# port_type is a type attribute for all port types.
#line 45
#
#line 45

#line 45
allow ypxfr_t port_type:udp_socket { send_msg recv_msg };
#line 45

#line 45

#line 45
# XXX Allow binding to any node type.  Remove once
#line 45
# individual rules have been added to all domains that 
#line 45
# bind sockets. 
#line 45
allow ypxfr_t node_type:udp_socket node_bind;
#line 45
#
#line 45
# Allow access to network files including /etc/resolv.conf
#line 45
#
#line 45
allow ypxfr_t net_conf_t:file { read getattr lock ioctl };
#line 45

#line 45
allow ypxfr_t self:udp_socket { connect };
#line 45

#line 45

#line 45

allow ypxfr_t etc_t:file { getattr read };
allow ypxfr_t portmap_port_t:tcp_socket name_connect;
allow ypxfr_t reserved_port_t:tcp_socket name_connect;
dontaudit ypxfr_t reserved_port_type:tcp_socket name_connect;
allow ypxfr_t self:unix_stream_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept };
#line 1 "domains/program/zebra.te"
#DESC Zebra - BGP server
#
# Author:  Russell Coker <russell@coker.com.au>
# X-Debian-Packages: zebra
#


#line 7

#line 7

#line 7

#line 7
type zebra_t, domain, privlog, daemon , sysctl_net_writer, transitionbool;
#line 7
type zebra_exec_t, file_type, sysadmfile, exec_type;
#line 7
dontaudit zebra_t self:capability sys_tty_config;
#line 7

#line 7
role system_r types zebra_t;
#line 7

#line 7
# Inherit and use descriptors from init.
#line 7
allow zebra_t init_t:fd use;
#line 7
allow zebra_t init_t:process sigchld;
#line 7
allow zebra_t self:process { { sigchld sigkill sigstop signull signal } fork };
#line 7

#line 7

#line 7
allow zebra_t { root_t usr_t lib_t etc_t }:dir { read getattr lock search ioctl };
#line 7
allow zebra_t lib_t:lnk_file { read getattr lock ioctl };
#line 7
allow zebra_t ld_so_t:file { read getattr lock execute ioctl };
#line 7
#allow zebra_t ld_so_t:file execute_no_trans;
#line 7
allow zebra_t ld_so_t:lnk_file { read getattr lock ioctl };
#line 7
allow zebra_t { texrel_shlib_t shlib_t }:file { read getattr lock execute ioctl };
#line 7
allow zebra_t { texrel_shlib_t shlib_t }:lnk_file { read getattr lock ioctl };
#line 7
allow zebra_t texrel_shlib_t:file execmod;
#line 7
allow zebra_t ld_so_cache_t:file { read getattr lock ioctl };
#line 7
allow zebra_t device_t:dir search;
#line 7
allow zebra_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 7

#line 7

#line 7
allow zebra_t { self proc_t }:dir { read getattr lock search ioctl };
#line 7
allow zebra_t { self proc_t }:lnk_file { getattr read };
#line 7

#line 7
allow zebra_t device_t:dir { read getattr lock search ioctl };
#line 7

#line 7
allow zebra_t udev_tdb_t:file { read getattr lock ioctl };
#line 7
allow zebra_t null_device_t:chr_file { ioctl read getattr lock write append };
#line 7
dontaudit zebra_t console_device_t:chr_file { ioctl read getattr lock write append };
#line 7
dontaudit zebra_t unpriv_userdomain:fd use;
#line 7

#line 7

#line 7
allow zebra_t sysfs_t:dir { read getattr lock search ioctl };
#line 7
allow zebra_t sysfs_t:file { read getattr lock ioctl };
#line 7
allow zebra_t sysfs_t:lnk_file { getattr read };
#line 7
 
#line 7

#line 7
allow zebra_t autofs_t:dir { search getattr };
#line 7

#line 7
dontaudit zebra_t { tty_device_t devpts_t }:chr_file { read write };
#line 7
dontaudit zebra_t root_t:file { getattr read };
#line 7
 
#line 7

#line 7

#line 7

#line 7

#line 7

#line 7

#line 7
# Read system variables in /sys.
#line 7

#line 7
allow zebra_t sysctl_t:dir search;
#line 7
allow zebra_t sysctl_kernel_t:dir search;
#line 7
allow zebra_t sysctl_kernel_t:file { getattr read };
#line 7

#line 7

#line 7

#line 7

#line 7

#line 7

#line 7
#
#line 7
# Allows user to define a tunable to disable domain transition
#line 7
#
#line 7

#line 7
bool zebra_disable_trans false;
#line 7
if (zebra_disable_trans) {
#line 7

#line 7
allow initrc_t zebra_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 7

#line 7

#line 7
allow sysadm_t zebra_exec_t:file { { read getattr lock execute ioctl } execute_no_trans };
#line 7

#line 7
} else {
#line 7
 
#line 7

#line 7

#line 7
#
#line 7
# Allow the process to transition to the new domain.
#line 7
#
#line 7
allow initrc_t zebra_t:process transition;
#line 7

#line 7
#
#line 7
# Do not audit when glibc secure mode is enabled upon the transition.
#line 7
#
#line 7
dontaudit initrc_t zebra_t:process noatsecure;
#line 7

#line 7
#
#line 7
# Do not audit when signal-related state is cleared upon the transition.
#line 7
#
#line 7
dontaudit initrc_t zebra_t:process siginh;
#line 7

#line 7
#
#line 7
# Do not audit when resource limits are reset upon the transition.
#line 7
#
#line 7
dontaudit initrc_t zebra_t:process rlimitinh;
#line 7

#line 7
#
#line 7
# Allow the process to execute the program.
#line 7
# 
#line 7
allow initrc_t zebra_exec_t:file { read { getattr execute } };
#line 7

#line 7
#
#line 7
# Allow the process to reap the new domain.
#line 7
#
#line 7
allow zebra_t initrc_t:process sigchld;
#line 7

#line 7
#
#line 7
# Allow the new domain to inherit and use file 
#line 7
# descriptions from the creating process and vice versa.
#line 7
#
#line 7
allow zebra_t initrc_t:fd use;
#line 7
allow initrc_t zebra_t:fd use;
#line 7

#line 7
#
#line 7
# Allow the new domain to write back to the old domain via a pipe.
#line 7
#
#line 7
allow zebra_t initrc_t:fifo_file { ioctl read getattr lock write append };
#line 7

#line 7
#
#line 7
# Allow the new domain to read and execute the program.
#line 7
#
#line 7
allow zebra_t zebra_exec_t:file { read getattr lock execute ioctl };
#line 7

#line 7
#
#line 7
# Allow the new domain to be entered via the program.
#line 7
#
#line 7
allow zebra_t zebra_exec_t:file entrypoint;
#line 7

#line 7
type_transition initrc_t zebra_exec_t:process zebra_t;
#line 7

#line 7

#line 7
allow initrc_t zebra_t:process { noatsecure siginh rlimitinh };
#line 7

#line 7
}
#line 7
 
#line 7
allow zebra_t privfd:fd use;
#line 7

#line 7
allow zebra_t initrc_devpts_t:chr_file { ioctl read getattr lock write append };
#line 7

#line 7

#line 7
# Create pid file.
#line 7
allow zebra_t var_t:dir { getattr search };
#line 7

#line 7
type zebra_var_run_t, file_type, sysadmfile, pidfile;
#line 7

#line 7

#line 7

#line 7

#line 7

#line 7

#line 7
#
#line 7
# Allow the process to modify the directory.
#line 7
#
#line 7
allow zebra_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 7

#line 7
#
#line 7
# Allow the process to create the file.
#line 7
#
#line 7

#line 7

#line 7

#line 7

#line 7

#line 7
allow zebra_t zebra_var_run_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 7

#line 7

#line 7

#line 7

#line 7

#line 7

#line 7

#line 7

#line 7

#line 7
type_transition zebra_t var_run_t:file zebra_var_run_t;
#line 7

#line 7

#line 7

#line 7
allow zebra_t var_t:dir search;
#line 7
allow zebra_t zebra_var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 7

#line 7

#line 7
allow zebra_t devtty_t:chr_file { ioctl read getattr lock write append };
#line 7

#line 7
# for daemons that look at /root on startup
#line 7
dontaudit zebra_t sysadm_home_dir_t:dir search;
#line 7

#line 7
# for df
#line 7
allow zebra_t fs_type:filesystem getattr;
#line 7
allow zebra_t removable_t:filesystem getattr;
#line 7

#line 7

#line 7
allow zebra_t etc_t:lnk_file read;
#line 7
allow zebra_t lib_t:file { read getattr lock ioctl };
#line 7

#line 7
allow zebra_t locale_t:dir { read getattr lock search ioctl };
#line 7
allow zebra_t locale_t:file { read getattr lock ioctl };
#line 7
allow zebra_t locale_t:lnk_file { getattr read };
#line 7

#line 7

#line 7

#line 7
# for localization
#line 7
allow zebra_t lib_t:file { getattr read };
#line 7

type zebra_conf_t, file_type, sysadmfile;

#line 9
allow { initrc_t zebra_t } zebra_conf_t:dir { read getattr lock search ioctl };
#line 9
allow { initrc_t zebra_t } zebra_conf_t:file { read getattr lock ioctl };
#line 9
allow { initrc_t zebra_t } zebra_conf_t:lnk_file { getattr read };
#line 9



#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the domain to create and use tcp sockets.
#line 11
# Other kinds of sockets must be separately authorized for use.
#line 11
allow zebra_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 11

#line 11
allow zebra_t unlabeled_t:association { sendto recvfrom };
#line 11

#line 11
#
#line 11
# Allow the domain to send or receive using any network interface.
#line 11
# netif_type is a type attribute for all network interface types.
#line 11
#
#line 11
allow zebra_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 11
#
#line 11
# Allow the domain to send to or receive from any node.
#line 11
# node_type is a type attribute for all node types.
#line 11
#
#line 11
allow zebra_t node_type:node { tcp_send rawip_send };
#line 11
allow zebra_t node_type:node { tcp_recv rawip_recv };
#line 11

#line 11
#
#line 11
# Allow the domain to send to or receive from any port.
#line 11
# port_type is a type attribute for all port types.
#line 11
#
#line 11

#line 11
allow zebra_t port_type:tcp_socket { send_msg recv_msg };
#line 11

#line 11

#line 11
# XXX Allow binding to any node type.  Remove once
#line 11
# individual rules have been added to all domains that 
#line 11
# bind sockets. 
#line 11
allow zebra_t node_type:tcp_socket node_bind;
#line 11
#
#line 11
# Allow access to network files including /etc/resolv.conf
#line 11
#
#line 11
allow zebra_t net_conf_t:file { read getattr lock ioctl };
#line 11

#line 11
allow zebra_t self:tcp_socket { listen accept };
#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the domain to create and use tcp sockets.
#line 11
# Other kinds of sockets must be separately authorized for use.
#line 11
allow zebra_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 11

#line 11
allow zebra_t unlabeled_t:association { sendto recvfrom };
#line 11

#line 11
#
#line 11
# Allow the domain to send or receive using any network interface.
#line 11
# netif_type is a type attribute for all network interface types.
#line 11
#
#line 11
allow zebra_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 11
#
#line 11
# Allow the domain to send to or receive from any node.
#line 11
# node_type is a type attribute for all node types.
#line 11
#
#line 11
allow zebra_t node_type:node { tcp_send rawip_send };
#line 11
allow zebra_t node_type:node { tcp_recv rawip_recv };
#line 11

#line 11
#
#line 11
# Allow the domain to send to or receive from any port.
#line 11
# port_type is a type attribute for all port types.
#line 11
#
#line 11

#line 11
allow zebra_t port_type:tcp_socket { send_msg recv_msg };
#line 11

#line 11

#line 11
# XXX Allow binding to any node type.  Remove once
#line 11
# individual rules have been added to all domains that 
#line 11
# bind sockets. 
#line 11
allow zebra_t node_type:tcp_socket node_bind;
#line 11
#
#line 11
# Allow access to network files including /etc/resolv.conf
#line 11
#
#line 11
allow zebra_t net_conf_t:file { read getattr lock ioctl };
#line 11

#line 11
allow zebra_t self:tcp_socket { connect };
#line 11

#line 11

#line 11

#line 11

#line 11

#line 11
#
#line 11
# Allow the domain to create and use udp sockets.
#line 11
# Other kinds of sockets must be separately authorized for use.
#line 11
allow zebra_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 11

#line 11
allow zebra_t unlabeled_t:association { sendto recvfrom };
#line 11

#line 11
#
#line 11
# Allow the domain to send or receive using any network interface.
#line 11
# netif_type is a type attribute for all network interface types.
#line 11
#
#line 11
allow zebra_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 11
#
#line 11
# Allow the domain to send to or receive from any node.
#line 11
# node_type is a type attribute for all node types.
#line 11
#
#line 11
allow zebra_t node_type:node { udp_send rawip_send };
#line 11
allow zebra_t node_type:node { udp_recv rawip_recv };
#line 11

#line 11
#
#line 11
# Allow the domain to send to or receive from any port.
#line 11
# port_type is a type attribute for all port types.
#line 11
#
#line 11

#line 11
allow zebra_t port_type:udp_socket { send_msg recv_msg };
#line 11

#line 11

#line 11
# XXX Allow binding to any node type.  Remove once
#line 11
# individual rules have been added to all domains that 
#line 11
# bind sockets. 
#line 11
allow zebra_t node_type:udp_socket node_bind;
#line 11
#
#line 11
# Allow access to network files including /etc/resolv.conf
#line 11
#
#line 11
allow zebra_t net_conf_t:file { read getattr lock ioctl };
#line 11

#line 11
allow zebra_t self:udp_socket { connect };
#line 11

#line 11

#line 11

#line 11

#line 11


#line 12

#line 12
if (allow_ypbind) {
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow zebra_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow zebra_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow zebra_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow zebra_t node_type:node { tcp_send rawip_send };
#line 12
allow zebra_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow zebra_t port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow zebra_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow zebra_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow zebra_t self:tcp_socket { listen accept };
#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use tcp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow zebra_t self:tcp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow zebra_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow zebra_t netif_t:netif { tcp_recv tcp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow zebra_t node_type:node { tcp_send rawip_send };
#line 12
allow zebra_t node_type:node { tcp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow zebra_t port_type:tcp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow zebra_t node_type:tcp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow zebra_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow zebra_t self:tcp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
#
#line 12
# Allow the domain to create and use udp sockets.
#line 12
# Other kinds of sockets must be separately authorized for use.
#line 12
allow zebra_t self:udp_socket { create ioctl read getattr write setattr append bind getopt setopt shutdown };
#line 12

#line 12
allow zebra_t unlabeled_t:association { sendto recvfrom };
#line 12

#line 12
#
#line 12
# Allow the domain to send or receive using any network interface.
#line 12
# netif_type is a type attribute for all network interface types.
#line 12
#
#line 12
allow zebra_t netif_t:netif { udp_recv udp_send rawip_send rawip_recv };
#line 12
#
#line 12
# Allow the domain to send to or receive from any node.
#line 12
# node_type is a type attribute for all node types.
#line 12
#
#line 12
allow zebra_t node_type:node { udp_send rawip_send };
#line 12
allow zebra_t node_type:node { udp_recv rawip_recv };
#line 12

#line 12
#
#line 12
# Allow the domain to send to or receive from any port.
#line 12
# port_type is a type attribute for all port types.
#line 12
#
#line 12

#line 12
allow zebra_t port_type:udp_socket { send_msg recv_msg };
#line 12

#line 12

#line 12
# XXX Allow binding to any node type.  Remove once
#line 12
# individual rules have been added to all domains that 
#line 12
# bind sockets. 
#line 12
allow zebra_t node_type:udp_socket node_bind;
#line 12
#
#line 12
# Allow access to network files including /etc/resolv.conf
#line 12
#
#line 12
allow zebra_t net_conf_t:file { read getattr lock ioctl };
#line 12

#line 12
allow zebra_t self:udp_socket { connect };
#line 12

#line 12

#line 12

#line 12

#line 12

#line 12

#line 12
allow zebra_t var_yp_t:dir { read getattr lock search ioctl };
#line 12
allow zebra_t var_yp_t:file { read getattr lock ioctl };
#line 12
allow zebra_t var_yp_t:lnk_file { getattr read };
#line 12

#line 12
allow zebra_t { reserved_port_t port_t }:{ tcp_socket udp_socket } name_bind;
#line 12
allow zebra_t { portmap_port_t reserved_port_t port_t }:tcp_socket name_connect;
#line 12
dontaudit zebra_t self:capability net_bind_service;
#line 12
dontaudit zebra_t reserved_port_type:tcp_socket name_connect;
#line 12
dontaudit zebra_t reserved_port_type:{ tcp_socket udp_socket } name_bind;
#line 12

#line 12
} else {
#line 12
dontaudit zebra_t var_yp_t:dir search;
#line 12
}
#line 12
 
allow zebra_t { etc_t etc_runtime_t }:file { getattr read };

allow zebra_t self:process setcap;
allow zebra_t self:capability { setgid setuid net_bind_service net_admin net_raw };

#line 17

#line 17

#line 17

#line 17
#
#line 17
# Allow the process to modify the directory.
#line 17
#
#line 17
allow zebra_t var_run_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 17

#line 17
#
#line 17
# Allow the process to create the file.
#line 17
#
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
allow zebra_t zebra_var_run_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17

#line 17
type_transition zebra_t var_run_t:sock_file zebra_var_run_t;
#line 17

#line 17



#line 19

#line 19
type zebra_log_t, file_type, sysadmfile, logfile;
#line 19

#line 19

#line 19

#line 19

#line 19
#
#line 19
# Allow the process to modify the directory.
#line 19
#
#line 19
allow zebra_t var_log_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 19

#line 19
#
#line 19
# Allow the process to create the file.
#line 19
#
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
allow zebra_t zebra_log_t:file { create ioctl read getattr lock write setattr append link unlink rename };
#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19

#line 19
type_transition zebra_t var_log_t:file zebra_log_t;
#line 19

#line 19

#line 19

#line 19
allow zebra_t zebra_log_t:dir { setattr { read getattr lock search ioctl add_name remove_name write } };
#line 19


# /tmp/.bgpd is such a bad idea!

#line 22
type zebra_tmp_t, file_type, sysadmfile, polymember, tmpfile ;
#line 22

#line 22

#line 22

#line 22

#line 22
#
#line 22
# Allow the process to modify the directory.
#line 22
#
#line 22
allow zebra_t tmp_t:dir { read getattr lock search ioctl add_name remove_name write };
#line 22

#line 22
#
#line 22
# Allow the process to create the file.
#line 22
#
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
allow zebra_t zebra_tmp_t:sock_file { create ioctl read getattr lock write setattr append link unlink rename };
#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22

#line 22
type_transition zebra_t tmp_t:sock_file zebra_tmp_t;
#line 22

#line 22

#line 22


allow zebra_t self:unix_dgram_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow zebra_t self:unix_stream_socket { connectto { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } listen accept } };
allow zebra_t self:rawip_socket { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } };
allow zebra_t self:netlink_route_socket { { create { ioctl read getattr write setattr append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write };
allow zebra_t zebra_port_t:tcp_socket name_bind;
allow zebra_t bgp_port_t:tcp_socket name_connect;

allow zebra_t proc_t:file { getattr read };
allow zebra_t { sysctl_t sysctl_net_t }:dir search;
allow zebra_t sysctl_net_t:file { ioctl read getattr lock write append };
#line 1 "assert.te"
##############################
#
# Assertions for the type enforcement (TE) configuration.
#

#
# Authors:  Stephen Smalley <sds@epoch.ncsc.mil> and Timothy Fraser  
#

##################################
#
# Access vector assertions.
#
# An access vector assertion specifies permissions that should not be in
# an access vector based on a source type, a target type, and a class.
# If any of the specified permissions are in the corresponding access
# vector, then the policy compiler will reject the policy configuration.
# Currently, there is only one kind of access vector assertion, neverallow, 
# but support for the other kinds of vectors could be easily added.  Access 
# vector assertions use the same syntax as access vector rules.
#

# Confined domains must never touch an unconfined domain except to
# send SIGCHLD for child termination notifications.
neverallow { domain -unrestricted -unconfinedtrans -snmpd_t } unconfined_t:process ~sigchld;

# Confined domains must never see /proc/pid entries for an unconfined domain.
neverallow { domain -unrestricted -snmpd_t } unconfined_t:dir { getattr search };

#
# Verify that every type that can be entered by
# a domain is also tagged as a domain.
#
neverallow domain ~domain:process { transition dyntransition};

# for gross mistakes in policy
neverallow domain domain:dir ~{ read getattr lock search ioctl };
neverallow domain domain:{ file lnk_file sock_file fifo_file chr_file blk_file } ~{ ioctl read getattr lock write append };
neverallow domain file_type:process *;
neverallow ~{ domain unlabeled_t } *:process *;
#line 1 "rbac"
################################################
#
# Role-based access control (RBAC) configuration.
#

########################################
#
# Role allow rules.
#
# A role allow rule specifies the allowable
# transitions between roles on an execve.
# If no rule is specified, then the change in
# roles will not be permitted.  Additional
# controls over role transitions based on the
# type of the process may be specified through
# the constraints file.
#
# The syntax of a role allow rule is:
# 	allow current_role new_role ;
# 

allow sysadm_r system_r;
allow user_r system_r;
allow user_r sysadm_r;
allow sysadm_r user_r;
allow system_r sysadm_r;
#line 1 "users"
##################################
#
# User configuration.
#
# This file defines each user recognized by the system security policy.
# Only the user identities defined in this file may be used as the
# user attribute in a security context.
#
# Each user has a set of roles that may be entered by processes
# with the users identity.  The syntax of a user declaration is:
#
# 	user username roles role_set [ ranges MLS_range_set ] level s0 range s0 - s15:c0.c255;
#
# The MLS range set should only be specified if MLS was enabled
# for the module and checkpolicy.

#
# system_u is the user identity for system processes and objects.
# There should be no corresponding Unix user identity for system_u,
# and a user process should never be assigned the system_u user
# identity.
#
#user system_u roles system_r level s0 range s0 - s15:c0.c255;
user system_u roles system_r level s0 range s0 - s15:c0.c255;

#
# user_u is a generic user identity for Linux users who have no
# SELinux user identity defined.  Authorized for all roles in the
# relaxed policy.  sysadm_r is retained for compatibility, but could
# be dropped as long as userspace has no hardcoded dependency on it.
# user_u must be retained due to present userspace hardcoded dependency.
#
user user_u roles { user_r sysadm_r system_r } level s0 range s0 - s15:c0.c255;

# root is retained as a separate user identity simply as a compatibility
# measure with the "strict" policy.  It could be dropped and mapped to user_u
# but this allows existing file contexts that have "root" as the user identity
# to remain valid.
user root roles { user_r sysadm_r system_r } level s0 range s0 - s15:c0.c255;
#line 1 "constraints"
#
# Define m4 macros for the constraints
#

#
# Define the constraints
#
# constrain class_set perm_set expression ;
#
# expression : ( expression ) 
#	     | not expression
#	     | expression and expression
#	     | expression or expression
#	     | u1 op u2
#	     | r1 role_op r2
#	     | t1 op t2
#	     | u1 op names
#	     | u2 op names
#	     | r1 op names
#	     | r2 op names
#	     | t1 op names
#	     | t2 op names
#
# op : == | != 
# role_op : == | != | eq | dom | domby | incomp
#
# names : name | { name_list }
# name_list : name | name_list name#		
#

#
# Restrict the ability to transition to other users
# or roles to a few privileged types.
#

constrain process transition
	( u1 == u2 or t1 == privuser );

constrain process transition 
	( r1 == r2 or t1 == privrole );

constrain process dyntransition
	( u1 == u2 and r1 == r2);

#
# Restrict the ability to label objects with other
# user identities to a few privileged types.
#

constrain { dir file lnk_file sock_file fifo_file chr_file blk_file } { create relabelto relabelfrom } 
	( u1 == u2 or t1 == privowner );

constrain { tcp_socket udp_socket rawip_socket netlink_socket packet_socket unix_stream_socket unix_dgram_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket } { create relabelto relabelfrom } 
	( u1 == u2 or t1 == privowner );
#line 1 "initial_sid_contexts"
# FLASK

#
# Define the security context for each initial SID
# sid sidname   context

sid kernel	system_u:system_r:kernel_t:s0 - s15:c0.c255
sid security	system_u:object_r:security_t:s0
sid unlabeled	system_u:object_r:unlabeled_t:s0
sid fs		system_u:object_r:fs_t:s0
sid file	system_u:object_r:file_t:s0
# Persistent label mapping is gone.  This initial SID can be removed.
sid file_labels	system_u:object_r:unlabeled_t:s0
# init_t:s0 is still used, but an initial SID is no longer required.
sid init	system_u:object_r:unlabeled_t:s0
# any_socket is no longer used.
sid any_socket 	system_u:object_r:unlabeled_t:s0
sid port	system_u:object_r:port_t:s0
sid netif	system_u:object_r:netif_t:s0
# netmsg is no longer used.
sid netmsg	system_u:object_r:unlabeled_t:s0
sid node	system_u:object_r:node_t:s0
# These sockets are now labeled with the kernel SID,
# and do not require their own initial SIDs.
sid igmp_packet system_u:object_r:unlabeled_t:s0
sid icmp_socket system_u:object_r:unlabeled_t:s0
sid tcp_socket  system_u:object_r:unlabeled_t:s0
# Most of the sysctl SIDs are now computed at runtime
# from genfs_contexts, so the corresponding initial SIDs
# are no longer required.
sid sysctl_modprobe	system_u:object_r:unlabeled_t:s0
# But we still need the base sysctl initial SID as a default.
sid sysctl	system_u:object_r:sysctl_t:s0
sid sysctl_fs	system_u:object_r:unlabeled_t:s0
sid sysctl_kernel	system_u:object_r:unlabeled_t:s0
sid sysctl_net	system_u:object_r:unlabeled_t:s0
sid sysctl_net_unix	system_u:object_r:unlabeled_t:s0
sid sysctl_vm	system_u:object_r:unlabeled_t:s0
sid sysctl_dev	system_u:object_r:unlabeled_t:s0
# No longer used, can be removed.
sid kmod	system_u:object_r:unlabeled_t:s0
sid policy	system_u:object_r:unlabeled_t:s0
sid scmp_packet	system_u:object_r:unlabeled_t:s0
sid devnull	system_u:object_r:null_device_t:s0

# FLASK
#line 1 "fs_use"
#
# Define the labeling behavior for inodes in particular filesystem types.
# This information was formerly hardcoded in the SELinux module.

# Use xattrs for the following filesystem types.
# Requires that a security xattr handler exist for the filesystem.
fs_use_xattr ext2 system_u:object_r:fs_t:s0;
fs_use_xattr ext3 system_u:object_r:fs_t:s0;
fs_use_xattr xfs system_u:object_r:fs_t:s0;
fs_use_xattr jfs system_u:object_r:fs_t:s0;
fs_use_xattr reiserfs system_u:object_r:fs_t:s0;

# Use the allocating task SID to label inodes in the following filesystem
# types, and label the filesystem itself with the specified context.
# This is appropriate for pseudo filesystems that represent objects
# like pipes and sockets, so that these objects are labeled with the same
# type as the creating task.  
fs_use_task pipefs system_u:object_r:fs_t:s0;
fs_use_task sockfs system_u:object_r:fs_t:s0;

# Use a transition SID based on the allocating task SID and the
# filesystem SID to label inodes in the following filesystem types,
# and label the filesystem itself with the specified context.
# This is appropriate for pseudo filesystems like devpts and tmpfs
# where we want to label objects with a derived type.
fs_use_trans devpts system_u:object_r:devpts_t:s0;
fs_use_trans tmpfs system_u:object_r:tmpfs_t:s0;
fs_use_trans shm system_u:object_r:tmpfs_t:s0;
fs_use_trans mqueue system_u:object_r:tmpfs_t:s0;

# The separate genfs_contexts configuration can be used for filesystem 
# types that cannot support persistent label mappings or use
# one of the fixed label schemes specified here.  
#line 1 "genfs_contexts"
# FLASK

#
# Security contexts for files in filesystems that
# cannot support xattr or use one of the fixed labeling schemes 
# specified in fs_use.
#
# Each specifications has the form:
# 	genfscon fstype pathname-prefix [ -type ] context
#
# The entry with the longest matching pathname prefix is used.
# / refers to the root directory of the file system, and
# everything is specified relative to this root directory.
# If there is no entry with a matching pathname prefix, then 
# the unlabeled initial SID is used.
#
# The optional type field specifies the file type as shown in the mode
# field by ls, e.g. use -c to match only character device files, -b
# to match only block device files.
#
# Except for proc, in 2.6 other filesystems are limited to a single entry (/)
# that covers all entries in the filesystem with a default file context.
# For proc, a pathname can be reliably generated from the proc_dir_entry
# tree.  The proc /sys entries are used for both proc inodes and for sysctl(2)
# calls. /proc/PID entries are automatically labeled based on the associated
# process.
#
# Support for other filesystem types requires corresponding code to be
# added to the kernel, either as an xattr handler in the filesystem 
# implementation (preferred, and necessary if you want to access the labels
# from userspace) or as logic in the SELinux module.

# proc (excluding /proc/PID)
genfscon proc /				system_u:object_r:proc_t:s0
genfscon proc /kmsg			system_u:object_r:proc_kmsg_t:s0
genfscon proc /kcore			system_u:object_r:proc_kcore_t:s0
genfscon proc /mdstat			system_u:object_r:proc_mdstat_t:s0
genfscon proc /mtrr			system_u:object_r:mtrr_device_t:s0
genfscon proc /net			system_u:object_r:proc_net_t:s0
genfscon proc /sysvipc			system_u:object_r:proc_t:s0
genfscon proc /sys			system_u:object_r:sysctl_t:s0
genfscon proc /sys/kernel		system_u:object_r:sysctl_kernel_t:s0
genfscon proc /sys/kernel/modprobe	system_u:object_r:sysctl_modprobe_t:s0
genfscon proc /sys/kernel/hotplug	system_u:object_r:sysctl_hotplug_t:s0
genfscon proc /sys/net			system_u:object_r:sysctl_net_t:s0
genfscon proc /sys/net/unix		system_u:object_r:sysctl_net_unix_t:s0
genfscon proc /sys/vm			system_u:object_r:sysctl_vm_t:s0
genfscon proc /sys/dev			system_u:object_r:sysctl_dev_t:s0
genfscon proc /net/rpc			system_u:object_r:sysctl_rpc_t:s0
genfscon proc /irq			system_u:object_r:sysctl_irq_t:s0

# rootfs
genfscon rootfs /			system_u:object_r:root_t:s0

# sysfs
genfscon sysfs /			system_u:object_r:sysfs_t:s0

# selinuxfs
genfscon selinuxfs /			system_u:object_r:security_t:s0

# autofs
genfscon autofs /			system_u:object_r:autofs_t:s0
genfscon automount /			system_u:object_r:autofs_t:s0

# usbdevfs
genfscon usbdevfs /			system_u:object_r:usbdevfs_t:s0

# iso9660
genfscon iso9660 /			system_u:object_r:iso9660_t:s0
genfscon udf /				system_u:object_r:iso9660_t:s0

# romfs
genfscon romfs /			system_u:object_r:romfs_t:s0
genfscon cramfs /			system_u:object_r:romfs_t:s0

# ramfs
genfscon ramfs /			system_u:object_r:ramfs_t:s0

# vfat, msdos
genfscon vfat /				system_u:object_r:dosfs_t:s0
genfscon msdos /			system_u:object_r:dosfs_t:s0
genfscon fat /				system_u:object_r:dosfs_t:s0
genfscon ntfs /				system_u:object_r:dosfs_t:s0

# samba
genfscon cifs /				system_u:object_r:cifs_t:s0
genfscon smbfs /			system_u:object_r:cifs_t:s0

# nfs
genfscon nfs /				system_u:object_r:nfs_t:s0
genfscon nfs4 /				system_u:object_r:nfs_t:s0
genfscon afs /				system_u:object_r:nfs_t:s0

genfscon debugfs /			system_u:object_r:debugfs_t:s0
genfscon inotifyfs /			system_u:object_r:inotifyfs_t:s0
genfscon hugetlbfs /			system_u:object_r:hugetlbfs_t:s0
genfscon capifs /			system_u:object_r:capifs_t:s0
genfscon configfs /			system_u:object_r:configfs_t:s0

# needs more work
genfscon eventpollfs / system_u:object_r:eventpollfs_t:s0
genfscon futexfs / system_u:object_r:futexfs_t:s0
genfscon bdev / system_u:object_r:bdev_t:s0
genfscon usbfs / system_u:object_r:usbfs_t:s0
genfscon nfsd / system_u:object_r:nfsd_fs_t:s0
genfscon rpc_pipefs / system_u:object_r:rpc_pipefs_t:s0
genfscon binfmt_misc / system_u:object_r:binfmt_misc_fs_t:s0

#line 1 "net_contexts"
# FLASK

#
# Security contexts for network entities
# If no context is specified, then a default initial SID is used.
#

# Modified by Reino Wallin <reino@oribium.com>
# Multi NIC, and IPSEC features

# Modified by Russell Coker
# ifdefs to encapsulate domains, and many additional port contexts

#
# Port numbers (default = initial SID "port")
# 
# protocol number context
# protocol low-high context
#
portcon tcp 7 system_u:object_r:inetd_child_port_t:s0
portcon udp 7 system_u:object_r:inetd_child_port_t:s0
portcon tcp 9 system_u:object_r:inetd_child_port_t:s0
portcon udp 9 system_u:object_r:inetd_child_port_t:s0
portcon tcp 13 system_u:object_r:inetd_child_port_t:s0
portcon udp 13 system_u:object_r:inetd_child_port_t:s0
portcon tcp 19 system_u:object_r:inetd_child_port_t:s0
portcon udp 19 system_u:object_r:inetd_child_port_t:s0
portcon tcp 37 system_u:object_r:inetd_child_port_t:s0
portcon udp 37 system_u:object_r:inetd_child_port_t:s0
portcon tcp 113 system_u:object_r:auth_port_t:s0
portcon tcp 512 system_u:object_r:inetd_child_port_t:s0
portcon tcp 543 system_u:object_r:inetd_child_port_t:s0
portcon tcp 544 system_u:object_r:inetd_child_port_t:s0
portcon tcp 891 system_u:object_r:inetd_child_port_t:s0
portcon udp 891 system_u:object_r:inetd_child_port_t:s0
portcon tcp 892 system_u:object_r:inetd_child_port_t:s0
portcon udp 892 system_u:object_r:inetd_child_port_t:s0
portcon tcp 2105 system_u:object_r:inetd_child_port_t:s0
portcon tcp 20 system_u:object_r:ftp_data_port_t:s0
portcon tcp 21 system_u:object_r:ftp_port_t:s0
portcon tcp 22 system_u:object_r:ssh_port_t:s0
portcon tcp 23 system_u:object_r:telnetd_port_t:s0

portcon tcp 25 system_u:object_r:smtp_port_t:s0
portcon tcp 465 system_u:object_r:smtp_port_t:s0
portcon tcp 587 system_u:object_r:smtp_port_t:s0

portcon udp 500 system_u:object_r:isakmp_port_t:s0
portcon udp 53 system_u:object_r:dns_port_t:s0
portcon tcp 53 system_u:object_r:dns_port_t:s0

portcon udp 67  system_u:object_r:dhcpd_port_t:s0
portcon udp 647  system_u:object_r:dhcpd_port_t:s0
portcon tcp 647  system_u:object_r:dhcpd_port_t:s0
portcon udp 847  system_u:object_r:dhcpd_port_t:s0
portcon tcp 847  system_u:object_r:dhcpd_port_t:s0
portcon udp 68  system_u:object_r:dhcpc_port_t:s0
portcon udp 70 system_u:object_r:gopher_port_t:s0
portcon tcp 70 system_u:object_r:gopher_port_t:s0

portcon udp 69  system_u:object_r:tftp_port_t:s0
portcon tcp 79  system_u:object_r:fingerd_port_t:s0

portcon tcp 80  system_u:object_r:http_port_t:s0
portcon tcp 443  system_u:object_r:http_port_t:s0
portcon tcp 488  system_u:object_r:http_port_t:s0
portcon tcp 8008  system_u:object_r:http_port_t:s0
portcon tcp 8090  system_u:object_r:http_port_t:s0

portcon tcp 106 system_u:object_r:pop_port_t:s0
portcon tcp 109 system_u:object_r:pop_port_t:s0
portcon tcp 110 system_u:object_r:pop_port_t:s0
portcon tcp 143 system_u:object_r:pop_port_t:s0
portcon tcp 220 system_u:object_r:pop_port_t:s0
portcon tcp 993 system_u:object_r:pop_port_t:s0
portcon tcp 995 system_u:object_r:pop_port_t:s0
portcon tcp 1109 system_u:object_r:pop_port_t:s0

portcon udp 111 system_u:object_r:portmap_port_t:s0
portcon tcp 111 system_u:object_r:portmap_port_t:s0

portcon tcp 119 system_u:object_r:innd_port_t:s0
portcon udp 123 system_u:object_r:ntp_port_t:s0

portcon tcp 137 system_u:object_r:smbd_port_t:s0
portcon udp 137 system_u:object_r:nmbd_port_t:s0
portcon tcp 138 system_u:object_r:smbd_port_t:s0
portcon udp 138 system_u:object_r:nmbd_port_t:s0
portcon tcp 139 system_u:object_r:smbd_port_t:s0
portcon udp 139 system_u:object_r:nmbd_port_t:s0
portcon tcp 445 system_u:object_r:smbd_port_t:s0

portcon udp 161 system_u:object_r:snmp_port_t:s0
portcon udp 162 system_u:object_r:snmp_port_t:s0
portcon tcp 199 system_u:object_r:snmp_port_t:s0
portcon udp 512 system_u:object_r:comsat_port_t:s0

portcon tcp 389 system_u:object_r:ldap_port_t:s0
portcon udp 389 system_u:object_r:ldap_port_t:s0
portcon tcp 636 system_u:object_r:ldap_port_t:s0
portcon udp 636 system_u:object_r:ldap_port_t:s0

portcon tcp 513 system_u:object_r:rlogind_port_t:s0
portcon tcp 514 system_u:object_r:rsh_port_t:s0

portcon tcp 515 system_u:object_r:printer_port_t:s0
portcon udp 514 system_u:object_r:syslogd_port_t:s0
portcon udp 517 system_u:object_r:ktalkd_port_t:s0
portcon udp 518 system_u:object_r:ktalkd_port_t:s0
portcon tcp 631 system_u:object_r:ipp_port_t:s0
portcon udp 631 system_u:object_r:ipp_port_t:s0
portcon tcp 88 system_u:object_r:kerberos_port_t:s0
portcon udp 88 system_u:object_r:kerberos_port_t:s0
portcon tcp 464 system_u:object_r:kerberos_admin_port_t:s0
portcon udp 464 system_u:object_r:kerberos_admin_port_t:s0
portcon tcp 749 system_u:object_r:kerberos_admin_port_t:s0
portcon tcp 750 system_u:object_r:kerberos_port_t:s0
portcon udp 750 system_u:object_r:kerberos_port_t:s0
portcon tcp 783 system_u:object_r:spamd_port_t:s0
portcon tcp 540 system_u:object_r:uucpd_port_t:s0
portcon tcp 2401 system_u:object_r:cvs_port_t:s0
portcon udp 2401 system_u:object_r:cvs_port_t:s0
portcon tcp 873 system_u:object_r:rsync_port_t:s0
portcon udp 873 system_u:object_r:rsync_port_t:s0
portcon tcp 901 system_u:object_r:swat_port_t:s0
portcon tcp 953 system_u:object_r:rndc_port_t:s0
portcon tcp 1213 system_u:object_r:giftd_port_t:s0
portcon tcp 1241 system_u:object_r:nessus_port_t:s0
portcon tcp 1234 system_u:object_r:monopd_port_t:s0
portcon udp 1645 system_u:object_r:radius_port_t:s0
portcon udp 1646 system_u:object_r:radacct_port_t:s0
portcon udp 1812 system_u:object_r:radius_port_t:s0
portcon udp 1813 system_u:object_r:radacct_port_t:s0
portcon udp 1718 system_u:object_r:gatekeeper_port_t:s0
portcon udp 1719 system_u:object_r:gatekeeper_port_t:s0
portcon tcp 1721 system_u:object_r:gatekeeper_port_t:s0
portcon tcp 7000 system_u:object_r:gatekeeper_port_t:s0
portcon tcp 2040 system_u:object_r:afs_fs_port_t:s0
portcon udp 7000 system_u:object_r:afs_fs_port_t:s0
portcon udp 7002 system_u:object_r:afs_pt_port_t:s0
portcon udp 7003 system_u:object_r:afs_vl_port_t:s0
portcon udp 7004 system_u:object_r:afs_ka_port_t:s0
portcon udp 7005 system_u:object_r:afs_fs_port_t:s0
portcon udp 7007 system_u:object_r:afs_bos_port_t:s0
portcon tcp 1720 system_u:object_r:asterisk_port_t:s0
portcon udp 2427 system_u:object_r:asterisk_port_t:s0
portcon udp 2727 system_u:object_r:asterisk_port_t:s0
portcon udp 4569 system_u:object_r:asterisk_port_t:s0
portcon udp 5060 system_u:object_r:asterisk_port_t:s0
portcon tcp 2000 system_u:object_r:mail_port_t:s0
portcon tcp 179  system_u:object_r:bgp_port_t:s0
portcon tcp 2601 system_u:object_r:zebra_port_t:s0
portcon tcp 2605 system_u:object_r:zebra_port_t:s0
portcon tcp 2628 system_u:object_r:dict_port_t:s0
portcon tcp 3306 system_u:object_r:mysqld_port_t:s0
portcon tcp 3632 system_u:object_r:distccd_port_t:s0
portcon udp 4011 system_u:object_r:pxe_port_t:s0
portcon udp 5000 system_u:object_r:openvpn_port_t:s0
portcon tcp 5323 system_u:object_r:imaze_port_t:s0
portcon udp 5323 system_u:object_r:imaze_port_t:s0
portcon tcp 5335 system_u:object_r:howl_port_t:s0
portcon udp 5353 system_u:object_r:howl_port_t:s0
portcon tcp 5222 system_u:object_r:jabber_client_port_t:s0
portcon tcp 5223 system_u:object_r:jabber_client_port_t:s0
portcon tcp 5269 system_u:object_r:jabber_interserver_port_t:s0
portcon tcp 5432 system_u:object_r:postgresql_port_t:s0
portcon tcp 5666 system_u:object_r:inetd_child_port_t:s0
portcon tcp 5703 system_u:object_r:ptal_port_t:s0
portcon tcp 9290 system_u:object_r:hplip_port_t:s0
portcon tcp 9291 system_u:object_r:hplip_port_t:s0
portcon tcp 9292 system_u:object_r:hplip_port_t:s0
portcon tcp 50000 system_u:object_r:hplip_port_t:s0
portcon tcp 50002 system_u:object_r:hplip_port_t:s0
portcon tcp 5900  system_u:object_r:vnc_port_t:s0 
portcon tcp 5988  system_u:object_r:pegasus_http_port_t:s0
portcon tcp 5989  system_u:object_r:pegasus_https_port_t:s0
portcon tcp 6000  system_u:object_r:xserver_port_t:s0
portcon tcp 6001  system_u:object_r:xserver_port_t:s0
portcon tcp 6002  system_u:object_r:xserver_port_t:s0
portcon tcp 6003  system_u:object_r:xserver_port_t:s0
portcon tcp 6004  system_u:object_r:xserver_port_t:s0
portcon tcp 6005  system_u:object_r:xserver_port_t:s0
portcon tcp 6006  system_u:object_r:xserver_port_t:s0
portcon tcp 6007  system_u:object_r:xserver_port_t:s0
portcon tcp 6008  system_u:object_r:xserver_port_t:s0
portcon tcp 6009  system_u:object_r:xserver_port_t:s0
portcon tcp 6010  system_u:object_r:xserver_port_t:s0
portcon tcp 6011  system_u:object_r:xserver_port_t:s0
portcon tcp 6012  system_u:object_r:xserver_port_t:s0
portcon tcp 6013  system_u:object_r:xserver_port_t:s0
portcon tcp 6014  system_u:object_r:xserver_port_t:s0
portcon tcp 6015  system_u:object_r:xserver_port_t:s0
portcon tcp 6016  system_u:object_r:xserver_port_t:s0
portcon tcp 6017  system_u:object_r:xserver_port_t:s0
portcon tcp 6018  system_u:object_r:xserver_port_t:s0
portcon tcp 6019  system_u:object_r:xserver_port_t:s0
portcon tcp 6667 system_u:object_r:ircd_port_t:s0
portcon tcp 8000 system_u:object_r:soundd_port_t:s0
# 9433 is for YIFF
portcon tcp 9433 system_u:object_r:soundd_port_t:s0
portcon tcp 3128  system_u:object_r:http_cache_port_t:s0
portcon tcp 8080  system_u:object_r:http_cache_port_t:s0
portcon udp 3130  system_u:object_r:http_cache_port_t:s0
# 8118 is for privoxy
portcon tcp 8118  system_u:object_r:http_cache_port_t:s0

portcon udp 4041 system_u:object_r:clockspeed_port_t:s0
portcon tcp 8081 system_u:object_r:transproxy_port_t:s0
portcon udp 10080 system_u:object_r:amanda_port_t:s0
portcon tcp 10080 system_u:object_r:amanda_port_t:s0
portcon udp 10081 system_u:object_r:amanda_port_t:s0
portcon tcp 10081 system_u:object_r:amanda_port_t:s0
portcon tcp 10082 system_u:object_r:amanda_port_t:s0
portcon tcp 10083 system_u:object_r:amanda_port_t:s0
portcon tcp 60000 system_u:object_r:postgrey_port_t:s0

portcon tcp 10024 system_u:object_r:amavisd_recv_port_t:s0
portcon tcp 10025 system_u:object_r:amavisd_send_port_t:s0
portcon tcp 3310 system_u:object_r:clamd_port_t:s0
portcon udp 6276 system_u:object_r:dcc_port_t:s0
portcon udp 6277 system_u:object_r:dcc_port_t:s0
portcon udp 24441 system_u:object_r:pyzor_port_t:s0
portcon tcp 2703 system_u:object_r:razor_port_t:s0
portcon tcp 8021 system_u:object_r:zope_port_t:s0

# Defaults for reserved ports.  Earlier portcon entries take precedence;
# these entries just cover any remaining reserved ports not otherwise 
# declared or omitted due to removal of a domain.
portcon tcp 1-1023 system_u:object_r:reserved_port_t:s0
portcon udp 1-1023 system_u:object_r:reserved_port_t:s0

# Network interfaces (default = initial SID "netif" and "netmsg")
#
# interface netif_context default_msg_context
#
netifcon eth0 system_u:object_r:netif_eth0_t:s0 system_u:object_r:unlabeled_t:s0
netifcon eth1 system_u:object_r:netif_eth1_t:s0 system_u:object_r:unlabeled_t:s0
netifcon eth2 system_u:object_r:netif_eth2_t:s0 system_u:object_r:unlabeled_t:s0
netifcon ippp0 system_u:object_r:netif_ippp0_t:s0 system_u:object_r:unlabeled_t:s0
netifcon ipsec0 system_u:object_r:netif_ipsec0_t:s0 system_u:object_r:unlabeled_t:s0
netifcon ipsec1 system_u:object_r:netif_ipsec1_t:s0 system_u:object_r:unlabeled_t:s0
netifcon ipsec2 system_u:object_r:netif_ipsec2_t:s0 system_u:object_r:unlabeled_t:s0
netifcon lo system_u:object_r:netif_lo_t:s0 system_u:object_r:unlabeled_t:s0

# Nodes (default = initial SID "node")
#
# address mask context
#
#nodecon 127.0.0.1	  255.255.255.255			   system_u:object_r:node_lo_t:s0
#nodecon 0.0.0.0		  255.255.255.255			   system_u:object_r:node_inaddr_any_t:s0
#nodecon ::		  ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff  system_u:object_r:node_unspec_t:s0
#nodecon ::1		  ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff  system_u:object_r:node_lo_t:s0
#nodecon ff00::		  ff00::				   system_u:object_r:node_multicast_t:s0
#nodecon fe80::		  ffff:ffff:ffff:ffff::			   system_u:object_r:node_link_local_t:s0
#nodecon fec0::		  ffc0::				   system_u:object_r:node_site_local_t:s0
#nodecon ::		  ffff:ffff:ffff:ffff:ffff:ffff::	   system_u:object_r:node_compat_ipv4_t:s0
#nodecon ::ffff:0000:0000  ffff:ffff:ffff:ffff:ffff:ffff::	   system_u:object_r:node_mapped_ipv4_t:s0

#nodecon 7F00:0001:FFFF:FFFF:0000:0000:0000:0000 255.255.255.255 system_u:object_r:unlabeled_t:s0
nodecon 0011:2233:4455:6677:8899:aabb:ccdd:eeff ffff:ffff:ffff:ffff:: system_u:object_r:unlabeled_t:s0
# FLASK
